(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x8) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x8, {
    get: (a2, b4) => (typeof require !== "undefined" ? require : a2)[b4]
  }) : x8)(function(x8) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x8 + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod3) => function __require2() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
      if (decorator = decorators[i4])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/proxy-deep/index.js
  var require_proxy_deep = __commonJS({
    "node_modules/proxy-deep/index.js"(exports2, module2) {
      "use strict";
      function parsePath(text) {
        return text.split(".");
      }
      function push2(arr, el) {
        const newArr = arr.slice();
        newArr.push(el);
        return newArr;
      }
      var trapNames = [
        "apply",
        "construct",
        "defineProperty",
        "deleteProperty",
        "enumerate",
        "get",
        "getOwnPropertyDescriptor",
        "getPrototypeOf",
        "has",
        "isExtensible",
        "ownKeys",
        "preventExtensions",
        "set",
        "setPrototypeOf"
      ];
      var keys = {
        get: 1,
        set: 1,
        deleteProperty: 1,
        has: 1,
        defineProperty: 1,
        getOwnPropertyDescriptor: 1
      };
      function DeepProxy(rootTarget, traps, options) {
        let path = [];
        let userData = {};
        if (options !== void 0 && typeof options.path !== "undefined") {
          path = parsePath(options.path);
        }
        if (options !== void 0 && typeof options.userData !== "undefined") {
          userData = options.userData;
        }
        function createProxy(target, path2) {
          const context2 = { rootTarget, path: path2 };
          Object.assign(context2, userData);
          const realTraps = {};
          for (const trapName of trapNames) {
            const keyParamIdx = keys[trapName], trap = traps[trapName];
            if (typeof trap !== "undefined") {
              if (typeof keyParamIdx !== "undefined") {
                realTraps[trapName] = function() {
                  const key = arguments[keyParamIdx];
                  context2.nest = function(nestedTarget) {
                    if (nestedTarget === void 0)
                      nestedTarget = rootTarget;
                    return createProxy(nestedTarget, push2(path2, key));
                  };
                  return trap.apply(context2, arguments);
                };
              } else {
                realTraps[trapName] = function() {
                  context2.nest = function(nestedTarget) {
                    if (nestedTarget === void 0)
                      nestedTarget = {};
                    return createProxy(nestedTarget, path2);
                  };
                  return trap.apply(context2, arguments);
                };
              }
            }
          }
          return new Proxy(target, realTraps);
        }
        return createProxy(rootTarget, path);
      }
      module2.exports = DeepProxy;
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports2, module2) {
      (function(module3, exports3) {
        "use strict";
        function assert2(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number2, base, endian) {
          if (BN.isBN(number2)) {
            return number2;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number2 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number2 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = __require("buffer").Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number2, base, endian) {
          if (typeof number2 === "number") {
            return this._initNumber(number2, base, endian);
          }
          if (typeof number2 === "object") {
            return this._initArray(number2, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert2(base === (base | 0) && base >= 2 && base <= 36);
          number2 = number2.toString().replace(/\s+/g, "");
          var start = 0;
          if (number2[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number2.length) {
            if (base === 16) {
              this._parseHex(number2, start, endian);
            } else {
              this._parseBase(number2, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number2, base, endian) {
          if (number2 < 0) {
            this.negative = 1;
            number2 = -number2;
          }
          if (number2 < 67108864) {
            this.words = [number2 & 67108863];
            this.length = 1;
          } else if (number2 < 4503599627370496) {
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert2(number2 < 9007199254740992);
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number2, base, endian) {
          assert2(typeof number2.length === "number");
          if (number2.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number2.length / 3);
          this.words = new Array(this.length);
          for (var i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = 0;
          }
          var j3, w3;
          var off = 0;
          if (endian === "be") {
            for (i4 = number2.length - 1, j3 = 0; i4 >= 0; i4 -= 3) {
              w3 = number2[i4] | number2[i4 - 1] << 8 | number2[i4 - 2] << 16;
              this.words[j3] |= w3 << off & 67108863;
              this.words[j3 + 1] = w3 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          } else if (endian === "le") {
            for (i4 = 0, j3 = 0; i4 < number2.length; i4 += 3) {
              w3 = number2[i4] | number2[i4 + 1] << 8 | number2[i4 + 2] << 16;
              this.words[j3] |= w3 << off & 67108863;
              this.words[j3 + 1] = w3 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string, index2) {
          var c3 = string.charCodeAt(index2);
          if (c3 >= 48 && c3 <= 57) {
            return c3 - 48;
          } else if (c3 >= 65 && c3 <= 70) {
            return c3 - 55;
          } else if (c3 >= 97 && c3 <= 102) {
            return c3 - 87;
          } else {
            assert2(false, "Invalid character in " + string);
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r2 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r2 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r2;
        }
        BN.prototype._parseHex = function _parseHex(number2, start, endian) {
          this.length = Math.ceil((number2.length - start) / 6);
          this.words = new Array(this.length);
          for (var i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = 0;
          }
          var off = 0;
          var j3 = 0;
          var w3;
          if (endian === "be") {
            for (i4 = number2.length - 1; i4 >= start; i4 -= 2) {
              w3 = parseHexByte(number2, start, i4) << off;
              this.words[j3] |= w3 & 67108863;
              if (off >= 18) {
                off -= 18;
                j3 += 1;
                this.words[j3] |= w3 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number2.length - start;
            for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number2.length; i4 += 2) {
              w3 = parseHexByte(number2, start, i4) << off;
              this.words[j3] |= w3 & 67108863;
              if (off >= 18) {
                off -= 18;
                j3 += 1;
                this.words[j3] |= w3 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r2 = 0;
          var b4 = 0;
          var len = Math.min(str.length, end);
          for (var i4 = start; i4 < len; i4++) {
            var c3 = str.charCodeAt(i4) - 48;
            r2 *= mul;
            if (c3 >= 49) {
              b4 = c3 - 49 + 10;
            } else if (c3 >= 17) {
              b4 = c3 - 17 + 10;
            } else {
              b4 = c3;
            }
            assert2(c3 >= 0 && b4 < mul, "Invalid character");
            r2 += b4;
          }
          return r2;
        }
        BN.prototype._parseBase = function _parseBase(number2, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number2.length - start;
          var mod3 = total % limbLen;
          var end = Math.min(total, total - mod3) + start;
          var word = 0;
          for (var i4 = start; i4 < end; i4 += limbLen) {
            word = parseBase(number2, i4, i4 + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod3 !== 0) {
            var pow3 = 1;
            word = parseBase(number2, i4, number2.length, base);
            for (i4 = 0; i4 < mod3; i4++) {
              pow3 *= base;
            }
            this.imuln(pow3);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i4 = 0; i4 < this.length; i4++) {
            dest.words[i4] = this.words[i4];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN.prototype.clone = function clone() {
          var r2 = new BN(null);
          this.copy(r2);
          return r2;
        };
        BN.prototype._expand = function _expand(size3) {
          while (this.length < size3) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN.prototype.inspect = inspect;
          }
        } else {
          BN.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString3(base, padding2) {
          base = base || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i4 = 0; i4 < this.length; i4++) {
              var w3 = this.words[i4];
              var word = ((w3 << off | carry) & 16777215).toString(16);
              carry = w3 >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i4--;
              }
              if (carry !== 0 || i4 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c3 = this.clone();
            c3.negative = 0;
            while (!c3.isZero()) {
              var r2 = c3.modrn(groupBase).toString(base);
              c3 = c3.idivn(groupBase);
              if (!c3.isZero()) {
                out = zeros[groupSize - r2.length] + r2 + out;
              } else {
                out = r2 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert2(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber2() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert2(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON2() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size3) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size3);
          }
          return new ArrayType(size3);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert2(byteLength <= reqLength, "byte array longer than desired length");
          assert2(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i4 = 0, shift2 = 0; i4 < this.length; i4++) {
            var word = this.words[i4] << shift2 | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift2 === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift2 = 0;
            } else {
              carry = word >>> 24;
              shift2 += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i4 = 0, shift2 = 0; i4 < this.length; i4++) {
            var word = this.words[i4] << shift2 | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift2 === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift2 = 0;
            } else {
              carry = word >>> 24;
              shift2 += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w3) {
            return 32 - Math.clz32(w3);
          };
        } else {
          BN.prototype._countBits = function _countBits(w3) {
            var t3 = w3;
            var r2 = 0;
            if (t3 >= 4096) {
              r2 += 13;
              t3 >>>= 13;
            }
            if (t3 >= 64) {
              r2 += 7;
              t3 >>>= 7;
            }
            if (t3 >= 8) {
              r2 += 4;
              t3 >>>= 4;
            }
            if (t3 >= 2) {
              r2 += 2;
              t3 >>>= 2;
            }
            return r2 + t3;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w3) {
          if (w3 === 0)
            return 26;
          var t3 = w3;
          var r2 = 0;
          if ((t3 & 8191) === 0) {
            r2 += 13;
            t3 >>>= 13;
          }
          if ((t3 & 127) === 0) {
            r2 += 7;
            t3 >>>= 7;
          }
          if ((t3 & 15) === 0) {
            r2 += 4;
            t3 >>>= 4;
          }
          if ((t3 & 3) === 0) {
            r2 += 2;
            t3 >>>= 2;
          }
          if ((t3 & 1) === 0) {
            r2++;
          }
          return r2;
        };
        BN.prototype.bitLength = function bitLength() {
          var w3 = this.words[this.length - 1];
          var hi = this._countBits(w3);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w3 = new Array(num.bitLength());
          for (var bit = 0; bit < w3.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w3[bit] = num.words[off] >>> wbit & 1;
          }
          return w3;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r2 = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var b4 = this._zeroBits(this.words[i4]);
            r2 += b4;
            if (b4 !== 26)
              break;
          }
          return r2;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i4 = 0; i4 < num.length; i4++) {
            this.words[i4] = this.words[i4] | num.words[i4];
          }
          return this._strip();
        };
        BN.prototype.ior = function ior(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or2(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b4;
          if (this.length > num.length) {
            b4 = num;
          } else {
            b4 = this;
          }
          for (var i4 = 0; i4 < b4.length; i4++) {
            this.words[i4] = this.words[i4] & num.words[i4];
          }
          this.length = b4.length;
          return this._strip();
        };
        BN.prototype.iand = function iand(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and2(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a2;
          var b4;
          if (this.length > num.length) {
            a2 = this;
            b4 = num;
          } else {
            a2 = num;
            b4 = this;
          }
          for (var i4 = 0; i4 < b4.length; i4++) {
            this.words[i4] = a2.words[i4] ^ b4.words[i4];
          }
          if (this !== a2) {
            for (; i4 < a2.length; i4++) {
              this.words[i4] = a2.words[i4];
            }
          }
          this.length = a2.length;
          return this._strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert2(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i4 = 0; i4 < bytesNeeded; i4++) {
            this.words[i4] = ~this.words[i4] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert2(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r2;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r2 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r2 = this.isub(num);
            num.negative = 1;
            return r2._normSign();
          }
          var a2, b4;
          if (this.length > num.length) {
            a2 = this;
            b4 = num;
          } else {
            a2 = num;
            b4 = this;
          }
          var carry = 0;
          for (var i4 = 0; i4 < b4.length; i4++) {
            r2 = (a2.words[i4] | 0) + (b4.words[i4] | 0) + carry;
            this.words[i4] = r2 & 67108863;
            carry = r2 >>> 26;
          }
          for (; carry !== 0 && i4 < a2.length; i4++) {
            r2 = (a2.words[i4] | 0) + carry;
            this.words[i4] = r2 & 67108863;
            carry = r2 >>> 26;
          }
          this.length = a2.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a2 !== this) {
            for (; i4 < a2.length; i4++) {
              this.words[i4] = a2.words[i4];
            }
          }
          return this;
        };
        BN.prototype.add = function add3(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r2 = this.iadd(num);
            num.negative = 1;
            return r2._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a2, b4;
          if (cmp > 0) {
            a2 = this;
            b4 = num;
          } else {
            a2 = num;
            b4 = this;
          }
          var carry = 0;
          for (var i4 = 0; i4 < b4.length; i4++) {
            r2 = (a2.words[i4] | 0) - (b4.words[i4] | 0) + carry;
            carry = r2 >> 26;
            this.words[i4] = r2 & 67108863;
          }
          for (; carry !== 0 && i4 < a2.length; i4++) {
            r2 = (a2.words[i4] | 0) + carry;
            carry = r2 >> 26;
            this.words[i4] = r2 & 67108863;
          }
          if (carry === 0 && i4 < a2.length && a2 !== this) {
            for (; i4 < a2.length; i4++) {
              this.words[i4] = a2.words[i4];
            }
          }
          this.length = Math.max(this.length, i4);
          if (a2 !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a2 = self2.words[0] | 0;
          var b4 = num.words[0] | 0;
          var r2 = a2 * b4;
          var lo = r2 & 67108863;
          var carry = r2 / 67108864 | 0;
          out.words[0] = lo;
          for (var k3 = 1; k3 < len; k3++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i4 = k3 - j3 | 0;
              a2 = self2.words[i4] | 0;
              b4 = num.words[j3] | 0;
              r2 = a2 * b4 + rword;
              ncarry += r2 / 67108864 | 0;
              rword = r2 & 67108863;
            }
            out.words[k3] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k3] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a2 = self2.words;
          var b4 = num.words;
          var o3 = out.words;
          var c3 = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a2[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a2[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a22 = a2[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a3 = a2[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a2[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a2[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a2[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a2[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a2[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a2[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b4[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b4[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b22 = b4[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b4[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b4[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b5 = b4[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b4[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b4[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b4[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b4[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o3[0] = w0;
          o3[1] = w1;
          o3[2] = w22;
          o3[3] = w3;
          o3[4] = w4;
          o3[5] = w5;
          o3[6] = w6;
          o3[7] = w7;
          o3[8] = w8;
          o3[9] = w9;
          o3[10] = w10;
          o3[11] = w11;
          o3[12] = w12;
          o3[13] = w13;
          o3[14] = w14;
          o3[15] = w15;
          o3[16] = w16;
          o3[17] = w17;
          o3[18] = w18;
          if (c3 !== 0) {
            o3[19] = c3;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k3 = 0; k3 < out.length - 1; k3++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i4 = k3 - j3;
              var a2 = self2.words[i4] | 0;
              var b4 = num.words[j3] | 0;
              var r2 = a2 * b4;
              var lo = r2 & 67108863;
              ncarry = ncarry + (r2 / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k3] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k3] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x8, y4) {
          this.x = x8;
          this.y = y4;
        }
        FFTM.prototype.makeRBT = function makeRBT(N2) {
          var t3 = new Array(N2);
          var l4 = BN.prototype._countBits(N2) - 1;
          for (var i4 = 0; i4 < N2; i4++) {
            t3[i4] = this.revBin(i4, l4, N2);
          }
          return t3;
        };
        FFTM.prototype.revBin = function revBin(x8, l4, N2) {
          if (x8 === 0 || x8 === N2 - 1)
            return x8;
          var rb = 0;
          for (var i4 = 0; i4 < l4; i4++) {
            rb |= (x8 & 1) << l4 - i4 - 1;
            x8 >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
          for (var i4 = 0; i4 < N2; i4++) {
            rtws[i4] = rws[rbt[i4]];
            itws[i4] = iws[rbt[i4]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N2);
          for (var s4 = 1; s4 < N2; s4 <<= 1) {
            var l4 = s4 << 1;
            var rtwdf = Math.cos(2 * Math.PI / l4);
            var itwdf = Math.sin(2 * Math.PI / l4);
            for (var p2 = 0; p2 < N2; p2 += l4) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j3 = 0; j3 < s4; j3++) {
                var re4 = rtws[p2 + j3];
                var ie3 = itws[p2 + j3];
                var ro = rtws[p2 + j3 + s4];
                var io = itws[p2 + j3 + s4];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p2 + j3] = re4 + ro;
                itws[p2 + j3] = ie3 + io;
                rtws[p2 + j3 + s4] = re4 - ro;
                itws[p2 + j3 + s4] = ie3 - io;
                if (j3 !== l4) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
          var N2 = Math.max(m5, n4) | 1;
          var odd = N2 & 1;
          var i4 = 0;
          for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
            i4++;
          }
          return 1 << i4 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
          if (N2 <= 1)
            return;
          for (var i4 = 0; i4 < N2 / 2; i4++) {
            var t3 = rws[i4];
            rws[i4] = rws[N2 - i4 - 1];
            rws[N2 - i4 - 1] = t3;
            t3 = iws[i4];
            iws[i4] = -iws[N2 - i4 - 1];
            iws[N2 - i4 - 1] = -t3;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws2, N2) {
          var carry = 0;
          for (var i4 = 0; i4 < N2 / 2; i4++) {
            var w3 = Math.round(ws2[2 * i4 + 1] / N2) * 8192 + Math.round(ws2[2 * i4] / N2) + carry;
            ws2[i4] = w3 & 67108863;
            if (w3 < 67108864) {
              carry = 0;
            } else {
              carry = w3 / 67108864 | 0;
            }
          }
          return ws2;
        };
        FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N2) {
          var carry = 0;
          for (var i4 = 0; i4 < len; i4++) {
            carry = carry + (ws2[i4] | 0);
            rws[2 * i4] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i4 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i4 = 2 * len; i4 < N2; ++i4) {
            rws[i4] = 0;
          }
          assert2(carry === 0);
          assert2((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N2) {
          var ph = new Array(N2);
          for (var i4 = 0; i4 < N2; i4++) {
            ph[i4] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x8, y4, out) {
          var N2 = 2 * this.guessLen13b(x8.length, y4.length);
          var rbt = this.makeRBT(N2);
          var _18 = this.stub(N2);
          var rws = new Array(N2);
          var rwst = new Array(N2);
          var iwst = new Array(N2);
          var nrws = new Array(N2);
          var nrwst = new Array(N2);
          var niwst = new Array(N2);
          var rmws = out.words;
          rmws.length = N2;
          this.convert13b(x8.words, x8.length, rws, N2);
          this.convert13b(y4.words, y4.length, nrws, N2);
          this.transform(rws, _18, rwst, iwst, N2, rbt);
          this.transform(nrws, _18, nrwst, niwst, N2, rbt);
          for (var i4 = 0; i4 < N2; i4++) {
            var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
            iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
            rwst[i4] = rx;
          }
          this.conjugate(rwst, iwst, N2);
          this.transform(rwst, iwst, rmws, _18, N2, rbt);
          this.conjugate(rmws, _18, N2);
          this.normalize13b(rmws, N2);
          out.negative = x8.negative ^ y4.negative;
          out.length = x8.length + y4.length;
          return out._strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert2(typeof num === "number");
          assert2(num < 67108864);
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w3 = (this.words[i4] | 0) * num;
            var lo = (w3 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w3 / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i4] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i4] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow3(num) {
          var w3 = toBitArray(num);
          if (w3.length === 0)
            return new BN(1);
          var res = this;
          for (var i4 = 0; i4 < w3.length; i4++, res = res.sqr()) {
            if (w3[i4] !== 0)
              break;
          }
          if (++i4 < w3.length) {
            for (var q4 = res.sqr(); i4 < w3.length; i4++, q4 = q4.sqr()) {
              if (w3[i4] === 0)
                continue;
              res = res.mul(q4);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r2 = bits % 26;
          var s4 = (bits - r2) / 26;
          var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
          var i4;
          if (r2 !== 0) {
            var carry = 0;
            for (i4 = 0; i4 < this.length; i4++) {
              var newCarry = this.words[i4] & carryMask;
              var c3 = (this.words[i4] | 0) - newCarry << r2;
              this.words[i4] = c3 | carry;
              carry = newCarry >>> 26 - r2;
            }
            if (carry) {
              this.words[i4] = carry;
              this.length++;
            }
          }
          if (s4 !== 0) {
            for (i4 = this.length - 1; i4 >= 0; i4--) {
              this.words[i4 + s4] = this.words[i4];
            }
            for (i4 = 0; i4 < s4; i4++) {
              this.words[i4] = 0;
            }
            this.length += s4;
          }
          return this._strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert2(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert2(typeof bits === "number" && bits >= 0);
          var h6;
          if (hint) {
            h6 = (hint - hint % 26) / 26;
          } else {
            h6 = 0;
          }
          var r2 = bits % 26;
          var s4 = Math.min((bits - r2) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          var maskedWords = extended;
          h6 -= s4;
          h6 = Math.max(0, h6);
          if (maskedWords) {
            for (var i4 = 0; i4 < s4; i4++) {
              maskedWords.words[i4] = this.words[i4];
            }
            maskedWords.length = s4;
          }
          if (s4 === 0) {
          } else if (this.length > s4) {
            this.length -= s4;
            for (i4 = 0; i4 < this.length; i4++) {
              this.words[i4] = this.words[i4 + s4];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h6); i4--) {
            var word = this.words[i4] | 0;
            this.words[i4] = carry << 26 - r2 | word >>> r2;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert2(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert2(typeof bit === "number" && bit >= 0);
          var r2 = bit % 26;
          var s4 = (bit - r2) / 26;
          var q4 = 1 << r2;
          if (this.length <= s4)
            return false;
          var w3 = this.words[s4];
          return !!(w3 & q4);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r2 = bits % 26;
          var s4 = (bits - r2) / 26;
          assert2(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s4) {
            return this;
          }
          if (r2 !== 0) {
            s4++;
          }
          this.length = Math.min(s4, this.length);
          if (r2 !== 0) {
            var mask = 67108863 ^ 67108863 >>> r2 << r2;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
            this.words[i4] -= 67108864;
            if (i4 === this.length - 1) {
              this.words[i4 + 1] = 1;
            } else {
              this.words[i4 + 1]++;
            }
          }
          this.length = Math.max(this.length, i4 + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
              this.words[i4] += 67108864;
              this.words[i4 + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
          var len = num.length + shift2;
          var i4;
          this._expand(len);
          var w3;
          var carry = 0;
          for (i4 = 0; i4 < num.length; i4++) {
            w3 = (this.words[i4 + shift2] | 0) + carry;
            var right = (num.words[i4] | 0) * mul;
            w3 -= right & 67108863;
            carry = (w3 >> 26) - (right / 67108864 | 0);
            this.words[i4 + shift2] = w3 & 67108863;
          }
          for (; i4 < this.length - shift2; i4++) {
            w3 = (this.words[i4 + shift2] | 0) + carry;
            carry = w3 >> 26;
            this.words[i4 + shift2] = w3 & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert2(carry === -1);
          carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            w3 = -(this.words[i4] | 0) + carry;
            carry = w3 >> 26;
            this.words[i4] = w3 & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift2 = this.length - num.length;
          var a2 = this.clone();
          var b4 = num;
          var bhi = b4.words[b4.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift2 = 26 - bhiBits;
          if (shift2 !== 0) {
            b4 = b4.ushln(shift2);
            a2.iushln(shift2);
            bhi = b4.words[b4.length - 1] | 0;
          }
          var m5 = a2.length - b4.length;
          var q4;
          if (mode !== "mod") {
            q4 = new BN(null);
            q4.length = m5 + 1;
            q4.words = new Array(q4.length);
            for (var i4 = 0; i4 < q4.length; i4++) {
              q4.words[i4] = 0;
            }
          }
          var diff = a2.clone()._ishlnsubmul(b4, 1, m5);
          if (diff.negative === 0) {
            a2 = diff;
            if (q4) {
              q4.words[m5] = 1;
            }
          }
          for (var j3 = m5 - 1; j3 >= 0; j3--) {
            var qj = (a2.words[b4.length + j3] | 0) * 67108864 + (a2.words[b4.length + j3 - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a2._ishlnsubmul(b4, qj, j3);
            while (a2.negative !== 0) {
              qj--;
              a2.negative = 0;
              a2._ishlnsubmul(b4, 1, j3);
              if (!a2.isZero()) {
                a2.negative ^= 1;
              }
            }
            if (q4) {
              q4.words[j3] = qj;
            }
          }
          if (q4) {
            q4._strip();
          }
          a2._strip();
          if (mode !== "div" && shift2 !== 0) {
            a2.iushrn(shift2);
          }
          return {
            div: q4 || null,
            mod: a2
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert2(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod3, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod3 = res.mod.neg();
              if (positive && mod3.negative !== 0) {
                mod3.iadd(num);
              }
            }
            return {
              div,
              mod: mod3
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod3 = res.mod.neg();
              if (positive && mod3.negative !== 0) {
                mod3.isub(num);
              }
            }
            return {
              div: res.div,
              mod: mod3
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod3(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod3.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert2(num <= 67108863);
          var p2 = (1 << 26) % num;
          var acc = 0;
          for (var i4 = this.length - 1; i4 >= 0; i4--) {
            acc = (p2 * acc + (this.words[i4] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert2(num <= 67108863);
          var carry = 0;
          for (var i4 = this.length - 1; i4 >= 0; i4--) {
            var w3 = (this.words[i4] | 0) + carry * 67108864;
            this.words[i4] = w3 / num | 0;
            carry = w3 % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p2) {
          assert2(p2.negative === 0);
          assert2(!p2.isZero());
          var x8 = this;
          var y4 = p2.clone();
          if (x8.negative !== 0) {
            x8 = x8.umod(p2);
          } else {
            x8 = x8.clone();
          }
          var A3 = new BN(1);
          var B5 = new BN(0);
          var C4 = new BN(0);
          var D4 = new BN(1);
          var g5 = 0;
          while (x8.isEven() && y4.isEven()) {
            x8.iushrn(1);
            y4.iushrn(1);
            ++g5;
          }
          var yp = y4.clone();
          var xp = x8.clone();
          while (!x8.isZero()) {
            for (var i4 = 0, im = 1; (x8.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
              ;
            if (i4 > 0) {
              x8.iushrn(i4);
              while (i4-- > 0) {
                if (A3.isOdd() || B5.isOdd()) {
                  A3.iadd(yp);
                  B5.isub(xp);
                }
                A3.iushrn(1);
                B5.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (y4.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
              ;
            if (j3 > 0) {
              y4.iushrn(j3);
              while (j3-- > 0) {
                if (C4.isOdd() || D4.isOdd()) {
                  C4.iadd(yp);
                  D4.isub(xp);
                }
                C4.iushrn(1);
                D4.iushrn(1);
              }
            }
            if (x8.cmp(y4) >= 0) {
              x8.isub(y4);
              A3.isub(C4);
              B5.isub(D4);
            } else {
              y4.isub(x8);
              C4.isub(A3);
              D4.isub(B5);
            }
          }
          return {
            a: C4,
            b: D4,
            gcd: y4.iushln(g5)
          };
        };
        BN.prototype._invmp = function _invmp(p2) {
          assert2(p2.negative === 0);
          assert2(!p2.isZero());
          var a2 = this;
          var b4 = p2.clone();
          if (a2.negative !== 0) {
            a2 = a2.umod(p2);
          } else {
            a2 = a2.clone();
          }
          var x1 = new BN(1);
          var x22 = new BN(0);
          var delta = b4.clone();
          while (a2.cmpn(1) > 0 && b4.cmpn(1) > 0) {
            for (var i4 = 0, im = 1; (a2.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
              ;
            if (i4 > 0) {
              a2.iushrn(i4);
              while (i4-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (b4.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
              ;
            if (j3 > 0) {
              b4.iushrn(j3);
              while (j3-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a2.cmp(b4) >= 0) {
              a2.isub(b4);
              x1.isub(x22);
            } else {
              b4.isub(a2);
              x22.isub(x1);
            }
          }
          var res;
          if (a2.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p2);
          }
          return res;
        };
        BN.prototype.gcd = function gcd2(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a2 = this.clone();
          var b4 = num.clone();
          a2.negative = 0;
          b4.negative = 0;
          for (var shift2 = 0; a2.isEven() && b4.isEven(); shift2++) {
            a2.iushrn(1);
            b4.iushrn(1);
          }
          do {
            while (a2.isEven()) {
              a2.iushrn(1);
            }
            while (b4.isEven()) {
              b4.iushrn(1);
            }
            var r2 = a2.cmp(b4);
            if (r2 < 0) {
              var t3 = a2;
              a2 = b4;
              b4 = t3;
            } else if (r2 === 0 || b4.cmpn(1) === 0) {
              break;
            }
            a2.isub(b4);
          } while (true);
          return b4.iushln(shift2);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven2() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd2() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert2(typeof bit === "number");
          var r2 = bit % 26;
          var s4 = (bit - r2) / 26;
          var q4 = 1 << r2;
          if (this.length <= s4) {
            this._expand(s4 + 1);
            this.words[s4] |= q4;
            return this;
          }
          var carry = q4;
          for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
            var w3 = this.words[i4] | 0;
            w3 += carry;
            carry = w3 >>> 26;
            w3 &= 67108863;
            this.words[i4] = w3;
          }
          if (carry !== 0) {
            this.words[i4] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero2() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert2(num <= 67108863, "Number is too big");
            var w3 = this.words[0] | 0;
            res = w3 === num ? 0 : w3 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i4 = this.length - 1; i4 >= 0; i4--) {
            var a2 = this.words[i4] | 0;
            var b4 = num.words[i4] | 0;
            if (a2 === b4)
              continue;
            if (a2 < b4) {
              res = -1;
            } else if (a2 > b4) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt2(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          assert2(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert2(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert2(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert2(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert2(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert2(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert2(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert2(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert2(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert2(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert2(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert2(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert2(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p2) {
          this.name = name;
          this.p = new BN(p2, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r2 = num;
          var rlen;
          do {
            this.split(r2, this.tmp);
            r2 = this.imulK(r2);
            r2 = r2.iadd(this.tmp);
            rlen = r2.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
          if (cmp === 0) {
            r2.words[0] = 0;
            r2.length = 1;
          } else if (cmp > 0) {
            r2.isub(this.p);
          } else {
            if (r2.strip !== void 0) {
              r2.strip();
            } else {
              r2._strip();
            }
          }
          return r2;
        };
        MPrime.prototype.split = function split2(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split2(input, output2) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i4 = 0; i4 < outLen; i4++) {
            output2.words[i4] = input.words[i4];
          }
          output2.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output2.words[output2.length++] = prev & mask;
          for (i4 = 10; i4 < input.length; i4++) {
            var next = input.words[i4] | 0;
            input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i4 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i4 = 0; i4 < num.length; i4++) {
            var w3 = num.words[i4] | 0;
            lo += w3 * 977;
            num.words[i4] = lo & 67108863;
            lo = w3 * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i4 = 0; i4 < num.length; i4++) {
            var hi = (num.words[i4] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i4] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m5) {
          if (typeof m5 === "string") {
            var prime = BN._prime(m5);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert2(m5.gtn(1), "modulus must be greater than 1");
            this.m = m5;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a2) {
          assert2(a2.negative === 0, "red works only with positives");
          assert2(a2.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a2, b4) {
          assert2((a2.negative | b4.negative) === 0, "red works only with positives");
          assert2(
            a2.red && a2.red === b4.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a2) {
          if (this.prime)
            return this.prime.ireduce(a2)._forceRed(this);
          move(a2, a2.umod(this.m)._forceRed(this));
          return a2;
        };
        Red.prototype.neg = function neg(a2) {
          if (a2.isZero()) {
            return a2.clone();
          }
          return this.m.sub(a2)._forceRed(this);
        };
        Red.prototype.add = function add3(a2, b4) {
          this._verify2(a2, b4);
          var res = a2.add(b4);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a2, b4) {
          this._verify2(a2, b4);
          var res = a2.iadd(b4);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a2, b4) {
          this._verify2(a2, b4);
          var res = a2.sub(b4);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a2, b4) {
          this._verify2(a2, b4);
          var res = a2.isub(b4);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a2, num) {
          this._verify1(a2);
          return this.imod(a2.ushln(num));
        };
        Red.prototype.imul = function imul(a2, b4) {
          this._verify2(a2, b4);
          return this.imod(a2.imul(b4));
        };
        Red.prototype.mul = function mul(a2, b4) {
          this._verify2(a2, b4);
          return this.imod(a2.mul(b4));
        };
        Red.prototype.isqr = function isqr(a2) {
          return this.imul(a2, a2.clone());
        };
        Red.prototype.sqr = function sqr(a2) {
          return this.mul(a2, a2);
        };
        Red.prototype.sqrt = function sqrt(a2) {
          if (a2.isZero())
            return a2.clone();
          var mod3 = this.m.andln(3);
          assert2(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow3 = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a2, pow3);
          }
          var q4 = this.m.subn(1);
          var s4 = 0;
          while (!q4.isZero() && q4.andln(1) === 0) {
            s4++;
            q4.iushrn(1);
          }
          assert2(!q4.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z5 = this.m.bitLength();
          z5 = new BN(2 * z5 * z5).toRed(this);
          while (this.pow(z5, lpow).cmp(nOne) !== 0) {
            z5.redIAdd(nOne);
          }
          var c3 = this.pow(z5, q4);
          var r2 = this.pow(a2, q4.addn(1).iushrn(1));
          var t3 = this.pow(a2, q4);
          var m5 = s4;
          while (t3.cmp(one) !== 0) {
            var tmp = t3;
            for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
              tmp = tmp.redSqr();
            }
            assert2(i4 < m5);
            var b4 = this.pow(c3, new BN(1).iushln(m5 - i4 - 1));
            r2 = r2.redMul(b4);
            c3 = b4.redSqr();
            t3 = t3.redMul(c3);
            m5 = i4;
          }
          return r2;
        };
        Red.prototype.invm = function invm(a2) {
          var inv = a2._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow3(a2, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a2.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a2;
          for (var i4 = 2; i4 < wnd.length; i4++) {
            wnd[i4] = this.mul(wnd[i4 - 1], a2);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i4 = num.length - 1; i4 >= 0; i4--) {
            var word = num.words[i4];
            for (var j3 = start - 1; j3 >= 0; j3--) {
              var bit = word >> j3 & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i4 !== 0 || j3 !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r2 = num.umod(this.m);
          return r2 === num ? r2.clone() : r2;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m5) {
          Red.call(this, m5);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r2 = this.imod(num.mul(this.rinv));
          r2.red = null;
          return r2;
        };
        Mont.prototype.imul = function imul(a2, b4) {
          if (a2.isZero() || b4.isZero()) {
            a2.words[0] = 0;
            a2.length = 1;
            return a2;
          }
          var t3 = a2.imul(b4);
          var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t3.isub(c3).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a2, b4) {
          if (a2.isZero() || b4.isZero())
            return new BN(0)._forceRed(this);
          var t3 = a2.mul(b4);
          var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t3.isub(c3).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a2) {
          var res = this.imod(a2._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, exports2);
    }
  });

  // node_modules/@ethersproject/logger/lib/_version.js
  var require_version = __commonJS({
    "node_modules/@ethersproject/logger/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "logger/5.7.0";
    }
  });

  // node_modules/@ethersproject/logger/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@ethersproject/logger/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Logger = exports2.ErrorCode = exports2.LogLevel = void 0;
      var _permanentCensorErrors = false;
      var _censorErrors = false;
      var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
      var _logLevel = LogLevels["default"];
      var _version_1 = require_version();
      var _globalLogger = null;
      function _checkNormalize() {
        try {
          var missing_1 = [];
          ["NFD", "NFC", "NFKD", "NFKC"].forEach(function(form) {
            try {
              if ("test".normalize(form) !== "test") {
                throw new Error("bad normalize");
              }
              ;
            } catch (error) {
              missing_1.push(form);
            }
          });
          if (missing_1.length) {
            throw new Error("missing " + missing_1.join(", "));
          }
          if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
            throw new Error("broken implementation");
          }
        } catch (error) {
          return error.message;
        }
        return null;
      }
      var _normalizeError = _checkNormalize();
      var LogLevel;
      (function(LogLevel2) {
        LogLevel2["DEBUG"] = "DEBUG";
        LogLevel2["INFO"] = "INFO";
        LogLevel2["WARNING"] = "WARNING";
        LogLevel2["ERROR"] = "ERROR";
        LogLevel2["OFF"] = "OFF";
      })(LogLevel = exports2.LogLevel || (exports2.LogLevel = {}));
      var ErrorCode;
      (function(ErrorCode2) {
        ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
        ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
        ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
        ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
        ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
        ErrorCode2["TIMEOUT"] = "TIMEOUT";
        ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
        ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
        ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
        ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
        ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
        ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
        ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
        ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
        ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
        ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
        ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
        ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
        ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
      })(ErrorCode = exports2.ErrorCode || (exports2.ErrorCode = {}));
      var HEX = "0123456789abcdef";
      var Logger21 = (
        /** @class */
        function() {
          function Logger22(version7) {
            Object.defineProperty(this, "version", {
              enumerable: true,
              value: version7,
              writable: false
            });
          }
          Logger22.prototype._log = function(logLevel, args) {
            var level2 = logLevel.toLowerCase();
            if (LogLevels[level2] == null) {
              this.throwArgumentError("invalid log level name", "logLevel", logLevel);
            }
            if (_logLevel > LogLevels[level2]) {
              return;
            }
            console.log.apply(console, args);
          };
          Logger22.prototype.debug = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            this._log(Logger22.levels.DEBUG, args);
          };
          Logger22.prototype.info = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            this._log(Logger22.levels.INFO, args);
          };
          Logger22.prototype.warn = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            this._log(Logger22.levels.WARNING, args);
          };
          Logger22.prototype.makeError = function(message, code, params) {
            if (_censorErrors) {
              return this.makeError("censored error", code, {});
            }
            if (!code) {
              code = Logger22.errors.UNKNOWN_ERROR;
            }
            if (!params) {
              params = {};
            }
            var messageDetails = [];
            Object.keys(params).forEach(function(key) {
              var value = params[key];
              try {
                if (value instanceof Uint8Array) {
                  var hex2 = "";
                  for (var i4 = 0; i4 < value.length; i4++) {
                    hex2 += HEX[value[i4] >> 4];
                    hex2 += HEX[value[i4] & 15];
                  }
                  messageDetails.push(key + "=Uint8Array(0x" + hex2 + ")");
                } else {
                  messageDetails.push(key + "=" + JSON.stringify(value));
                }
              } catch (error2) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
              }
            });
            messageDetails.push("code=" + code);
            messageDetails.push("version=" + this.version);
            var reason = message;
            var url = "";
            switch (code) {
              case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                var fault = message;
                switch (fault) {
                  case "overflow":
                  case "underflow":
                  case "division-by-zero":
                    url += "-" + fault;
                    break;
                  case "negative-power":
                  case "negative-width":
                    url += "-unsupported";
                    break;
                  case "unbound-bitwise-result":
                    url += "-unbound-result";
                    break;
                }
                break;
              }
              case ErrorCode.CALL_EXCEPTION:
              case ErrorCode.INSUFFICIENT_FUNDS:
              case ErrorCode.MISSING_NEW:
              case ErrorCode.NONCE_EXPIRED:
              case ErrorCode.REPLACEMENT_UNDERPRICED:
              case ErrorCode.TRANSACTION_REPLACED:
              case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
            }
            if (url) {
              message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
            }
            if (messageDetails.length) {
              message += " (" + messageDetails.join(", ") + ")";
            }
            var error = new Error(message);
            error.reason = reason;
            error.code = code;
            Object.keys(params).forEach(function(key) {
              error[key] = params[key];
            });
            return error;
          };
          Logger22.prototype.throwError = function(message, code, params) {
            throw this.makeError(message, code, params);
          };
          Logger22.prototype.throwArgumentError = function(message, name, value) {
            return this.throwError(message, Logger22.errors.INVALID_ARGUMENT, {
              argument: name,
              value
            });
          };
          Logger22.prototype.assert = function(condition, message, code, params) {
            if (!!condition) {
              return;
            }
            this.throwError(message, code, params);
          };
          Logger22.prototype.assertArgument = function(condition, message, name, value) {
            if (!!condition) {
              return;
            }
            this.throwArgumentError(message, name, value);
          };
          Logger22.prototype.checkNormalize = function(message) {
            if (message == null) {
              message = "platform missing String.prototype.normalize";
            }
            if (_normalizeError) {
              this.throwError("platform missing String.prototype.normalize", Logger22.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize",
                form: _normalizeError
              });
            }
          };
          Logger22.prototype.checkSafeUint53 = function(value, message) {
            if (typeof value !== "number") {
              return;
            }
            if (message == null) {
              message = "value not safe";
            }
            if (value < 0 || value >= 9007199254740991) {
              this.throwError(message, Logger22.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value
              });
            }
            if (value % 1) {
              this.throwError(message, Logger22.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value
              });
            }
          };
          Logger22.prototype.checkArgumentCount = function(count, expectedCount, message) {
            if (message) {
              message = ": " + message;
            } else {
              message = "";
            }
            if (count < expectedCount) {
              this.throwError("missing argument" + message, Logger22.errors.MISSING_ARGUMENT, {
                count,
                expectedCount
              });
            }
            if (count > expectedCount) {
              this.throwError("too many arguments" + message, Logger22.errors.UNEXPECTED_ARGUMENT, {
                count,
                expectedCount
              });
            }
          };
          Logger22.prototype.checkNew = function(target, kind) {
            if (target === Object || target == null) {
              this.throwError("missing new", Logger22.errors.MISSING_NEW, { name: kind.name });
            }
          };
          Logger22.prototype.checkAbstract = function(target, kind) {
            if (target === kind) {
              this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger22.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
            } else if (target === Object || target == null) {
              this.throwError("missing new", Logger22.errors.MISSING_NEW, { name: kind.name });
            }
          };
          Logger22.globalLogger = function() {
            if (!_globalLogger) {
              _globalLogger = new Logger22(_version_1.version);
            }
            return _globalLogger;
          };
          Logger22.setCensorship = function(censorship, permanent) {
            if (!censorship && permanent) {
              this.globalLogger().throwError("cannot permanently disable censorship", Logger22.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
              });
            }
            if (_permanentCensorErrors) {
              if (!censorship) {
                return;
              }
              this.globalLogger().throwError("error censorship permanent", Logger22.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
              });
            }
            _censorErrors = !!censorship;
            _permanentCensorErrors = !!permanent;
          };
          Logger22.setLogLevel = function(logLevel) {
            var level2 = LogLevels[logLevel.toLowerCase()];
            if (level2 == null) {
              Logger22.globalLogger().warn("invalid log level - " + logLevel);
              return;
            }
            _logLevel = level2;
          };
          Logger22.from = function(version7) {
            return new Logger22(version7);
          };
          Logger22.errors = ErrorCode;
          Logger22.levels = LogLevel;
          return Logger22;
        }()
      );
      exports2.Logger = Logger21;
    }
  });

  // node_modules/@ethersproject/bytes/lib/_version.js
  var require_version2 = __commonJS({
    "node_modules/@ethersproject/bytes/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "bytes/5.7.0";
    }
  });

  // node_modules/@ethersproject/bytes/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/@ethersproject/bytes/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.joinSignature = exports2.splitSignature = exports2.hexZeroPad = exports2.hexStripZeros = exports2.hexValue = exports2.hexConcat = exports2.hexDataSlice = exports2.hexDataLength = exports2.hexlify = exports2.isHexString = exports2.zeroPad = exports2.stripZeros = exports2.concat = exports2.arrayify = exports2.isBytes = exports2.isBytesLike = void 0;
      var logger_1 = require_lib();
      var _version_1 = require_version2();
      var logger19 = new logger_1.Logger(_version_1.version);
      function isHexable(value) {
        return !!value.toHexString;
      }
      function addSlice(array2) {
        if (array2.slice) {
          return array2;
        }
        array2.slice = function() {
          var args = Array.prototype.slice.call(arguments);
          return addSlice(new Uint8Array(Array.prototype.slice.apply(array2, args)));
        };
        return array2;
      }
      function isBytesLike2(value) {
        return isHexString8(value) && !(value.length % 2) || isBytes5(value);
      }
      exports2.isBytesLike = isBytesLike2;
      function isInteger(value) {
        return typeof value === "number" && value == value && value % 1 === 0;
      }
      function isBytes5(value) {
        if (value == null) {
          return false;
        }
        if (value.constructor === Uint8Array) {
          return true;
        }
        if (typeof value === "string") {
          return false;
        }
        if (!isInteger(value.length) || value.length < 0) {
          return false;
        }
        for (var i4 = 0; i4 < value.length; i4++) {
          var v7 = value[i4];
          if (!isInteger(v7) || v7 < 0 || v7 >= 256) {
            return false;
          }
        }
        return true;
      }
      exports2.isBytes = isBytes5;
      function arrayify4(value, options) {
        if (!options) {
          options = {};
        }
        if (typeof value === "number") {
          logger19.checkSafeUint53(value, "invalid arrayify value");
          var result = [];
          while (value) {
            result.unshift(value & 255);
            value = parseInt(String(value / 256));
          }
          if (result.length === 0) {
            result.push(0);
          }
          return addSlice(new Uint8Array(result));
        }
        if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
          value = "0x" + value;
        }
        if (isHexable(value)) {
          value = value.toHexString();
        }
        if (isHexString8(value)) {
          var hex2 = value.substring(2);
          if (hex2.length % 2) {
            if (options.hexPad === "left") {
              hex2 = "0" + hex2;
            } else if (options.hexPad === "right") {
              hex2 += "0";
            } else {
              logger19.throwArgumentError("hex data is odd-length", "value", value);
            }
          }
          var result = [];
          for (var i4 = 0; i4 < hex2.length; i4 += 2) {
            result.push(parseInt(hex2.substring(i4, i4 + 2), 16));
          }
          return addSlice(new Uint8Array(result));
        }
        if (isBytes5(value)) {
          return addSlice(new Uint8Array(value));
        }
        return logger19.throwArgumentError("invalid arrayify value", "value", value);
      }
      exports2.arrayify = arrayify4;
      function concat6(items) {
        var objects = items.map(function(item) {
          return arrayify4(item);
        });
        var length = objects.reduce(function(accum, item) {
          return accum + item.length;
        }, 0);
        var result = new Uint8Array(length);
        objects.reduce(function(offset, object2) {
          result.set(object2, offset);
          return offset + object2.length;
        }, 0);
        return addSlice(result);
      }
      exports2.concat = concat6;
      function stripZeros2(value) {
        var result = arrayify4(value);
        if (result.length === 0) {
          return result;
        }
        var start = 0;
        while (start < result.length && result[start] === 0) {
          start++;
        }
        if (start) {
          result = result.slice(start);
        }
        return result;
      }
      exports2.stripZeros = stripZeros2;
      function zeroPad2(value, length) {
        value = arrayify4(value);
        if (value.length > length) {
          logger19.throwArgumentError("value out of range", "value", arguments[0]);
        }
        var result = new Uint8Array(length);
        result.set(value, length - value.length);
        return addSlice(result);
      }
      exports2.zeroPad = zeroPad2;
      function isHexString8(value, length) {
        if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
          return false;
        }
        if (length && value.length !== 2 + 2 * length) {
          return false;
        }
        return true;
      }
      exports2.isHexString = isHexString8;
      var HexCharacters = "0123456789abcdef";
      function hexlify6(value, options) {
        if (!options) {
          options = {};
        }
        if (typeof value === "number") {
          logger19.checkSafeUint53(value, "invalid hexlify value");
          var hex2 = "";
          while (value) {
            hex2 = HexCharacters[value & 15] + hex2;
            value = Math.floor(value / 16);
          }
          if (hex2.length) {
            if (hex2.length % 2) {
              hex2 = "0" + hex2;
            }
            return "0x" + hex2;
          }
          return "0x00";
        }
        if (typeof value === "bigint") {
          value = value.toString(16);
          if (value.length % 2) {
            return "0x0" + value;
          }
          return "0x" + value;
        }
        if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
          value = "0x" + value;
        }
        if (isHexable(value)) {
          return value.toHexString();
        }
        if (isHexString8(value)) {
          if (value.length % 2) {
            if (options.hexPad === "left") {
              value = "0x0" + value.substring(2);
            } else if (options.hexPad === "right") {
              value += "0";
            } else {
              logger19.throwArgumentError("hex data is odd-length", "value", value);
            }
          }
          return value.toLowerCase();
        }
        if (isBytes5(value)) {
          var result = "0x";
          for (var i4 = 0; i4 < value.length; i4++) {
            var v7 = value[i4];
            result += HexCharacters[(v7 & 240) >> 4] + HexCharacters[v7 & 15];
          }
          return result;
        }
        return logger19.throwArgumentError("invalid hexlify value", "value", value);
      }
      exports2.hexlify = hexlify6;
      function hexDataLength4(data) {
        if (typeof data !== "string") {
          data = hexlify6(data);
        } else if (!isHexString8(data) || data.length % 2) {
          return null;
        }
        return (data.length - 2) / 2;
      }
      exports2.hexDataLength = hexDataLength4;
      function hexDataSlice4(data, offset, endOffset) {
        if (typeof data !== "string") {
          data = hexlify6(data);
        } else if (!isHexString8(data) || data.length % 2) {
          logger19.throwArgumentError("invalid hexData", "value", data);
        }
        offset = 2 + 2 * offset;
        if (endOffset != null) {
          return "0x" + data.substring(offset, 2 + 2 * endOffset);
        }
        return "0x" + data.substring(offset);
      }
      exports2.hexDataSlice = hexDataSlice4;
      function hexConcat3(items) {
        var result = "0x";
        items.forEach(function(item) {
          result += hexlify6(item).substring(2);
        });
        return result;
      }
      exports2.hexConcat = hexConcat3;
      function hexValue6(value) {
        var trimmed = hexStripZeros2(hexlify6(value, { hexPad: "left" }));
        if (trimmed === "0x") {
          return "0x0";
        }
        return trimmed;
      }
      exports2.hexValue = hexValue6;
      function hexStripZeros2(value) {
        if (typeof value !== "string") {
          value = hexlify6(value);
        }
        if (!isHexString8(value)) {
          logger19.throwArgumentError("invalid hex string", "value", value);
        }
        value = value.substring(2);
        var offset = 0;
        while (offset < value.length && value[offset] === "0") {
          offset++;
        }
        return "0x" + value.substring(offset);
      }
      exports2.hexStripZeros = hexStripZeros2;
      function hexZeroPad5(value, length) {
        if (typeof value !== "string") {
          value = hexlify6(value);
        } else if (!isHexString8(value)) {
          logger19.throwArgumentError("invalid hex string", "value", value);
        }
        if (value.length > 2 * length + 2) {
          logger19.throwArgumentError("value out of range", "value", arguments[1]);
        }
        while (value.length < 2 * length + 2) {
          value = "0x0" + value.substring(2);
        }
        return value;
      }
      exports2.hexZeroPad = hexZeroPad5;
      function splitSignature2(signature) {
        var result = {
          r: "0x",
          s: "0x",
          _vs: "0x",
          recoveryParam: 0,
          v: 0,
          yParityAndS: "0x",
          compact: "0x"
        };
        if (isBytesLike2(signature)) {
          var bytes2 = arrayify4(signature);
          if (bytes2.length === 64) {
            result.v = 27 + (bytes2[32] >> 7);
            bytes2[32] &= 127;
            result.r = hexlify6(bytes2.slice(0, 32));
            result.s = hexlify6(bytes2.slice(32, 64));
          } else if (bytes2.length === 65) {
            result.r = hexlify6(bytes2.slice(0, 32));
            result.s = hexlify6(bytes2.slice(32, 64));
            result.v = bytes2[64];
          } else {
            logger19.throwArgumentError("invalid signature string", "signature", signature);
          }
          if (result.v < 27) {
            if (result.v === 0 || result.v === 1) {
              result.v += 27;
            } else {
              logger19.throwArgumentError("signature invalid v byte", "signature", signature);
            }
          }
          result.recoveryParam = 1 - result.v % 2;
          if (result.recoveryParam) {
            bytes2[32] |= 128;
          }
          result._vs = hexlify6(bytes2.slice(32, 64));
        } else {
          result.r = signature.r;
          result.s = signature.s;
          result.v = signature.v;
          result.recoveryParam = signature.recoveryParam;
          result._vs = signature._vs;
          if (result._vs != null) {
            var vs_1 = zeroPad2(arrayify4(result._vs), 32);
            result._vs = hexlify6(vs_1);
            var recoveryParam = vs_1[0] >= 128 ? 1 : 0;
            if (result.recoveryParam == null) {
              result.recoveryParam = recoveryParam;
            } else if (result.recoveryParam !== recoveryParam) {
              logger19.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            }
            vs_1[0] &= 127;
            var s4 = hexlify6(vs_1);
            if (result.s == null) {
              result.s = s4;
            } else if (result.s !== s4) {
              logger19.throwArgumentError("signature v mismatch _vs", "signature", signature);
            }
          }
          if (result.recoveryParam == null) {
            if (result.v == null) {
              logger19.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            } else if (result.v === 0 || result.v === 1) {
              result.recoveryParam = result.v;
            } else {
              result.recoveryParam = 1 - result.v % 2;
            }
          } else {
            if (result.v == null) {
              result.v = 27 + result.recoveryParam;
            } else {
              var recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
              if (result.recoveryParam !== recId) {
                logger19.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
              }
            }
          }
          if (result.r == null || !isHexString8(result.r)) {
            logger19.throwArgumentError("signature missing or invalid r", "signature", signature);
          } else {
            result.r = hexZeroPad5(result.r, 32);
          }
          if (result.s == null || !isHexString8(result.s)) {
            logger19.throwArgumentError("signature missing or invalid s", "signature", signature);
          } else {
            result.s = hexZeroPad5(result.s, 32);
          }
          var vs = arrayify4(result.s);
          if (vs[0] >= 128) {
            logger19.throwArgumentError("signature s out of range", "signature", signature);
          }
          if (result.recoveryParam) {
            vs[0] |= 128;
          }
          var _vs = hexlify6(vs);
          if (result._vs) {
            if (!isHexString8(result._vs)) {
              logger19.throwArgumentError("signature invalid _vs", "signature", signature);
            }
            result._vs = hexZeroPad5(result._vs, 32);
          }
          if (result._vs == null) {
            result._vs = _vs;
          } else if (result._vs !== _vs) {
            logger19.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
          }
        }
        result.yParityAndS = result._vs;
        result.compact = result.r + result.yParityAndS.substring(2);
        return result;
      }
      exports2.splitSignature = splitSignature2;
      function joinSignature2(signature) {
        signature = splitSignature2(signature);
        return hexlify6(concat6([
          signature.r,
          signature.s,
          signature.recoveryParam ? "0x1c" : "0x1b"
        ]));
      }
      exports2.joinSignature = joinSignature2;
    }
  });

  // node_modules/@ethersproject/bignumber/lib/_version.js
  var require_version3 = __commonJS({
    "node_modules/@ethersproject/bignumber/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "bignumber/5.7.0";
    }
  });

  // node_modules/@ethersproject/bignumber/lib/bignumber.js
  var require_bignumber = __commonJS({
    "node_modules/@ethersproject/bignumber/lib/bignumber.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2._base16To36 = exports2._base36To16 = exports2.BigNumber = exports2.isBigNumberish = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var BN = bn_js_1.default.BN;
      var bytes_1 = require_lib2();
      var logger_1 = require_lib();
      var _version_1 = require_version3();
      var logger19 = new logger_1.Logger(_version_1.version);
      var _constructorGuard2 = {};
      var MAX_SAFE = 9007199254740991;
      function isBigNumberish(value) {
        return value != null && (BigNumber8.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, bytes_1.isHexString)(value) || typeof value === "bigint" || (0, bytes_1.isBytes)(value));
      }
      exports2.isBigNumberish = isBigNumberish;
      var _warnedToStringRadix = false;
      var BigNumber8 = (
        /** @class */
        function() {
          function BigNumber9(constructorGuard, hex2) {
            if (constructorGuard !== _constructorGuard2) {
              logger19.throwError("cannot call constructor directly; use BigNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
              });
            }
            this._hex = hex2;
            this._isBigNumber = true;
            Object.freeze(this);
          }
          BigNumber9.prototype.fromTwos = function(value) {
            return toBigNumber(toBN(this).fromTwos(value));
          };
          BigNumber9.prototype.toTwos = function(value) {
            return toBigNumber(toBN(this).toTwos(value));
          };
          BigNumber9.prototype.abs = function() {
            if (this._hex[0] === "-") {
              return BigNumber9.from(this._hex.substring(1));
            }
            return this;
          };
          BigNumber9.prototype.add = function(other) {
            return toBigNumber(toBN(this).add(toBN(other)));
          };
          BigNumber9.prototype.sub = function(other) {
            return toBigNumber(toBN(this).sub(toBN(other)));
          };
          BigNumber9.prototype.div = function(other) {
            var o3 = BigNumber9.from(other);
            if (o3.isZero()) {
              throwFault("division-by-zero", "div");
            }
            return toBigNumber(toBN(this).div(toBN(other)));
          };
          BigNumber9.prototype.mul = function(other) {
            return toBigNumber(toBN(this).mul(toBN(other)));
          };
          BigNumber9.prototype.mod = function(other) {
            var value = toBN(other);
            if (value.isNeg()) {
              throwFault("division-by-zero", "mod");
            }
            return toBigNumber(toBN(this).umod(value));
          };
          BigNumber9.prototype.pow = function(other) {
            var value = toBN(other);
            if (value.isNeg()) {
              throwFault("negative-power", "pow");
            }
            return toBigNumber(toBN(this).pow(value));
          };
          BigNumber9.prototype.and = function(other) {
            var value = toBN(other);
            if (this.isNegative() || value.isNeg()) {
              throwFault("unbound-bitwise-result", "and");
            }
            return toBigNumber(toBN(this).and(value));
          };
          BigNumber9.prototype.or = function(other) {
            var value = toBN(other);
            if (this.isNegative() || value.isNeg()) {
              throwFault("unbound-bitwise-result", "or");
            }
            return toBigNumber(toBN(this).or(value));
          };
          BigNumber9.prototype.xor = function(other) {
            var value = toBN(other);
            if (this.isNegative() || value.isNeg()) {
              throwFault("unbound-bitwise-result", "xor");
            }
            return toBigNumber(toBN(this).xor(value));
          };
          BigNumber9.prototype.mask = function(value) {
            if (this.isNegative() || value < 0) {
              throwFault("negative-width", "mask");
            }
            return toBigNumber(toBN(this).maskn(value));
          };
          BigNumber9.prototype.shl = function(value) {
            if (this.isNegative() || value < 0) {
              throwFault("negative-width", "shl");
            }
            return toBigNumber(toBN(this).shln(value));
          };
          BigNumber9.prototype.shr = function(value) {
            if (this.isNegative() || value < 0) {
              throwFault("negative-width", "shr");
            }
            return toBigNumber(toBN(this).shrn(value));
          };
          BigNumber9.prototype.eq = function(other) {
            return toBN(this).eq(toBN(other));
          };
          BigNumber9.prototype.lt = function(other) {
            return toBN(this).lt(toBN(other));
          };
          BigNumber9.prototype.lte = function(other) {
            return toBN(this).lte(toBN(other));
          };
          BigNumber9.prototype.gt = function(other) {
            return toBN(this).gt(toBN(other));
          };
          BigNumber9.prototype.gte = function(other) {
            return toBN(this).gte(toBN(other));
          };
          BigNumber9.prototype.isNegative = function() {
            return this._hex[0] === "-";
          };
          BigNumber9.prototype.isZero = function() {
            return toBN(this).isZero();
          };
          BigNumber9.prototype.toNumber = function() {
            try {
              return toBN(this).toNumber();
            } catch (error) {
              throwFault("overflow", "toNumber", this.toString());
            }
            return null;
          };
          BigNumber9.prototype.toBigInt = function() {
            try {
              return BigInt(this.toString());
            } catch (e) {
            }
            return logger19.throwError("this platform does not support BigInt", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              value: this.toString()
            });
          };
          BigNumber9.prototype.toString = function() {
            if (arguments.length > 0) {
              if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                  _warnedToStringRadix = true;
                  logger19.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
              } else if (arguments[0] === 16) {
                logger19.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
              } else {
                logger19.throwError("BigNumber.toString does not accept parameters", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
              }
            }
            return toBN(this).toString(10);
          };
          BigNumber9.prototype.toHexString = function() {
            return this._hex;
          };
          BigNumber9.prototype.toJSON = function(key) {
            return { type: "BigNumber", hex: this.toHexString() };
          };
          BigNumber9.from = function(value) {
            if (value instanceof BigNumber9) {
              return value;
            }
            if (typeof value === "string") {
              if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber9(_constructorGuard2, toHex2(value));
              }
              if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber9(_constructorGuard2, toHex2(new BN(value)));
              }
              return logger19.throwArgumentError("invalid BigNumber string", "value", value);
            }
            if (typeof value === "number") {
              if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
              }
              if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
              }
              return BigNumber9.from(String(value));
            }
            var anyValue = value;
            if (typeof anyValue === "bigint") {
              return BigNumber9.from(anyValue.toString());
            }
            if ((0, bytes_1.isBytes)(anyValue)) {
              return BigNumber9.from((0, bytes_1.hexlify)(anyValue));
            }
            if (anyValue) {
              if (anyValue.toHexString) {
                var hex2 = anyValue.toHexString();
                if (typeof hex2 === "string") {
                  return BigNumber9.from(hex2);
                }
              } else {
                var hex2 = anyValue._hex;
                if (hex2 == null && anyValue.type === "BigNumber") {
                  hex2 = anyValue.hex;
                }
                if (typeof hex2 === "string") {
                  if ((0, bytes_1.isHexString)(hex2) || hex2[0] === "-" && (0, bytes_1.isHexString)(hex2.substring(1))) {
                    return BigNumber9.from(hex2);
                  }
                }
              }
            }
            return logger19.throwArgumentError("invalid BigNumber value", "value", value);
          };
          BigNumber9.isBigNumber = function(value) {
            return !!(value && value._isBigNumber);
          };
          return BigNumber9;
        }()
      );
      exports2.BigNumber = BigNumber8;
      function toHex2(value) {
        if (typeof value !== "string") {
          return toHex2(value.toString(16));
        }
        if (value[0] === "-") {
          value = value.substring(1);
          if (value[0] === "-") {
            logger19.throwArgumentError("invalid hex", "value", value);
          }
          value = toHex2(value);
          if (value === "0x00") {
            return value;
          }
          return "-" + value;
        }
        if (value.substring(0, 2) !== "0x") {
          value = "0x" + value;
        }
        if (value === "0x") {
          return "0x00";
        }
        if (value.length % 2) {
          value = "0x0" + value.substring(2);
        }
        while (value.length > 4 && value.substring(0, 4) === "0x00") {
          value = "0x" + value.substring(4);
        }
        return value;
      }
      function toBigNumber(value) {
        return BigNumber8.from(toHex2(value));
      }
      function toBN(value) {
        var hex2 = BigNumber8.from(value).toHexString();
        if (hex2[0] === "-") {
          return new BN("-" + hex2.substring(3), 16);
        }
        return new BN(hex2.substring(2), 16);
      }
      function throwFault(fault, operation, value) {
        var params = { fault, operation };
        if (value != null) {
          params.value = value;
        }
        return logger19.throwError(fault, logger_1.Logger.errors.NUMERIC_FAULT, params);
      }
      function _base36To16(value) {
        return new BN(value, 36).toString(16);
      }
      exports2._base36To16 = _base36To16;
      function _base16To36(value) {
        return new BN(value, 16).toString(36);
      }
      exports2._base16To36 = _base16To36;
    }
  });

  // node_modules/@ethersproject/bignumber/lib/fixednumber.js
  var require_fixednumber = __commonJS({
    "node_modules/@ethersproject/bignumber/lib/fixednumber.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FixedNumber = exports2.FixedFormat = exports2.parseFixed = exports2.formatFixed = void 0;
      var bytes_1 = require_lib2();
      var logger_1 = require_lib();
      var _version_1 = require_version3();
      var logger19 = new logger_1.Logger(_version_1.version);
      var bignumber_1 = require_bignumber();
      var _constructorGuard2 = {};
      var Zero = bignumber_1.BigNumber.from(0);
      var NegativeOne = bignumber_1.BigNumber.from(-1);
      function throwFault(message, fault, operation, value) {
        var params = { fault, operation };
        if (value !== void 0) {
          params.value = value;
        }
        return logger19.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);
      }
      var zeros = "0";
      while (zeros.length < 256) {
        zeros += zeros;
      }
      function getMultiplier(decimals) {
        if (typeof decimals !== "number") {
          try {
            decimals = bignumber_1.BigNumber.from(decimals).toNumber();
          } catch (e) {
          }
        }
        if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
          return "1" + zeros.substring(0, decimals);
        }
        return logger19.throwArgumentError("invalid decimal size", "decimals", decimals);
      }
      function formatFixed(value, decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        var multiplier = getMultiplier(decimals);
        value = bignumber_1.BigNumber.from(value);
        var negative = value.lt(Zero);
        if (negative) {
          value = value.mul(NegativeOne);
        }
        var fraction = value.mod(multiplier).toString();
        while (fraction.length < multiplier.length - 1) {
          fraction = "0" + fraction;
        }
        fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
        var whole = value.div(multiplier).toString();
        if (multiplier.length === 1) {
          value = whole;
        } else {
          value = whole + "." + fraction;
        }
        if (negative) {
          value = "-" + value;
        }
        return value;
      }
      exports2.formatFixed = formatFixed;
      function parseFixed(value, decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        var multiplier = getMultiplier(decimals);
        if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
          logger19.throwArgumentError("invalid decimal value", "value", value);
        }
        var negative = value.substring(0, 1) === "-";
        if (negative) {
          value = value.substring(1);
        }
        if (value === ".") {
          logger19.throwArgumentError("missing value", "value", value);
        }
        var comps = value.split(".");
        if (comps.length > 2) {
          logger19.throwArgumentError("too many decimal points", "value", value);
        }
        var whole = comps[0], fraction = comps[1];
        if (!whole) {
          whole = "0";
        }
        if (!fraction) {
          fraction = "0";
        }
        while (fraction[fraction.length - 1] === "0") {
          fraction = fraction.substring(0, fraction.length - 1);
        }
        if (fraction.length > multiplier.length - 1) {
          throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
        }
        if (fraction === "") {
          fraction = "0";
        }
        while (fraction.length < multiplier.length - 1) {
          fraction += "0";
        }
        var wholeValue = bignumber_1.BigNumber.from(whole);
        var fractionValue = bignumber_1.BigNumber.from(fraction);
        var wei = wholeValue.mul(multiplier).add(fractionValue);
        if (negative) {
          wei = wei.mul(NegativeOne);
        }
        return wei;
      }
      exports2.parseFixed = parseFixed;
      var FixedFormat = (
        /** @class */
        function() {
          function FixedFormat2(constructorGuard, signed, width, decimals) {
            if (constructorGuard !== _constructorGuard2) {
              logger19.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
              });
            }
            this.signed = signed;
            this.width = width;
            this.decimals = decimals;
            this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
            this._multiplier = getMultiplier(decimals);
            Object.freeze(this);
          }
          FixedFormat2.from = function(value) {
            if (value instanceof FixedFormat2) {
              return value;
            }
            if (typeof value === "number") {
              value = "fixed128x" + value;
            }
            var signed = true;
            var width = 128;
            var decimals = 18;
            if (typeof value === "string") {
              if (value === "fixed") {
              } else if (value === "ufixed") {
                signed = false;
              } else {
                var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) {
                  logger19.throwArgumentError("invalid fixed format", "format", value);
                }
                signed = match[1] !== "u";
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
              }
            } else if (value) {
              var check = function(key, type, defaultValue) {
                if (value[key] == null) {
                  return defaultValue;
                }
                if (typeof value[key] !== type) {
                  logger19.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                }
                return value[key];
              };
              signed = check("signed", "boolean", signed);
              width = check("width", "number", width);
              decimals = check("decimals", "number", decimals);
            }
            if (width % 8) {
              logger19.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
            }
            if (decimals > 80) {
              logger19.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
            }
            return new FixedFormat2(_constructorGuard2, signed, width, decimals);
          };
          return FixedFormat2;
        }()
      );
      exports2.FixedFormat = FixedFormat;
      var FixedNumber2 = (
        /** @class */
        function() {
          function FixedNumber3(constructorGuard, hex2, value, format3) {
            if (constructorGuard !== _constructorGuard2) {
              logger19.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
              });
            }
            this.format = format3;
            this._hex = hex2;
            this._value = value;
            this._isFixedNumber = true;
            Object.freeze(this);
          }
          FixedNumber3.prototype._checkFormat = function(other) {
            if (this.format.name !== other.format.name) {
              logger19.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
            }
          };
          FixedNumber3.prototype.addUnsafe = function(other) {
            this._checkFormat(other);
            var a2 = parseFixed(this._value, this.format.decimals);
            var b4 = parseFixed(other._value, other.format.decimals);
            return FixedNumber3.fromValue(a2.add(b4), this.format.decimals, this.format);
          };
          FixedNumber3.prototype.subUnsafe = function(other) {
            this._checkFormat(other);
            var a2 = parseFixed(this._value, this.format.decimals);
            var b4 = parseFixed(other._value, other.format.decimals);
            return FixedNumber3.fromValue(a2.sub(b4), this.format.decimals, this.format);
          };
          FixedNumber3.prototype.mulUnsafe = function(other) {
            this._checkFormat(other);
            var a2 = parseFixed(this._value, this.format.decimals);
            var b4 = parseFixed(other._value, other.format.decimals);
            return FixedNumber3.fromValue(a2.mul(b4).div(this.format._multiplier), this.format.decimals, this.format);
          };
          FixedNumber3.prototype.divUnsafe = function(other) {
            this._checkFormat(other);
            var a2 = parseFixed(this._value, this.format.decimals);
            var b4 = parseFixed(other._value, other.format.decimals);
            return FixedNumber3.fromValue(a2.mul(this.format._multiplier).div(b4), this.format.decimals, this.format);
          };
          FixedNumber3.prototype.floor = function() {
            var comps = this.toString().split(".");
            if (comps.length === 1) {
              comps.push("0");
            }
            var result = FixedNumber3.from(comps[0], this.format);
            var hasFraction = !comps[1].match(/^(0*)$/);
            if (this.isNegative() && hasFraction) {
              result = result.subUnsafe(ONE2.toFormat(result.format));
            }
            return result;
          };
          FixedNumber3.prototype.ceiling = function() {
            var comps = this.toString().split(".");
            if (comps.length === 1) {
              comps.push("0");
            }
            var result = FixedNumber3.from(comps[0], this.format);
            var hasFraction = !comps[1].match(/^(0*)$/);
            if (!this.isNegative() && hasFraction) {
              result = result.addUnsafe(ONE2.toFormat(result.format));
            }
            return result;
          };
          FixedNumber3.prototype.round = function(decimals) {
            if (decimals == null) {
              decimals = 0;
            }
            var comps = this.toString().split(".");
            if (comps.length === 1) {
              comps.push("0");
            }
            if (decimals < 0 || decimals > 80 || decimals % 1) {
              logger19.throwArgumentError("invalid decimal count", "decimals", decimals);
            }
            if (comps[1].length <= decimals) {
              return this;
            }
            var factor = FixedNumber3.from("1" + zeros.substring(0, decimals), this.format);
            var bump = BUMP.toFormat(this.format);
            return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
          };
          FixedNumber3.prototype.isZero = function() {
            return this._value === "0.0" || this._value === "0";
          };
          FixedNumber3.prototype.isNegative = function() {
            return this._value[0] === "-";
          };
          FixedNumber3.prototype.toString = function() {
            return this._value;
          };
          FixedNumber3.prototype.toHexString = function(width) {
            if (width == null) {
              return this._hex;
            }
            if (width % 8) {
              logger19.throwArgumentError("invalid byte width", "width", width);
            }
            var hex2 = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
            return (0, bytes_1.hexZeroPad)(hex2, width / 8);
          };
          FixedNumber3.prototype.toUnsafeFloat = function() {
            return parseFloat(this.toString());
          };
          FixedNumber3.prototype.toFormat = function(format3) {
            return FixedNumber3.fromString(this._value, format3);
          };
          FixedNumber3.fromValue = function(value, decimals, format3) {
            if (format3 == null && decimals != null && !(0, bignumber_1.isBigNumberish)(decimals)) {
              format3 = decimals;
              decimals = null;
            }
            if (decimals == null) {
              decimals = 0;
            }
            if (format3 == null) {
              format3 = "fixed";
            }
            return FixedNumber3.fromString(formatFixed(value, decimals), FixedFormat.from(format3));
          };
          FixedNumber3.fromString = function(value, format3) {
            if (format3 == null) {
              format3 = "fixed";
            }
            var fixedFormat = FixedFormat.from(format3);
            var numeric = parseFixed(value, fixedFormat.decimals);
            if (!fixedFormat.signed && numeric.lt(Zero)) {
              throwFault("unsigned value cannot be negative", "overflow", "value", value);
            }
            var hex2 = null;
            if (fixedFormat.signed) {
              hex2 = numeric.toTwos(fixedFormat.width).toHexString();
            } else {
              hex2 = numeric.toHexString();
              hex2 = (0, bytes_1.hexZeroPad)(hex2, fixedFormat.width / 8);
            }
            var decimal = formatFixed(numeric, fixedFormat.decimals);
            return new FixedNumber3(_constructorGuard2, hex2, decimal, fixedFormat);
          };
          FixedNumber3.fromBytes = function(value, format3) {
            if (format3 == null) {
              format3 = "fixed";
            }
            var fixedFormat = FixedFormat.from(format3);
            if ((0, bytes_1.arrayify)(value).length > fixedFormat.width / 8) {
              throw new Error("overflow");
            }
            var numeric = bignumber_1.BigNumber.from(value);
            if (fixedFormat.signed) {
              numeric = numeric.fromTwos(fixedFormat.width);
            }
            var hex2 = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
            var decimal = formatFixed(numeric, fixedFormat.decimals);
            return new FixedNumber3(_constructorGuard2, hex2, decimal, fixedFormat);
          };
          FixedNumber3.from = function(value, format3) {
            if (typeof value === "string") {
              return FixedNumber3.fromString(value, format3);
            }
            if ((0, bytes_1.isBytes)(value)) {
              return FixedNumber3.fromBytes(value, format3);
            }
            try {
              return FixedNumber3.fromValue(value, 0, format3);
            } catch (error) {
              if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {
                throw error;
              }
            }
            return logger19.throwArgumentError("invalid FixedNumber value", "value", value);
          };
          FixedNumber3.isFixedNumber = function(value) {
            return !!(value && value._isFixedNumber);
          };
          return FixedNumber3;
        }()
      );
      exports2.FixedNumber = FixedNumber2;
      var ONE2 = FixedNumber2.from(1);
      var BUMP = FixedNumber2.from("0.5");
    }
  });

  // node_modules/@ethersproject/bignumber/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/@ethersproject/bignumber/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2._base36To16 = exports2._base16To36 = exports2.parseFixed = exports2.FixedNumber = exports2.FixedFormat = exports2.formatFixed = exports2.BigNumber = void 0;
      var bignumber_1 = require_bignumber();
      Object.defineProperty(exports2, "BigNumber", { enumerable: true, get: function() {
        return bignumber_1.BigNumber;
      } });
      var fixednumber_1 = require_fixednumber();
      Object.defineProperty(exports2, "formatFixed", { enumerable: true, get: function() {
        return fixednumber_1.formatFixed;
      } });
      Object.defineProperty(exports2, "FixedFormat", { enumerable: true, get: function() {
        return fixednumber_1.FixedFormat;
      } });
      Object.defineProperty(exports2, "FixedNumber", { enumerable: true, get: function() {
        return fixednumber_1.FixedNumber;
      } });
      Object.defineProperty(exports2, "parseFixed", { enumerable: true, get: function() {
        return fixednumber_1.parseFixed;
      } });
      var bignumber_2 = require_bignumber();
      Object.defineProperty(exports2, "_base16To36", { enumerable: true, get: function() {
        return bignumber_2._base16To36;
      } });
      Object.defineProperty(exports2, "_base36To16", { enumerable: true, get: function() {
        return bignumber_2._base36To16;
      } });
    }
  });

  // node_modules/@ethersproject/properties/lib/_version.js
  var require_version4 = __commonJS({
    "node_modules/@ethersproject/properties/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "properties/5.7.0";
    }
  });

  // node_modules/@ethersproject/properties/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/@ethersproject/properties/lib/index.js"(exports2) {
      "use strict";
      var __awaiter10 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n4) {
          return function(v7) {
            return step([n4, v7]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t3[1]) {
                    _18.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _18.label < t3[2]) {
                    _18.label = t3[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e) {
              op = [6, e];
              y4 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Description = exports2.deepCopy = exports2.shallowCopy = exports2.checkProperties = exports2.resolveProperties = exports2.getStatic = exports2.defineReadOnly = void 0;
      var logger_1 = require_lib();
      var _version_1 = require_version4();
      var logger19 = new logger_1.Logger(_version_1.version);
      function defineReadOnly12(object2, name, value) {
        Object.defineProperty(object2, name, {
          enumerable: true,
          value,
          writable: false
        });
      }
      exports2.defineReadOnly = defineReadOnly12;
      function getStatic6(ctor, key) {
        for (var i4 = 0; i4 < 32; i4++) {
          if (ctor[key]) {
            return ctor[key];
          }
          if (!ctor.prototype || typeof ctor.prototype !== "object") {
            break;
          }
          ctor = Object.getPrototypeOf(ctor.prototype).constructor;
        }
        return null;
      }
      exports2.getStatic = getStatic6;
      function resolveProperties5(object2) {
        return __awaiter10(this, void 0, void 0, function() {
          var promises, results;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                promises = Object.keys(object2).map(function(key) {
                  var value = object2[key];
                  return Promise.resolve(value).then(function(v7) {
                    return { key, value: v7 };
                  });
                });
                return [4, Promise.all(promises)];
              case 1:
                results = _a.sent();
                return [2, results.reduce(function(accum, result) {
                  accum[result.key] = result.value;
                  return accum;
                }, {})];
            }
          });
        });
      }
      exports2.resolveProperties = resolveProperties5;
      function checkProperties3(object2, properties) {
        if (!object2 || typeof object2 !== "object") {
          logger19.throwArgumentError("invalid object", "object", object2);
        }
        Object.keys(object2).forEach(function(key) {
          if (!properties[key]) {
            logger19.throwArgumentError("invalid object key - " + key, "transaction:" + key, object2);
          }
        });
      }
      exports2.checkProperties = checkProperties3;
      function shallowCopy6(object2) {
        var result = {};
        for (var key in object2) {
          result[key] = object2[key];
        }
        return result;
      }
      exports2.shallowCopy = shallowCopy6;
      var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
      function _isFrozen(object2) {
        if (object2 === void 0 || object2 === null || opaque[typeof object2]) {
          return true;
        }
        if (Array.isArray(object2) || typeof object2 === "object") {
          if (!Object.isFrozen(object2)) {
            return false;
          }
          var keys = Object.keys(object2);
          for (var i4 = 0; i4 < keys.length; i4++) {
            var value = null;
            try {
              value = object2[keys[i4]];
            } catch (error) {
              continue;
            }
            if (!_isFrozen(value)) {
              return false;
            }
          }
          return true;
        }
        return logger19.throwArgumentError("Cannot deepCopy " + typeof object2, "object", object2);
      }
      function _deepCopy(object2) {
        if (_isFrozen(object2)) {
          return object2;
        }
        if (Array.isArray(object2)) {
          return Object.freeze(object2.map(function(item) {
            return deepCopy8(item);
          }));
        }
        if (typeof object2 === "object") {
          var result = {};
          for (var key in object2) {
            var value = object2[key];
            if (value === void 0) {
              continue;
            }
            defineReadOnly12(result, key, deepCopy8(value));
          }
          return result;
        }
        return logger19.throwArgumentError("Cannot deepCopy " + typeof object2, "object", object2);
      }
      function deepCopy8(object2) {
        return _deepCopy(object2);
      }
      exports2.deepCopy = deepCopy8;
      var Description = (
        /** @class */
        function() {
          function Description2(info) {
            for (var key in info) {
              this[key] = deepCopy8(info[key]);
            }
          }
          return Description2;
        }()
      );
      exports2.Description = Description;
    }
  });

  // node_modules/@ethersproject/abi/lib/_version.js
  var require_version5 = __commonJS({
    "node_modules/@ethersproject/abi/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "abi/5.7.0";
    }
  });

  // node_modules/@ethersproject/abi/lib/fragments.js
  var require_fragments = __commonJS({
    "node_modules/@ethersproject/abi/lib/fragments.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorFragment = exports2.FunctionFragment = exports2.ConstructorFragment = exports2.EventFragment = exports2.Fragment = exports2.ParamType = exports2.FormatTypes = void 0;
      var bignumber_1 = require_lib3();
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version5();
      var logger19 = new logger_1.Logger(_version_1.version);
      var _constructorGuard2 = {};
      var ModifiersBytes = { calldata: true, memory: true, storage: true };
      var ModifiersNest = { calldata: true, memory: true };
      function checkModifier(type, name) {
        if (type === "bytes" || type === "string") {
          if (ModifiersBytes[name]) {
            return true;
          }
        } else if (type === "address") {
          if (name === "payable") {
            return true;
          }
        } else if (type.indexOf("[") >= 0 || type === "tuple") {
          if (ModifiersNest[name]) {
            return true;
          }
        }
        if (ModifiersBytes[name] || name === "payable") {
          logger19.throwArgumentError("invalid modifier", "name", name);
        }
        return false;
      }
      function parseParamType(param, allowIndexed) {
        var originalParam = param;
        function throwError(i5) {
          logger19.throwArgumentError("unexpected character at position " + i5, "param", param);
        }
        param = param.replace(/\s/g, " ");
        function newNode(parent2) {
          var node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
          if (allowIndexed) {
            node2.indexed = false;
          }
          return node2;
        }
        var parent = { type: "", name: "", state: { allowType: true } };
        var node = parent;
        for (var i4 = 0; i4 < param.length; i4++) {
          var c3 = param[i4];
          switch (c3) {
            case "(":
              if (node.state.allowType && node.type === "") {
                node.type = "tuple";
              } else if (!node.state.allowParams) {
                throwError(i4);
              }
              node.state.allowType = false;
              node.type = verifyType(node.type);
              node.components = [newNode(node)];
              node = node.components[0];
              break;
            case ")":
              delete node.state;
              if (node.name === "indexed") {
                if (!allowIndexed) {
                  throwError(i4);
                }
                node.indexed = true;
                node.name = "";
              }
              if (checkModifier(node.type, node.name)) {
                node.name = "";
              }
              node.type = verifyType(node.type);
              var child = node;
              node = node.parent;
              if (!node) {
                throwError(i4);
              }
              delete child.parent;
              node.state.allowParams = false;
              node.state.allowName = true;
              node.state.allowArray = true;
              break;
            case ",":
              delete node.state;
              if (node.name === "indexed") {
                if (!allowIndexed) {
                  throwError(i4);
                }
                node.indexed = true;
                node.name = "";
              }
              if (checkModifier(node.type, node.name)) {
                node.name = "";
              }
              node.type = verifyType(node.type);
              var sibling = newNode(node.parent);
              node.parent.components.push(sibling);
              delete node.parent;
              node = sibling;
              break;
            case " ":
              if (node.state.allowType) {
                if (node.type !== "") {
                  node.type = verifyType(node.type);
                  delete node.state.allowType;
                  node.state.allowName = true;
                  node.state.allowParams = true;
                }
              }
              if (node.state.allowName) {
                if (node.name !== "") {
                  if (node.name === "indexed") {
                    if (!allowIndexed) {
                      throwError(i4);
                    }
                    if (node.indexed) {
                      throwError(i4);
                    }
                    node.indexed = true;
                    node.name = "";
                  } else if (checkModifier(node.type, node.name)) {
                    node.name = "";
                  } else {
                    node.state.allowName = false;
                  }
                }
              }
              break;
            case "[":
              if (!node.state.allowArray) {
                throwError(i4);
              }
              node.type += c3;
              node.state.allowArray = false;
              node.state.allowName = false;
              node.state.readArray = true;
              break;
            case "]":
              if (!node.state.readArray) {
                throwError(i4);
              }
              node.type += c3;
              node.state.readArray = false;
              node.state.allowArray = true;
              node.state.allowName = true;
              break;
            default:
              if (node.state.allowType) {
                node.type += c3;
                node.state.allowParams = true;
                node.state.allowArray = true;
              } else if (node.state.allowName) {
                node.name += c3;
                delete node.state.allowArray;
              } else if (node.state.readArray) {
                node.type += c3;
              } else {
                throwError(i4);
              }
          }
        }
        if (node.parent) {
          logger19.throwArgumentError("unexpected eof", "param", param);
        }
        delete parent.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(originalParam.length - 7);
          }
          if (node.indexed) {
            throwError(originalParam.length - 7);
          }
          node.indexed = true;
          node.name = "";
        } else if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        parent.type = verifyType(parent.type);
        return parent;
      }
      function populate(object2, params) {
        for (var key in params) {
          (0, properties_1.defineReadOnly)(object2, key, params[key]);
        }
      }
      exports2.FormatTypes = Object.freeze({
        // Bare formatting, as is needed for computing a sighash of an event or function
        sighash: "sighash",
        // Human-Readable with Minimal spacing and without names (compact human-readable)
        minimal: "minimal",
        // Human-Readable with nice spacing, including all names
        full: "full",
        // JSON-format a la Solidity
        json: "json"
      });
      var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
      var ParamType2 = (
        /** @class */
        function() {
          function ParamType3(constructorGuard, params) {
            if (constructorGuard !== _constructorGuard2) {
              logger19.throwError("use fromString", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
              });
            }
            populate(this, params);
            var match = this.type.match(paramTypeArray);
            if (match) {
              populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType3.fromObject({
                  type: match[1],
                  components: this.components
                }),
                baseType: "array"
              });
            } else {
              populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: this.components != null ? "tuple" : this.type
              });
            }
            this._isParamType = true;
            Object.freeze(this);
          }
          ParamType3.prototype.format = function(format3) {
            if (!format3) {
              format3 = exports2.FormatTypes.sighash;
            }
            if (!exports2.FormatTypes[format3]) {
              logger19.throwArgumentError("invalid format type", "format", format3);
            }
            if (format3 === exports2.FormatTypes.json) {
              var result_1 = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: this.name || void 0
              };
              if (typeof this.indexed === "boolean") {
                result_1.indexed = this.indexed;
              }
              if (this.components) {
                result_1.components = this.components.map(function(comp) {
                  return JSON.parse(comp.format(format3));
                });
              }
              return JSON.stringify(result_1);
            }
            var result = "";
            if (this.baseType === "array") {
              result += this.arrayChildren.format(format3);
              result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
            } else {
              if (this.baseType === "tuple") {
                if (format3 !== exports2.FormatTypes.sighash) {
                  result += this.type;
                }
                result += "(" + this.components.map(function(comp) {
                  return comp.format(format3);
                }).join(format3 === exports2.FormatTypes.full ? ", " : ",") + ")";
              } else {
                result += this.type;
              }
            }
            if (format3 !== exports2.FormatTypes.sighash) {
              if (this.indexed === true) {
                result += " indexed";
              }
              if (format3 === exports2.FormatTypes.full && this.name) {
                result += " " + this.name;
              }
            }
            return result;
          };
          ParamType3.from = function(value, allowIndexed) {
            if (typeof value === "string") {
              return ParamType3.fromString(value, allowIndexed);
            }
            return ParamType3.fromObject(value);
          };
          ParamType3.fromObject = function(value) {
            if (ParamType3.isParamType(value)) {
              return value;
            }
            return new ParamType3(_constructorGuard2, {
              name: value.name || null,
              type: verifyType(value.type),
              indexed: value.indexed == null ? null : !!value.indexed,
              components: value.components ? value.components.map(ParamType3.fromObject) : null
            });
          };
          ParamType3.fromString = function(value, allowIndexed) {
            function ParamTypify(node) {
              return ParamType3.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
              });
            }
            return ParamTypify(parseParamType(value, !!allowIndexed));
          };
          ParamType3.isParamType = function(value) {
            return !!(value != null && value._isParamType);
          };
          return ParamType3;
        }()
      );
      exports2.ParamType = ParamType2;
      function parseParams(value, allowIndex) {
        return splitNesting(value).map(function(param) {
          return ParamType2.fromString(param, allowIndex);
        });
      }
      var Fragment2 = (
        /** @class */
        function() {
          function Fragment3(constructorGuard, params) {
            if (constructorGuard !== _constructorGuard2) {
              logger19.throwError("use a static from method", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
              });
            }
            populate(this, params);
            this._isFragment = true;
            Object.freeze(this);
          }
          Fragment3.from = function(value) {
            if (Fragment3.isFragment(value)) {
              return value;
            }
            if (typeof value === "string") {
              return Fragment3.fromString(value);
            }
            return Fragment3.fromObject(value);
          };
          Fragment3.fromObject = function(value) {
            if (Fragment3.isFragment(value)) {
              return value;
            }
            switch (value.type) {
              case "function":
                return FunctionFragment2.fromObject(value);
              case "event":
                return EventFragment2.fromObject(value);
              case "constructor":
                return ConstructorFragment2.fromObject(value);
              case "error":
                return ErrorFragment2.fromObject(value);
              case "fallback":
              case "receive":
                return null;
            }
            return logger19.throwArgumentError("invalid fragment object", "value", value);
          };
          Fragment3.fromString = function(value) {
            value = value.replace(/\s/g, " ");
            value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
            value = value.trim();
            if (value.split(" ")[0] === "event") {
              return EventFragment2.fromString(value.substring(5).trim());
            } else if (value.split(" ")[0] === "function") {
              return FunctionFragment2.fromString(value.substring(8).trim());
            } else if (value.split("(")[0].trim() === "constructor") {
              return ConstructorFragment2.fromString(value.trim());
            } else if (value.split(" ")[0] === "error") {
              return ErrorFragment2.fromString(value.substring(5).trim());
            }
            return logger19.throwArgumentError("unsupported fragment", "value", value);
          };
          Fragment3.isFragment = function(value) {
            return !!(value && value._isFragment);
          };
          return Fragment3;
        }()
      );
      exports2.Fragment = Fragment2;
      var EventFragment2 = (
        /** @class */
        function(_super) {
          __extends2(EventFragment3, _super);
          function EventFragment3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          EventFragment3.prototype.format = function(format3) {
            if (!format3) {
              format3 = exports2.FormatTypes.sighash;
            }
            if (!exports2.FormatTypes[format3]) {
              logger19.throwArgumentError("invalid format type", "format", format3);
            }
            if (format3 === exports2.FormatTypes.json) {
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map(function(input) {
                  return JSON.parse(input.format(format3));
                })
              });
            }
            var result = "";
            if (format3 !== exports2.FormatTypes.sighash) {
              result += "event ";
            }
            result += this.name + "(" + this.inputs.map(function(input) {
              return input.format(format3);
            }).join(format3 === exports2.FormatTypes.full ? ", " : ",") + ") ";
            if (format3 !== exports2.FormatTypes.sighash) {
              if (this.anonymous) {
                result += "anonymous ";
              }
            }
            return result.trim();
          };
          EventFragment3.from = function(value) {
            if (typeof value === "string") {
              return EventFragment3.fromString(value);
            }
            return EventFragment3.fromObject(value);
          };
          EventFragment3.fromObject = function(value) {
            if (EventFragment3.isEventFragment(value)) {
              return value;
            }
            if (value.type !== "event") {
              logger19.throwArgumentError("invalid event object", "value", value);
            }
            var params = {
              name: verifyIdentifier(value.name),
              anonymous: value.anonymous,
              inputs: value.inputs ? value.inputs.map(ParamType2.fromObject) : [],
              type: "event"
            };
            return new EventFragment3(_constructorGuard2, params);
          };
          EventFragment3.fromString = function(value) {
            var match = value.match(regexParen);
            if (!match) {
              logger19.throwArgumentError("invalid event string", "value", value);
            }
            var anonymous = false;
            match[3].split(" ").forEach(function(modifier) {
              switch (modifier.trim()) {
                case "anonymous":
                  anonymous = true;
                  break;
                case "":
                  break;
                default:
                  logger19.warn("unknown modifier: " + modifier);
              }
            });
            return EventFragment3.fromObject({
              name: match[1].trim(),
              anonymous,
              inputs: parseParams(match[2], true),
              type: "event"
            });
          };
          EventFragment3.isEventFragment = function(value) {
            return value && value._isFragment && value.type === "event";
          };
          return EventFragment3;
        }(Fragment2)
      );
      exports2.EventFragment = EventFragment2;
      function parseGas(value, params) {
        params.gas = null;
        var comps = value.split("@");
        if (comps.length !== 1) {
          if (comps.length > 2) {
            logger19.throwArgumentError("invalid human-readable ABI signature", "value", value);
          }
          if (!comps[1].match(/^[0-9]+$/)) {
            logger19.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
          }
          params.gas = bignumber_1.BigNumber.from(comps[1]);
          return comps[0];
        }
        return value;
      }
      function parseModifiers(value, params) {
        params.constant = false;
        params.payable = false;
        params.stateMutability = "nonpayable";
        value.split(" ").forEach(function(modifier) {
          switch (modifier.trim()) {
            case "constant":
              params.constant = true;
              break;
            case "payable":
              params.payable = true;
              params.stateMutability = "payable";
              break;
            case "nonpayable":
              params.payable = false;
              params.stateMutability = "nonpayable";
              break;
            case "pure":
              params.constant = true;
              params.stateMutability = "pure";
              break;
            case "view":
              params.constant = true;
              params.stateMutability = "view";
              break;
            case "external":
            case "public":
            case "":
              break;
            default:
              console.log("unknown modifier: " + modifier);
          }
        });
      }
      function verifyState(value) {
        var result = {
          constant: false,
          payable: true,
          stateMutability: "payable"
        };
        if (value.stateMutability != null) {
          result.stateMutability = value.stateMutability;
          result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
          if (value.constant != null) {
            if (!!value.constant !== result.constant) {
              logger19.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
          }
          result.payable = result.stateMutability === "payable";
          if (value.payable != null) {
            if (!!value.payable !== result.payable) {
              logger19.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
          }
        } else if (value.payable != null) {
          result.payable = !!value.payable;
          if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger19.throwArgumentError("unable to determine stateMutability", "value", value);
          }
          result.constant = !!value.constant;
          if (result.constant) {
            result.stateMutability = "view";
          } else {
            result.stateMutability = result.payable ? "payable" : "nonpayable";
          }
          if (result.payable && result.constant) {
            logger19.throwArgumentError("cannot have constant payable function", "value", value);
          }
        } else if (value.constant != null) {
          result.constant = !!value.constant;
          result.payable = !result.constant;
          result.stateMutability = result.constant ? "view" : "payable";
        } else if (value.type !== "constructor") {
          logger19.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        return result;
      }
      var ConstructorFragment2 = (
        /** @class */
        function(_super) {
          __extends2(ConstructorFragment3, _super);
          function ConstructorFragment3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          ConstructorFragment3.prototype.format = function(format3) {
            if (!format3) {
              format3 = exports2.FormatTypes.sighash;
            }
            if (!exports2.FormatTypes[format3]) {
              logger19.throwArgumentError("invalid format type", "format", format3);
            }
            if (format3 === exports2.FormatTypes.json) {
              return JSON.stringify({
                type: "constructor",
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map(function(input) {
                  return JSON.parse(input.format(format3));
                })
              });
            }
            if (format3 === exports2.FormatTypes.sighash) {
              logger19.throwError("cannot format a constructor for sighash", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
              });
            }
            var result = "constructor(" + this.inputs.map(function(input) {
              return input.format(format3);
            }).join(format3 === exports2.FormatTypes.full ? ", " : ",") + ") ";
            if (this.stateMutability && this.stateMutability !== "nonpayable") {
              result += this.stateMutability + " ";
            }
            return result.trim();
          };
          ConstructorFragment3.from = function(value) {
            if (typeof value === "string") {
              return ConstructorFragment3.fromString(value);
            }
            return ConstructorFragment3.fromObject(value);
          };
          ConstructorFragment3.fromObject = function(value) {
            if (ConstructorFragment3.isConstructorFragment(value)) {
              return value;
            }
            if (value.type !== "constructor") {
              logger19.throwArgumentError("invalid constructor object", "value", value);
            }
            var state = verifyState(value);
            if (state.constant) {
              logger19.throwArgumentError("constructor cannot be constant", "value", value);
            }
            var params = {
              name: null,
              type: value.type,
              inputs: value.inputs ? value.inputs.map(ParamType2.fromObject) : [],
              payable: state.payable,
              stateMutability: state.stateMutability,
              gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
            };
            return new ConstructorFragment3(_constructorGuard2, params);
          };
          ConstructorFragment3.fromString = function(value) {
            var params = { type: "constructor" };
            value = parseGas(value, params);
            var parens = value.match(regexParen);
            if (!parens || parens[1].trim() !== "constructor") {
              logger19.throwArgumentError("invalid constructor string", "value", value);
            }
            params.inputs = parseParams(parens[2].trim(), false);
            parseModifiers(parens[3].trim(), params);
            return ConstructorFragment3.fromObject(params);
          };
          ConstructorFragment3.isConstructorFragment = function(value) {
            return value && value._isFragment && value.type === "constructor";
          };
          return ConstructorFragment3;
        }(Fragment2)
      );
      exports2.ConstructorFragment = ConstructorFragment2;
      var FunctionFragment2 = (
        /** @class */
        function(_super) {
          __extends2(FunctionFragment3, _super);
          function FunctionFragment3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          FunctionFragment3.prototype.format = function(format3) {
            if (!format3) {
              format3 = exports2.FormatTypes.sighash;
            }
            if (!exports2.FormatTypes[format3]) {
              logger19.throwArgumentError("invalid format type", "format", format3);
            }
            if (format3 === exports2.FormatTypes.json) {
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map(function(input) {
                  return JSON.parse(input.format(format3));
                }),
                outputs: this.outputs.map(function(output2) {
                  return JSON.parse(output2.format(format3));
                })
              });
            }
            var result = "";
            if (format3 !== exports2.FormatTypes.sighash) {
              result += "function ";
            }
            result += this.name + "(" + this.inputs.map(function(input) {
              return input.format(format3);
            }).join(format3 === exports2.FormatTypes.full ? ", " : ",") + ") ";
            if (format3 !== exports2.FormatTypes.sighash) {
              if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                  result += this.stateMutability + " ";
                }
              } else if (this.constant) {
                result += "view ";
              }
              if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map(function(output2) {
                  return output2.format(format3);
                }).join(", ") + ") ";
              }
              if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
              }
            }
            return result.trim();
          };
          FunctionFragment3.from = function(value) {
            if (typeof value === "string") {
              return FunctionFragment3.fromString(value);
            }
            return FunctionFragment3.fromObject(value);
          };
          FunctionFragment3.fromObject = function(value) {
            if (FunctionFragment3.isFunctionFragment(value)) {
              return value;
            }
            if (value.type !== "function") {
              logger19.throwArgumentError("invalid function object", "value", value);
            }
            var state = verifyState(value);
            var params = {
              type: value.type,
              name: verifyIdentifier(value.name),
              constant: state.constant,
              inputs: value.inputs ? value.inputs.map(ParamType2.fromObject) : [],
              outputs: value.outputs ? value.outputs.map(ParamType2.fromObject) : [],
              payable: state.payable,
              stateMutability: state.stateMutability,
              gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
            };
            return new FunctionFragment3(_constructorGuard2, params);
          };
          FunctionFragment3.fromString = function(value) {
            var params = { type: "function" };
            value = parseGas(value, params);
            var comps = value.split(" returns ");
            if (comps.length > 2) {
              logger19.throwArgumentError("invalid function string", "value", value);
            }
            var parens = comps[0].match(regexParen);
            if (!parens) {
              logger19.throwArgumentError("invalid function signature", "value", value);
            }
            params.name = parens[1].trim();
            if (params.name) {
              verifyIdentifier(params.name);
            }
            params.inputs = parseParams(parens[2], false);
            parseModifiers(parens[3].trim(), params);
            if (comps.length > 1) {
              var returns = comps[1].match(regexParen);
              if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger19.throwArgumentError("unexpected tokens", "value", value);
              }
              params.outputs = parseParams(returns[2], false);
            } else {
              params.outputs = [];
            }
            return FunctionFragment3.fromObject(params);
          };
          FunctionFragment3.isFunctionFragment = function(value) {
            return value && value._isFragment && value.type === "function";
          };
          return FunctionFragment3;
        }(ConstructorFragment2)
      );
      exports2.FunctionFragment = FunctionFragment2;
      function checkForbidden(fragment) {
        var sig = fragment.format();
        if (sig === "Error(string)" || sig === "Panic(uint256)") {
          logger19.throwArgumentError("cannot specify user defined " + sig + " error", "fragment", fragment);
        }
        return fragment;
      }
      var ErrorFragment2 = (
        /** @class */
        function(_super) {
          __extends2(ErrorFragment3, _super);
          function ErrorFragment3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          ErrorFragment3.prototype.format = function(format3) {
            if (!format3) {
              format3 = exports2.FormatTypes.sighash;
            }
            if (!exports2.FormatTypes[format3]) {
              logger19.throwArgumentError("invalid format type", "format", format3);
            }
            if (format3 === exports2.FormatTypes.json) {
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map(function(input) {
                  return JSON.parse(input.format(format3));
                })
              });
            }
            var result = "";
            if (format3 !== exports2.FormatTypes.sighash) {
              result += "error ";
            }
            result += this.name + "(" + this.inputs.map(function(input) {
              return input.format(format3);
            }).join(format3 === exports2.FormatTypes.full ? ", " : ",") + ") ";
            return result.trim();
          };
          ErrorFragment3.from = function(value) {
            if (typeof value === "string") {
              return ErrorFragment3.fromString(value);
            }
            return ErrorFragment3.fromObject(value);
          };
          ErrorFragment3.fromObject = function(value) {
            if (ErrorFragment3.isErrorFragment(value)) {
              return value;
            }
            if (value.type !== "error") {
              logger19.throwArgumentError("invalid error object", "value", value);
            }
            var params = {
              type: value.type,
              name: verifyIdentifier(value.name),
              inputs: value.inputs ? value.inputs.map(ParamType2.fromObject) : []
            };
            return checkForbidden(new ErrorFragment3(_constructorGuard2, params));
          };
          ErrorFragment3.fromString = function(value) {
            var params = { type: "error" };
            var parens = value.match(regexParen);
            if (!parens) {
              logger19.throwArgumentError("invalid error signature", "value", value);
            }
            params.name = parens[1].trim();
            if (params.name) {
              verifyIdentifier(params.name);
            }
            params.inputs = parseParams(parens[2], false);
            return checkForbidden(ErrorFragment3.fromObject(params));
          };
          ErrorFragment3.isErrorFragment = function(value) {
            return value && value._isFragment && value.type === "error";
          };
          return ErrorFragment3;
        }(Fragment2)
      );
      exports2.ErrorFragment = ErrorFragment2;
      function verifyType(type) {
        if (type.match(/^uint($|[^1-9])/)) {
          type = "uint256" + type.substring(4);
        } else if (type.match(/^int($|[^1-9])/)) {
          type = "int256" + type.substring(3);
        }
        return type;
      }
      var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
      function verifyIdentifier(value) {
        if (!value || !value.match(regexIdentifier)) {
          logger19.throwArgumentError('invalid identifier "' + value + '"', "value", value);
        }
        return value;
      }
      var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
      function splitNesting(value) {
        value = value.trim();
        var result = [];
        var accum = "";
        var depth = 0;
        for (var offset = 0; offset < value.length; offset++) {
          var c3 = value[offset];
          if (c3 === "," && depth === 0) {
            result.push(accum);
            accum = "";
          } else {
            accum += c3;
            if (c3 === "(") {
              depth++;
            } else if (c3 === ")") {
              depth--;
              if (depth === -1) {
                logger19.throwArgumentError("unbalanced parenthesis", "value", value);
              }
            }
          }
        }
        if (accum) {
          result.push(accum);
        }
        return result;
      }
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/abstract-coder.js
  var require_abstract_coder = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/abstract-coder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Reader = exports2.Writer = exports2.Coder = exports2.checkResultErrors = void 0;
      var bytes_1 = require_lib2();
      var bignumber_1 = require_lib3();
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version5();
      var logger19 = new logger_1.Logger(_version_1.version);
      function checkResultErrors3(result) {
        var errors3 = [];
        var checkErrors = function(path, object2) {
          if (!Array.isArray(object2)) {
            return;
          }
          for (var key in object2) {
            var childPath = path.slice();
            childPath.push(key);
            try {
              checkErrors(childPath, object2[key]);
            } catch (error) {
              errors3.push({ path: childPath, error });
            }
          }
        };
        checkErrors([], result);
        return errors3;
      }
      exports2.checkResultErrors = checkResultErrors3;
      var Coder = (
        /** @class */
        function() {
          function Coder2(name, type, localName, dynamic) {
            this.name = name;
            this.type = type;
            this.localName = localName;
            this.dynamic = dynamic;
          }
          Coder2.prototype._throwError = function(message, value) {
            logger19.throwArgumentError(message, this.localName, value);
          };
          return Coder2;
        }()
      );
      exports2.Coder = Coder;
      var Writer = (
        /** @class */
        function() {
          function Writer2(wordSize) {
            (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
            this._data = [];
            this._dataLength = 0;
            this._padding = new Uint8Array(wordSize);
          }
          Object.defineProperty(Writer2.prototype, "data", {
            get: function() {
              return (0, bytes_1.hexConcat)(this._data);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Writer2.prototype, "length", {
            get: function() {
              return this._dataLength;
            },
            enumerable: false,
            configurable: true
          });
          Writer2.prototype._writeData = function(data) {
            this._data.push(data);
            this._dataLength += data.length;
            return data.length;
          };
          Writer2.prototype.appendWriter = function(writer) {
            return this._writeData((0, bytes_1.concat)(writer._data));
          };
          Writer2.prototype.writeBytes = function(value) {
            var bytes2 = (0, bytes_1.arrayify)(value);
            var paddingOffset = bytes2.length % this.wordSize;
            if (paddingOffset) {
              bytes2 = (0, bytes_1.concat)([bytes2, this._padding.slice(paddingOffset)]);
            }
            return this._writeData(bytes2);
          };
          Writer2.prototype._getValue = function(value) {
            var bytes2 = (0, bytes_1.arrayify)(bignumber_1.BigNumber.from(value));
            if (bytes2.length > this.wordSize) {
              logger19.throwError("value out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes2.length
              });
            }
            if (bytes2.length % this.wordSize) {
              bytes2 = (0, bytes_1.concat)([this._padding.slice(bytes2.length % this.wordSize), bytes2]);
            }
            return bytes2;
          };
          Writer2.prototype.writeValue = function(value) {
            return this._writeData(this._getValue(value));
          };
          Writer2.prototype.writeUpdatableValue = function() {
            var _this = this;
            var offset = this._data.length;
            this._data.push(this._padding);
            this._dataLength += this.wordSize;
            return function(value) {
              _this._data[offset] = _this._getValue(value);
            };
          };
          return Writer2;
        }()
      );
      exports2.Writer = Writer;
      var Reader = (
        /** @class */
        function() {
          function Reader2(data, wordSize, coerceFunc, allowLoose) {
            (0, properties_1.defineReadOnly)(this, "_data", (0, bytes_1.arrayify)(data));
            (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
            (0, properties_1.defineReadOnly)(this, "_coerceFunc", coerceFunc);
            (0, properties_1.defineReadOnly)(this, "allowLoose", allowLoose);
            this._offset = 0;
          }
          Object.defineProperty(Reader2.prototype, "data", {
            get: function() {
              return (0, bytes_1.hexlify)(this._data);
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Reader2.prototype, "consumed", {
            get: function() {
              return this._offset;
            },
            enumerable: false,
            configurable: true
          });
          Reader2.coerce = function(name, value) {
            var match = name.match("^u?int([0-9]+)$");
            if (match && parseInt(match[1]) <= 48) {
              value = value.toNumber();
            }
            return value;
          };
          Reader2.prototype.coerce = function(name, value) {
            if (this._coerceFunc) {
              return this._coerceFunc(name, value);
            }
            return Reader2.coerce(name, value);
          };
          Reader2.prototype._peekBytes = function(offset, length, loose) {
            var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
            if (this._offset + alignedLength > this._data.length) {
              if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
              } else {
                logger19.throwError("data out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
                  length: this._data.length,
                  offset: this._offset + alignedLength
                });
              }
            }
            return this._data.slice(this._offset, this._offset + alignedLength);
          };
          Reader2.prototype.subReader = function(offset) {
            return new Reader2(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
          };
          Reader2.prototype.readBytes = function(length, loose) {
            var bytes2 = this._peekBytes(0, length, !!loose);
            this._offset += bytes2.length;
            return bytes2.slice(0, length);
          };
          Reader2.prototype.readValue = function() {
            return bignumber_1.BigNumber.from(this.readBytes(this.wordSize));
          };
          return Reader2;
        }()
      );
      exports2.Reader = Reader;
    }
  });

  // node_modules/js-sha3/src/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/js-sha3/src/sha3.js"(exports2, module2) {
      (function() {
        "use strict";
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA3_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
        var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
        var KECCAK_PADDING = [1, 256, 65536, 16777216];
        var PADDING = [6, 1536, 393216, 100663296];
        var SHIFT = [0, 8, 16, 24];
        var RC = [
          1,
          0,
          32898,
          0,
          32906,
          2147483648,
          2147516416,
          2147483648,
          32907,
          0,
          2147483649,
          0,
          2147516545,
          2147483648,
          32777,
          2147483648,
          138,
          0,
          136,
          0,
          2147516425,
          0,
          2147483658,
          0,
          2147516555,
          0,
          139,
          2147483648,
          32905,
          2147483648,
          32771,
          2147483648,
          32770,
          2147483648,
          128,
          2147483648,
          32778,
          0,
          2147483658,
          2147483648,
          2147516545,
          2147483648,
          32896,
          2147483648,
          2147483649,
          0,
          2147516424,
          2147483648
        ];
        var BITS = [224, 256, 384, 512];
        var SHAKE_BITS = [128, 256];
        var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
        var CSHAKE_BYTEPAD = {
          "128": 168,
          "256": 136
        };
        if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(bits2, padding2, outputType) {
          return function(message) {
            return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
          };
        };
        var createShakeOutputMethod = function(bits2, padding2, outputType) {
          return function(message, outputBits) {
            return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
          };
        };
        var createCshakeOutputMethod = function(bits2, padding2, outputType) {
          return function(message, outputBits, n4, s4) {
            return methods["cshake" + bits2].update(message, outputBits, n4, s4)[outputType]();
          };
        };
        var createKmacOutputMethod = function(bits2, padding2, outputType) {
          return function(key, message, outputBits, s4) {
            return methods["kmac" + bits2].update(key, message, outputBits, s4)[outputType]();
          };
        };
        var createOutputMethods = function(method, createMethod2, bits2, padding2) {
          for (var i5 = 0; i5 < OUTPUT_TYPES.length; ++i5) {
            var type = OUTPUT_TYPES[i5];
            method[type] = createMethod2(bits2, padding2, type);
          }
          return method;
        };
        var createMethod = function(bits2, padding2) {
          var method = createOutputMethod(bits2, padding2, "hex");
          method.create = function() {
            return new Keccak2(bits2, padding2, bits2);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          return createOutputMethods(method, createOutputMethod, bits2, padding2);
        };
        var createShakeMethod = function(bits2, padding2) {
          var method = createShakeOutputMethod(bits2, padding2, "hex");
          method.create = function(outputBits) {
            return new Keccak2(bits2, padding2, outputBits);
          };
          method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
          };
          return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
        };
        var createCshakeMethod = function(bits2, padding2) {
          var w3 = CSHAKE_BYTEPAD[bits2];
          var method = createCshakeOutputMethod(bits2, padding2, "hex");
          method.create = function(outputBits, n4, s4) {
            if (!n4 && !s4) {
              return methods["shake" + bits2].create(outputBits);
            } else {
              return new Keccak2(bits2, padding2, outputBits).bytepad([n4, s4], w3);
            }
          };
          method.update = function(message, outputBits, n4, s4) {
            return method.create(outputBits, n4, s4).update(message);
          };
          return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
        };
        var createKmacMethod = function(bits2, padding2) {
          var w3 = CSHAKE_BYTEPAD[bits2];
          var method = createKmacOutputMethod(bits2, padding2, "hex");
          method.create = function(key, outputBits, s4) {
            return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s4], w3).bytepad([key], w3);
          };
          method.update = function(key, message, outputBits, s4) {
            return method.create(key, outputBits, s4).update(message);
          };
          return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
        };
        var algorithms = [
          { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
          { name: "sha3", padding: PADDING, bits: BITS, createMethod },
          { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
          { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
          { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
        ];
        var methods = {}, methodNames = [];
        for (var i4 = 0; i4 < algorithms.length; ++i4) {
          var algorithm = algorithms[i4];
          var bits = algorithm.bits;
          for (var j3 = 0; j3 < bits.length; ++j3) {
            var methodName = algorithm.name + "_" + bits[j3];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j3], algorithm.padding);
            if (algorithm.name !== "sha3") {
              var newMethodName = algorithm.name + bits[j3];
              methodNames.push(newMethodName);
              methods[newMethodName] = methods[methodName];
            }
          }
        }
        function Keccak2(bits2, padding2, outputBits) {
          this.blocks = [];
          this.s = [];
          this.padding = padding2;
          this.outputBits = outputBits;
          this.reset = true;
          this.finalized = false;
          this.block = 0;
          this.start = 0;
          this.blockCount = 1600 - (bits2 << 1) >> 5;
          this.byteCount = this.blockCount << 2;
          this.outputBlocks = outputBits >> 5;
          this.extraBytes = (outputBits & 31) >> 3;
          for (var i5 = 0; i5 < 50; ++i5) {
            this.s[i5] = 0;
          }
        }
        Keccak2.prototype.update = function(message) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s4 = this.s, i5, code;
          while (index2 < length) {
            if (this.reset) {
              this.reset = false;
              blocks[0] = this.block;
              for (i5 = 1; i5 < blockCount + 1; ++i5) {
                blocks[i5] = 0;
              }
            }
            if (notString) {
              for (i5 = this.start; index2 < length && i5 < byteCount; ++index2) {
                blocks[i5 >> 2] |= message[index2] << SHIFT[i5++ & 3];
              }
            } else {
              for (i5 = this.start; index2 < length && i5 < byteCount; ++index2) {
                code = message.charCodeAt(index2);
                if (code < 128) {
                  blocks[i5 >> 2] |= code << SHIFT[i5++ & 3];
                } else if (code < 2048) {
                  blocks[i5 >> 2] |= (192 | code >> 6) << SHIFT[i5++ & 3];
                  blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks[i5 >> 2] |= (224 | code >> 12) << SHIFT[i5++ & 3];
                  blocks[i5 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i5++ & 3];
                  blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                  blocks[i5 >> 2] |= (240 | code >> 18) << SHIFT[i5++ & 3];
                  blocks[i5 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i5++ & 3];
                  blocks[i5 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i5++ & 3];
                  blocks[i5 >> 2] |= (128 | code & 63) << SHIFT[i5++ & 3];
                }
              }
            }
            this.lastByteIndex = i5;
            if (i5 >= byteCount) {
              this.start = i5 - byteCount;
              this.block = blocks[blockCount];
              for (i5 = 0; i5 < blockCount; ++i5) {
                s4[i5] ^= blocks[i5];
              }
              f5(s4);
              this.reset = true;
            } else {
              this.start = i5;
            }
          }
          return this;
        };
        Keccak2.prototype.encode = function(x8, right) {
          var o3 = x8 & 255, n4 = 1;
          var bytes2 = [o3];
          x8 = x8 >> 8;
          o3 = x8 & 255;
          while (o3 > 0) {
            bytes2.unshift(o3);
            x8 = x8 >> 8;
            o3 = x8 & 255;
            ++n4;
          }
          if (right) {
            bytes2.push(n4);
          } else {
            bytes2.unshift(n4);
          }
          this.update(bytes2);
          return bytes2.length;
        };
        Keccak2.prototype.encodeString = function(str) {
          var notString, type = typeof str;
          if (type !== "string") {
            if (type === "object") {
              if (str === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
                str = new Uint8Array(str);
              } else if (!Array.isArray(str)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var bytes2 = 0, length = str.length;
          if (notString) {
            bytes2 = length;
          } else {
            for (var i5 = 0; i5 < str.length; ++i5) {
              var code = str.charCodeAt(i5);
              if (code < 128) {
                bytes2 += 1;
              } else if (code < 2048) {
                bytes2 += 2;
              } else if (code < 55296 || code >= 57344) {
                bytes2 += 3;
              } else {
                code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i5) & 1023);
                bytes2 += 4;
              }
            }
          }
          bytes2 += this.encode(bytes2 * 8);
          this.update(str);
          return bytes2;
        };
        Keccak2.prototype.bytepad = function(strs, w3) {
          var bytes2 = this.encode(w3);
          for (var i5 = 0; i5 < strs.length; ++i5) {
            bytes2 += this.encodeString(strs[i5]);
          }
          var paddingBytes = w3 - bytes2 % w3;
          var zeros = [];
          zeros.length = paddingBytes;
          this.update(zeros);
          return this;
        };
        Keccak2.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks = this.blocks, i5 = this.lastByteIndex, blockCount = this.blockCount, s4 = this.s;
          blocks[i5 >> 2] |= this.padding[i5 & 3];
          if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for (i5 = 1; i5 < blockCount + 1; ++i5) {
              blocks[i5] = 0;
            }
          }
          blocks[blockCount - 1] |= 2147483648;
          for (i5 = 0; i5 < blockCount; ++i5) {
            s4[i5] ^= blocks[i5];
          }
          f5(s4);
        };
        Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
          this.finalize();
          var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j4 = 0;
          var hex2 = "", block;
          while (j4 < outputBlocks) {
            for (i5 = 0; i5 < blockCount && j4 < outputBlocks; ++i5, ++j4) {
              block = s4[i5];
              hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
            }
            if (j4 % blockCount === 0) {
              f5(s4);
              i5 = 0;
            }
          }
          if (extraBytes) {
            block = s4[i5];
            hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
            if (extraBytes > 1) {
              hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
            }
            if (extraBytes > 2) {
              hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
            }
          }
          return hex2;
        };
        Keccak2.prototype.arrayBuffer = function() {
          this.finalize();
          var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j4 = 0;
          var bytes2 = this.outputBits >> 3;
          var buffer2;
          if (extraBytes) {
            buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
          } else {
            buffer2 = new ArrayBuffer(bytes2);
          }
          var array2 = new Uint32Array(buffer2);
          while (j4 < outputBlocks) {
            for (i5 = 0; i5 < blockCount && j4 < outputBlocks; ++i5, ++j4) {
              array2[j4] = s4[i5];
            }
            if (j4 % blockCount === 0) {
              f5(s4);
            }
          }
          if (extraBytes) {
            array2[i5] = s4[i5];
            buffer2 = buffer2.slice(0, bytes2);
          }
          return buffer2;
        };
        Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
        Keccak2.prototype.digest = Keccak2.prototype.array = function() {
          this.finalize();
          var blockCount = this.blockCount, s4 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j4 = 0;
          var array2 = [], offset, block;
          while (j4 < outputBlocks) {
            for (i5 = 0; i5 < blockCount && j4 < outputBlocks; ++i5, ++j4) {
              offset = j4 << 2;
              block = s4[i5];
              array2[offset] = block & 255;
              array2[offset + 1] = block >> 8 & 255;
              array2[offset + 2] = block >> 16 & 255;
              array2[offset + 3] = block >> 24 & 255;
            }
            if (j4 % blockCount === 0) {
              f5(s4);
            }
          }
          if (extraBytes) {
            offset = j4 << 2;
            block = s4[i5];
            array2[offset] = block & 255;
            if (extraBytes > 1) {
              array2[offset + 1] = block >> 8 & 255;
            }
            if (extraBytes > 2) {
              array2[offset + 2] = block >> 16 & 255;
            }
          }
          return array2;
        };
        function Kmac(bits2, padding2, outputBits) {
          Keccak2.call(this, bits2, padding2, outputBits);
        }
        Kmac.prototype = new Keccak2();
        Kmac.prototype.finalize = function() {
          this.encode(this.outputBits, true);
          return Keccak2.prototype.finalize.call(this);
        };
        var f5 = function(s4) {
          var h6, l4, n4, c0, c1, c22, c3, c4, c5, c6, c7, c8, c9, b0, b1, b22, b32, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
          for (n4 = 0; n4 < 48; n4 += 2) {
            c0 = s4[0] ^ s4[10] ^ s4[20] ^ s4[30] ^ s4[40];
            c1 = s4[1] ^ s4[11] ^ s4[21] ^ s4[31] ^ s4[41];
            c22 = s4[2] ^ s4[12] ^ s4[22] ^ s4[32] ^ s4[42];
            c3 = s4[3] ^ s4[13] ^ s4[23] ^ s4[33] ^ s4[43];
            c4 = s4[4] ^ s4[14] ^ s4[24] ^ s4[34] ^ s4[44];
            c5 = s4[5] ^ s4[15] ^ s4[25] ^ s4[35] ^ s4[45];
            c6 = s4[6] ^ s4[16] ^ s4[26] ^ s4[36] ^ s4[46];
            c7 = s4[7] ^ s4[17] ^ s4[27] ^ s4[37] ^ s4[47];
            c8 = s4[8] ^ s4[18] ^ s4[28] ^ s4[38] ^ s4[48];
            c9 = s4[9] ^ s4[19] ^ s4[29] ^ s4[39] ^ s4[49];
            h6 = c8 ^ (c22 << 1 | c3 >>> 31);
            l4 = c9 ^ (c3 << 1 | c22 >>> 31);
            s4[0] ^= h6;
            s4[1] ^= l4;
            s4[10] ^= h6;
            s4[11] ^= l4;
            s4[20] ^= h6;
            s4[21] ^= l4;
            s4[30] ^= h6;
            s4[31] ^= l4;
            s4[40] ^= h6;
            s4[41] ^= l4;
            h6 = c0 ^ (c4 << 1 | c5 >>> 31);
            l4 = c1 ^ (c5 << 1 | c4 >>> 31);
            s4[2] ^= h6;
            s4[3] ^= l4;
            s4[12] ^= h6;
            s4[13] ^= l4;
            s4[22] ^= h6;
            s4[23] ^= l4;
            s4[32] ^= h6;
            s4[33] ^= l4;
            s4[42] ^= h6;
            s4[43] ^= l4;
            h6 = c22 ^ (c6 << 1 | c7 >>> 31);
            l4 = c3 ^ (c7 << 1 | c6 >>> 31);
            s4[4] ^= h6;
            s4[5] ^= l4;
            s4[14] ^= h6;
            s4[15] ^= l4;
            s4[24] ^= h6;
            s4[25] ^= l4;
            s4[34] ^= h6;
            s4[35] ^= l4;
            s4[44] ^= h6;
            s4[45] ^= l4;
            h6 = c4 ^ (c8 << 1 | c9 >>> 31);
            l4 = c5 ^ (c9 << 1 | c8 >>> 31);
            s4[6] ^= h6;
            s4[7] ^= l4;
            s4[16] ^= h6;
            s4[17] ^= l4;
            s4[26] ^= h6;
            s4[27] ^= l4;
            s4[36] ^= h6;
            s4[37] ^= l4;
            s4[46] ^= h6;
            s4[47] ^= l4;
            h6 = c6 ^ (c0 << 1 | c1 >>> 31);
            l4 = c7 ^ (c1 << 1 | c0 >>> 31);
            s4[8] ^= h6;
            s4[9] ^= l4;
            s4[18] ^= h6;
            s4[19] ^= l4;
            s4[28] ^= h6;
            s4[29] ^= l4;
            s4[38] ^= h6;
            s4[39] ^= l4;
            s4[48] ^= h6;
            s4[49] ^= l4;
            b0 = s4[0];
            b1 = s4[1];
            b322 = s4[11] << 4 | s4[10] >>> 28;
            b33 = s4[10] << 4 | s4[11] >>> 28;
            b14 = s4[20] << 3 | s4[21] >>> 29;
            b15 = s4[21] << 3 | s4[20] >>> 29;
            b46 = s4[31] << 9 | s4[30] >>> 23;
            b47 = s4[30] << 9 | s4[31] >>> 23;
            b28 = s4[40] << 18 | s4[41] >>> 14;
            b29 = s4[41] << 18 | s4[40] >>> 14;
            b20 = s4[2] << 1 | s4[3] >>> 31;
            b21 = s4[3] << 1 | s4[2] >>> 31;
            b22 = s4[13] << 12 | s4[12] >>> 20;
            b32 = s4[12] << 12 | s4[13] >>> 20;
            b34 = s4[22] << 10 | s4[23] >>> 22;
            b35 = s4[23] << 10 | s4[22] >>> 22;
            b16 = s4[33] << 13 | s4[32] >>> 19;
            b17 = s4[32] << 13 | s4[33] >>> 19;
            b48 = s4[42] << 2 | s4[43] >>> 30;
            b49 = s4[43] << 2 | s4[42] >>> 30;
            b40 = s4[5] << 30 | s4[4] >>> 2;
            b41 = s4[4] << 30 | s4[5] >>> 2;
            b222 = s4[14] << 6 | s4[15] >>> 26;
            b23 = s4[15] << 6 | s4[14] >>> 26;
            b4 = s4[25] << 11 | s4[24] >>> 21;
            b5 = s4[24] << 11 | s4[25] >>> 21;
            b36 = s4[34] << 15 | s4[35] >>> 17;
            b37 = s4[35] << 15 | s4[34] >>> 17;
            b18 = s4[45] << 29 | s4[44] >>> 3;
            b19 = s4[44] << 29 | s4[45] >>> 3;
            b10 = s4[6] << 28 | s4[7] >>> 4;
            b11 = s4[7] << 28 | s4[6] >>> 4;
            b42 = s4[17] << 23 | s4[16] >>> 9;
            b43 = s4[16] << 23 | s4[17] >>> 9;
            b24 = s4[26] << 25 | s4[27] >>> 7;
            b25 = s4[27] << 25 | s4[26] >>> 7;
            b6 = s4[36] << 21 | s4[37] >>> 11;
            b7 = s4[37] << 21 | s4[36] >>> 11;
            b38 = s4[47] << 24 | s4[46] >>> 8;
            b39 = s4[46] << 24 | s4[47] >>> 8;
            b30 = s4[8] << 27 | s4[9] >>> 5;
            b31 = s4[9] << 27 | s4[8] >>> 5;
            b12 = s4[18] << 20 | s4[19] >>> 12;
            b13 = s4[19] << 20 | s4[18] >>> 12;
            b44 = s4[29] << 7 | s4[28] >>> 25;
            b45 = s4[28] << 7 | s4[29] >>> 25;
            b26 = s4[38] << 8 | s4[39] >>> 24;
            b27 = s4[39] << 8 | s4[38] >>> 24;
            b8 = s4[48] << 14 | s4[49] >>> 18;
            b9 = s4[49] << 14 | s4[48] >>> 18;
            s4[0] = b0 ^ ~b22 & b4;
            s4[1] = b1 ^ ~b32 & b5;
            s4[10] = b10 ^ ~b12 & b14;
            s4[11] = b11 ^ ~b13 & b15;
            s4[20] = b20 ^ ~b222 & b24;
            s4[21] = b21 ^ ~b23 & b25;
            s4[30] = b30 ^ ~b322 & b34;
            s4[31] = b31 ^ ~b33 & b35;
            s4[40] = b40 ^ ~b42 & b44;
            s4[41] = b41 ^ ~b43 & b45;
            s4[2] = b22 ^ ~b4 & b6;
            s4[3] = b32 ^ ~b5 & b7;
            s4[12] = b12 ^ ~b14 & b16;
            s4[13] = b13 ^ ~b15 & b17;
            s4[22] = b222 ^ ~b24 & b26;
            s4[23] = b23 ^ ~b25 & b27;
            s4[32] = b322 ^ ~b34 & b36;
            s4[33] = b33 ^ ~b35 & b37;
            s4[42] = b42 ^ ~b44 & b46;
            s4[43] = b43 ^ ~b45 & b47;
            s4[4] = b4 ^ ~b6 & b8;
            s4[5] = b5 ^ ~b7 & b9;
            s4[14] = b14 ^ ~b16 & b18;
            s4[15] = b15 ^ ~b17 & b19;
            s4[24] = b24 ^ ~b26 & b28;
            s4[25] = b25 ^ ~b27 & b29;
            s4[34] = b34 ^ ~b36 & b38;
            s4[35] = b35 ^ ~b37 & b39;
            s4[44] = b44 ^ ~b46 & b48;
            s4[45] = b45 ^ ~b47 & b49;
            s4[6] = b6 ^ ~b8 & b0;
            s4[7] = b7 ^ ~b9 & b1;
            s4[16] = b16 ^ ~b18 & b10;
            s4[17] = b17 ^ ~b19 & b11;
            s4[26] = b26 ^ ~b28 & b20;
            s4[27] = b27 ^ ~b29 & b21;
            s4[36] = b36 ^ ~b38 & b30;
            s4[37] = b37 ^ ~b39 & b31;
            s4[46] = b46 ^ ~b48 & b40;
            s4[47] = b47 ^ ~b49 & b41;
            s4[8] = b8 ^ ~b0 & b22;
            s4[9] = b9 ^ ~b1 & b32;
            s4[18] = b18 ^ ~b10 & b12;
            s4[19] = b19 ^ ~b11 & b13;
            s4[28] = b28 ^ ~b20 & b222;
            s4[29] = b29 ^ ~b21 & b23;
            s4[38] = b38 ^ ~b30 & b322;
            s4[39] = b39 ^ ~b31 & b33;
            s4[48] = b48 ^ ~b40 & b42;
            s4[49] = b49 ^ ~b41 & b43;
            s4[0] ^= RC[n4];
            s4[1] ^= RC[n4 + 1];
          }
        };
        if (COMMON_JS) {
          module2.exports = methods;
        } else {
          for (i4 = 0; i4 < methodNames.length; ++i4) {
            root[methodNames[i4]] = methods[methodNames[i4]];
          }
          if (AMD) {
            define(function() {
              return methods;
            });
          }
        }
      })();
    }
  });

  // node_modules/@ethersproject/keccak256/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/@ethersproject/keccak256/lib/index.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.keccak256 = void 0;
      var js_sha3_1 = __importDefault(require_sha3());
      var bytes_1 = require_lib2();
      function keccak2563(data) {
        return "0x" + js_sha3_1.default.keccak_256((0, bytes_1.arrayify)(data));
      }
      exports2.keccak256 = keccak2563;
    }
  });

  // node_modules/@ethersproject/rlp/lib/_version.js
  var require_version6 = __commonJS({
    "node_modules/@ethersproject/rlp/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "rlp/5.7.0";
    }
  });

  // node_modules/@ethersproject/rlp/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/@ethersproject/rlp/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decode = exports2.encode = void 0;
      var bytes_1 = require_lib2();
      var logger_1 = require_lib();
      var _version_1 = require_version6();
      var logger19 = new logger_1.Logger(_version_1.version);
      function arrayifyInteger(value) {
        var result = [];
        while (value) {
          result.unshift(value & 255);
          value >>= 8;
        }
        return result;
      }
      function unarrayifyInteger(data, offset, length) {
        var result = 0;
        for (var i4 = 0; i4 < length; i4++) {
          result = result * 256 + data[offset + i4];
        }
        return result;
      }
      function _encode(object2) {
        if (Array.isArray(object2)) {
          var payload_1 = [];
          object2.forEach(function(child) {
            payload_1 = payload_1.concat(_encode(child));
          });
          if (payload_1.length <= 55) {
            payload_1.unshift(192 + payload_1.length);
            return payload_1;
          }
          var length_1 = arrayifyInteger(payload_1.length);
          length_1.unshift(247 + length_1.length);
          return length_1.concat(payload_1);
        }
        if (!(0, bytes_1.isBytesLike)(object2)) {
          logger19.throwArgumentError("RLP object must be BytesLike", "object", object2);
        }
        var data = Array.prototype.slice.call((0, bytes_1.arrayify)(object2));
        if (data.length === 1 && data[0] <= 127) {
          return data;
        } else if (data.length <= 55) {
          data.unshift(128 + data.length);
          return data;
        }
        var length = arrayifyInteger(data.length);
        length.unshift(183 + length.length);
        return length.concat(data);
      }
      function encode(object2) {
        return (0, bytes_1.hexlify)(_encode(object2));
      }
      exports2.encode = encode;
      function _decodeChildren(data, offset, childOffset, length) {
        var result = [];
        while (childOffset < offset + 1 + length) {
          var decoded = _decode(data, childOffset);
          result.push(decoded.result);
          childOffset += decoded.consumed;
          if (childOffset > offset + 1 + length) {
            logger19.throwError("child data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
          }
        }
        return { consumed: 1 + length, result };
      }
      function _decode(data, offset) {
        if (data.length === 0) {
          logger19.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        if (data[offset] >= 248) {
          var lengthLength = data[offset] - 247;
          if (offset + 1 + lengthLength > data.length) {
            logger19.throwError("data short segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
          }
          var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);
          if (offset + 1 + lengthLength + length_2 > data.length) {
            logger19.throwError("data long segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
          }
          return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);
        } else if (data[offset] >= 192) {
          var length_3 = data[offset] - 192;
          if (offset + 1 + length_3 > data.length) {
            logger19.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
          }
          return _decodeChildren(data, offset, offset + 1, length_3);
        } else if (data[offset] >= 184) {
          var lengthLength = data[offset] - 183;
          if (offset + 1 + lengthLength > data.length) {
            logger19.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
          }
          var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);
          if (offset + 1 + lengthLength + length_4 > data.length) {
            logger19.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
          }
          var result = (0, bytes_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));
          return { consumed: 1 + lengthLength + length_4, result };
        } else if (data[offset] >= 128) {
          var length_5 = data[offset] - 128;
          if (offset + 1 + length_5 > data.length) {
            logger19.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
          }
          var result = (0, bytes_1.hexlify)(data.slice(offset + 1, offset + 1 + length_5));
          return { consumed: 1 + length_5, result };
        }
        return { consumed: 1, result: (0, bytes_1.hexlify)(data[offset]) };
      }
      function decode(data) {
        var bytes2 = (0, bytes_1.arrayify)(data);
        var decoded = _decode(bytes2, 0);
        if (decoded.consumed !== bytes2.length) {
          logger19.throwArgumentError("invalid rlp data", "data", data);
        }
        return decoded.result;
      }
      exports2.decode = decode;
    }
  });

  // node_modules/@ethersproject/address/lib/_version.js
  var require_version7 = __commonJS({
    "node_modules/@ethersproject/address/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "address/5.7.0";
    }
  });

  // node_modules/@ethersproject/address/lib/index.js
  var require_lib7 = __commonJS({
    "node_modules/@ethersproject/address/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getCreate2Address = exports2.getContractAddress = exports2.getIcapAddress = exports2.isAddress = exports2.getAddress = void 0;
      var bytes_1 = require_lib2();
      var bignumber_1 = require_lib3();
      var keccak256_1 = require_lib5();
      var rlp_1 = require_lib6();
      var logger_1 = require_lib();
      var _version_1 = require_version7();
      var logger19 = new logger_1.Logger(_version_1.version);
      function getChecksumAddress(address) {
        if (!(0, bytes_1.isHexString)(address, 20)) {
          logger19.throwArgumentError("invalid address", "address", address);
        }
        address = address.toLowerCase();
        var chars = address.substring(2).split("");
        var expanded = new Uint8Array(40);
        for (var i5 = 0; i5 < 40; i5++) {
          expanded[i5] = chars[i5].charCodeAt(0);
        }
        var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));
        for (var i5 = 0; i5 < 40; i5 += 2) {
          if (hashed[i5 >> 1] >> 4 >= 8) {
            chars[i5] = chars[i5].toUpperCase();
          }
          if ((hashed[i5 >> 1] & 15) >= 8) {
            chars[i5 + 1] = chars[i5 + 1].toUpperCase();
          }
        }
        return "0x" + chars.join("");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function log10(x8) {
        if (Math.log10) {
          return Math.log10(x8);
        }
        return Math.log(x8) / Math.LN10;
      }
      var ibanLookup = {};
      for (i4 = 0; i4 < 10; i4++) {
        ibanLookup[String(i4)] = String(i4);
      }
      var i4;
      for (i4 = 0; i4 < 26; i4++) {
        ibanLookup[String.fromCharCode(65 + i4)] = String(10 + i4);
      }
      var i4;
      var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
      function ibanChecksum(address) {
        address = address.toUpperCase();
        address = address.substring(4) + address.substring(0, 2) + "00";
        var expanded = address.split("").map(function(c3) {
          return ibanLookup[c3];
        }).join("");
        while (expanded.length >= safeDigits) {
          var block = expanded.substring(0, safeDigits);
          expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
        }
        var checksum2 = String(98 - parseInt(expanded, 10) % 97);
        while (checksum2.length < 2) {
          checksum2 = "0" + checksum2;
        }
        return checksum2;
      }
      function getAddress5(address) {
        var result = null;
        if (typeof address !== "string") {
          logger19.throwArgumentError("invalid address", "address", address);
        }
        if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
          if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
          }
          result = getChecksumAddress(address);
          if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger19.throwArgumentError("bad address checksum", "address", address);
          }
        } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
          if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger19.throwArgumentError("bad icap checksum", "address", address);
          }
          result = (0, bignumber_1._base36To16)(address.substring(4));
          while (result.length < 40) {
            result = "0" + result;
          }
          result = getChecksumAddress("0x" + result);
        } else {
          logger19.throwArgumentError("invalid address", "address", address);
        }
        return result;
      }
      exports2.getAddress = getAddress5;
      function isAddress3(address) {
        try {
          getAddress5(address);
          return true;
        } catch (error) {
        }
        return false;
      }
      exports2.isAddress = isAddress3;
      function getIcapAddress2(address) {
        var base36 = (0, bignumber_1._base16To36)(getAddress5(address).substring(2)).toUpperCase();
        while (base36.length < 30) {
          base36 = "0" + base36;
        }
        return "XE" + ibanChecksum("XE00" + base36) + base36;
      }
      exports2.getIcapAddress = getIcapAddress2;
      function getContractAddress6(transaction2) {
        var from2 = null;
        try {
          from2 = getAddress5(transaction2.from);
        } catch (error) {
          logger19.throwArgumentError("missing from address", "transaction", transaction2);
        }
        var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction2.nonce).toHexString()));
        return getAddress5((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from2, nonce])), 12));
      }
      exports2.getContractAddress = getContractAddress6;
      function getCreate2Address3(from2, salt, initCodeHash) {
        if ((0, bytes_1.hexDataLength)(salt) !== 32) {
          logger19.throwArgumentError("salt must be 32 bytes", "salt", salt);
        }
        if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {
          logger19.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
        }
        return getAddress5((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)(["0xff", getAddress5(from2), salt, initCodeHash])), 12));
      }
      exports2.getCreate2Address = getCreate2Address3;
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/address.js
  var require_address = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/address.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AddressCoder = void 0;
      var address_1 = require_lib7();
      var bytes_1 = require_lib2();
      var abstract_coder_1 = require_abstract_coder();
      var AddressCoder = (
        /** @class */
        function(_super) {
          __extends2(AddressCoder2, _super);
          function AddressCoder2(localName) {
            return _super.call(this, "address", "address", localName, false) || this;
          }
          AddressCoder2.prototype.defaultValue = function() {
            return "0x0000000000000000000000000000000000000000";
          };
          AddressCoder2.prototype.encode = function(writer, value) {
            try {
              value = (0, address_1.getAddress)(value);
            } catch (error) {
              this._throwError(error.message, value);
            }
            return writer.writeValue(value);
          };
          AddressCoder2.prototype.decode = function(reader) {
            return (0, address_1.getAddress)((0, bytes_1.hexZeroPad)(reader.readValue().toHexString(), 20));
          };
          return AddressCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.AddressCoder = AddressCoder;
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/anonymous.js
  var require_anonymous = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/anonymous.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AnonymousCoder = void 0;
      var abstract_coder_1 = require_abstract_coder();
      var AnonymousCoder = (
        /** @class */
        function(_super) {
          __extends2(AnonymousCoder2, _super);
          function AnonymousCoder2(coder) {
            var _this = _super.call(this, coder.name, coder.type, void 0, coder.dynamic) || this;
            _this.coder = coder;
            return _this;
          }
          AnonymousCoder2.prototype.defaultValue = function() {
            return this.coder.defaultValue();
          };
          AnonymousCoder2.prototype.encode = function(writer, value) {
            return this.coder.encode(writer, value);
          };
          AnonymousCoder2.prototype.decode = function(reader) {
            return this.coder.decode(reader);
          };
          return AnonymousCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.AnonymousCoder = AnonymousCoder;
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/array.js
  var require_array = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/array.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ArrayCoder = exports2.unpack = exports2.pack = void 0;
      var logger_1 = require_lib();
      var _version_1 = require_version5();
      var logger19 = new logger_1.Logger(_version_1.version);
      var abstract_coder_1 = require_abstract_coder();
      var anonymous_1 = require_anonymous();
      function pack(writer, coders, values) {
        var arrayValues = null;
        if (Array.isArray(values)) {
          arrayValues = values;
        } else if (values && typeof values === "object") {
          var unique_1 = {};
          arrayValues = coders.map(function(coder) {
            var name = coder.localName;
            if (!name) {
              logger19.throwError("cannot encode object for signature with missing names", logger_1.Logger.errors.INVALID_ARGUMENT, {
                argument: "values",
                coder,
                value: values
              });
            }
            if (unique_1[name]) {
              logger19.throwError("cannot encode object for signature with duplicate names", logger_1.Logger.errors.INVALID_ARGUMENT, {
                argument: "values",
                coder,
                value: values
              });
            }
            unique_1[name] = true;
            return values[name];
          });
        } else {
          logger19.throwArgumentError("invalid tuple value", "tuple", values);
        }
        if (coders.length !== arrayValues.length) {
          logger19.throwArgumentError("types/value length mismatch", "tuple", values);
        }
        var staticWriter = new abstract_coder_1.Writer(writer.wordSize);
        var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);
        var updateFuncs = [];
        coders.forEach(function(coder, index2) {
          var value = arrayValues[index2];
          if (coder.dynamic) {
            var dynamicOffset_1 = dynamicWriter.length;
            coder.encode(dynamicWriter, value);
            var updateFunc_1 = staticWriter.writeUpdatableValue();
            updateFuncs.push(function(baseOffset) {
              updateFunc_1(baseOffset + dynamicOffset_1);
            });
          } else {
            coder.encode(staticWriter, value);
          }
        });
        updateFuncs.forEach(function(func) {
          func(staticWriter.length);
        });
        var length = writer.appendWriter(staticWriter);
        length += writer.appendWriter(dynamicWriter);
        return length;
      }
      exports2.pack = pack;
      function unpack(reader, coders) {
        var values = [];
        var baseReader = reader.subReader(0);
        coders.forEach(function(coder) {
          var value = null;
          if (coder.dynamic) {
            var offset = reader.readValue();
            var offsetReader = baseReader.subReader(offset.toNumber());
            try {
              value = coder.decode(offsetReader);
            } catch (error) {
              if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
                throw error;
              }
              value = error;
              value.baseType = coder.name;
              value.name = coder.localName;
              value.type = coder.type;
            }
          } else {
            try {
              value = coder.decode(reader);
            } catch (error) {
              if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
                throw error;
              }
              value = error;
              value.baseType = coder.name;
              value.name = coder.localName;
              value.type = coder.type;
            }
          }
          if (value != void 0) {
            values.push(value);
          }
        });
        var uniqueNames = coders.reduce(function(accum, coder) {
          var name = coder.localName;
          if (name) {
            if (!accum[name]) {
              accum[name] = 0;
            }
            accum[name]++;
          }
          return accum;
        }, {});
        coders.forEach(function(coder, index2) {
          var name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
            return;
          }
          if (name === "length") {
            name = "_length";
          }
          if (values[name] != null) {
            return;
          }
          var value = values[index2];
          if (value instanceof Error) {
            Object.defineProperty(values, name, {
              enumerable: true,
              get: function() {
                throw value;
              }
            });
          } else {
            values[name] = value;
          }
        });
        var _loop_1 = function(i5) {
          var value = values[i5];
          if (value instanceof Error) {
            Object.defineProperty(values, i5, {
              enumerable: true,
              get: function() {
                throw value;
              }
            });
          }
        };
        for (var i4 = 0; i4 < values.length; i4++) {
          _loop_1(i4);
        }
        return Object.freeze(values);
      }
      exports2.unpack = unpack;
      var ArrayCoder = (
        /** @class */
        function(_super) {
          __extends2(ArrayCoder2, _super);
          function ArrayCoder2(coder, length, localName) {
            var _this = this;
            var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
            var dynamic = length === -1 || coder.dynamic;
            _this = _super.call(this, "array", type, localName, dynamic) || this;
            _this.coder = coder;
            _this.length = length;
            return _this;
          }
          ArrayCoder2.prototype.defaultValue = function() {
            var defaultChild = this.coder.defaultValue();
            var result = [];
            for (var i4 = 0; i4 < this.length; i4++) {
              result.push(defaultChild);
            }
            return result;
          };
          ArrayCoder2.prototype.encode = function(writer, value) {
            if (!Array.isArray(value)) {
              this._throwError("expected array value", value);
            }
            var count = this.length;
            if (count === -1) {
              count = value.length;
              writer.writeValue(value.length);
            }
            logger19.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
            var coders = [];
            for (var i4 = 0; i4 < value.length; i4++) {
              coders.push(this.coder);
            }
            return pack(writer, coders, value);
          };
          ArrayCoder2.prototype.decode = function(reader) {
            var count = this.length;
            if (count === -1) {
              count = reader.readValue().toNumber();
              if (count * 32 > reader._data.length) {
                logger19.throwError("insufficient data length", logger_1.Logger.errors.BUFFER_OVERRUN, {
                  length: reader._data.length,
                  count
                });
              }
            }
            var coders = [];
            for (var i4 = 0; i4 < count; i4++) {
              coders.push(new anonymous_1.AnonymousCoder(this.coder));
            }
            return reader.coerce(this.name, unpack(reader, coders));
          };
          return ArrayCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.ArrayCoder = ArrayCoder;
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/boolean.js
  var require_boolean = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/boolean.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BooleanCoder = void 0;
      var abstract_coder_1 = require_abstract_coder();
      var BooleanCoder = (
        /** @class */
        function(_super) {
          __extends2(BooleanCoder2, _super);
          function BooleanCoder2(localName) {
            return _super.call(this, "bool", "bool", localName, false) || this;
          }
          BooleanCoder2.prototype.defaultValue = function() {
            return false;
          };
          BooleanCoder2.prototype.encode = function(writer, value) {
            return writer.writeValue(value ? 1 : 0);
          };
          BooleanCoder2.prototype.decode = function(reader) {
            return reader.coerce(this.type, !reader.readValue().isZero());
          };
          return BooleanCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.BooleanCoder = BooleanCoder;
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/bytes.js
  var require_bytes = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/bytes.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.BytesCoder = exports2.DynamicBytesCoder = void 0;
      var bytes_1 = require_lib2();
      var abstract_coder_1 = require_abstract_coder();
      var DynamicBytesCoder = (
        /** @class */
        function(_super) {
          __extends2(DynamicBytesCoder2, _super);
          function DynamicBytesCoder2(type, localName) {
            return _super.call(this, type, type, localName, true) || this;
          }
          DynamicBytesCoder2.prototype.defaultValue = function() {
            return "0x";
          };
          DynamicBytesCoder2.prototype.encode = function(writer, value) {
            value = (0, bytes_1.arrayify)(value);
            var length = writer.writeValue(value.length);
            length += writer.writeBytes(value);
            return length;
          };
          DynamicBytesCoder2.prototype.decode = function(reader) {
            return reader.readBytes(reader.readValue().toNumber(), true);
          };
          return DynamicBytesCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.DynamicBytesCoder = DynamicBytesCoder;
      var BytesCoder = (
        /** @class */
        function(_super) {
          __extends2(BytesCoder2, _super);
          function BytesCoder2(localName) {
            return _super.call(this, "bytes", localName) || this;
          }
          BytesCoder2.prototype.decode = function(reader) {
            return reader.coerce(this.name, (0, bytes_1.hexlify)(_super.prototype.decode.call(this, reader)));
          };
          return BytesCoder2;
        }(DynamicBytesCoder)
      );
      exports2.BytesCoder = BytesCoder;
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/fixed-bytes.js
  var require_fixed_bytes = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/fixed-bytes.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FixedBytesCoder = void 0;
      var bytes_1 = require_lib2();
      var abstract_coder_1 = require_abstract_coder();
      var FixedBytesCoder = (
        /** @class */
        function(_super) {
          __extends2(FixedBytesCoder2, _super);
          function FixedBytesCoder2(size3, localName) {
            var _this = this;
            var name = "bytes" + String(size3);
            _this = _super.call(this, name, name, localName, false) || this;
            _this.size = size3;
            return _this;
          }
          FixedBytesCoder2.prototype.defaultValue = function() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
          };
          FixedBytesCoder2.prototype.encode = function(writer, value) {
            var data = (0, bytes_1.arrayify)(value);
            if (data.length !== this.size) {
              this._throwError("incorrect data length", value);
            }
            return writer.writeBytes(data);
          };
          FixedBytesCoder2.prototype.decode = function(reader) {
            return reader.coerce(this.name, (0, bytes_1.hexlify)(reader.readBytes(this.size)));
          };
          return FixedBytesCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.FixedBytesCoder = FixedBytesCoder;
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/null.js
  var require_null = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/null.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NullCoder = void 0;
      var abstract_coder_1 = require_abstract_coder();
      var NullCoder = (
        /** @class */
        function(_super) {
          __extends2(NullCoder2, _super);
          function NullCoder2(localName) {
            return _super.call(this, "null", "", localName, false) || this;
          }
          NullCoder2.prototype.defaultValue = function() {
            return null;
          };
          NullCoder2.prototype.encode = function(writer, value) {
            if (value != null) {
              this._throwError("not null", value);
            }
            return writer.writeBytes([]);
          };
          NullCoder2.prototype.decode = function(reader) {
            reader.readBytes(0);
            return reader.coerce(this.name, null);
          };
          return NullCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.NullCoder = NullCoder;
    }
  });

  // node_modules/@ethersproject/constants/lib/addresses.js
  var require_addresses = __commonJS({
    "node_modules/@ethersproject/constants/lib/addresses.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AddressZero = void 0;
      exports2.AddressZero = "0x0000000000000000000000000000000000000000";
    }
  });

  // node_modules/@ethersproject/constants/lib/bignumbers.js
  var require_bignumbers = __commonJS({
    "node_modules/@ethersproject/constants/lib/bignumbers.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MaxInt256 = exports2.MinInt256 = exports2.MaxUint256 = exports2.WeiPerEther = exports2.Two = exports2.One = exports2.Zero = exports2.NegativeOne = void 0;
      var bignumber_1 = require_lib3();
      var NegativeOne = /* @__PURE__ */ bignumber_1.BigNumber.from(-1);
      exports2.NegativeOne = NegativeOne;
      var Zero = /* @__PURE__ */ bignumber_1.BigNumber.from(0);
      exports2.Zero = Zero;
      var One = /* @__PURE__ */ bignumber_1.BigNumber.from(1);
      exports2.One = One;
      var Two = /* @__PURE__ */ bignumber_1.BigNumber.from(2);
      exports2.Two = Two;
      var WeiPerEther = /* @__PURE__ */ bignumber_1.BigNumber.from("1000000000000000000");
      exports2.WeiPerEther = WeiPerEther;
      var MaxUint256 = /* @__PURE__ */ bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      exports2.MaxUint256 = MaxUint256;
      var MinInt256 = /* @__PURE__ */ bignumber_1.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
      exports2.MinInt256 = MinInt256;
      var MaxInt256 = /* @__PURE__ */ bignumber_1.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      exports2.MaxInt256 = MaxInt256;
    }
  });

  // node_modules/@ethersproject/constants/lib/hashes.js
  var require_hashes = __commonJS({
    "node_modules/@ethersproject/constants/lib/hashes.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HashZero = void 0;
      exports2.HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
    }
  });

  // node_modules/@ethersproject/constants/lib/strings.js
  var require_strings = __commonJS({
    "node_modules/@ethersproject/constants/lib/strings.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EtherSymbol = void 0;
      exports2.EtherSymbol = "\u039E";
    }
  });

  // node_modules/@ethersproject/constants/lib/index.js
  var require_lib8 = __commonJS({
    "node_modules/@ethersproject/constants/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EtherSymbol = exports2.HashZero = exports2.MaxInt256 = exports2.MinInt256 = exports2.MaxUint256 = exports2.WeiPerEther = exports2.Two = exports2.One = exports2.Zero = exports2.NegativeOne = exports2.AddressZero = void 0;
      var addresses_1 = require_addresses();
      Object.defineProperty(exports2, "AddressZero", { enumerable: true, get: function() {
        return addresses_1.AddressZero;
      } });
      var bignumbers_1 = require_bignumbers();
      Object.defineProperty(exports2, "NegativeOne", { enumerable: true, get: function() {
        return bignumbers_1.NegativeOne;
      } });
      Object.defineProperty(exports2, "Zero", { enumerable: true, get: function() {
        return bignumbers_1.Zero;
      } });
      Object.defineProperty(exports2, "One", { enumerable: true, get: function() {
        return bignumbers_1.One;
      } });
      Object.defineProperty(exports2, "Two", { enumerable: true, get: function() {
        return bignumbers_1.Two;
      } });
      Object.defineProperty(exports2, "WeiPerEther", { enumerable: true, get: function() {
        return bignumbers_1.WeiPerEther;
      } });
      Object.defineProperty(exports2, "MaxUint256", { enumerable: true, get: function() {
        return bignumbers_1.MaxUint256;
      } });
      Object.defineProperty(exports2, "MinInt256", { enumerable: true, get: function() {
        return bignumbers_1.MinInt256;
      } });
      Object.defineProperty(exports2, "MaxInt256", { enumerable: true, get: function() {
        return bignumbers_1.MaxInt256;
      } });
      var hashes_1 = require_hashes();
      Object.defineProperty(exports2, "HashZero", { enumerable: true, get: function() {
        return hashes_1.HashZero;
      } });
      var strings_1 = require_strings();
      Object.defineProperty(exports2, "EtherSymbol", { enumerable: true, get: function() {
        return strings_1.EtherSymbol;
      } });
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/number.js
  var require_number = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/number.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NumberCoder = void 0;
      var bignumber_1 = require_lib3();
      var constants_1 = require_lib8();
      var abstract_coder_1 = require_abstract_coder();
      var NumberCoder = (
        /** @class */
        function(_super) {
          __extends2(NumberCoder2, _super);
          function NumberCoder2(size3, signed, localName) {
            var _this = this;
            var name = (signed ? "int" : "uint") + size3 * 8;
            _this = _super.call(this, name, name, localName, false) || this;
            _this.size = size3;
            _this.signed = signed;
            return _this;
          }
          NumberCoder2.prototype.defaultValue = function() {
            return 0;
          };
          NumberCoder2.prototype.encode = function(writer, value) {
            var v7 = bignumber_1.BigNumber.from(value);
            var maxUintValue = constants_1.MaxUint256.mask(writer.wordSize * 8);
            if (this.signed) {
              var bounds = maxUintValue.mask(this.size * 8 - 1);
              if (v7.gt(bounds) || v7.lt(bounds.add(constants_1.One).mul(constants_1.NegativeOne))) {
                this._throwError("value out-of-bounds", value);
              }
            } else if (v7.lt(constants_1.Zero) || v7.gt(maxUintValue.mask(this.size * 8))) {
              this._throwError("value out-of-bounds", value);
            }
            v7 = v7.toTwos(this.size * 8).mask(this.size * 8);
            if (this.signed) {
              v7 = v7.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
            }
            return writer.writeValue(v7);
          };
          NumberCoder2.prototype.decode = function(reader) {
            var value = reader.readValue().mask(this.size * 8);
            if (this.signed) {
              value = value.fromTwos(this.size * 8);
            }
            return reader.coerce(this.name, value);
          };
          return NumberCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.NumberCoder = NumberCoder;
    }
  });

  // node_modules/@ethersproject/strings/lib/_version.js
  var require_version8 = __commonJS({
    "node_modules/@ethersproject/strings/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "strings/5.7.0";
    }
  });

  // node_modules/@ethersproject/strings/lib/utf8.js
  var require_utf8 = __commonJS({
    "node_modules/@ethersproject/strings/lib/utf8.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.toUtf8CodePoints = exports2.toUtf8String = exports2._toUtf8String = exports2._toEscapedUtf8String = exports2.toUtf8Bytes = exports2.Utf8ErrorFuncs = exports2.Utf8ErrorReason = exports2.UnicodeNormalizationForm = void 0;
      var bytes_1 = require_lib2();
      var logger_1 = require_lib();
      var _version_1 = require_version8();
      var logger19 = new logger_1.Logger(_version_1.version);
      var UnicodeNormalizationForm2;
      (function(UnicodeNormalizationForm3) {
        UnicodeNormalizationForm3["current"] = "";
        UnicodeNormalizationForm3["NFC"] = "NFC";
        UnicodeNormalizationForm3["NFD"] = "NFD";
        UnicodeNormalizationForm3["NFKC"] = "NFKC";
        UnicodeNormalizationForm3["NFKD"] = "NFKD";
      })(UnicodeNormalizationForm2 = exports2.UnicodeNormalizationForm || (exports2.UnicodeNormalizationForm = {}));
      var Utf8ErrorReason2;
      (function(Utf8ErrorReason3) {
        Utf8ErrorReason3["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
        Utf8ErrorReason3["BAD_PREFIX"] = "bad codepoint prefix";
        Utf8ErrorReason3["OVERRUN"] = "string overrun";
        Utf8ErrorReason3["MISSING_CONTINUE"] = "missing continuation byte";
        Utf8ErrorReason3["OUT_OF_RANGE"] = "out of UTF-8 range";
        Utf8ErrorReason3["UTF16_SURROGATE"] = "UTF-16 surrogate";
        Utf8ErrorReason3["OVERLONG"] = "overlong representation";
      })(Utf8ErrorReason2 = exports2.Utf8ErrorReason || (exports2.Utf8ErrorReason = {}));
      function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
        return logger19.throwArgumentError("invalid codepoint at offset " + offset + "; " + reason, "bytes", bytes2);
      }
      function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
        if (reason === Utf8ErrorReason2.BAD_PREFIX || reason === Utf8ErrorReason2.UNEXPECTED_CONTINUE) {
          var i4 = 0;
          for (var o3 = offset + 1; o3 < bytes2.length; o3++) {
            if (bytes2[o3] >> 6 !== 2) {
              break;
            }
            i4++;
          }
          return i4;
        }
        if (reason === Utf8ErrorReason2.OVERRUN) {
          return bytes2.length - offset - 1;
        }
        return 0;
      }
      function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
        if (reason === Utf8ErrorReason2.OVERLONG) {
          output2.push(badCodepoint);
          return 0;
        }
        output2.push(65533);
        return ignoreFunc(reason, offset, bytes2, output2, badCodepoint);
      }
      exports2.Utf8ErrorFuncs = Object.freeze({
        error: errorFunc,
        ignore: ignoreFunc,
        replace: replaceFunc
      });
      function getUtf8CodePoints(bytes2, onError) {
        if (onError == null) {
          onError = exports2.Utf8ErrorFuncs.error;
        }
        bytes2 = (0, bytes_1.arrayify)(bytes2);
        var result = [];
        var i4 = 0;
        while (i4 < bytes2.length) {
          var c3 = bytes2[i4++];
          if (c3 >> 7 === 0) {
            result.push(c3);
            continue;
          }
          var extraLength = null;
          var overlongMask = null;
          if ((c3 & 224) === 192) {
            extraLength = 1;
            overlongMask = 127;
          } else if ((c3 & 240) === 224) {
            extraLength = 2;
            overlongMask = 2047;
          } else if ((c3 & 248) === 240) {
            extraLength = 3;
            overlongMask = 65535;
          } else {
            if ((c3 & 192) === 128) {
              i4 += onError(Utf8ErrorReason2.UNEXPECTED_CONTINUE, i4 - 1, bytes2, result);
            } else {
              i4 += onError(Utf8ErrorReason2.BAD_PREFIX, i4 - 1, bytes2, result);
            }
            continue;
          }
          if (i4 - 1 + extraLength >= bytes2.length) {
            i4 += onError(Utf8ErrorReason2.OVERRUN, i4 - 1, bytes2, result);
            continue;
          }
          var res = c3 & (1 << 8 - extraLength - 1) - 1;
          for (var j3 = 0; j3 < extraLength; j3++) {
            var nextChar = bytes2[i4];
            if ((nextChar & 192) != 128) {
              i4 += onError(Utf8ErrorReason2.MISSING_CONTINUE, i4, bytes2, result);
              res = null;
              break;
            }
            ;
            res = res << 6 | nextChar & 63;
            i4++;
          }
          if (res === null) {
            continue;
          }
          if (res > 1114111) {
            i4 += onError(Utf8ErrorReason2.OUT_OF_RANGE, i4 - 1 - extraLength, bytes2, result, res);
            continue;
          }
          if (res >= 55296 && res <= 57343) {
            i4 += onError(Utf8ErrorReason2.UTF16_SURROGATE, i4 - 1 - extraLength, bytes2, result, res);
            continue;
          }
          if (res <= overlongMask) {
            i4 += onError(Utf8ErrorReason2.OVERLONG, i4 - 1 - extraLength, bytes2, result, res);
            continue;
          }
          result.push(res);
        }
        return result;
      }
      function toUtf8Bytes4(str, form) {
        if (form === void 0) {
          form = UnicodeNormalizationForm2.current;
        }
        if (form != UnicodeNormalizationForm2.current) {
          logger19.checkNormalize();
          str = str.normalize(form);
        }
        var result = [];
        for (var i4 = 0; i4 < str.length; i4++) {
          var c3 = str.charCodeAt(i4);
          if (c3 < 128) {
            result.push(c3);
          } else if (c3 < 2048) {
            result.push(c3 >> 6 | 192);
            result.push(c3 & 63 | 128);
          } else if ((c3 & 64512) == 55296) {
            i4++;
            var c22 = str.charCodeAt(i4);
            if (i4 >= str.length || (c22 & 64512) !== 56320) {
              throw new Error("invalid utf-8 string");
            }
            var pair = 65536 + ((c3 & 1023) << 10) + (c22 & 1023);
            result.push(pair >> 18 | 240);
            result.push(pair >> 12 & 63 | 128);
            result.push(pair >> 6 & 63 | 128);
            result.push(pair & 63 | 128);
          } else {
            result.push(c3 >> 12 | 224);
            result.push(c3 >> 6 & 63 | 128);
            result.push(c3 & 63 | 128);
          }
        }
        return (0, bytes_1.arrayify)(result);
      }
      exports2.toUtf8Bytes = toUtf8Bytes4;
      function escapeChar(value) {
        var hex2 = "0000" + value.toString(16);
        return "\\u" + hex2.substring(hex2.length - 4);
      }
      function _toEscapedUtf8String2(bytes2, onError) {
        return '"' + getUtf8CodePoints(bytes2, onError).map(function(codePoint) {
          if (codePoint < 256) {
            switch (codePoint) {
              case 8:
                return "\\b";
              case 9:
                return "\\t";
              case 10:
                return "\\n";
              case 13:
                return "\\r";
              case 34:
                return '\\"';
              case 92:
                return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) {
              return String.fromCharCode(codePoint);
            }
          }
          if (codePoint <= 65535) {
            return escapeChar(codePoint);
          }
          codePoint -= 65536;
          return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
        }).join("") + '"';
      }
      exports2._toEscapedUtf8String = _toEscapedUtf8String2;
      function _toUtf8String(codePoints) {
        return codePoints.map(function(codePoint) {
          if (codePoint <= 65535) {
            return String.fromCharCode(codePoint);
          }
          codePoint -= 65536;
          return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
        }).join("");
      }
      exports2._toUtf8String = _toUtf8String;
      function toUtf8String3(bytes2, onError) {
        return _toUtf8String(getUtf8CodePoints(bytes2, onError));
      }
      exports2.toUtf8String = toUtf8String3;
      function toUtf8CodePoints2(str, form) {
        if (form === void 0) {
          form = UnicodeNormalizationForm2.current;
        }
        return getUtf8CodePoints(toUtf8Bytes4(str, form));
      }
      exports2.toUtf8CodePoints = toUtf8CodePoints2;
    }
  });

  // node_modules/@ethersproject/strings/lib/bytes32.js
  var require_bytes32 = __commonJS({
    "node_modules/@ethersproject/strings/lib/bytes32.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseBytes32String = exports2.formatBytes32String = void 0;
      var constants_1 = require_lib8();
      var bytes_1 = require_lib2();
      var utf8_1 = require_utf8();
      function formatBytes32String2(text) {
        var bytes2 = (0, utf8_1.toUtf8Bytes)(text);
        if (bytes2.length > 31) {
          throw new Error("bytes32 string must be less than 32 bytes");
        }
        return (0, bytes_1.hexlify)((0, bytes_1.concat)([bytes2, constants_1.HashZero]).slice(0, 32));
      }
      exports2.formatBytes32String = formatBytes32String2;
      function parseBytes32String2(bytes2) {
        var data = (0, bytes_1.arrayify)(bytes2);
        if (data.length !== 32) {
          throw new Error("invalid bytes32 - not 32 bytes long");
        }
        if (data[31] !== 0) {
          throw new Error("invalid bytes32 string - no null terminator");
        }
        var length = 31;
        while (data[length - 1] === 0) {
          length--;
        }
        return (0, utf8_1.toUtf8String)(data.slice(0, length));
      }
      exports2.parseBytes32String = parseBytes32String2;
    }
  });

  // node_modules/@ethersproject/strings/lib/idna.js
  var require_idna = __commonJS({
    "node_modules/@ethersproject/strings/lib/idna.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.nameprep = exports2._nameprepTableC = exports2._nameprepTableB2 = exports2._nameprepTableA1 = void 0;
      var utf8_1 = require_utf8();
      function bytes2(data) {
        if (data.length % 4 !== 0) {
          throw new Error("bad data");
        }
        var result = [];
        for (var i4 = 0; i4 < data.length; i4 += 4) {
          result.push(parseInt(data.substring(i4, i4 + 4), 16));
        }
        return result;
      }
      function createTable(data, func) {
        if (!func) {
          func = function(value) {
            return [parseInt(value, 16)];
          };
        }
        var lo = 0;
        var result = {};
        data.split(",").forEach(function(pair) {
          var comps = pair.split(":");
          lo += parseInt(comps[0], 16);
          result[lo] = func(comps[1]);
        });
        return result;
      }
      function createRangeTable(data) {
        var hi = 0;
        return data.split(",").map(function(v7) {
          var comps = v7.split("-");
          if (comps.length === 1) {
            comps[1] = "0";
          } else if (comps[1] === "") {
            comps[1] = "1";
          }
          var lo = hi + parseInt(comps[0], 16);
          hi = parseInt(comps[1], 16);
          return { l: lo, h: hi };
        });
      }
      function matchMap(value, ranges) {
        var lo = 0;
        for (var i4 = 0; i4 < ranges.length; i4++) {
          var range2 = ranges[i4];
          lo += range2.l;
          if (value >= lo && value <= lo + range2.h && (value - lo) % (range2.d || 1) === 0) {
            if (range2.e && range2.e.indexOf(value - lo) !== -1) {
              continue;
            }
            return range2;
          }
        }
        return null;
      }
      var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
      var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(function(v7) {
        return parseInt(v7, 16);
      });
      var Table_B_2_ranges = [
        { h: 25, s: 32, l: 65 },
        { h: 30, s: 32, e: [23], l: 127 },
        { h: 54, s: 1, e: [48], l: 64, d: 2 },
        { h: 14, s: 1, l: 57, d: 2 },
        { h: 44, s: 1, l: 17, d: 2 },
        { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
        { h: 16, s: 1, l: 68, d: 2 },
        { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
        { h: 26, s: 32, e: [17], l: 435 },
        { h: 22, s: 1, l: 71, d: 2 },
        { h: 15, s: 80, l: 40 },
        { h: 31, s: 32, l: 16 },
        { h: 32, s: 1, l: 80, d: 2 },
        { h: 52, s: 1, l: 42, d: 2 },
        { h: 12, s: 1, l: 55, d: 2 },
        { h: 40, s: 1, e: [38], l: 15, d: 2 },
        { h: 14, s: 1, l: 48, d: 2 },
        { h: 37, s: 48, l: 49 },
        { h: 148, s: 1, l: 6351, d: 2 },
        { h: 88, s: 1, l: 160, d: 2 },
        { h: 15, s: 16, l: 704 },
        { h: 25, s: 26, l: 854 },
        { h: 25, s: 32, l: 55915 },
        { h: 37, s: 40, l: 1247 },
        { h: 25, s: -119711, l: 53248 },
        { h: 25, s: -119763, l: 52 },
        { h: 25, s: -119815, l: 52 },
        { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
        { h: 25, s: -119919, l: 52 },
        { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
        { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
        { h: 25, s: -120075, l: 52 },
        { h: 25, s: -120127, l: 52 },
        { h: 25, s: -120179, l: 52 },
        { h: 25, s: -120231, l: 52 },
        { h: 25, s: -120283, l: 52 },
        { h: 25, s: -120335, l: 52 },
        { h: 24, s: -119543, e: [17], l: 56 },
        { h: 24, s: -119601, e: [17], l: 58 },
        { h: 24, s: -119659, e: [17], l: 58 },
        { h: 24, s: -119717, e: [17], l: 58 },
        { h: 24, s: -119775, e: [17], l: 58 }
      ];
      var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
      var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
      var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
      var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
      function flatten(values) {
        return values.reduce(function(accum, value) {
          value.forEach(function(value2) {
            accum.push(value2);
          });
          return accum;
        }, []);
      }
      function _nameprepTableA1(codepoint) {
        return !!matchMap(codepoint, Table_A_1_ranges);
      }
      exports2._nameprepTableA1 = _nameprepTableA1;
      function _nameprepTableB2(codepoint) {
        var range2 = matchMap(codepoint, Table_B_2_ranges);
        if (range2) {
          return [codepoint + range2.s];
        }
        var codes = Table_B_2_lut_abs[codepoint];
        if (codes) {
          return codes;
        }
        var shift2 = Table_B_2_lut_rel[codepoint];
        if (shift2) {
          return [codepoint + shift2[0]];
        }
        var complex = Table_B_2_complex[codepoint];
        if (complex) {
          return complex;
        }
        return null;
      }
      exports2._nameprepTableB2 = _nameprepTableB2;
      function _nameprepTableC(codepoint) {
        return !!matchMap(codepoint, Table_C_ranges);
      }
      exports2._nameprepTableC = _nameprepTableC;
      function nameprep2(value) {
        if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
          return value.toLowerCase();
        }
        var codes = (0, utf8_1.toUtf8CodePoints)(value);
        codes = flatten(codes.map(function(code) {
          if (Table_B_1_flags.indexOf(code) >= 0) {
            return [];
          }
          if (code >= 65024 && code <= 65039) {
            return [];
          }
          var codesTableB2 = _nameprepTableB2(code);
          if (codesTableB2) {
            return codesTableB2;
          }
          return [code];
        }));
        codes = (0, utf8_1.toUtf8CodePoints)((0, utf8_1._toUtf8String)(codes), utf8_1.UnicodeNormalizationForm.NFKC);
        codes.forEach(function(code) {
          if (_nameprepTableC(code)) {
            throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
          }
        });
        codes.forEach(function(code) {
          if (_nameprepTableA1(code)) {
            throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
          }
        });
        var name = (0, utf8_1._toUtf8String)(codes);
        if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
          throw new Error("invalid hyphen");
        }
        return name;
      }
      exports2.nameprep = nameprep2;
    }
  });

  // node_modules/@ethersproject/strings/lib/index.js
  var require_lib9 = __commonJS({
    "node_modules/@ethersproject/strings/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.nameprep = exports2.parseBytes32String = exports2.formatBytes32String = exports2.UnicodeNormalizationForm = exports2.Utf8ErrorReason = exports2.Utf8ErrorFuncs = exports2.toUtf8String = exports2.toUtf8CodePoints = exports2.toUtf8Bytes = exports2._toEscapedUtf8String = void 0;
      var bytes32_1 = require_bytes32();
      Object.defineProperty(exports2, "formatBytes32String", { enumerable: true, get: function() {
        return bytes32_1.formatBytes32String;
      } });
      Object.defineProperty(exports2, "parseBytes32String", { enumerable: true, get: function() {
        return bytes32_1.parseBytes32String;
      } });
      var idna_1 = require_idna();
      Object.defineProperty(exports2, "nameprep", { enumerable: true, get: function() {
        return idna_1.nameprep;
      } });
      var utf8_1 = require_utf8();
      Object.defineProperty(exports2, "_toEscapedUtf8String", { enumerable: true, get: function() {
        return utf8_1._toEscapedUtf8String;
      } });
      Object.defineProperty(exports2, "toUtf8Bytes", { enumerable: true, get: function() {
        return utf8_1.toUtf8Bytes;
      } });
      Object.defineProperty(exports2, "toUtf8CodePoints", { enumerable: true, get: function() {
        return utf8_1.toUtf8CodePoints;
      } });
      Object.defineProperty(exports2, "toUtf8String", { enumerable: true, get: function() {
        return utf8_1.toUtf8String;
      } });
      Object.defineProperty(exports2, "UnicodeNormalizationForm", { enumerable: true, get: function() {
        return utf8_1.UnicodeNormalizationForm;
      } });
      Object.defineProperty(exports2, "Utf8ErrorFuncs", { enumerable: true, get: function() {
        return utf8_1.Utf8ErrorFuncs;
      } });
      Object.defineProperty(exports2, "Utf8ErrorReason", { enumerable: true, get: function() {
        return utf8_1.Utf8ErrorReason;
      } });
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/string.js
  var require_string = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/string.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.StringCoder = void 0;
      var strings_1 = require_lib9();
      var bytes_1 = require_bytes();
      var StringCoder = (
        /** @class */
        function(_super) {
          __extends2(StringCoder2, _super);
          function StringCoder2(localName) {
            return _super.call(this, "string", localName) || this;
          }
          StringCoder2.prototype.defaultValue = function() {
            return "";
          };
          StringCoder2.prototype.encode = function(writer, value) {
            return _super.prototype.encode.call(this, writer, (0, strings_1.toUtf8Bytes)(value));
          };
          StringCoder2.prototype.decode = function(reader) {
            return (0, strings_1.toUtf8String)(_super.prototype.decode.call(this, reader));
          };
          return StringCoder2;
        }(bytes_1.DynamicBytesCoder)
      );
      exports2.StringCoder = StringCoder;
    }
  });

  // node_modules/@ethersproject/abi/lib/coders/tuple.js
  var require_tuple = __commonJS({
    "node_modules/@ethersproject/abi/lib/coders/tuple.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TupleCoder = void 0;
      var abstract_coder_1 = require_abstract_coder();
      var array_1 = require_array();
      var TupleCoder = (
        /** @class */
        function(_super) {
          __extends2(TupleCoder2, _super);
          function TupleCoder2(coders, localName) {
            var _this = this;
            var dynamic = false;
            var types = [];
            coders.forEach(function(coder) {
              if (coder.dynamic) {
                dynamic = true;
              }
              types.push(coder.type);
            });
            var type = "tuple(" + types.join(",") + ")";
            _this = _super.call(this, "tuple", type, localName, dynamic) || this;
            _this.coders = coders;
            return _this;
          }
          TupleCoder2.prototype.defaultValue = function() {
            var values = [];
            this.coders.forEach(function(coder) {
              values.push(coder.defaultValue());
            });
            var uniqueNames = this.coders.reduce(function(accum, coder) {
              var name = coder.localName;
              if (name) {
                if (!accum[name]) {
                  accum[name] = 0;
                }
                accum[name]++;
              }
              return accum;
            }, {});
            this.coders.forEach(function(coder, index2) {
              var name = coder.localName;
              if (!name || uniqueNames[name] !== 1) {
                return;
              }
              if (name === "length") {
                name = "_length";
              }
              if (values[name] != null) {
                return;
              }
              values[name] = values[index2];
            });
            return Object.freeze(values);
          };
          TupleCoder2.prototype.encode = function(writer, value) {
            return (0, array_1.pack)(writer, this.coders, value);
          };
          TupleCoder2.prototype.decode = function(reader) {
            return reader.coerce(this.name, (0, array_1.unpack)(reader, this.coders));
          };
          return TupleCoder2;
        }(abstract_coder_1.Coder)
      );
      exports2.TupleCoder = TupleCoder;
    }
  });

  // node_modules/@ethersproject/abi/lib/abi-coder.js
  var require_abi_coder = __commonJS({
    "node_modules/@ethersproject/abi/lib/abi-coder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultAbiCoder = exports2.AbiCoder = void 0;
      var bytes_1 = require_lib2();
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version5();
      var logger19 = new logger_1.Logger(_version_1.version);
      var abstract_coder_1 = require_abstract_coder();
      var address_1 = require_address();
      var array_1 = require_array();
      var boolean_1 = require_boolean();
      var bytes_2 = require_bytes();
      var fixed_bytes_1 = require_fixed_bytes();
      var null_1 = require_null();
      var number_1 = require_number();
      var string_1 = require_string();
      var tuple_1 = require_tuple();
      var fragments_1 = require_fragments();
      var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
      var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
      var AbiCoder2 = (
        /** @class */
        function() {
          function AbiCoder3(coerceFunc) {
            (0, properties_1.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
          }
          AbiCoder3.prototype._getCoder = function(param) {
            var _this = this;
            switch (param.baseType) {
              case "address":
                return new address_1.AddressCoder(param.name);
              case "bool":
                return new boolean_1.BooleanCoder(param.name);
              case "string":
                return new string_1.StringCoder(param.name);
              case "bytes":
                return new bytes_2.BytesCoder(param.name);
              case "array":
                return new array_1.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
              case "tuple":
                return new tuple_1.TupleCoder((param.components || []).map(function(component) {
                  return _this._getCoder(component);
                }), param.name);
              case "":
                return new null_1.NullCoder(param.name);
            }
            var match = param.type.match(paramTypeNumber);
            if (match) {
              var size3 = parseInt(match[2] || "256");
              if (size3 === 0 || size3 > 256 || size3 % 8 !== 0) {
                logger19.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
              }
              return new number_1.NumberCoder(size3 / 8, match[1] === "int", param.name);
            }
            match = param.type.match(paramTypeBytes);
            if (match) {
              var size3 = parseInt(match[1]);
              if (size3 === 0 || size3 > 32) {
                logger19.throwArgumentError("invalid bytes length", "param", param);
              }
              return new fixed_bytes_1.FixedBytesCoder(size3, param.name);
            }
            return logger19.throwArgumentError("invalid type", "type", param.type);
          };
          AbiCoder3.prototype._getWordSize = function() {
            return 32;
          };
          AbiCoder3.prototype._getReader = function(data, allowLoose) {
            return new abstract_coder_1.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
          };
          AbiCoder3.prototype._getWriter = function() {
            return new abstract_coder_1.Writer(this._getWordSize());
          };
          AbiCoder3.prototype.getDefaultValue = function(types) {
            var _this = this;
            var coders = types.map(function(type) {
              return _this._getCoder(fragments_1.ParamType.from(type));
            });
            var coder = new tuple_1.TupleCoder(coders, "_");
            return coder.defaultValue();
          };
          AbiCoder3.prototype.encode = function(types, values) {
            var _this = this;
            if (types.length !== values.length) {
              logger19.throwError("types/values length mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types, values }
              });
            }
            var coders = types.map(function(type) {
              return _this._getCoder(fragments_1.ParamType.from(type));
            });
            var coder = new tuple_1.TupleCoder(coders, "_");
            var writer = this._getWriter();
            coder.encode(writer, values);
            return writer.data;
          };
          AbiCoder3.prototype.decode = function(types, data, loose) {
            var _this = this;
            var coders = types.map(function(type) {
              return _this._getCoder(fragments_1.ParamType.from(type));
            });
            var coder = new tuple_1.TupleCoder(coders, "_");
            return coder.decode(this._getReader((0, bytes_1.arrayify)(data), loose));
          };
          return AbiCoder3;
        }()
      );
      exports2.AbiCoder = AbiCoder2;
      exports2.defaultAbiCoder = new AbiCoder2();
    }
  });

  // node_modules/@ethersproject/hash/lib/id.js
  var require_id = __commonJS({
    "node_modules/@ethersproject/hash/lib/id.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.id = void 0;
      var keccak256_1 = require_lib5();
      var strings_1 = require_lib9();
      function id3(text) {
        return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(text));
      }
      exports2.id = id3;
    }
  });

  // node_modules/@ethersproject/hash/lib/_version.js
  var require_version9 = __commonJS({
    "node_modules/@ethersproject/hash/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "hash/5.7.0";
    }
  });

  // node_modules/@ethersproject/base64/lib/browser-base64.js
  var require_browser_base64 = __commonJS({
    "node_modules/@ethersproject/base64/lib/browser-base64.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.encode = exports2.decode = void 0;
      var bytes_1 = require_lib2();
      function decode(textData) {
        textData = atob(textData);
        var data = [];
        for (var i4 = 0; i4 < textData.length; i4++) {
          data.push(textData.charCodeAt(i4));
        }
        return (0, bytes_1.arrayify)(data);
      }
      exports2.decode = decode;
      function encode(data) {
        data = (0, bytes_1.arrayify)(data);
        var textData = "";
        for (var i4 = 0; i4 < data.length; i4++) {
          textData += String.fromCharCode(data[i4]);
        }
        return btoa(textData);
      }
      exports2.encode = encode;
    }
  });

  // node_modules/@ethersproject/base64/lib/index.js
  var require_lib10 = __commonJS({
    "node_modules/@ethersproject/base64/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.encode = exports2.decode = void 0;
      var base64_1 = require_browser_base64();
      Object.defineProperty(exports2, "decode", { enumerable: true, get: function() {
        return base64_1.decode;
      } });
      Object.defineProperty(exports2, "encode", { enumerable: true, get: function() {
        return base64_1.encode;
      } });
    }
  });

  // node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js
  var require_decoder = __commonJS({
    "node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.read_emoji_trie = exports2.read_zero_terminated_array = exports2.read_mapped_map = exports2.read_member_array = exports2.signed = exports2.read_compressed_payload = exports2.read_payload = exports2.decode_arithmetic = void 0;
      function flat(array2, depth) {
        if (depth == null) {
          depth = 1;
        }
        var result = [];
        var forEach = result.forEach;
        var flatDeep = function(arr, depth2) {
          forEach.call(arr, function(val) {
            if (depth2 > 0 && Array.isArray(val)) {
              flatDeep(val, depth2 - 1);
            } else {
              result.push(val);
            }
          });
        };
        flatDeep(array2, depth);
        return result;
      }
      function fromEntries(array2) {
        var result = {};
        for (var i4 = 0; i4 < array2.length; i4++) {
          var value = array2[i4];
          result[value[0]] = value[1];
        }
        return result;
      }
      function decode_arithmetic(bytes2) {
        var pos = 0;
        function u16() {
          return bytes2[pos++] << 8 | bytes2[pos++];
        }
        var symbol_count = u16();
        var total = 1;
        var acc = [0, 1];
        for (var i4 = 1; i4 < symbol_count; i4++) {
          acc.push(total += u16());
        }
        var skip = u16();
        var pos_payload = pos;
        pos += skip;
        var read_width = 0;
        var read_buffer = 0;
        function read_bit() {
          if (read_width == 0) {
            read_buffer = read_buffer << 8 | bytes2[pos++];
            read_width = 8;
          }
          return read_buffer >> --read_width & 1;
        }
        var N2 = 31;
        var FULL = Math.pow(2, N2);
        var HALF = FULL >>> 1;
        var QRTR = HALF >> 1;
        var MASK = FULL - 1;
        var register = 0;
        for (var i4 = 0; i4 < N2; i4++)
          register = register << 1 | read_bit();
        var symbols = [];
        var low = 0;
        var range2 = FULL;
        while (true) {
          var value = Math.floor(((register - low + 1) * total - 1) / range2);
          var start = 0;
          var end = symbol_count;
          while (end - start > 1) {
            var mid = start + end >>> 1;
            if (value < acc[mid]) {
              end = mid;
            } else {
              start = mid;
            }
          }
          if (start == 0)
            break;
          symbols.push(start);
          var a2 = low + Math.floor(range2 * acc[start] / total);
          var b4 = low + Math.floor(range2 * acc[start + 1] / total) - 1;
          while (((a2 ^ b4) & HALF) == 0) {
            register = register << 1 & MASK | read_bit();
            a2 = a2 << 1 & MASK;
            b4 = b4 << 1 & MASK | 1;
          }
          while (a2 & ~b4 & QRTR) {
            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
            a2 = a2 << 1 ^ HALF;
            b4 = (b4 ^ HALF) << 1 | HALF | 1;
          }
          low = a2;
          range2 = 1 + b4 - a2;
        }
        var offset = symbol_count - 4;
        return symbols.map(function(x8) {
          switch (x8 - offset) {
            case 3:
              return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
            case 2:
              return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
            case 1:
              return offset + bytes2[pos_payload++];
            default:
              return x8 - 1;
          }
        });
      }
      exports2.decode_arithmetic = decode_arithmetic;
      function read_payload(v7) {
        var pos = 0;
        return function() {
          return v7[pos++];
        };
      }
      exports2.read_payload = read_payload;
      function read_compressed_payload(bytes2) {
        return read_payload(decode_arithmetic(bytes2));
      }
      exports2.read_compressed_payload = read_compressed_payload;
      function signed(i4) {
        return i4 & 1 ? ~i4 >> 1 : i4 >> 1;
      }
      exports2.signed = signed;
      function read_counts(n4, next) {
        var v7 = Array(n4);
        for (var i4 = 0; i4 < n4; i4++)
          v7[i4] = 1 + next();
        return v7;
      }
      function read_ascending(n4, next) {
        var v7 = Array(n4);
        for (var i4 = 0, x8 = -1; i4 < n4; i4++)
          v7[i4] = x8 += 1 + next();
        return v7;
      }
      function read_deltas(n4, next) {
        var v7 = Array(n4);
        for (var i4 = 0, x8 = 0; i4 < n4; i4++)
          v7[i4] = x8 += signed(next());
        return v7;
      }
      function read_member_array(next, lookup) {
        var v7 = read_ascending(next(), next);
        var n4 = next();
        var vX = read_ascending(n4, next);
        var vN = read_counts(n4, next);
        for (var i4 = 0; i4 < n4; i4++) {
          for (var j3 = 0; j3 < vN[i4]; j3++) {
            v7.push(vX[i4] + j3);
          }
        }
        return lookup ? v7.map(function(x8) {
          return lookup[x8];
        }) : v7;
      }
      exports2.read_member_array = read_member_array;
      function read_mapped_map(next) {
        var ret = [];
        while (true) {
          var w3 = next();
          if (w3 == 0)
            break;
          ret.push(read_linear_table(w3, next));
        }
        while (true) {
          var w3 = next() - 1;
          if (w3 < 0)
            break;
          ret.push(read_replacement_table(w3, next));
        }
        return fromEntries(flat(ret));
      }
      exports2.read_mapped_map = read_mapped_map;
      function read_zero_terminated_array(next) {
        var v7 = [];
        while (true) {
          var i4 = next();
          if (i4 == 0)
            break;
          v7.push(i4);
        }
        return v7;
      }
      exports2.read_zero_terminated_array = read_zero_terminated_array;
      function read_transposed(n4, w3, next) {
        var m5 = Array(n4).fill(void 0).map(function() {
          return [];
        });
        for (var i4 = 0; i4 < w3; i4++) {
          read_deltas(n4, next).forEach(function(x8, j3) {
            return m5[j3].push(x8);
          });
        }
        return m5;
      }
      function read_linear_table(w3, next) {
        var dx = 1 + next();
        var dy = next();
        var vN = read_zero_terminated_array(next);
        var m5 = read_transposed(vN.length, 1 + w3, next);
        return flat(m5.map(function(v7, i4) {
          var x8 = v7[0], ys = v7.slice(1);
          return Array(vN[i4]).fill(void 0).map(function(_18, j3) {
            var j_dy = j3 * dy;
            return [x8 + j3 * dx, ys.map(function(y4) {
              return y4 + j_dy;
            })];
          });
        }));
      }
      function read_replacement_table(w3, next) {
        var n4 = 1 + next();
        var m5 = read_transposed(n4, 1 + w3, next);
        return m5.map(function(v7) {
          return [v7[0], v7.slice(1)];
        });
      }
      function read_emoji_trie(next) {
        var sorted = read_member_array(next).sort(function(a2, b4) {
          return a2 - b4;
        });
        return read();
        function read() {
          var branches = [];
          while (true) {
            var keys = read_member_array(next, sorted);
            if (keys.length == 0)
              break;
            branches.push({ set: new Set(keys), node: read() });
          }
          branches.sort(function(a2, b4) {
            return b4.set.size - a2.set.size;
          });
          var temp = next();
          var valid = temp % 3;
          temp = temp / 3 | 0;
          var fe0f = !!(temp & 1);
          temp >>= 1;
          var save = temp == 1;
          var check = temp == 2;
          return { branches, valid, fe0f, save, check };
        }
      }
      exports2.read_emoji_trie = read_emoji_trie;
    }
  });

  // node_modules/@ethersproject/hash/lib/ens-normalize/include.js
  var require_include = __commonJS({
    "node_modules/@ethersproject/hash/lib/ens-normalize/include.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getData = void 0;
      var base64_1 = require_lib10();
      var decoder_js_1 = require_decoder();
      function getData() {
        return (0, decoder_js_1.read_compressed_payload)((0, base64_1.decode)("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
      }
      exports2.getData = getData;
    }
  });

  // node_modules/@ethersproject/hash/lib/ens-normalize/lib.js
  var require_lib11 = __commonJS({
    "node_modules/@ethersproject/hash/lib/ens-normalize/lib.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ens_normalize = exports2.ens_normalize_post_check = void 0;
      var strings_1 = require_lib9();
      var include_js_1 = require_include();
      var r2 = (0, include_js_1.getData)();
      var decoder_js_1 = require_decoder();
      var VALID = new Set((0, decoder_js_1.read_member_array)(r2));
      var IGNORED = new Set((0, decoder_js_1.read_member_array)(r2));
      var MAPPED = (0, decoder_js_1.read_mapped_map)(r2);
      var EMOJI_ROOT = (0, decoder_js_1.read_emoji_trie)(r2);
      var HYPHEN = 45;
      var UNDERSCORE = 95;
      function explode_cp(name) {
        return (0, strings_1.toUtf8CodePoints)(name);
      }
      function filter_fe0f(cps) {
        return cps.filter(function(cp) {
          return cp != 65039;
        });
      }
      function ens_normalize_post_check(name) {
        for (var _i = 0, _a = name.split("."); _i < _a.length; _i++) {
          var label = _a[_i];
          var cps = explode_cp(label);
          try {
            for (var i4 = cps.lastIndexOf(UNDERSCORE) - 1; i4 >= 0; i4--) {
              if (cps[i4] !== UNDERSCORE) {
                throw new Error("underscore only allowed at start");
              }
            }
            if (cps.length >= 4 && cps.every(function(cp) {
              return cp < 128;
            }) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
              throw new Error("invalid label extension");
            }
          } catch (err) {
            throw new Error('Invalid label "' + label + '": ' + err.message);
          }
        }
        return name;
      }
      exports2.ens_normalize_post_check = ens_normalize_post_check;
      function ens_normalize(name) {
        return ens_normalize_post_check(normalize2(name, filter_fe0f));
      }
      exports2.ens_normalize = ens_normalize;
      function normalize2(name, emoji_filter) {
        var input = explode_cp(name).reverse();
        var output2 = [];
        while (input.length) {
          var emoji = consume_emoji_reversed(input);
          if (emoji) {
            output2.push.apply(output2, emoji_filter(emoji));
            continue;
          }
          var cp = input.pop();
          if (VALID.has(cp)) {
            output2.push(cp);
            continue;
          }
          if (IGNORED.has(cp)) {
            continue;
          }
          var cps = MAPPED[cp];
          if (cps) {
            output2.push.apply(output2, cps);
            continue;
          }
          throw new Error("Disallowed codepoint: 0x" + cp.toString(16).toUpperCase());
        }
        return ens_normalize_post_check(nfc(String.fromCodePoint.apply(String, output2)));
      }
      function nfc(s4) {
        return s4.normalize("NFC");
      }
      function consume_emoji_reversed(cps, eaten) {
        var _a;
        var node = EMOJI_ROOT;
        var emoji;
        var saved;
        var stack = [];
        var pos = cps.length;
        if (eaten)
          eaten.length = 0;
        var _loop_1 = function() {
          var cp = cps[--pos];
          node = (_a = node.branches.find(function(x8) {
            return x8.set.has(cp);
          })) === null || _a === void 0 ? void 0 : _a.node;
          if (!node)
            return "break";
          if (node.save) {
            saved = cp;
          } else if (node.check) {
            if (cp === saved)
              return "break";
          }
          stack.push(cp);
          if (node.fe0f) {
            stack.push(65039);
            if (pos > 0 && cps[pos - 1] == 65039)
              pos--;
          }
          if (node.valid) {
            emoji = stack.slice();
            if (node.valid == 2)
              emoji.splice(1, 1);
            if (eaten)
              eaten.push.apply(eaten, cps.slice(pos).reverse());
            cps.length = pos;
          }
        };
        while (pos) {
          var state_1 = _loop_1();
          if (state_1 === "break")
            break;
        }
        return emoji;
      }
    }
  });

  // node_modules/@ethersproject/hash/lib/namehash.js
  var require_namehash = __commonJS({
    "node_modules/@ethersproject/hash/lib/namehash.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.dnsEncode = exports2.namehash = exports2.isValidName = exports2.ensNormalize = void 0;
      var bytes_1 = require_lib2();
      var strings_1 = require_lib9();
      var keccak256_1 = require_lib5();
      var logger_1 = require_lib();
      var _version_1 = require_version9();
      var logger19 = new logger_1.Logger(_version_1.version);
      var lib_1 = require_lib11();
      var Zeros = new Uint8Array(32);
      Zeros.fill(0);
      function checkComponent(comp) {
        if (comp.length === 0) {
          throw new Error("invalid ENS name; empty component");
        }
        return comp;
      }
      function ensNameSplit(name) {
        var bytes2 = (0, strings_1.toUtf8Bytes)((0, lib_1.ens_normalize)(name));
        var comps = [];
        if (name.length === 0) {
          return comps;
        }
        var last2 = 0;
        for (var i4 = 0; i4 < bytes2.length; i4++) {
          var d6 = bytes2[i4];
          if (d6 === 46) {
            comps.push(checkComponent(bytes2.slice(last2, i4)));
            last2 = i4 + 1;
          }
        }
        if (last2 >= bytes2.length) {
          throw new Error("invalid ENS name; empty component");
        }
        comps.push(checkComponent(bytes2.slice(last2)));
        return comps;
      }
      function ensNormalize(name) {
        return ensNameSplit(name).map(function(comp) {
          return (0, strings_1.toUtf8String)(comp);
        }).join(".");
      }
      exports2.ensNormalize = ensNormalize;
      function isValidName2(name) {
        try {
          return ensNameSplit(name).length !== 0;
        } catch (error) {
        }
        return false;
      }
      exports2.isValidName = isValidName2;
      function namehash4(name) {
        if (typeof name !== "string") {
          logger19.throwArgumentError("invalid ENS name; not a string", "name", name);
        }
        var result = Zeros;
        var comps = ensNameSplit(name);
        while (comps.length) {
          result = (0, keccak256_1.keccak256)((0, bytes_1.concat)([result, (0, keccak256_1.keccak256)(comps.pop())]));
        }
        return (0, bytes_1.hexlify)(result);
      }
      exports2.namehash = namehash4;
      function dnsEncode3(name) {
        return (0, bytes_1.hexlify)((0, bytes_1.concat)(ensNameSplit(name).map(function(comp) {
          if (comp.length > 63) {
            throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
          }
          var bytes2 = new Uint8Array(comp.length + 1);
          bytes2.set(comp, 1);
          bytes2[0] = bytes2.length - 1;
          return bytes2;
        }))) + "00";
      }
      exports2.dnsEncode = dnsEncode3;
    }
  });

  // node_modules/@ethersproject/hash/lib/message.js
  var require_message = __commonJS({
    "node_modules/@ethersproject/hash/lib/message.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hashMessage = exports2.messagePrefix = void 0;
      var bytes_1 = require_lib2();
      var keccak256_1 = require_lib5();
      var strings_1 = require_lib9();
      exports2.messagePrefix = "Ethereum Signed Message:\n";
      function hashMessage3(message) {
        if (typeof message === "string") {
          message = (0, strings_1.toUtf8Bytes)(message);
        }
        return (0, keccak256_1.keccak256)((0, bytes_1.concat)([
          (0, strings_1.toUtf8Bytes)(exports2.messagePrefix),
          (0, strings_1.toUtf8Bytes)(String(message.length)),
          message
        ]));
      }
      exports2.hashMessage = hashMessage3;
    }
  });

  // node_modules/@ethersproject/hash/lib/typed-data.js
  var require_typed_data = __commonJS({
    "node_modules/@ethersproject/hash/lib/typed-data.js"(exports2) {
      "use strict";
      var __awaiter10 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n4) {
          return function(v7) {
            return step([n4, v7]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t3[1]) {
                    _18.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _18.label < t3[2]) {
                    _18.label = t3[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e) {
              op = [6, e];
              y4 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TypedDataEncoder = void 0;
      var address_1 = require_lib7();
      var bignumber_1 = require_lib3();
      var bytes_1 = require_lib2();
      var keccak256_1 = require_lib5();
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version9();
      var logger19 = new logger_1.Logger(_version_1.version);
      var id_1 = require_id();
      var padding2 = new Uint8Array(32);
      padding2.fill(0);
      var NegativeOne = bignumber_1.BigNumber.from(-1);
      var Zero = bignumber_1.BigNumber.from(0);
      var One = bignumber_1.BigNumber.from(1);
      var MaxUint256 = bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      function hexPadRight(value) {
        var bytes2 = (0, bytes_1.arrayify)(value);
        var padOffset = bytes2.length % 32;
        if (padOffset) {
          return (0, bytes_1.hexConcat)([bytes2, padding2.slice(padOffset)]);
        }
        return (0, bytes_1.hexlify)(bytes2);
      }
      var hexTrue = (0, bytes_1.hexZeroPad)(One.toHexString(), 32);
      var hexFalse = (0, bytes_1.hexZeroPad)(Zero.toHexString(), 32);
      var domainFieldTypes = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
      };
      var domainFieldNames = [
        "name",
        "version",
        "chainId",
        "verifyingContract",
        "salt"
      ];
      function checkString(key) {
        return function(value) {
          if (typeof value !== "string") {
            logger19.throwArgumentError("invalid domain value for " + JSON.stringify(key), "domain." + key, value);
          }
          return value;
        };
      }
      var domainChecks = {
        name: checkString("name"),
        version: checkString("version"),
        chainId: function(value) {
          try {
            return bignumber_1.BigNumber.from(value).toString();
          } catch (error) {
          }
          return logger19.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", value);
        },
        verifyingContract: function(value) {
          try {
            return (0, address_1.getAddress)(value).toLowerCase();
          } catch (error) {
          }
          return logger19.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", value);
        },
        salt: function(value) {
          try {
            var bytes2 = (0, bytes_1.arrayify)(value);
            if (bytes2.length !== 32) {
              throw new Error("bad length");
            }
            return (0, bytes_1.hexlify)(bytes2);
          } catch (error) {
          }
          return logger19.throwArgumentError('invalid domain value "salt"', "domain.salt", value);
        }
      };
      function getBaseEncoder(type) {
        {
          var match = type.match(/^(u?)int(\d*)$/);
          if (match) {
            var signed = match[1] === "";
            var width = parseInt(match[2] || "256");
            if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
              logger19.throwArgumentError("invalid numeric width", "type", type);
            }
            var boundsUpper_1 = MaxUint256.mask(signed ? width - 1 : width);
            var boundsLower_1 = signed ? boundsUpper_1.add(One).mul(NegativeOne) : Zero;
            return function(value) {
              var v7 = bignumber_1.BigNumber.from(value);
              if (v7.lt(boundsLower_1) || v7.gt(boundsUpper_1)) {
                logger19.throwArgumentError("value out-of-bounds for " + type, "value", value);
              }
              return (0, bytes_1.hexZeroPad)(v7.toTwos(256).toHexString(), 32);
            };
          }
        }
        {
          var match = type.match(/^bytes(\d+)$/);
          if (match) {
            var width_1 = parseInt(match[1]);
            if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {
              logger19.throwArgumentError("invalid bytes width", "type", type);
            }
            return function(value) {
              var bytes2 = (0, bytes_1.arrayify)(value);
              if (bytes2.length !== width_1) {
                logger19.throwArgumentError("invalid length for " + type, "value", value);
              }
              return hexPadRight(value);
            };
          }
        }
        switch (type) {
          case "address":
            return function(value) {
              return (0, bytes_1.hexZeroPad)((0, address_1.getAddress)(value), 32);
            };
          case "bool":
            return function(value) {
              return !value ? hexFalse : hexTrue;
            };
          case "bytes":
            return function(value) {
              return (0, keccak256_1.keccak256)(value);
            };
          case "string":
            return function(value) {
              return (0, id_1.id)(value);
            };
        }
        return null;
      }
      function encodeType2(name, fields) {
        return name + "(" + fields.map(function(_a) {
          var name2 = _a.name, type = _a.type;
          return type + " " + name2;
        }).join(",") + ")";
      }
      var TypedDataEncoder = (
        /** @class */
        function() {
          function TypedDataEncoder2(types) {
            (0, properties_1.defineReadOnly)(this, "types", Object.freeze((0, properties_1.deepCopy)(types)));
            (0, properties_1.defineReadOnly)(this, "_encoderCache", {});
            (0, properties_1.defineReadOnly)(this, "_types", {});
            var links = {};
            var parents = {};
            var subtypes = {};
            Object.keys(types).forEach(function(type) {
              links[type] = {};
              parents[type] = [];
              subtypes[type] = {};
            });
            var _loop_1 = function(name_12) {
              var uniqueNames = {};
              types[name_12].forEach(function(field) {
                if (uniqueNames[field.name]) {
                  logger19.throwArgumentError("duplicate variable name " + JSON.stringify(field.name) + " in " + JSON.stringify(name_12), "types", types);
                }
                uniqueNames[field.name] = true;
                var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                if (baseType === name_12) {
                  logger19.throwArgumentError("circular type reference to " + JSON.stringify(baseType), "types", types);
                }
                var encoder3 = getBaseEncoder(baseType);
                if (encoder3) {
                  return;
                }
                if (!parents[baseType]) {
                  logger19.throwArgumentError("unknown type " + JSON.stringify(baseType), "types", types);
                }
                parents[baseType].push(name_12);
                links[name_12][baseType] = true;
              });
            };
            for (var name_1 in types) {
              _loop_1(name_1);
            }
            var primaryTypes = Object.keys(parents).filter(function(n4) {
              return parents[n4].length === 0;
            });
            if (primaryTypes.length === 0) {
              logger19.throwArgumentError("missing primary type", "types", types);
            } else if (primaryTypes.length > 1) {
              logger19.throwArgumentError("ambiguous primary types or unused types: " + primaryTypes.map(function(t3) {
                return JSON.stringify(t3);
              }).join(", "), "types", types);
            }
            (0, properties_1.defineReadOnly)(this, "primaryType", primaryTypes[0]);
            function checkCircular(type, found) {
              if (found[type]) {
                logger19.throwArgumentError("circular type reference to " + JSON.stringify(type), "types", types);
              }
              found[type] = true;
              Object.keys(links[type]).forEach(function(child) {
                if (!parents[child]) {
                  return;
                }
                checkCircular(child, found);
                Object.keys(found).forEach(function(subtype) {
                  subtypes[subtype][child] = true;
                });
              });
              delete found[type];
            }
            checkCircular(this.primaryType, {});
            for (var name_2 in subtypes) {
              var st = Object.keys(subtypes[name_2]);
              st.sort();
              this._types[name_2] = encodeType2(name_2, types[name_2]) + st.map(function(t3) {
                return encodeType2(t3, types[t3]);
              }).join("");
            }
          }
          TypedDataEncoder2.prototype.getEncoder = function(type) {
            var encoder3 = this._encoderCache[type];
            if (!encoder3) {
              encoder3 = this._encoderCache[type] = this._getEncoder(type);
            }
            return encoder3;
          };
          TypedDataEncoder2.prototype._getEncoder = function(type) {
            var _this = this;
            {
              var encoder3 = getBaseEncoder(type);
              if (encoder3) {
                return encoder3;
              }
            }
            var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (match) {
              var subtype_1 = match[1];
              var subEncoder_1 = this.getEncoder(subtype_1);
              var length_1 = parseInt(match[3]);
              return function(value) {
                if (length_1 >= 0 && value.length !== length_1) {
                  logger19.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
                }
                var result = value.map(subEncoder_1);
                if (_this._types[subtype_1]) {
                  result = result.map(keccak256_1.keccak256);
                }
                return (0, keccak256_1.keccak256)((0, bytes_1.hexConcat)(result));
              };
            }
            var fields = this.types[type];
            if (fields) {
              var encodedType_1 = (0, id_1.id)(this._types[type]);
              return function(value) {
                var values = fields.map(function(_a) {
                  var name = _a.name, type2 = _a.type;
                  var result = _this.getEncoder(type2)(value[name]);
                  if (_this._types[type2]) {
                    return (0, keccak256_1.keccak256)(result);
                  }
                  return result;
                });
                values.unshift(encodedType_1);
                return (0, bytes_1.hexConcat)(values);
              };
            }
            return logger19.throwArgumentError("unknown type: " + type, "type", type);
          };
          TypedDataEncoder2.prototype.encodeType = function(name) {
            var result = this._types[name];
            if (!result) {
              logger19.throwArgumentError("unknown type: " + JSON.stringify(name), "name", name);
            }
            return result;
          };
          TypedDataEncoder2.prototype.encodeData = function(type, value) {
            return this.getEncoder(type)(value);
          };
          TypedDataEncoder2.prototype.hashStruct = function(name, value) {
            return (0, keccak256_1.keccak256)(this.encodeData(name, value));
          };
          TypedDataEncoder2.prototype.encode = function(value) {
            return this.encodeData(this.primaryType, value);
          };
          TypedDataEncoder2.prototype.hash = function(value) {
            return this.hashStruct(this.primaryType, value);
          };
          TypedDataEncoder2.prototype._visit = function(type, value, callback) {
            var _this = this;
            {
              var encoder3 = getBaseEncoder(type);
              if (encoder3) {
                return callback(type, value);
              }
            }
            var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (match) {
              var subtype_2 = match[1];
              var length_2 = parseInt(match[3]);
              if (length_2 >= 0 && value.length !== length_2) {
                logger19.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
              }
              return value.map(function(v7) {
                return _this._visit(subtype_2, v7, callback);
              });
            }
            var fields = this.types[type];
            if (fields) {
              return fields.reduce(function(accum, _a) {
                var name = _a.name, type2 = _a.type;
                accum[name] = _this._visit(type2, value[name], callback);
                return accum;
              }, {});
            }
            return logger19.throwArgumentError("unknown type: " + type, "type", type);
          };
          TypedDataEncoder2.prototype.visit = function(value, callback) {
            return this._visit(this.primaryType, value, callback);
          };
          TypedDataEncoder2.from = function(types) {
            return new TypedDataEncoder2(types);
          };
          TypedDataEncoder2.getPrimaryType = function(types) {
            return TypedDataEncoder2.from(types).primaryType;
          };
          TypedDataEncoder2.hashStruct = function(name, types, value) {
            return TypedDataEncoder2.from(types).hashStruct(name, value);
          };
          TypedDataEncoder2.hashDomain = function(domain) {
            var domainFields = [];
            for (var name_3 in domain) {
              var type = domainFieldTypes[name_3];
              if (!type) {
                logger19.throwArgumentError("invalid typed-data domain key: " + JSON.stringify(name_3), "domain", domain);
              }
              domainFields.push({ name: name_3, type });
            }
            domainFields.sort(function(a2, b4) {
              return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b4.name);
            });
            return TypedDataEncoder2.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
          };
          TypedDataEncoder2.encode = function(domain, types, value) {
            return (0, bytes_1.hexConcat)([
              "0x1901",
              TypedDataEncoder2.hashDomain(domain),
              TypedDataEncoder2.from(types).hash(value)
            ]);
          };
          TypedDataEncoder2.hash = function(domain, types, value) {
            return (0, keccak256_1.keccak256)(TypedDataEncoder2.encode(domain, types, value));
          };
          TypedDataEncoder2.resolveNames = function(domain, types, value, resolveName2) {
            return __awaiter10(this, void 0, void 0, function() {
              var ensCache, encoder3, _a, _b, _i, name_4, _c, _d;
              return __generator2(this, function(_e2) {
                switch (_e2.label) {
                  case 0:
                    domain = (0, properties_1.shallowCopy)(domain);
                    ensCache = {};
                    if (domain.verifyingContract && !(0, bytes_1.isHexString)(domain.verifyingContract, 20)) {
                      ensCache[domain.verifyingContract] = "0x";
                    }
                    encoder3 = TypedDataEncoder2.from(types);
                    encoder3.visit(value, function(type, value2) {
                      if (type === "address" && !(0, bytes_1.isHexString)(value2, 20)) {
                        ensCache[value2] = "0x";
                      }
                      return value2;
                    });
                    _a = [];
                    for (_b in ensCache)
                      _a.push(_b);
                    _i = 0;
                    _e2.label = 1;
                  case 1:
                    if (!(_i < _a.length))
                      return [3, 4];
                    name_4 = _a[_i];
                    _c = ensCache;
                    _d = name_4;
                    return [4, resolveName2(name_4)];
                  case 2:
                    _c[_d] = _e2.sent();
                    _e2.label = 3;
                  case 3:
                    _i++;
                    return [3, 1];
                  case 4:
                    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                      domain.verifyingContract = ensCache[domain.verifyingContract];
                    }
                    value = encoder3.visit(value, function(type, value2) {
                      if (type === "address" && ensCache[value2]) {
                        return ensCache[value2];
                      }
                      return value2;
                    });
                    return [2, { domain, value }];
                }
              });
            });
          };
          TypedDataEncoder2.getPayload = function(domain, types, value) {
            TypedDataEncoder2.hashDomain(domain);
            var domainValues = {};
            var domainTypes = [];
            domainFieldNames.forEach(function(name) {
              var value2 = domain[name];
              if (value2 == null) {
                return;
              }
              domainValues[name] = domainChecks[name](value2);
              domainTypes.push({ name, type: domainFieldTypes[name] });
            });
            var encoder3 = TypedDataEncoder2.from(types);
            var typesWithDomain = (0, properties_1.shallowCopy)(types);
            if (typesWithDomain.EIP712Domain) {
              logger19.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
            } else {
              typesWithDomain.EIP712Domain = domainTypes;
            }
            encoder3.encode(value);
            return {
              types: typesWithDomain,
              domain: domainValues,
              primaryType: encoder3.primaryType,
              message: encoder3.visit(value, function(type, value2) {
                if (type.match(/^bytes(\d*)/)) {
                  return (0, bytes_1.hexlify)((0, bytes_1.arrayify)(value2));
                }
                if (type.match(/^u?int/)) {
                  return bignumber_1.BigNumber.from(value2).toString();
                }
                switch (type) {
                  case "address":
                    return value2.toLowerCase();
                  case "bool":
                    return !!value2;
                  case "string":
                    if (typeof value2 !== "string") {
                      logger19.throwArgumentError("invalid string", "value", value2);
                    }
                    return value2;
                }
                return logger19.throwArgumentError("unsupported type", "type", type);
              })
            };
          };
          return TypedDataEncoder2;
        }()
      );
      exports2.TypedDataEncoder = TypedDataEncoder;
    }
  });

  // node_modules/@ethersproject/hash/lib/index.js
  var require_lib12 = __commonJS({
    "node_modules/@ethersproject/hash/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2._TypedDataEncoder = exports2.hashMessage = exports2.messagePrefix = exports2.ensNormalize = exports2.isValidName = exports2.namehash = exports2.dnsEncode = exports2.id = void 0;
      var id_1 = require_id();
      Object.defineProperty(exports2, "id", { enumerable: true, get: function() {
        return id_1.id;
      } });
      var namehash_1 = require_namehash();
      Object.defineProperty(exports2, "dnsEncode", { enumerable: true, get: function() {
        return namehash_1.dnsEncode;
      } });
      Object.defineProperty(exports2, "isValidName", { enumerable: true, get: function() {
        return namehash_1.isValidName;
      } });
      Object.defineProperty(exports2, "namehash", { enumerable: true, get: function() {
        return namehash_1.namehash;
      } });
      var message_1 = require_message();
      Object.defineProperty(exports2, "hashMessage", { enumerable: true, get: function() {
        return message_1.hashMessage;
      } });
      Object.defineProperty(exports2, "messagePrefix", { enumerable: true, get: function() {
        return message_1.messagePrefix;
      } });
      var namehash_2 = require_namehash();
      Object.defineProperty(exports2, "ensNormalize", { enumerable: true, get: function() {
        return namehash_2.ensNormalize;
      } });
      var typed_data_1 = require_typed_data();
      Object.defineProperty(exports2, "_TypedDataEncoder", { enumerable: true, get: function() {
        return typed_data_1.TypedDataEncoder;
      } });
    }
  });

  // node_modules/@ethersproject/abi/lib/interface.js
  var require_interface = __commonJS({
    "node_modules/@ethersproject/abi/lib/interface.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Interface = exports2.Indexed = exports2.ErrorDescription = exports2.TransactionDescription = exports2.LogDescription = exports2.checkResultErrors = void 0;
      var address_1 = require_lib7();
      var bignumber_1 = require_lib3();
      var bytes_1 = require_lib2();
      var hash_1 = require_lib12();
      var keccak256_1 = require_lib5();
      var properties_1 = require_lib4();
      var abi_coder_1 = require_abi_coder();
      var abstract_coder_1 = require_abstract_coder();
      Object.defineProperty(exports2, "checkResultErrors", { enumerable: true, get: function() {
        return abstract_coder_1.checkResultErrors;
      } });
      var fragments_1 = require_fragments();
      var logger_1 = require_lib();
      var _version_1 = require_version5();
      var logger19 = new logger_1.Logger(_version_1.version);
      var LogDescription2 = (
        /** @class */
        function(_super) {
          __extends2(LogDescription3, _super);
          function LogDescription3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          return LogDescription3;
        }(properties_1.Description)
      );
      exports2.LogDescription = LogDescription2;
      var TransactionDescription2 = (
        /** @class */
        function(_super) {
          __extends2(TransactionDescription3, _super);
          function TransactionDescription3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          return TransactionDescription3;
        }(properties_1.Description)
      );
      exports2.TransactionDescription = TransactionDescription2;
      var ErrorDescription = (
        /** @class */
        function(_super) {
          __extends2(ErrorDescription2, _super);
          function ErrorDescription2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          return ErrorDescription2;
        }(properties_1.Description)
      );
      exports2.ErrorDescription = ErrorDescription;
      var Indexed3 = (
        /** @class */
        function(_super) {
          __extends2(Indexed4, _super);
          function Indexed4() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          Indexed4.isIndexed = function(value) {
            return !!(value && value._isIndexed);
          };
          return Indexed4;
        }(properties_1.Description)
      );
      exports2.Indexed = Indexed3;
      var BuiltinErrors = {
        "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
        "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
      };
      function wrapAccessError(property7, error) {
        var wrap = new Error("deferred error during ABI decoding triggered accessing " + property7);
        wrap.error = error;
        return wrap;
      }
      var Interface3 = (
        /** @class */
        function() {
          function Interface4(fragments) {
            var _newTarget = this.constructor;
            var _this = this;
            var abi = [];
            if (typeof fragments === "string") {
              abi = JSON.parse(fragments);
            } else {
              abi = fragments;
            }
            (0, properties_1.defineReadOnly)(this, "fragments", abi.map(function(fragment) {
              return fragments_1.Fragment.from(fragment);
            }).filter(function(fragment) {
              return fragment != null;
            }));
            (0, properties_1.defineReadOnly)(this, "_abiCoder", (0, properties_1.getStatic)(_newTarget, "getAbiCoder")());
            (0, properties_1.defineReadOnly)(this, "functions", {});
            (0, properties_1.defineReadOnly)(this, "errors", {});
            (0, properties_1.defineReadOnly)(this, "events", {});
            (0, properties_1.defineReadOnly)(this, "structs", {});
            this.fragments.forEach(function(fragment) {
              var bucket = null;
              switch (fragment.type) {
                case "constructor":
                  if (_this.deploy) {
                    logger19.warn("duplicate definition - constructor");
                    return;
                  }
                  (0, properties_1.defineReadOnly)(_this, "deploy", fragment);
                  return;
                case "function":
                  bucket = _this.functions;
                  break;
                case "event":
                  bucket = _this.events;
                  break;
                case "error":
                  bucket = _this.errors;
                  break;
                default:
                  return;
              }
              var signature = fragment.format();
              if (bucket[signature]) {
                logger19.warn("duplicate definition - " + signature);
                return;
              }
              bucket[signature] = fragment;
            });
            if (!this.deploy) {
              (0, properties_1.defineReadOnly)(this, "deploy", fragments_1.ConstructorFragment.from({
                payable: false,
                type: "constructor"
              }));
            }
            (0, properties_1.defineReadOnly)(this, "_isInterface", true);
          }
          Interface4.prototype.format = function(format3) {
            if (!format3) {
              format3 = fragments_1.FormatTypes.full;
            }
            if (format3 === fragments_1.FormatTypes.sighash) {
              logger19.throwArgumentError("interface does not support formatting sighash", "format", format3);
            }
            var abi = this.fragments.map(function(fragment) {
              return fragment.format(format3);
            });
            if (format3 === fragments_1.FormatTypes.json) {
              return JSON.stringify(abi.map(function(j3) {
                return JSON.parse(j3);
              }));
            }
            return abi;
          };
          Interface4.getAbiCoder = function() {
            return abi_coder_1.defaultAbiCoder;
          };
          Interface4.getAddress = function(address) {
            return (0, address_1.getAddress)(address);
          };
          Interface4.getSighash = function(fragment) {
            return (0, bytes_1.hexDataSlice)((0, hash_1.id)(fragment.format()), 0, 4);
          };
          Interface4.getEventTopic = function(eventFragment) {
            return (0, hash_1.id)(eventFragment.format());
          };
          Interface4.prototype.getFunction = function(nameOrSignatureOrSighash) {
            if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
              for (var name_1 in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name_1)) {
                  return this.functions[name_1];
                }
              }
              logger19.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
            }
            if (nameOrSignatureOrSighash.indexOf("(") === -1) {
              var name_2 = nameOrSignatureOrSighash.trim();
              var matching = Object.keys(this.functions).filter(function(f5) {
                return f5.split(
                  "("
                  /* fix:) */
                )[0] === name_2;
              });
              if (matching.length === 0) {
                logger19.throwArgumentError("no matching function", "name", name_2);
              } else if (matching.length > 1) {
                logger19.throwArgumentError("multiple matching functions", "name", name_2);
              }
              return this.functions[matching[0]];
            }
            var result = this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
            if (!result) {
              logger19.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
            }
            return result;
          };
          Interface4.prototype.getEvent = function(nameOrSignatureOrTopic) {
            if ((0, bytes_1.isHexString)(nameOrSignatureOrTopic)) {
              var topichash = nameOrSignatureOrTopic.toLowerCase();
              for (var name_3 in this.events) {
                if (topichash === this.getEventTopic(name_3)) {
                  return this.events[name_3];
                }
              }
              logger19.throwArgumentError("no matching event", "topichash", topichash);
            }
            if (nameOrSignatureOrTopic.indexOf("(") === -1) {
              var name_4 = nameOrSignatureOrTopic.trim();
              var matching = Object.keys(this.events).filter(function(f5) {
                return f5.split(
                  "("
                  /* fix:) */
                )[0] === name_4;
              });
              if (matching.length === 0) {
                logger19.throwArgumentError("no matching event", "name", name_4);
              } else if (matching.length > 1) {
                logger19.throwArgumentError("multiple matching events", "name", name_4);
              }
              return this.events[matching[0]];
            }
            var result = this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];
            if (!result) {
              logger19.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
            }
            return result;
          };
          Interface4.prototype.getError = function(nameOrSignatureOrSighash) {
            if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
              var getSighash = (0, properties_1.getStatic)(this.constructor, "getSighash");
              for (var name_5 in this.errors) {
                var error = this.errors[name_5];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                  return this.errors[name_5];
                }
              }
              logger19.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
            }
            if (nameOrSignatureOrSighash.indexOf("(") === -1) {
              var name_6 = nameOrSignatureOrSighash.trim();
              var matching = Object.keys(this.errors).filter(function(f5) {
                return f5.split(
                  "("
                  /* fix:) */
                )[0] === name_6;
              });
              if (matching.length === 0) {
                logger19.throwArgumentError("no matching error", "name", name_6);
              } else if (matching.length > 1) {
                logger19.throwArgumentError("multiple matching errors", "name", name_6);
              }
              return this.errors[matching[0]];
            }
            var result = this.errors[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
            if (!result) {
              logger19.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
            }
            return result;
          };
          Interface4.prototype.getSighash = function(fragment) {
            if (typeof fragment === "string") {
              try {
                fragment = this.getFunction(fragment);
              } catch (error) {
                try {
                  fragment = this.getError(fragment);
                } catch (_18) {
                  throw error;
                }
              }
            }
            return (0, properties_1.getStatic)(this.constructor, "getSighash")(fragment);
          };
          Interface4.prototype.getEventTopic = function(eventFragment) {
            if (typeof eventFragment === "string") {
              eventFragment = this.getEvent(eventFragment);
            }
            return (0, properties_1.getStatic)(this.constructor, "getEventTopic")(eventFragment);
          };
          Interface4.prototype._decodeParams = function(params, data) {
            return this._abiCoder.decode(params, data);
          };
          Interface4.prototype._encodeParams = function(params, values) {
            return this._abiCoder.encode(params, values);
          };
          Interface4.prototype.encodeDeploy = function(values) {
            return this._encodeParams(this.deploy.inputs, values || []);
          };
          Interface4.prototype.decodeErrorResult = function(fragment, data) {
            if (typeof fragment === "string") {
              fragment = this.getError(fragment);
            }
            var bytes2 = (0, bytes_1.arrayify)(data);
            if ((0, bytes_1.hexlify)(bytes2.slice(0, 4)) !== this.getSighash(fragment)) {
              logger19.throwArgumentError("data signature does not match error " + fragment.name + ".", "data", (0, bytes_1.hexlify)(bytes2));
            }
            return this._decodeParams(fragment.inputs, bytes2.slice(4));
          };
          Interface4.prototype.encodeErrorResult = function(fragment, values) {
            if (typeof fragment === "string") {
              fragment = this.getError(fragment);
            }
            return (0, bytes_1.hexlify)((0, bytes_1.concat)([
              this.getSighash(fragment),
              this._encodeParams(fragment.inputs, values || [])
            ]));
          };
          Interface4.prototype.decodeFunctionData = function(functionFragment, data) {
            if (typeof functionFragment === "string") {
              functionFragment = this.getFunction(functionFragment);
            }
            var bytes2 = (0, bytes_1.arrayify)(data);
            if ((0, bytes_1.hexlify)(bytes2.slice(0, 4)) !== this.getSighash(functionFragment)) {
              logger19.throwArgumentError("data signature does not match function " + functionFragment.name + ".", "data", (0, bytes_1.hexlify)(bytes2));
            }
            return this._decodeParams(functionFragment.inputs, bytes2.slice(4));
          };
          Interface4.prototype.encodeFunctionData = function(functionFragment, values) {
            if (typeof functionFragment === "string") {
              functionFragment = this.getFunction(functionFragment);
            }
            return (0, bytes_1.hexlify)((0, bytes_1.concat)([
              this.getSighash(functionFragment),
              this._encodeParams(functionFragment.inputs, values || [])
            ]));
          };
          Interface4.prototype.decodeFunctionResult = function(functionFragment, data) {
            if (typeof functionFragment === "string") {
              functionFragment = this.getFunction(functionFragment);
            }
            var bytes2 = (0, bytes_1.arrayify)(data);
            var reason = null;
            var message = "";
            var errorArgs = null;
            var errorName = null;
            var errorSignature = null;
            switch (bytes2.length % this._abiCoder._getWordSize()) {
              case 0:
                try {
                  return this._abiCoder.decode(functionFragment.outputs, bytes2);
                } catch (error2) {
                }
                break;
              case 4: {
                var selector = (0, bytes_1.hexlify)(bytes2.slice(0, 4));
                var builtin = BuiltinErrors[selector];
                if (builtin) {
                  errorArgs = this._abiCoder.decode(builtin.inputs, bytes2.slice(4));
                  errorName = builtin.name;
                  errorSignature = builtin.signature;
                  if (builtin.reason) {
                    reason = errorArgs[0];
                  }
                  if (errorName === "Error") {
                    message = "; VM Exception while processing transaction: reverted with reason string " + JSON.stringify(errorArgs[0]);
                  } else if (errorName === "Panic") {
                    message = "; VM Exception while processing transaction: reverted with panic code " + errorArgs[0];
                  }
                } else {
                  try {
                    var error = this.getError(selector);
                    errorArgs = this._abiCoder.decode(error.inputs, bytes2.slice(4));
                    errorName = error.name;
                    errorSignature = error.format();
                  } catch (error2) {
                  }
                }
                break;
              }
            }
            return logger19.throwError("call revert exception" + message, logger_1.Logger.errors.CALL_EXCEPTION, {
              method: functionFragment.format(),
              data: (0, bytes_1.hexlify)(data),
              errorArgs,
              errorName,
              errorSignature,
              reason
            });
          };
          Interface4.prototype.encodeFunctionResult = function(functionFragment, values) {
            if (typeof functionFragment === "string") {
              functionFragment = this.getFunction(functionFragment);
            }
            return (0, bytes_1.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
          };
          Interface4.prototype.encodeFilterTopics = function(eventFragment, values) {
            var _this = this;
            if (typeof eventFragment === "string") {
              eventFragment = this.getEvent(eventFragment);
            }
            if (values.length > eventFragment.inputs.length) {
              logger19.throwError("too many arguments for " + eventFragment.format(), logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
              });
            }
            var topics = [];
            if (!eventFragment.anonymous) {
              topics.push(this.getEventTopic(eventFragment));
            }
            var encodeTopic = function(param, value) {
              if (param.type === "string") {
                return (0, hash_1.id)(value);
              } else if (param.type === "bytes") {
                return (0, keccak256_1.keccak256)((0, bytes_1.hexlify)(value));
              }
              if (param.type === "bool" && typeof value === "boolean") {
                value = value ? "0x01" : "0x00";
              }
              if (param.type.match(/^u?int/)) {
                value = bignumber_1.BigNumber.from(value).toHexString();
              }
              if (param.type === "address") {
                _this._abiCoder.encode(["address"], [value]);
              }
              return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
            };
            values.forEach(function(value, index2) {
              var param = eventFragment.inputs[index2];
              if (!param.indexed) {
                if (value != null) {
                  logger19.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
                }
                return;
              }
              if (value == null) {
                topics.push(null);
              } else if (param.baseType === "array" || param.baseType === "tuple") {
                logger19.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
              } else if (Array.isArray(value)) {
                topics.push(value.map(function(value2) {
                  return encodeTopic(param, value2);
                }));
              } else {
                topics.push(encodeTopic(param, value));
              }
            });
            while (topics.length && topics[topics.length - 1] === null) {
              topics.pop();
            }
            return topics;
          };
          Interface4.prototype.encodeEventLog = function(eventFragment, values) {
            var _this = this;
            if (typeof eventFragment === "string") {
              eventFragment = this.getEvent(eventFragment);
            }
            var topics = [];
            var dataTypes = [];
            var dataValues = [];
            if (!eventFragment.anonymous) {
              topics.push(this.getEventTopic(eventFragment));
            }
            if (values.length !== eventFragment.inputs.length) {
              logger19.throwArgumentError("event arguments/values mismatch", "values", values);
            }
            eventFragment.inputs.forEach(function(param, index2) {
              var value = values[index2];
              if (param.indexed) {
                if (param.type === "string") {
                  topics.push((0, hash_1.id)(value));
                } else if (param.type === "bytes") {
                  topics.push((0, keccak256_1.keccak256)(value));
                } else if (param.baseType === "tuple" || param.baseType === "array") {
                  throw new Error("not implemented");
                } else {
                  topics.push(_this._abiCoder.encode([param.type], [value]));
                }
              } else {
                dataTypes.push(param);
                dataValues.push(value);
              }
            });
            return {
              data: this._abiCoder.encode(dataTypes, dataValues),
              topics
            };
          };
          Interface4.prototype.decodeEventLog = function(eventFragment, data, topics) {
            if (typeof eventFragment === "string") {
              eventFragment = this.getEvent(eventFragment);
            }
            if (topics != null && !eventFragment.anonymous) {
              var topicHash = this.getEventTopic(eventFragment);
              if (!(0, bytes_1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger19.throwError("fragment/topic mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
              }
              topics = topics.slice(1);
            }
            var indexed = [];
            var nonIndexed = [];
            var dynamic = [];
            eventFragment.inputs.forEach(function(param, index2) {
              if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                  indexed.push(fragments_1.ParamType.fromObject({ type: "bytes32", name: param.name }));
                  dynamic.push(true);
                } else {
                  indexed.push(param);
                  dynamic.push(false);
                }
              } else {
                nonIndexed.push(param);
                dynamic.push(false);
              }
            });
            var resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0, bytes_1.concat)(topics)) : null;
            var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
            var result = [];
            var nonIndexedIndex = 0, indexedIndex = 0;
            eventFragment.inputs.forEach(function(param, index2) {
              if (param.indexed) {
                if (resultIndexed == null) {
                  result[index2] = new Indexed3({ _isIndexed: true, hash: null });
                } else if (dynamic[index2]) {
                  result[index2] = new Indexed3({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                } else {
                  try {
                    result[index2] = resultIndexed[indexedIndex++];
                  } catch (error) {
                    result[index2] = error;
                  }
                }
              } else {
                try {
                  result[index2] = resultNonIndexed[nonIndexedIndex++];
                } catch (error) {
                  result[index2] = error;
                }
              }
              if (param.name && result[param.name] == null) {
                var value_1 = result[index2];
                if (value_1 instanceof Error) {
                  Object.defineProperty(result, param.name, {
                    enumerable: true,
                    get: function() {
                      throw wrapAccessError("property " + JSON.stringify(param.name), value_1);
                    }
                  });
                } else {
                  result[param.name] = value_1;
                }
              }
            });
            var _loop_1 = function(i5) {
              var value = result[i5];
              if (value instanceof Error) {
                Object.defineProperty(result, i5, {
                  enumerable: true,
                  get: function() {
                    throw wrapAccessError("index " + i5, value);
                  }
                });
              }
            };
            for (var i4 = 0; i4 < result.length; i4++) {
              _loop_1(i4);
            }
            return Object.freeze(result);
          };
          Interface4.prototype.parseTransaction = function(tx) {
            var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
            if (!fragment) {
              return null;
            }
            return new TransactionDescription2({
              args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
              functionFragment: fragment,
              name: fragment.name,
              signature: fragment.format(),
              sighash: this.getSighash(fragment),
              value: bignumber_1.BigNumber.from(tx.value || "0")
            });
          };
          Interface4.prototype.parseLog = function(log) {
            var fragment = this.getEvent(log.topics[0]);
            if (!fragment || fragment.anonymous) {
              return null;
            }
            return new LogDescription2({
              eventFragment: fragment,
              name: fragment.name,
              signature: fragment.format(),
              topic: this.getEventTopic(fragment),
              args: this.decodeEventLog(fragment, log.data, log.topics)
            });
          };
          Interface4.prototype.parseError = function(data) {
            var hexData = (0, bytes_1.hexlify)(data);
            var fragment = this.getError(hexData.substring(0, 10).toLowerCase());
            if (!fragment) {
              return null;
            }
            return new ErrorDescription({
              args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
              errorFragment: fragment,
              name: fragment.name,
              signature: fragment.format(),
              sighash: this.getSighash(fragment)
            });
          };
          Interface4.isInterface = function(value) {
            return !!(value && value._isInterface);
          };
          return Interface4;
        }()
      );
      exports2.Interface = Interface3;
    }
  });

  // node_modules/@ethersproject/abi/lib/index.js
  var require_lib13 = __commonJS({
    "node_modules/@ethersproject/abi/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TransactionDescription = exports2.LogDescription = exports2.checkResultErrors = exports2.Indexed = exports2.Interface = exports2.defaultAbiCoder = exports2.AbiCoder = exports2.FormatTypes = exports2.ParamType = exports2.FunctionFragment = exports2.Fragment = exports2.EventFragment = exports2.ErrorFragment = exports2.ConstructorFragment = void 0;
      var fragments_1 = require_fragments();
      Object.defineProperty(exports2, "ConstructorFragment", { enumerable: true, get: function() {
        return fragments_1.ConstructorFragment;
      } });
      Object.defineProperty(exports2, "ErrorFragment", { enumerable: true, get: function() {
        return fragments_1.ErrorFragment;
      } });
      Object.defineProperty(exports2, "EventFragment", { enumerable: true, get: function() {
        return fragments_1.EventFragment;
      } });
      Object.defineProperty(exports2, "FormatTypes", { enumerable: true, get: function() {
        return fragments_1.FormatTypes;
      } });
      Object.defineProperty(exports2, "Fragment", { enumerable: true, get: function() {
        return fragments_1.Fragment;
      } });
      Object.defineProperty(exports2, "FunctionFragment", { enumerable: true, get: function() {
        return fragments_1.FunctionFragment;
      } });
      Object.defineProperty(exports2, "ParamType", { enumerable: true, get: function() {
        return fragments_1.ParamType;
      } });
      var abi_coder_1 = require_abi_coder();
      Object.defineProperty(exports2, "AbiCoder", { enumerable: true, get: function() {
        return abi_coder_1.AbiCoder;
      } });
      Object.defineProperty(exports2, "defaultAbiCoder", { enumerable: true, get: function() {
        return abi_coder_1.defaultAbiCoder;
      } });
      var interface_1 = require_interface();
      Object.defineProperty(exports2, "checkResultErrors", { enumerable: true, get: function() {
        return interface_1.checkResultErrors;
      } });
      Object.defineProperty(exports2, "Indexed", { enumerable: true, get: function() {
        return interface_1.Indexed;
      } });
      Object.defineProperty(exports2, "Interface", { enumerable: true, get: function() {
        return interface_1.Interface;
      } });
      Object.defineProperty(exports2, "LogDescription", { enumerable: true, get: function() {
        return interface_1.LogDescription;
      } });
      Object.defineProperty(exports2, "TransactionDescription", { enumerable: true, get: function() {
        return interface_1.TransactionDescription;
      } });
    }
  });

  // node_modules/@ethersproject/abstract-provider/lib/_version.js
  var require_version10 = __commonJS({
    "node_modules/@ethersproject/abstract-provider/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "abstract-provider/5.7.0";
    }
  });

  // node_modules/@ethersproject/abstract-provider/lib/index.js
  var require_lib14 = __commonJS({
    "node_modules/@ethersproject/abstract-provider/lib/index.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      var __awaiter10 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n4) {
          return function(v7) {
            return step([n4, v7]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t3[1]) {
                    _18.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _18.label < t3[2]) {
                    _18.label = t3[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e) {
              op = [6, e];
              y4 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Provider = exports2.TransactionOrderForkEvent = exports2.TransactionForkEvent = exports2.BlockForkEvent = exports2.ForkEvent = void 0;
      var bignumber_1 = require_lib3();
      var bytes_1 = require_lib2();
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version10();
      var logger19 = new logger_1.Logger(_version_1.version);
      var ForkEvent2 = (
        /** @class */
        function(_super) {
          __extends2(ForkEvent3, _super);
          function ForkEvent3() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          ForkEvent3.isForkEvent = function(value) {
            return !!(value && value._isForkEvent);
          };
          return ForkEvent3;
        }(properties_1.Description)
      );
      exports2.ForkEvent = ForkEvent2;
      var BlockForkEvent = (
        /** @class */
        function(_super) {
          __extends2(BlockForkEvent2, _super);
          function BlockForkEvent2(blockHash, expiry) {
            var _this = this;
            if (!(0, bytes_1.isHexString)(blockHash, 32)) {
              logger19.throwArgumentError("invalid blockHash", "blockHash", blockHash);
            }
            _this = _super.call(this, {
              _isForkEvent: true,
              _isBlockForkEvent: true,
              expiry: expiry || 0,
              blockHash
            }) || this;
            return _this;
          }
          return BlockForkEvent2;
        }(ForkEvent2)
      );
      exports2.BlockForkEvent = BlockForkEvent;
      var TransactionForkEvent = (
        /** @class */
        function(_super) {
          __extends2(TransactionForkEvent2, _super);
          function TransactionForkEvent2(hash3, expiry) {
            var _this = this;
            if (!(0, bytes_1.isHexString)(hash3, 32)) {
              logger19.throwArgumentError("invalid transaction hash", "hash", hash3);
            }
            _this = _super.call(this, {
              _isForkEvent: true,
              _isTransactionForkEvent: true,
              expiry: expiry || 0,
              hash: hash3
            }) || this;
            return _this;
          }
          return TransactionForkEvent2;
        }(ForkEvent2)
      );
      exports2.TransactionForkEvent = TransactionForkEvent;
      var TransactionOrderForkEvent = (
        /** @class */
        function(_super) {
          __extends2(TransactionOrderForkEvent2, _super);
          function TransactionOrderForkEvent2(beforeHash, afterHash, expiry) {
            var _this = this;
            if (!(0, bytes_1.isHexString)(beforeHash, 32)) {
              logger19.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
            }
            if (!(0, bytes_1.isHexString)(afterHash, 32)) {
              logger19.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
            }
            _this = _super.call(this, {
              _isForkEvent: true,
              _isTransactionOrderForkEvent: true,
              expiry: expiry || 0,
              beforeHash,
              afterHash
            }) || this;
            return _this;
          }
          return TransactionOrderForkEvent2;
        }(ForkEvent2)
      );
      exports2.TransactionOrderForkEvent = TransactionOrderForkEvent;
      var Provider5 = (
        /** @class */
        function() {
          function Provider6() {
            var _newTarget = this.constructor;
            logger19.checkAbstract(_newTarget, Provider6);
            (0, properties_1.defineReadOnly)(this, "_isProvider", true);
          }
          Provider6.prototype.getFeeData = function() {
            return __awaiter10(this, void 0, void 0, function() {
              var _a, block, gasPrice, lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas;
              return __generator2(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    return [4, (0, properties_1.resolveProperties)({
                      block: this.getBlock("latest"),
                      gasPrice: this.getGasPrice().catch(function(error) {
                        return null;
                      })
                    })];
                  case 1:
                    _a = _b.sent(), block = _a.block, gasPrice = _a.gasPrice;
                    lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
                    if (block && block.baseFeePerGas) {
                      lastBaseFeePerGas = block.baseFeePerGas;
                      maxPriorityFeePerGas = bignumber_1.BigNumber.from("1500000000");
                      maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
                    }
                    return [2, { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice }];
                }
              });
            });
          };
          Provider6.prototype.addListener = function(eventName, listener) {
            return this.on(eventName, listener);
          };
          Provider6.prototype.removeListener = function(eventName, listener) {
            return this.off(eventName, listener);
          };
          Provider6.isProvider = function(value) {
            return !!(value && value._isProvider);
          };
          return Provider6;
        }()
      );
      exports2.Provider = Provider5;
    }
  });

  // node_modules/@ethersproject/abstract-signer/lib/_version.js
  var require_version11 = __commonJS({
    "node_modules/@ethersproject/abstract-signer/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "abstract-signer/5.7.0";
    }
  });

  // node_modules/@ethersproject/abstract-signer/lib/index.js
  var require_lib15 = __commonJS({
    "node_modules/@ethersproject/abstract-signer/lib/index.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      var __awaiter10 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n4) {
          return function(v7) {
            return step([n4, v7]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t3[1]) {
                    _18.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _18.label < t3[2]) {
                    _18.label = t3[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e) {
              op = [6, e];
              y4 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.VoidSigner = exports2.Signer = void 0;
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version11();
      var logger19 = new logger_1.Logger(_version_1.version);
      var allowedTransactionKeys3 = [
        "accessList",
        "ccipReadEnabled",
        "chainId",
        "customData",
        "data",
        "from",
        "gasLimit",
        "gasPrice",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "to",
        "type",
        "value"
      ];
      var forwardErrors = [
        logger_1.Logger.errors.INSUFFICIENT_FUNDS,
        logger_1.Logger.errors.NONCE_EXPIRED,
        logger_1.Logger.errors.REPLACEMENT_UNDERPRICED
      ];
      var Signer7 = (
        /** @class */
        function() {
          function Signer8() {
            var _newTarget = this.constructor;
            logger19.checkAbstract(_newTarget, Signer8);
            (0, properties_1.defineReadOnly)(this, "_isSigner", true);
          }
          Signer8.prototype.getBalance = function(blockTag) {
            return __awaiter10(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("getBalance");
                    return [4, this.provider.getBalance(this.getAddress(), blockTag)];
                  case 1:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype.getTransactionCount = function(blockTag) {
            return __awaiter10(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("getTransactionCount");
                    return [4, this.provider.getTransactionCount(this.getAddress(), blockTag)];
                  case 1:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype.estimateGas = function(transaction2) {
            return __awaiter10(this, void 0, void 0, function() {
              var tx;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("estimateGas");
                    return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction2))];
                  case 1:
                    tx = _a.sent();
                    return [4, this.provider.estimateGas(tx)];
                  case 2:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype.call = function(transaction2, blockTag) {
            return __awaiter10(this, void 0, void 0, function() {
              var tx;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("call");
                    return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction2))];
                  case 1:
                    tx = _a.sent();
                    return [4, this.provider.call(tx, blockTag)];
                  case 2:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype.sendTransaction = function(transaction2) {
            return __awaiter10(this, void 0, void 0, function() {
              var tx, signedTx;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("sendTransaction");
                    return [4, this.populateTransaction(transaction2)];
                  case 1:
                    tx = _a.sent();
                    return [4, this.signTransaction(tx)];
                  case 2:
                    signedTx = _a.sent();
                    return [4, this.provider.sendTransaction(signedTx)];
                  case 3:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype.getChainId = function() {
            return __awaiter10(this, void 0, void 0, function() {
              var network;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("getChainId");
                    return [4, this.provider.getNetwork()];
                  case 1:
                    network = _a.sent();
                    return [2, network.chainId];
                }
              });
            });
          };
          Signer8.prototype.getGasPrice = function() {
            return __awaiter10(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("getGasPrice");
                    return [4, this.provider.getGasPrice()];
                  case 1:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype.getFeeData = function() {
            return __awaiter10(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("getFeeData");
                    return [4, this.provider.getFeeData()];
                  case 1:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype.resolveName = function(name) {
            return __awaiter10(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this._checkProvider("resolveName");
                    return [4, this.provider.resolveName(name)];
                  case 1:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype.checkTransaction = function(transaction2) {
            for (var key in transaction2) {
              if (allowedTransactionKeys3.indexOf(key) === -1) {
                logger19.throwArgumentError("invalid transaction key: " + key, "transaction", transaction2);
              }
            }
            var tx = (0, properties_1.shallowCopy)(transaction2);
            if (tx.from == null) {
              tx.from = this.getAddress();
            } else {
              tx.from = Promise.all([
                Promise.resolve(tx.from),
                this.getAddress()
              ]).then(function(result) {
                if (result[0].toLowerCase() !== result[1].toLowerCase()) {
                  logger19.throwArgumentError("from address mismatch", "transaction", transaction2);
                }
                return result[0];
              });
            }
            return tx;
          };
          Signer8.prototype.populateTransaction = function(transaction2) {
            return __awaiter10(this, void 0, void 0, function() {
              var tx, hasEip1559, feeData, gasPrice;
              var _this = this;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction2))];
                  case 1:
                    tx = _a.sent();
                    if (tx.to != null) {
                      tx.to = Promise.resolve(tx.to).then(function(to) {
                        return __awaiter10(_this, void 0, void 0, function() {
                          var address;
                          return __generator2(this, function(_a2) {
                            switch (_a2.label) {
                              case 0:
                                if (to == null) {
                                  return [2, null];
                                }
                                return [4, this.resolveName(to)];
                              case 1:
                                address = _a2.sent();
                                if (address == null) {
                                  logger19.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                                }
                                return [2, address];
                            }
                          });
                        });
                      });
                      tx.to.catch(function(error) {
                      });
                    }
                    hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
                    if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                      logger19.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction2);
                    } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                      logger19.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction2);
                    }
                    if (!((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)))
                      return [3, 2];
                    tx.type = 2;
                    return [3, 5];
                  case 2:
                    if (!(tx.type === 0 || tx.type === 1))
                      return [3, 3];
                    if (tx.gasPrice == null) {
                      tx.gasPrice = this.getGasPrice();
                    }
                    return [3, 5];
                  case 3:
                    return [4, this.getFeeData()];
                  case 4:
                    feeData = _a.sent();
                    if (tx.type == null) {
                      if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                        tx.type = 2;
                        if (tx.gasPrice != null) {
                          gasPrice = tx.gasPrice;
                          delete tx.gasPrice;
                          tx.maxFeePerGas = gasPrice;
                          tx.maxPriorityFeePerGas = gasPrice;
                        } else {
                          if (tx.maxFeePerGas == null) {
                            tx.maxFeePerGas = feeData.maxFeePerGas;
                          }
                          if (tx.maxPriorityFeePerGas == null) {
                            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                          }
                        }
                      } else if (feeData.gasPrice != null) {
                        if (hasEip1559) {
                          logger19.throwError("network does not support EIP-1559", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                            operation: "populateTransaction"
                          });
                        }
                        if (tx.gasPrice == null) {
                          tx.gasPrice = feeData.gasPrice;
                        }
                        tx.type = 0;
                      } else {
                        logger19.throwError("failed to get consistent fee data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                          operation: "signer.getFeeData"
                        });
                      }
                    } else if (tx.type === 2) {
                      if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                      }
                      if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                      }
                    }
                    _a.label = 5;
                  case 5:
                    if (tx.nonce == null) {
                      tx.nonce = this.getTransactionCount("pending");
                    }
                    if (tx.gasLimit == null) {
                      tx.gasLimit = this.estimateGas(tx).catch(function(error) {
                        if (forwardErrors.indexOf(error.code) >= 0) {
                          throw error;
                        }
                        return logger19.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                          error,
                          tx
                        });
                      });
                    }
                    if (tx.chainId == null) {
                      tx.chainId = this.getChainId();
                    } else {
                      tx.chainId = Promise.all([
                        Promise.resolve(tx.chainId),
                        this.getChainId()
                      ]).then(function(results) {
                        if (results[1] !== 0 && results[0] !== results[1]) {
                          logger19.throwArgumentError("chainId address mismatch", "transaction", transaction2);
                        }
                        return results[0];
                      });
                    }
                    return [4, (0, properties_1.resolveProperties)(tx)];
                  case 6:
                    return [2, _a.sent()];
                }
              });
            });
          };
          Signer8.prototype._checkProvider = function(operation) {
            if (!this.provider) {
              logger19.throwError("missing provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: operation || "_checkProvider"
              });
            }
          };
          Signer8.isSigner = function(value) {
            return !!(value && value._isSigner);
          };
          return Signer8;
        }()
      );
      exports2.Signer = Signer7;
      var VoidSigner3 = (
        /** @class */
        function(_super) {
          __extends2(VoidSigner4, _super);
          function VoidSigner4(address, provider) {
            var _this = _super.call(this) || this;
            (0, properties_1.defineReadOnly)(_this, "address", address);
            (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
            return _this;
          }
          VoidSigner4.prototype.getAddress = function() {
            return Promise.resolve(this.address);
          };
          VoidSigner4.prototype._fail = function(message, operation) {
            return Promise.resolve().then(function() {
              logger19.throwError(message, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation });
            });
          };
          VoidSigner4.prototype.signMessage = function(message) {
            return this._fail("VoidSigner cannot sign messages", "signMessage");
          };
          VoidSigner4.prototype.signTransaction = function(transaction2) {
            return this._fail("VoidSigner cannot sign transactions", "signTransaction");
          };
          VoidSigner4.prototype._signTypedData = function(domain, types, value) {
            return this._fail("VoidSigner cannot sign typed data", "signTypedData");
          };
          VoidSigner4.prototype.connect = function(provider) {
            return new VoidSigner4(this.address, provider);
          };
          return VoidSigner4;
        }(Signer7)
      );
      exports2.VoidSigner = VoidSigner3;
    }
  });

  // node_modules/elliptic/package.json
  var require_package = __commonJS({
    "node_modules/elliptic/package.json"(exports2, module2) {
      module2.exports = {
        name: "elliptic",
        version: "6.5.4",
        description: "EC cryptography",
        main: "lib/elliptic.js",
        files: [
          "lib"
        ],
        scripts: {
          lint: "eslint lib test",
          "lint:fix": "npm run lint -- --fix",
          unit: "istanbul test _mocha --reporter=spec test/index.js",
          test: "npm run lint && npm run unit",
          version: "grunt dist && git add dist/"
        },
        repository: {
          type: "git",
          url: "git@github.com:indutny/elliptic"
        },
        keywords: [
          "EC",
          "Elliptic",
          "curve",
          "Cryptography"
        ],
        author: "Fedor Indutny <fedor@indutny.com>",
        license: "MIT",
        bugs: {
          url: "https://github.com/indutny/elliptic/issues"
        },
        homepage: "https://github.com/indutny/elliptic",
        devDependencies: {
          brfs: "^2.0.2",
          coveralls: "^3.1.0",
          eslint: "^7.6.0",
          grunt: "^1.2.1",
          "grunt-browserify": "^5.3.0",
          "grunt-cli": "^1.3.2",
          "grunt-contrib-connect": "^3.0.0",
          "grunt-contrib-copy": "^1.0.0",
          "grunt-contrib-uglify": "^5.0.0",
          "grunt-mocha-istanbul": "^5.0.2",
          "grunt-saucelabs": "^9.0.1",
          istanbul: "^0.4.5",
          mocha: "^8.0.1"
        },
        dependencies: {
          "bn.js": "^4.11.9",
          brorand: "^1.1.0",
          "hash.js": "^1.0.0",
          "hmac-drbg": "^1.0.1",
          inherits: "^2.0.4",
          "minimalistic-assert": "^1.0.1",
          "minimalistic-crypto-utils": "^1.0.1"
        }
      };
    }
  });

  // node_modules/elliptic/node_modules/bn.js/lib/bn.js
  var require_bn2 = __commonJS({
    "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports2, module2) {
      (function(module3, exports3) {
        "use strict";
        function assert2(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number2, base, endian) {
          if (BN.isBN(number2)) {
            return number2;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number2 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number2 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = __require("buffer").Buffer;
          }
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number2, base, endian) {
          if (typeof number2 === "number") {
            return this._initNumber(number2, base, endian);
          }
          if (typeof number2 === "object") {
            return this._initArray(number2, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert2(base === (base | 0) && base >= 2 && base <= 36);
          number2 = number2.toString().replace(/\s+/g, "");
          var start = 0;
          if (number2[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number2.length) {
            if (base === 16) {
              this._parseHex(number2, start, endian);
            } else {
              this._parseBase(number2, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN.prototype._initNumber = function _initNumber(number2, base, endian) {
          if (number2 < 0) {
            this.negative = 1;
            number2 = -number2;
          }
          if (number2 < 67108864) {
            this.words = [number2 & 67108863];
            this.length = 1;
          } else if (number2 < 4503599627370496) {
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert2(number2 < 9007199254740992);
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number2, base, endian) {
          assert2(typeof number2.length === "number");
          if (number2.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number2.length / 3);
          this.words = new Array(this.length);
          for (var i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = 0;
          }
          var j3, w3;
          var off = 0;
          if (endian === "be") {
            for (i4 = number2.length - 1, j3 = 0; i4 >= 0; i4 -= 3) {
              w3 = number2[i4] | number2[i4 - 1] << 8 | number2[i4 - 2] << 16;
              this.words[j3] |= w3 << off & 67108863;
              this.words[j3 + 1] = w3 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          } else if (endian === "le") {
            for (i4 = 0, j3 = 0; i4 < number2.length; i4 += 3) {
              w3 = number2[i4] | number2[i4 + 1] << 8 | number2[i4 + 2] << 16;
              this.words[j3] |= w3 << off & 67108863;
              this.words[j3 + 1] = w3 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string, index2) {
          var c3 = string.charCodeAt(index2);
          if (c3 >= 65 && c3 <= 70) {
            return c3 - 55;
          } else if (c3 >= 97 && c3 <= 102) {
            return c3 - 87;
          } else {
            return c3 - 48 & 15;
          }
        }
        function parseHexByte(string, lowerBound, index2) {
          var r2 = parseHex4Bits(string, index2);
          if (index2 - 1 >= lowerBound) {
            r2 |= parseHex4Bits(string, index2 - 1) << 4;
          }
          return r2;
        }
        BN.prototype._parseHex = function _parseHex(number2, start, endian) {
          this.length = Math.ceil((number2.length - start) / 6);
          this.words = new Array(this.length);
          for (var i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = 0;
          }
          var off = 0;
          var j3 = 0;
          var w3;
          if (endian === "be") {
            for (i4 = number2.length - 1; i4 >= start; i4 -= 2) {
              w3 = parseHexByte(number2, start, i4) << off;
              this.words[j3] |= w3 & 67108863;
              if (off >= 18) {
                off -= 18;
                j3 += 1;
                this.words[j3] |= w3 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number2.length - start;
            for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number2.length; i4 += 2) {
              w3 = parseHexByte(number2, start, i4) << off;
              this.words[j3] |= w3 & 67108863;
              if (off >= 18) {
                off -= 18;
                j3 += 1;
                this.words[j3] |= w3 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r2 = 0;
          var len = Math.min(str.length, end);
          for (var i4 = start; i4 < len; i4++) {
            var c3 = str.charCodeAt(i4) - 48;
            r2 *= mul;
            if (c3 >= 49) {
              r2 += c3 - 49 + 10;
            } else if (c3 >= 17) {
              r2 += c3 - 17 + 10;
            } else {
              r2 += c3;
            }
          }
          return r2;
        }
        BN.prototype._parseBase = function _parseBase(number2, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number2.length - start;
          var mod3 = total % limbLen;
          var end = Math.min(total, total - mod3) + start;
          var word = 0;
          for (var i4 = start; i4 < end; i4 += limbLen) {
            word = parseBase(number2, i4, i4 + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod3 !== 0) {
            var pow3 = 1;
            word = parseBase(number2, i4, number2.length, base);
            for (i4 = 0; i4 < mod3; i4++) {
              pow3 *= base;
            }
            this.imuln(pow3);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i4 = 0; i4 < this.length; i4++) {
            dest.words[i4] = this.words[i4];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone() {
          var r2 = new BN(null);
          this.copy(r2);
          return r2;
        };
        BN.prototype._expand = function _expand(size3) {
          while (this.length < size3) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN.prototype.toString = function toString3(base, padding2) {
          base = base || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i4 = 0; i4 < this.length; i4++) {
              var w3 = this.words[i4];
              var word = ((w3 << off | carry) & 16777215).toString(16);
              carry = w3 >>> 24 - off & 16777215;
              if (carry !== 0 || i4 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i4--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c3 = this.clone();
            c3.negative = 0;
            while (!c3.isZero()) {
              var r2 = c3.modn(groupBase).toString(base);
              c3 = c3.idivn(groupBase);
              if (!c3.isZero()) {
                out = zeros[groupSize - r2.length] + r2 + out;
              } else {
                out = r2 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert2(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber2() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert2(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON2() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert2(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert2(byteLength <= reqLength, "byte array longer than desired length");
          assert2(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b4, i4;
          var q4 = this.clone();
          if (!littleEndian) {
            for (i4 = 0; i4 < reqLength - byteLength; i4++) {
              res[i4] = 0;
            }
            for (i4 = 0; !q4.isZero(); i4++) {
              b4 = q4.andln(255);
              q4.iushrn(8);
              res[reqLength - i4 - 1] = b4;
            }
          } else {
            for (i4 = 0; !q4.isZero(); i4++) {
              b4 = q4.andln(255);
              q4.iushrn(8);
              res[i4] = b4;
            }
            for (; i4 < reqLength; i4++) {
              res[i4] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w3) {
            return 32 - Math.clz32(w3);
          };
        } else {
          BN.prototype._countBits = function _countBits(w3) {
            var t3 = w3;
            var r2 = 0;
            if (t3 >= 4096) {
              r2 += 13;
              t3 >>>= 13;
            }
            if (t3 >= 64) {
              r2 += 7;
              t3 >>>= 7;
            }
            if (t3 >= 8) {
              r2 += 4;
              t3 >>>= 4;
            }
            if (t3 >= 2) {
              r2 += 2;
              t3 >>>= 2;
            }
            return r2 + t3;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w3) {
          if (w3 === 0)
            return 26;
          var t3 = w3;
          var r2 = 0;
          if ((t3 & 8191) === 0) {
            r2 += 13;
            t3 >>>= 13;
          }
          if ((t3 & 127) === 0) {
            r2 += 7;
            t3 >>>= 7;
          }
          if ((t3 & 15) === 0) {
            r2 += 4;
            t3 >>>= 4;
          }
          if ((t3 & 3) === 0) {
            r2 += 2;
            t3 >>>= 2;
          }
          if ((t3 & 1) === 0) {
            r2++;
          }
          return r2;
        };
        BN.prototype.bitLength = function bitLength() {
          var w3 = this.words[this.length - 1];
          var hi = this._countBits(w3);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w3 = new Array(num.bitLength());
          for (var bit = 0; bit < w3.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w3[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w3;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r2 = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var b4 = this._zeroBits(this.words[i4]);
            r2 += b4;
            if (b4 !== 26)
              break;
          }
          return r2;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i4 = 0; i4 < num.length; i4++) {
            this.words[i4] = this.words[i4] | num.words[i4];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or2(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b4;
          if (this.length > num.length) {
            b4 = num;
          } else {
            b4 = this;
          }
          for (var i4 = 0; i4 < b4.length; i4++) {
            this.words[i4] = this.words[i4] & num.words[i4];
          }
          this.length = b4.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and2(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a2;
          var b4;
          if (this.length > num.length) {
            a2 = this;
            b4 = num;
          } else {
            a2 = num;
            b4 = this;
          }
          for (var i4 = 0; i4 < b4.length; i4++) {
            this.words[i4] = a2.words[i4] ^ b4.words[i4];
          }
          if (this !== a2) {
            for (; i4 < a2.length; i4++) {
              this.words[i4] = a2.words[i4];
            }
          }
          this.length = a2.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width) {
          assert2(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i4 = 0; i4 < bytesNeeded; i4++) {
            this.words[i4] = ~this.words[i4] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert2(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r2;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r2 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r2 = this.isub(num);
            num.negative = 1;
            return r2._normSign();
          }
          var a2, b4;
          if (this.length > num.length) {
            a2 = this;
            b4 = num;
          } else {
            a2 = num;
            b4 = this;
          }
          var carry = 0;
          for (var i4 = 0; i4 < b4.length; i4++) {
            r2 = (a2.words[i4] | 0) + (b4.words[i4] | 0) + carry;
            this.words[i4] = r2 & 67108863;
            carry = r2 >>> 26;
          }
          for (; carry !== 0 && i4 < a2.length; i4++) {
            r2 = (a2.words[i4] | 0) + carry;
            this.words[i4] = r2 & 67108863;
            carry = r2 >>> 26;
          }
          this.length = a2.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a2 !== this) {
            for (; i4 < a2.length; i4++) {
              this.words[i4] = a2.words[i4];
            }
          }
          return this;
        };
        BN.prototype.add = function add3(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r2 = this.iadd(num);
            num.negative = 1;
            return r2._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a2, b4;
          if (cmp > 0) {
            a2 = this;
            b4 = num;
          } else {
            a2 = num;
            b4 = this;
          }
          var carry = 0;
          for (var i4 = 0; i4 < b4.length; i4++) {
            r2 = (a2.words[i4] | 0) - (b4.words[i4] | 0) + carry;
            carry = r2 >> 26;
            this.words[i4] = r2 & 67108863;
          }
          for (; carry !== 0 && i4 < a2.length; i4++) {
            r2 = (a2.words[i4] | 0) + carry;
            carry = r2 >> 26;
            this.words[i4] = r2 & 67108863;
          }
          if (carry === 0 && i4 < a2.length && a2 !== this) {
            for (; i4 < a2.length; i4++) {
              this.words[i4] = a2.words[i4];
            }
          }
          this.length = Math.max(this.length, i4);
          if (a2 !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a2 = self2.words[0] | 0;
          var b4 = num.words[0] | 0;
          var r2 = a2 * b4;
          var lo = r2 & 67108863;
          var carry = r2 / 67108864 | 0;
          out.words[0] = lo;
          for (var k3 = 1; k3 < len; k3++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i4 = k3 - j3 | 0;
              a2 = self2.words[i4] | 0;
              b4 = num.words[j3] | 0;
              r2 = a2 * b4 + rword;
              ncarry += r2 / 67108864 | 0;
              rword = r2 & 67108863;
            }
            out.words[k3] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k3] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a2 = self2.words;
          var b4 = num.words;
          var o3 = out.words;
          var c3 = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a2[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a2[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a22 = a2[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a3 = a2[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a2[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a2[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a2[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a2[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a2[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a2[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b4[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b4[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b22 = b4[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b4[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b4[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b5 = b4[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b4[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b4[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b4[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b4[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
          c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o3[0] = w0;
          o3[1] = w1;
          o3[2] = w22;
          o3[3] = w3;
          o3[4] = w4;
          o3[5] = w5;
          o3[6] = w6;
          o3[7] = w7;
          o3[8] = w8;
          o3[9] = w9;
          o3[10] = w10;
          o3[11] = w11;
          o3[12] = w12;
          o3[13] = w13;
          o3[14] = w14;
          o3[15] = w15;
          o3[16] = w16;
          o3[17] = w17;
          o3[18] = w18;
          if (c3 !== 0) {
            o3[19] = c3;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k3 = 0; k3 < out.length - 1; k3++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i4 = k3 - j3;
              var a2 = self2.words[i4] | 0;
              var b4 = num.words[j3] | 0;
              var r2 = a2 * b4;
              var lo = r2 & 67108863;
              ncarry = ncarry + (r2 / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k3] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k3] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x8, y4) {
          this.x = x8;
          this.y = y4;
        }
        FFTM.prototype.makeRBT = function makeRBT(N2) {
          var t3 = new Array(N2);
          var l4 = BN.prototype._countBits(N2) - 1;
          for (var i4 = 0; i4 < N2; i4++) {
            t3[i4] = this.revBin(i4, l4, N2);
          }
          return t3;
        };
        FFTM.prototype.revBin = function revBin(x8, l4, N2) {
          if (x8 === 0 || x8 === N2 - 1)
            return x8;
          var rb = 0;
          for (var i4 = 0; i4 < l4; i4++) {
            rb |= (x8 & 1) << l4 - i4 - 1;
            x8 >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
          for (var i4 = 0; i4 < N2; i4++) {
            rtws[i4] = rws[rbt[i4]];
            itws[i4] = iws[rbt[i4]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N2);
          for (var s4 = 1; s4 < N2; s4 <<= 1) {
            var l4 = s4 << 1;
            var rtwdf = Math.cos(2 * Math.PI / l4);
            var itwdf = Math.sin(2 * Math.PI / l4);
            for (var p2 = 0; p2 < N2; p2 += l4) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j3 = 0; j3 < s4; j3++) {
                var re4 = rtws[p2 + j3];
                var ie3 = itws[p2 + j3];
                var ro = rtws[p2 + j3 + s4];
                var io = itws[p2 + j3 + s4];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p2 + j3] = re4 + ro;
                itws[p2 + j3] = ie3 + io;
                rtws[p2 + j3 + s4] = re4 - ro;
                itws[p2 + j3 + s4] = ie3 - io;
                if (j3 !== l4) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n4, m5) {
          var N2 = Math.max(m5, n4) | 1;
          var odd = N2 & 1;
          var i4 = 0;
          for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
            i4++;
          }
          return 1 << i4 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
          if (N2 <= 1)
            return;
          for (var i4 = 0; i4 < N2 / 2; i4++) {
            var t3 = rws[i4];
            rws[i4] = rws[N2 - i4 - 1];
            rws[N2 - i4 - 1] = t3;
            t3 = iws[i4];
            iws[i4] = -iws[N2 - i4 - 1];
            iws[N2 - i4 - 1] = -t3;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws2, N2) {
          var carry = 0;
          for (var i4 = 0; i4 < N2 / 2; i4++) {
            var w3 = Math.round(ws2[2 * i4 + 1] / N2) * 8192 + Math.round(ws2[2 * i4] / N2) + carry;
            ws2[i4] = w3 & 67108863;
            if (w3 < 67108864) {
              carry = 0;
            } else {
              carry = w3 / 67108864 | 0;
            }
          }
          return ws2;
        };
        FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N2) {
          var carry = 0;
          for (var i4 = 0; i4 < len; i4++) {
            carry = carry + (ws2[i4] | 0);
            rws[2 * i4] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i4 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i4 = 2 * len; i4 < N2; ++i4) {
            rws[i4] = 0;
          }
          assert2(carry === 0);
          assert2((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N2) {
          var ph = new Array(N2);
          for (var i4 = 0; i4 < N2; i4++) {
            ph[i4] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x8, y4, out) {
          var N2 = 2 * this.guessLen13b(x8.length, y4.length);
          var rbt = this.makeRBT(N2);
          var _18 = this.stub(N2);
          var rws = new Array(N2);
          var rwst = new Array(N2);
          var iwst = new Array(N2);
          var nrws = new Array(N2);
          var nrwst = new Array(N2);
          var niwst = new Array(N2);
          var rmws = out.words;
          rmws.length = N2;
          this.convert13b(x8.words, x8.length, rws, N2);
          this.convert13b(y4.words, y4.length, nrws, N2);
          this.transform(rws, _18, rwst, iwst, N2, rbt);
          this.transform(nrws, _18, nrwst, niwst, N2, rbt);
          for (var i4 = 0; i4 < N2; i4++) {
            var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
            iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
            rwst[i4] = rx;
          }
          this.conjugate(rwst, iwst, N2);
          this.transform(rwst, iwst, rmws, _18, N2, rbt);
          this.conjugate(rmws, _18, N2);
          this.normalize13b(rmws, N2);
          out.negative = x8.negative ^ y4.negative;
          out.length = x8.length + y4.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w3 = (this.words[i4] | 0) * num;
            var lo = (w3 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w3 / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i4] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i4] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow3(num) {
          var w3 = toBitArray(num);
          if (w3.length === 0)
            return new BN(1);
          var res = this;
          for (var i4 = 0; i4 < w3.length; i4++, res = res.sqr()) {
            if (w3[i4] !== 0)
              break;
          }
          if (++i4 < w3.length) {
            for (var q4 = res.sqr(); i4 < w3.length; i4++, q4 = q4.sqr()) {
              if (w3[i4] === 0)
                continue;
              res = res.mul(q4);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r2 = bits % 26;
          var s4 = (bits - r2) / 26;
          var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
          var i4;
          if (r2 !== 0) {
            var carry = 0;
            for (i4 = 0; i4 < this.length; i4++) {
              var newCarry = this.words[i4] & carryMask;
              var c3 = (this.words[i4] | 0) - newCarry << r2;
              this.words[i4] = c3 | carry;
              carry = newCarry >>> 26 - r2;
            }
            if (carry) {
              this.words[i4] = carry;
              this.length++;
            }
          }
          if (s4 !== 0) {
            for (i4 = this.length - 1; i4 >= 0; i4--) {
              this.words[i4 + s4] = this.words[i4];
            }
            for (i4 = 0; i4 < s4; i4++) {
              this.words[i4] = 0;
            }
            this.length += s4;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert2(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert2(typeof bits === "number" && bits >= 0);
          var h6;
          if (hint) {
            h6 = (hint - hint % 26) / 26;
          } else {
            h6 = 0;
          }
          var r2 = bits % 26;
          var s4 = Math.min((bits - r2) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          var maskedWords = extended;
          h6 -= s4;
          h6 = Math.max(0, h6);
          if (maskedWords) {
            for (var i4 = 0; i4 < s4; i4++) {
              maskedWords.words[i4] = this.words[i4];
            }
            maskedWords.length = s4;
          }
          if (s4 === 0) {
          } else if (this.length > s4) {
            this.length -= s4;
            for (i4 = 0; i4 < this.length; i4++) {
              this.words[i4] = this.words[i4 + s4];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h6); i4--) {
            var word = this.words[i4] | 0;
            this.words[i4] = carry << 26 - r2 | word >>> r2;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert2(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert2(typeof bit === "number" && bit >= 0);
          var r2 = bit % 26;
          var s4 = (bit - r2) / 26;
          var q4 = 1 << r2;
          if (this.length <= s4)
            return false;
          var w3 = this.words[s4];
          return !!(w3 & q4);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r2 = bits % 26;
          var s4 = (bits - r2) / 26;
          assert2(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s4) {
            return this;
          }
          if (r2 !== 0) {
            s4++;
          }
          this.length = Math.min(s4, this.length);
          if (r2 !== 0) {
            var mask = 67108863 ^ 67108863 >>> r2 << r2;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
            this.words[i4] -= 67108864;
            if (i4 === this.length - 1) {
              this.words[i4 + 1] = 1;
            } else {
              this.words[i4 + 1]++;
            }
          }
          this.length = Math.max(this.length, i4 + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
              this.words[i4] += 67108864;
              this.words[i4 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
          var len = num.length + shift2;
          var i4;
          this._expand(len);
          var w3;
          var carry = 0;
          for (i4 = 0; i4 < num.length; i4++) {
            w3 = (this.words[i4 + shift2] | 0) + carry;
            var right = (num.words[i4] | 0) * mul;
            w3 -= right & 67108863;
            carry = (w3 >> 26) - (right / 67108864 | 0);
            this.words[i4 + shift2] = w3 & 67108863;
          }
          for (; i4 < this.length - shift2; i4++) {
            w3 = (this.words[i4 + shift2] | 0) + carry;
            carry = w3 >> 26;
            this.words[i4 + shift2] = w3 & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert2(carry === -1);
          carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            w3 = -(this.words[i4] | 0) + carry;
            carry = w3 >> 26;
            this.words[i4] = w3 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift2 = this.length - num.length;
          var a2 = this.clone();
          var b4 = num;
          var bhi = b4.words[b4.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift2 = 26 - bhiBits;
          if (shift2 !== 0) {
            b4 = b4.ushln(shift2);
            a2.iushln(shift2);
            bhi = b4.words[b4.length - 1] | 0;
          }
          var m5 = a2.length - b4.length;
          var q4;
          if (mode !== "mod") {
            q4 = new BN(null);
            q4.length = m5 + 1;
            q4.words = new Array(q4.length);
            for (var i4 = 0; i4 < q4.length; i4++) {
              q4.words[i4] = 0;
            }
          }
          var diff = a2.clone()._ishlnsubmul(b4, 1, m5);
          if (diff.negative === 0) {
            a2 = diff;
            if (q4) {
              q4.words[m5] = 1;
            }
          }
          for (var j3 = m5 - 1; j3 >= 0; j3--) {
            var qj = (a2.words[b4.length + j3] | 0) * 67108864 + (a2.words[b4.length + j3 - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a2._ishlnsubmul(b4, qj, j3);
            while (a2.negative !== 0) {
              qj--;
              a2.negative = 0;
              a2._ishlnsubmul(b4, 1, j3);
              if (!a2.isZero()) {
                a2.negative ^= 1;
              }
            }
            if (q4) {
              q4.words[j3] = qj;
            }
          }
          if (q4) {
            q4.strip();
          }
          a2.strip();
          if (mode !== "div" && shift2 !== 0) {
            a2.iushrn(shift2);
          }
          return {
            div: q4 || null,
            mod: a2
          };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert2(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN(0),
              mod: new BN(0)
            };
          }
          var div, mod3, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod3 = res.mod.neg();
              if (positive && mod3.negative !== 0) {
                mod3.iadd(num);
              }
            }
            return {
              div,
              mod: mod3
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod3 = res.mod.neg();
              if (positive && mod3.negative !== 0) {
                mod3.isub(num);
              }
            }
            return {
              div: res.div,
              mod: mod3
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod3(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod3.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert2(num <= 67108863);
          var p2 = (1 << 26) % num;
          var acc = 0;
          for (var i4 = this.length - 1; i4 >= 0; i4--) {
            acc = (p2 * acc + (this.words[i4] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert2(num <= 67108863);
          var carry = 0;
          for (var i4 = this.length - 1; i4 >= 0; i4--) {
            var w3 = (this.words[i4] | 0) + carry * 67108864;
            this.words[i4] = w3 / num | 0;
            carry = w3 % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p2) {
          assert2(p2.negative === 0);
          assert2(!p2.isZero());
          var x8 = this;
          var y4 = p2.clone();
          if (x8.negative !== 0) {
            x8 = x8.umod(p2);
          } else {
            x8 = x8.clone();
          }
          var A3 = new BN(1);
          var B5 = new BN(0);
          var C4 = new BN(0);
          var D4 = new BN(1);
          var g5 = 0;
          while (x8.isEven() && y4.isEven()) {
            x8.iushrn(1);
            y4.iushrn(1);
            ++g5;
          }
          var yp = y4.clone();
          var xp = x8.clone();
          while (!x8.isZero()) {
            for (var i4 = 0, im = 1; (x8.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
              ;
            if (i4 > 0) {
              x8.iushrn(i4);
              while (i4-- > 0) {
                if (A3.isOdd() || B5.isOdd()) {
                  A3.iadd(yp);
                  B5.isub(xp);
                }
                A3.iushrn(1);
                B5.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (y4.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
              ;
            if (j3 > 0) {
              y4.iushrn(j3);
              while (j3-- > 0) {
                if (C4.isOdd() || D4.isOdd()) {
                  C4.iadd(yp);
                  D4.isub(xp);
                }
                C4.iushrn(1);
                D4.iushrn(1);
              }
            }
            if (x8.cmp(y4) >= 0) {
              x8.isub(y4);
              A3.isub(C4);
              B5.isub(D4);
            } else {
              y4.isub(x8);
              C4.isub(A3);
              D4.isub(B5);
            }
          }
          return {
            a: C4,
            b: D4,
            gcd: y4.iushln(g5)
          };
        };
        BN.prototype._invmp = function _invmp(p2) {
          assert2(p2.negative === 0);
          assert2(!p2.isZero());
          var a2 = this;
          var b4 = p2.clone();
          if (a2.negative !== 0) {
            a2 = a2.umod(p2);
          } else {
            a2 = a2.clone();
          }
          var x1 = new BN(1);
          var x22 = new BN(0);
          var delta = b4.clone();
          while (a2.cmpn(1) > 0 && b4.cmpn(1) > 0) {
            for (var i4 = 0, im = 1; (a2.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
              ;
            if (i4 > 0) {
              a2.iushrn(i4);
              while (i4-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (b4.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1)
              ;
            if (j3 > 0) {
              b4.iushrn(j3);
              while (j3-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a2.cmp(b4) >= 0) {
              a2.isub(b4);
              x1.isub(x22);
            } else {
              b4.isub(a2);
              x22.isub(x1);
            }
          }
          var res;
          if (a2.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p2);
          }
          return res;
        };
        BN.prototype.gcd = function gcd2(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a2 = this.clone();
          var b4 = num.clone();
          a2.negative = 0;
          b4.negative = 0;
          for (var shift2 = 0; a2.isEven() && b4.isEven(); shift2++) {
            a2.iushrn(1);
            b4.iushrn(1);
          }
          do {
            while (a2.isEven()) {
              a2.iushrn(1);
            }
            while (b4.isEven()) {
              b4.iushrn(1);
            }
            var r2 = a2.cmp(b4);
            if (r2 < 0) {
              var t3 = a2;
              a2 = b4;
              b4 = t3;
            } else if (r2 === 0 || b4.cmpn(1) === 0) {
              break;
            }
            a2.isub(b4);
          } while (true);
          return b4.iushln(shift2);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven2() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd2() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert2(typeof bit === "number");
          var r2 = bit % 26;
          var s4 = (bit - r2) / 26;
          var q4 = 1 << r2;
          if (this.length <= s4) {
            this._expand(s4 + 1);
            this.words[s4] |= q4;
            return this;
          }
          var carry = q4;
          for (var i4 = s4; carry !== 0 && i4 < this.length; i4++) {
            var w3 = this.words[i4] | 0;
            w3 += carry;
            carry = w3 >>> 26;
            w3 &= 67108863;
            this.words[i4] = w3;
          }
          if (carry !== 0) {
            this.words[i4] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero2() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert2(num <= 67108863, "Number is too big");
            var w3 = this.words[0] | 0;
            res = w3 === num ? 0 : w3 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i4 = this.length - 1; i4 >= 0; i4--) {
            var a2 = this.words[i4] | 0;
            var b4 = num.words[i4] | 0;
            if (a2 === b4)
              continue;
            if (a2 < b4) {
              res = -1;
            } else if (a2 > b4) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt2(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq2(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          assert2(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert2(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert2(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert2(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert2(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert2(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert2(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert2(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert2(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert2(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert2(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert2(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert2(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p2) {
          this.name = name;
          this.p = new BN(p2, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r2 = num;
          var rlen;
          do {
            this.split(r2, this.tmp);
            r2 = this.imulK(r2);
            r2 = r2.iadd(this.tmp);
            rlen = r2.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
          if (cmp === 0) {
            r2.words[0] = 0;
            r2.length = 1;
          } else if (cmp > 0) {
            r2.isub(this.p);
          } else {
            if (r2.strip !== void 0) {
              r2.strip();
            } else {
              r2._strip();
            }
          }
          return r2;
        };
        MPrime.prototype.split = function split2(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split2(input, output2) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i4 = 0; i4 < outLen; i4++) {
            output2.words[i4] = input.words[i4];
          }
          output2.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output2.words[output2.length++] = prev & mask;
          for (i4 = 10; i4 < input.length; i4++) {
            var next = input.words[i4] | 0;
            input.words[i4 - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i4 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i4 = 0; i4 < num.length; i4++) {
            var w3 = num.words[i4] | 0;
            lo += w3 * 977;
            num.words[i4] = lo & 67108863;
            lo = w3 * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i4 = 0; i4 < num.length; i4++) {
            var hi = (num.words[i4] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i4] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m5) {
          if (typeof m5 === "string") {
            var prime = BN._prime(m5);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert2(m5.gtn(1), "modulus must be greater than 1");
            this.m = m5;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a2) {
          assert2(a2.negative === 0, "red works only with positives");
          assert2(a2.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a2, b4) {
          assert2((a2.negative | b4.negative) === 0, "red works only with positives");
          assert2(
            a2.red && a2.red === b4.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a2) {
          if (this.prime)
            return this.prime.ireduce(a2)._forceRed(this);
          return a2.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a2) {
          if (a2.isZero()) {
            return a2.clone();
          }
          return this.m.sub(a2)._forceRed(this);
        };
        Red.prototype.add = function add3(a2, b4) {
          this._verify2(a2, b4);
          var res = a2.add(b4);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a2, b4) {
          this._verify2(a2, b4);
          var res = a2.iadd(b4);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a2, b4) {
          this._verify2(a2, b4);
          var res = a2.sub(b4);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a2, b4) {
          this._verify2(a2, b4);
          var res = a2.isub(b4);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a2, num) {
          this._verify1(a2);
          return this.imod(a2.ushln(num));
        };
        Red.prototype.imul = function imul(a2, b4) {
          this._verify2(a2, b4);
          return this.imod(a2.imul(b4));
        };
        Red.prototype.mul = function mul(a2, b4) {
          this._verify2(a2, b4);
          return this.imod(a2.mul(b4));
        };
        Red.prototype.isqr = function isqr(a2) {
          return this.imul(a2, a2.clone());
        };
        Red.prototype.sqr = function sqr(a2) {
          return this.mul(a2, a2);
        };
        Red.prototype.sqrt = function sqrt(a2) {
          if (a2.isZero())
            return a2.clone();
          var mod3 = this.m.andln(3);
          assert2(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow3 = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a2, pow3);
          }
          var q4 = this.m.subn(1);
          var s4 = 0;
          while (!q4.isZero() && q4.andln(1) === 0) {
            s4++;
            q4.iushrn(1);
          }
          assert2(!q4.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z5 = this.m.bitLength();
          z5 = new BN(2 * z5 * z5).toRed(this);
          while (this.pow(z5, lpow).cmp(nOne) !== 0) {
            z5.redIAdd(nOne);
          }
          var c3 = this.pow(z5, q4);
          var r2 = this.pow(a2, q4.addn(1).iushrn(1));
          var t3 = this.pow(a2, q4);
          var m5 = s4;
          while (t3.cmp(one) !== 0) {
            var tmp = t3;
            for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
              tmp = tmp.redSqr();
            }
            assert2(i4 < m5);
            var b4 = this.pow(c3, new BN(1).iushln(m5 - i4 - 1));
            r2 = r2.redMul(b4);
            c3 = b4.redSqr();
            t3 = t3.redMul(c3);
            m5 = i4;
          }
          return r2;
        };
        Red.prototype.invm = function invm(a2) {
          var inv = a2._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow3(a2, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a2.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a2;
          for (var i4 = 2; i4 < wnd.length; i4++) {
            wnd[i4] = this.mul(wnd[i4 - 1], a2);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i4 = num.length - 1; i4 >= 0; i4--) {
            var word = num.words[i4];
            for (var j3 = start - 1; j3 >= 0; j3--) {
              var bit = word >> j3 & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i4 !== 0 || j3 !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r2 = num.umod(this.m);
          return r2 === num ? r2.clone() : r2;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m5) {
          Red.call(this, m5);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r2 = this.imod(num.mul(this.rinv));
          r2.red = null;
          return r2;
        };
        Mont.prototype.imul = function imul(a2, b4) {
          if (a2.isZero() || b4.isZero()) {
            a2.words[0] = 0;
            a2.length = 1;
            return a2;
          }
          var t3 = a2.imul(b4);
          var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t3.isub(c3).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a2, b4) {
          if (a2.isZero() || b4.isZero())
            return new BN(0)._forceRed(this);
          var t3 = a2.mul(b4);
          var c3 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t3.isub(c3).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a2) {
          var res = this.imod(a2._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, exports2);
    }
  });

  // node_modules/minimalistic-assert/index.js
  var require_minimalistic_assert = __commonJS({
    "node_modules/minimalistic-assert/index.js"(exports2, module2) {
      module2.exports = assert2;
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert2.equal = function assertEqual(l4, r2, msg) {
        if (l4 != r2)
          throw new Error(msg || "Assertion failed: " + l4 + " != " + r2);
      };
    }
  });

  // node_modules/minimalistic-crypto-utils/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
      "use strict";
      var utils = exports2;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i4 = 0; i4 < msg.length; i4++)
            res[i4] = msg[i4] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i4 = 0; i4 < msg.length; i4 += 2)
            res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
        } else {
          for (var i4 = 0; i4 < msg.length; i4++) {
            var c3 = msg.charCodeAt(i4);
            var hi = c3 >> 8;
            var lo = c3 & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i4 = 0; i4 < msg.length; i4++)
          res += zero2(msg[i4].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/utils.js
  var require_utils2 = __commonJS({
    "node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
      "use strict";
      var utils = exports2;
      var BN = require_bn2();
      var minAssert = require_minimalistic_assert();
      var minUtils = require_utils();
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w3, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws2 = 1 << w3 + 1;
        var k3 = num.clone();
        for (var i4 = 0; i4 < naf.length; i4++) {
          var z5;
          var mod3 = k3.andln(ws2 - 1);
          if (k3.isOdd()) {
            if (mod3 > (ws2 >> 1) - 1)
              z5 = (ws2 >> 1) - mod3;
            else
              z5 = mod3;
            k3.isubn(z5);
          } else {
            z5 = 0;
          }
          naf[i4] = z5;
          k3.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k22) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k22 = k22.clone();
        var d1 = 0;
        var d22 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k22.andln(3) + d22 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u22;
          if ((m24 & 1) === 0) {
            u22 = 0;
          } else {
            m8 = k22.andln(7) + d22 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u22 = -m24;
            else
              u22 = m24;
          }
          jsf[1].push(u22);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d22 === u22 + 1)
            d22 = 1 - d22;
          k1.iushrn(1);
          k22.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes2) {
        return typeof bytes2 === "string" ? utils.toArray(bytes2, "hex") : bytes2;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes2) {
        return new BN(bytes2, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    }
  });

  // node_modules/brorand/index.js
  var require_brorand = __commonJS({
    "node_modules/brorand/index.js"(exports2, module2) {
      var r2;
      module2.exports = function rand(len) {
        if (!r2)
          r2 = new Rand(null);
        return r2.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module2.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n4) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n4);
        var res = new Uint8Array(n4);
        for (var i4 = 0; i4 < res.length; i4++)
          res[i4] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n4) {
            var arr = new Uint8Array(n4);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n4) {
            var arr = new Uint8Array(n4);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          crypto3 = __require("crypto");
          if (typeof crypto3.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n4) {
            return crypto3.randomBytes(n4);
          };
        } catch (e) {
        }
      }
      var crypto3;
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/base.js
  var require_base = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
      "use strict";
      var BN = require_bn2();
      var utils = require_utils2();
      var getNAF = utils.getNAF;
      var getJSF = utils.getJSF;
      var assert2 = utils.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module2.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p2, k3) {
        assert2(p2.precomputed);
        var doubles = p2._getDoubles();
        var naf = getNAF(k3, 1, this._bitLength);
        var I4 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I4 /= 3;
        var repr = [];
        var j3;
        var nafW;
        for (j3 = 0; j3 < naf.length; j3 += doubles.step) {
          nafW = 0;
          for (var l4 = j3 + doubles.step - 1; l4 >= j3; l4--)
            nafW = (nafW << 1) + naf[l4];
          repr.push(nafW);
        }
        var a2 = this.jpoint(null, null, null);
        var b4 = this.jpoint(null, null, null);
        for (var i4 = I4; i4 > 0; i4--) {
          for (j3 = 0; j3 < repr.length; j3++) {
            nafW = repr[j3];
            if (nafW === i4)
              b4 = b4.mixedAdd(doubles.points[j3]);
            else if (nafW === -i4)
              b4 = b4.mixedAdd(doubles.points[j3].neg());
          }
          a2 = a2.add(b4);
        }
        return a2.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p2, k3) {
        var w3 = 4;
        var nafPoints = p2._getNAFPoints(w3);
        w3 = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k3, w3, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i4 = naf.length - 1; i4 >= 0; i4--) {
          for (var l4 = 0; i4 >= 0 && naf[i4] === 0; i4--)
            l4++;
          if (i4 >= 0)
            l4++;
          acc = acc.dblp(l4);
          if (i4 < 0)
            break;
          var z5 = naf[i4];
          assert2(z5 !== 0);
          if (p2.type === "affine") {
            if (z5 > 0)
              acc = acc.mixedAdd(wnd[z5 - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z5 - 1 >> 1].neg());
          } else {
            if (z5 > 0)
              acc = acc.add(wnd[z5 - 1 >> 1]);
            else
              acc = acc.add(wnd[-z5 - 1 >> 1].neg());
          }
        }
        return p2.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        var i4;
        var j3;
        var p2;
        for (i4 = 0; i4 < len; i4++) {
          p2 = points[i4];
          var nafPoints = p2._getNAFPoints(defW);
          wndWidth[i4] = nafPoints.wnd;
          wnd[i4] = nafPoints.points;
        }
        for (i4 = len - 1; i4 >= 1; i4 -= 2) {
          var a2 = i4 - 1;
          var b4 = i4;
          if (wndWidth[a2] !== 1 || wndWidth[b4] !== 1) {
            naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
            naf[b4] = getNAF(coeffs[b4], wndWidth[b4], this._bitLength);
            max = Math.max(naf[a2].length, max);
            max = Math.max(naf[b4].length, max);
            continue;
          }
          var comb = [
            points[a2],
            /* 1 */
            null,
            /* 3 */
            null,
            /* 5 */
            points[b4]
            /* 7 */
          ];
          if (points[a2].y.cmp(points[b4].y) === 0) {
            comb[1] = points[a2].add(points[b4]);
            comb[2] = points[a2].toJ().mixedAdd(points[b4].neg());
          } else if (points[a2].y.cmp(points[b4].y.redNeg()) === 0) {
            comb[1] = points[a2].toJ().mixedAdd(points[b4]);
            comb[2] = points[a2].add(points[b4].neg());
          } else {
            comb[1] = points[a2].toJ().mixedAdd(points[b4]);
            comb[2] = points[a2].toJ().mixedAdd(points[b4].neg());
          }
          var index2 = [
            -3,
            /* -1 -1 */
            -1,
            /* -1 0 */
            -5,
            /* -1 1 */
            -7,
            /* 0 -1 */
            0,
            /* 0 0 */
            7,
            /* 0 1 */
            5,
            /* 1 -1 */
            1,
            /* 1 0 */
            3
            /* 1 1 */
          ];
          var jsf = getJSF(coeffs[a2], coeffs[b4]);
          max = Math.max(jsf[0].length, max);
          naf[a2] = new Array(max);
          naf[b4] = new Array(max);
          for (j3 = 0; j3 < max; j3++) {
            var ja = jsf[0][j3] | 0;
            var jb = jsf[1][j3] | 0;
            naf[a2][j3] = index2[(ja + 1) * 3 + (jb + 1)];
            naf[b4][j3] = 0;
            wnd[a2] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i4 = max; i4 >= 0; i4--) {
          var k3 = 0;
          while (i4 >= 0) {
            var zero = true;
            for (j3 = 0; j3 < len; j3++) {
              tmp[j3] = naf[j3][i4] | 0;
              if (tmp[j3] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k3++;
            i4--;
          }
          if (i4 >= 0)
            k3++;
          acc = acc.dblp(k3);
          if (i4 < 0)
            break;
          for (j3 = 0; j3 < len; j3++) {
            var z5 = tmp[j3];
            p2;
            if (z5 === 0)
              continue;
            else if (z5 > 0)
              p2 = wnd[j3][z5 - 1 >> 1];
            else if (z5 < 0)
              p2 = wnd[j3][-z5 - 1 >> 1].neg();
            if (p2.type === "affine")
              acc = acc.mixedAdd(p2);
            else
              acc = acc.add(p2);
          }
        }
        for (i4 = 0; i4 < len; i4++)
          wnd[i4] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq2() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
        bytes2 = utils.toArray(bytes2, enc);
        var len = this.p.byteLength();
        if ((bytes2[0] === 4 || bytes2[0] === 6 || bytes2[0] === 7) && bytes2.length - 1 === 2 * len) {
          if (bytes2[0] === 6)
            assert2(bytes2[bytes2.length - 1] % 2 === 0);
          else if (bytes2[0] === 7)
            assert2(bytes2[bytes2.length - 1] % 2 === 1);
          var res = this.point(
            bytes2.slice(1, 1 + len),
            bytes2.slice(1 + len, 1 + 2 * len)
          );
          return res;
        } else if ((bytes2[0] === 2 || bytes2[0] === 3) && bytes2.length - 1 === len) {
          return this.pointFromX(bytes2.slice(1, 1 + len), bytes2[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x8 = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x8);
        return [4].concat(x8, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = {
          doubles: null,
          naf: null,
          beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k3) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k3.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i4 = 0; i4 < power; i4 += step) {
          for (var j3 = 0; j3 < step; j3++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return {
          step,
          points: doubles
        };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i4 = 1; i4 < max; i4++)
          res[i4] = res[i4 - 1].add(dbl);
        return {
          wnd,
          points: res
        };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k3) {
        var r2 = this;
        for (var i4 = 0; i4 < k3; i4++)
          r2 = r2.dbl();
        return r2;
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports2, module2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/short.js
  var require_short = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
      "use strict";
      var utils = require_utils2();
      var BN = require_bn2();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var assert2 = utils.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits(ShortCurve, Base);
      module2.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return {
              a: new BN(vec.a, 16),
              b: new BN(vec.b, 16)
            };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return {
          beta,
          lambda,
          basis
        };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s4 = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s4).fromRed();
        var l22 = ntinv.redSub(s4).fromRed();
        return [l1, l22];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u3 = lambda;
        var v7 = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x22 = new BN(0);
        var y22 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b22;
        var prevR;
        var i4 = 0;
        var r2;
        var x8;
        while (u3.cmpn(0) !== 0) {
          var q4 = v7.div(u3);
          r2 = v7.sub(q4.mul(u3));
          x8 = x22.sub(q4.mul(x1));
          var y4 = y22.sub(q4.mul(y1));
          if (!a1 && r2.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r2.neg();
            b1 = x8;
          } else if (a1 && ++i4 === 2) {
            break;
          }
          prevR = r2;
          v7 = u3;
          u3 = r2;
          x22 = x1;
          x1 = x8;
          y22 = y1;
          y1 = y4;
        }
        a2 = r2.neg();
        b22 = x8;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b22.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b22 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b22 = b22.neg();
        }
        return [
          { a: a1, b: b1 },
          { a: a2, b: b22 }
        ];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k3) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v22 = basis[1];
        var c1 = v22.b.mul(k3).divRound(this.n);
        var c22 = v1.b.neg().mul(k3).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c22.mul(v22.a);
        var q1 = c1.mul(v1.b);
        var q22 = c22.mul(v22.b);
        var k1 = k3.sub(p1).sub(p2);
        var k22 = q1.add(q22).neg();
        return { k1, k2: k22 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x8, odd) {
        x8 = new BN(x8, 16);
        if (!x8.red)
          x8 = x8.toRed(this.red);
        var y22 = x8.redSqr().redMul(x8).redIAdd(x8.redMul(this.a)).redIAdd(this.b);
        var y4 = y22.redSqrt();
        if (y4.redSqr().redSub(y22).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd2 = y4.fromRed().isOdd();
        if (odd && !isOdd2 || !odd && isOdd2)
          y4 = y4.redNeg();
        return this.point(x8, y4);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x8 = point.x;
        var y4 = point.y;
        var ax = this.a.redMul(x8);
        var rhs = x8.redSqr().redMul(x8).redIAdd(ax).redIAdd(this.b);
        return y4.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i4 = 0; i4 < points.length; i4++) {
          var split2 = this._endoSplit(coeffs[i4]);
          var p2 = points[i4];
          var beta = p2._getBeta();
          if (split2.k1.negative) {
            split2.k1.ineg();
            p2 = p2.neg(true);
          }
          if (split2.k2.negative) {
            split2.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i4 * 2] = p2;
          npoints[i4 * 2 + 1] = beta;
          ncoeffs[i4 * 2] = split2.k1;
          ncoeffs[i4 * 2 + 1] = split2.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
        for (var j3 = 0; j3 < i4 * 2; j3++) {
          npoints[j3] = null;
          ncoeffs[j3] = null;
        }
        return res;
      };
      function Point3(curve, x8, y4, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x8 === null && y4 === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x8, 16);
          this.y = new BN(y4, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits(Point3, Base.BasePoint);
      ShortCurve.prototype.point = function point(x8, y4, isRed) {
        return new Point3(this, x8, y4, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point3.fromJSON(this, obj, red);
      };
      Point3.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function(p2) {
            return curve.point(p2.x.redMul(curve.endo.beta), p2.y);
          };
          pre.beta = beta;
          beta.precomputed = {
            beta: null,
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(endoMul)
            }
          };
        }
        return beta;
      };
      Point3.prototype.toJSON = function toJSON2() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }];
      };
      Point3.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = {
          beta: null,
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [res].concat(pre.doubles.points.map(obj2point))
          },
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [res].concat(pre.naf.points.map(obj2point))
          }
        };
        return res;
      };
      Point3.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point3.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point3.prototype.add = function add3(p2) {
        if (this.inf)
          return p2;
        if (p2.inf)
          return this;
        if (this.eq(p2))
          return this.dbl();
        if (this.neg().eq(p2))
          return this.curve.point(null, null);
        if (this.x.cmp(p2.x) === 0)
          return this.curve.point(null, null);
        var c3 = this.y.redSub(p2.y);
        if (c3.cmpn(0) !== 0)
          c3 = c3.redMul(this.x.redSub(p2.x).redInvm());
        var nx = c3.redSqr().redISub(this.x).redISub(p2.x);
        var ny = c3.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point3.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a2 = this.curve.a;
        var x22 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c3 = x22.redAdd(x22).redIAdd(x22).redIAdd(a2).redMul(dyinv);
        var nx = c3.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c3.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point3.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point3.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point3.prototype.mul = function mul(k3) {
        k3 = new BN(k3, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k3))
          return this.curve._fixedNafMul(this, k3);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k3]);
        else
          return this.curve._wnafMul(this, k3);
      };
      Point3.prototype.mulAdd = function mulAdd(k1, p2, k22) {
        var points = [this, p2];
        var coeffs = [k1, k22];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point3.prototype.jmulAdd = function jmulAdd(k1, p2, k22) {
        var points = [this, p2];
        var coeffs = [k1, k22];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point3.prototype.eq = function eq2(p2) {
        return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
      };
      Point3.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate2 = function(p2) {
            return p2.neg();
          };
          res.precomputed = {
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(negate2)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(negate2)
            }
          };
        }
        return res;
      };
      Point3.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x8, y4, z5) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x8 === null && y4 === null && z5 === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x8, 16);
          this.y = new BN(y4, 16);
          this.z = new BN(z5, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x8, y4, z5) {
        return new JPoint(this, x8, y4, z5);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add3(p2) {
        if (this.isInfinity())
          return p2;
        if (p2.isInfinity())
          return this;
        var pz2 = p2.z.redSqr();
        var z22 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u22 = p2.x.redMul(z22);
        var s1 = this.y.redMul(pz2.redMul(p2.z));
        var s22 = p2.y.redMul(z22.redMul(this.z));
        var h6 = u1.redSub(u22);
        var r2 = s1.redSub(s22);
        if (h6.cmpn(0) === 0) {
          if (r2.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h22 = h6.redSqr();
        var h32 = h22.redMul(h6);
        var v7 = u1.redMul(h22);
        var nx = r2.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
        var ny = r2.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
        var nz = this.z.redMul(p2.z).redMul(h6);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p2) {
        if (this.isInfinity())
          return p2.toJ();
        if (p2.isInfinity())
          return this;
        var z22 = this.z.redSqr();
        var u1 = this.x;
        var u22 = p2.x.redMul(z22);
        var s1 = this.y;
        var s22 = p2.y.redMul(z22).redMul(this.z);
        var h6 = u1.redSub(u22);
        var r2 = s1.redSub(s22);
        if (h6.cmpn(0) === 0) {
          if (r2.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h22 = h6.redSqr();
        var h32 = h22.redMul(h6);
        var v7 = u1.redMul(h22);
        var nx = r2.redSqr().redIAdd(h32).redISub(v7).redISub(v7);
        var ny = r2.redMul(v7.redISub(nx)).redISub(s1.redMul(h32));
        var nz = this.z.redMul(h6);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow3) {
        if (pow3 === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow3)
          return this.dbl();
        var i4;
        if (this.curve.zeroA || this.curve.threeA) {
          var r2 = this;
          for (i4 = 0; i4 < pow3; i4++)
            r2 = r2.dbl();
          return r2;
        }
        var a2 = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i4 = 0; i4 < pow3; i4++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c3 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c3.redSqr().redISub(t1.redAdd(t1));
          var t22 = t1.redISub(nx);
          var dny = c3.redMul(t22);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i4 + 1 < pow3)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s4 = s4.redIAdd(s4);
          var m5 = xx.redAdd(xx).redIAdd(xx);
          var t3 = m5.redSqr().redISub(s4).redISub(s4);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t3;
          ny = m5.redMul(s4.redISub(t3)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a2 = this.x.redSqr();
          var b4 = this.y.redSqr();
          var c3 = b4.redSqr();
          var d6 = this.x.redAdd(b4).redSqr().redISub(a2).redISub(c3);
          d6 = d6.redIAdd(d6);
          var e = a2.redAdd(a2).redIAdd(a2);
          var f5 = e.redSqr();
          var c8 = c3.redIAdd(c3);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f5.redISub(d6).redISub(d6);
          ny = e.redMul(d6.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s4 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s4 = s4.redIAdd(s4);
          var m5 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t3 = m5.redSqr().redISub(s4).redISub(s4);
          nx = t3;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m5.redMul(s4.redISub(t3)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a2 = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c3 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c3.redSqr().redISub(t1.redAdd(t1));
        var t22 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c3.redMul(t22).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m5 = xx.redAdd(xx).redIAdd(xx);
        var mm = m5.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee3 = e.redSqr();
        var t3 = yyyy.redIAdd(yyyy);
        t3 = t3.redIAdd(t3);
        t3 = t3.redIAdd(t3);
        t3 = t3.redIAdd(t3);
        var u3 = m5.redIAdd(e).redSqr().redISub(mm).redISub(ee3).redISub(t3);
        var yyu4 = yy.redMul(u3);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee3).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u3.redMul(t3.redISub(u3)).redISub(e.redMul(ee3)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee3);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k3, kbase) {
        k3 = new BN(k3, kbase);
        return this.curve._wnafMul(this, k3);
      };
      JPoint.prototype.eq = function eq2(p2) {
        if (p2.type === "affine")
          return this.eq(p2.toJ());
        if (this === p2)
          return true;
        var z22 = this.z.redSqr();
        var pz2 = p2.z.redSqr();
        if (this.x.redMul(pz2).redISub(p2.x.redMul(z22)).cmpn(0) !== 0)
          return false;
        var z32 = z22.redMul(this.z);
        var pz3 = pz2.redMul(p2.z);
        return this.y.redMul(pz3).redISub(p2.y.redMul(z32)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x8) {
        var zs = this.z.redSqr();
        var rx = x8.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x8.clone();
        var t3 = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t3);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/mont.js
  var require_mont = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
      "use strict";
      var BN = require_bn2();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var utils = require_utils2();
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits(MontCurve, Base);
      module2.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x8 = point.normalize().x;
        var x22 = x8.redSqr();
        var rhs = x22.redMul(x8).redAdd(x22.redMul(this.a)).redAdd(x8);
        var y4 = rhs.redSqrt();
        return y4.redSqr().cmp(rhs) === 0;
      };
      function Point3(curve, x8, z5) {
        Base.BasePoint.call(this, curve, "projective");
        if (x8 === null && z5 === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x8, 16);
          this.z = new BN(z5, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits(Point3, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes2, enc) {
        return this.point(utils.toArray(bytes2, enc), 1);
      };
      MontCurve.prototype.point = function point(x8, z5) {
        return new Point3(this, x8, z5);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point3.fromJSON(this, obj);
      };
      Point3.prototype.precompute = function precompute() {
      };
      Point3.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point3.fromJSON = function fromJSON(curve, obj) {
        return new Point3(curve, obj[0], obj[1] || curve.one);
      };
      Point3.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point3.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point3.prototype.dbl = function dbl() {
        var a2 = this.x.redAdd(this.z);
        var aa = a2.redSqr();
        var b4 = this.x.redSub(this.z);
        var bb = b4.redSqr();
        var c3 = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c3.redMul(bb.redAdd(this.curve.a24.redMul(c3)));
        return this.curve.point(nx, nz);
      };
      Point3.prototype.add = function add3() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point3.prototype.diffAdd = function diffAdd(p2, diff) {
        var a2 = this.x.redAdd(this.z);
        var b4 = this.x.redSub(this.z);
        var c3 = p2.x.redAdd(p2.z);
        var d6 = p2.x.redSub(p2.z);
        var da = d6.redMul(a2);
        var cb = c3.redMul(b4);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point3.prototype.mul = function mul(k3) {
        var t3 = k3.clone();
        var a2 = this;
        var b4 = this.curve.point(null, null);
        var c3 = this;
        for (var bits = []; t3.cmpn(0) !== 0; t3.iushrn(1))
          bits.push(t3.andln(1));
        for (var i4 = bits.length - 1; i4 >= 0; i4--) {
          if (bits[i4] === 0) {
            a2 = a2.diffAdd(b4, c3);
            b4 = b4.dbl();
          } else {
            b4 = a2.diffAdd(b4, c3);
            a2 = a2.dbl();
          }
        }
        return b4;
      };
      Point3.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point3.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point3.prototype.eq = function eq2(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point3.prototype.normalize = function normalize2() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point3.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/edwards.js
  var require_edwards = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
      "use strict";
      var utils = require_utils2();
      var BN = require_bn2();
      var inherits = require_inherits_browser();
      var Base = require_base();
      var assert2 = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits(EdwardsCurve, Base);
      module2.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x8, y4, z5, t3) {
        return this.point(x8, y4, z5, t3);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x8, odd) {
        x8 = new BN(x8, 16);
        if (!x8.red)
          x8 = x8.toRed(this.red);
        var x22 = x8.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x22));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
        var y22 = rhs.redMul(lhs.redInvm());
        var y4 = y22.redSqrt();
        if (y4.redSqr().redSub(y22).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd2 = y4.fromRed().isOdd();
        if (odd && !isOdd2 || !odd && isOdd2)
          y4 = y4.redNeg();
        return this.point(x8, y4);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y4, odd) {
        y4 = new BN(y4, 16);
        if (!y4.red)
          y4 = y4.toRed(this.red);
        var y22 = y4.redSqr();
        var lhs = y22.redSub(this.c2);
        var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x22 = lhs.redMul(rhs.redInvm());
        if (x22.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y4);
        }
        var x8 = x22.redSqrt();
        if (x8.redSqr().redSub(x22).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x8.fromRed().isOdd() !== odd)
          x8 = x8.redNeg();
        return this.point(x8, y4);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x22 = point.x.redSqr();
        var y22 = point.y.redSqr();
        var lhs = x22.redMul(this.a).redAdd(y22);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x22).redMul(y22)));
        return lhs.cmp(rhs) === 0;
      };
      function Point3(curve, x8, y4, z5, t3) {
        Base.BasePoint.call(this, curve, "projective");
        if (x8 === null && y4 === null && z5 === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x8, 16);
          this.y = new BN(y4, 16);
          this.z = z5 ? new BN(z5, 16) : this.curve.one;
          this.t = t3 && new BN(t3, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits(Point3, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point3.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x8, y4, z5, t3) {
        return new Point3(this, x8, y4, z5, t3);
      };
      Point3.fromJSON = function fromJSON(curve, obj) {
        return new Point3(curve, obj[0], obj[1], obj[2]);
      };
      Point3.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point3.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point3.prototype._extDbl = function _extDbl() {
        var a2 = this.x.redSqr();
        var b4 = this.y.redSqr();
        var c3 = this.z.redSqr();
        c3 = c3.redIAdd(c3);
        var d6 = this.curve._mulA(a2);
        var e = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b4);
        var g5 = d6.redAdd(b4);
        var f5 = g5.redSub(c3);
        var h6 = d6.redSub(b4);
        var nx = e.redMul(f5);
        var ny = g5.redMul(h6);
        var nt2 = e.redMul(h6);
        var nz = f5.redMul(g5);
        return this.curve.point(nx, ny, nz, nt2);
      };
      Point3.prototype._projDbl = function _projDbl() {
        var b4 = this.x.redAdd(this.y).redSqr();
        var c3 = this.x.redSqr();
        var d6 = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h6;
        var j3;
        if (this.curve.twisted) {
          e = this.curve._mulA(c3);
          var f5 = e.redAdd(d6);
          if (this.zOne) {
            nx = b4.redSub(c3).redSub(d6).redMul(f5.redSub(this.curve.two));
            ny = f5.redMul(e.redSub(d6));
            nz = f5.redSqr().redSub(f5).redSub(f5);
          } else {
            h6 = this.z.redSqr();
            j3 = f5.redSub(h6).redISub(h6);
            nx = b4.redSub(c3).redISub(d6).redMul(j3);
            ny = f5.redMul(e.redSub(d6));
            nz = f5.redMul(j3);
          }
        } else {
          e = c3.redAdd(d6);
          h6 = this.curve._mulC(this.z).redSqr();
          j3 = e.redSub(h6).redSub(h6);
          nx = this.curve._mulC(b4.redISub(e)).redMul(j3);
          ny = this.curve._mulC(e).redMul(c3.redISub(d6));
          nz = e.redMul(j3);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point3.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point3.prototype._extAdd = function _extAdd(p2) {
        var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
        var b4 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
        var c3 = this.t.redMul(this.curve.dd).redMul(p2.t);
        var d6 = this.z.redMul(p2.z.redAdd(p2.z));
        var e = b4.redSub(a2);
        var f5 = d6.redSub(c3);
        var g5 = d6.redAdd(c3);
        var h6 = b4.redAdd(a2);
        var nx = e.redMul(f5);
        var ny = g5.redMul(h6);
        var nt2 = e.redMul(h6);
        var nz = f5.redMul(g5);
        return this.curve.point(nx, ny, nz, nt2);
      };
      Point3.prototype._projAdd = function _projAdd(p2) {
        var a2 = this.z.redMul(p2.z);
        var b4 = a2.redSqr();
        var c3 = this.x.redMul(p2.x);
        var d6 = this.y.redMul(p2.y);
        var e = this.curve.d.redMul(c3).redMul(d6);
        var f5 = b4.redSub(e);
        var g5 = b4.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c3).redISub(d6);
        var nx = a2.redMul(f5).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a2.redMul(g5).redMul(d6.redSub(this.curve._mulA(c3)));
          nz = f5.redMul(g5);
        } else {
          ny = a2.redMul(g5).redMul(d6.redSub(c3));
          nz = this.curve._mulC(f5).redMul(g5);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point3.prototype.add = function add3(p2) {
        if (this.isInfinity())
          return p2;
        if (p2.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p2);
        else
          return this._projAdd(p2);
      };
      Point3.prototype.mul = function mul(k3) {
        if (this._hasDoubles(k3))
          return this.curve._fixedNafMul(this, k3);
        else
          return this.curve._wnafMul(this, k3);
      };
      Point3.prototype.mulAdd = function mulAdd(k1, p2, k22) {
        return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, false);
      };
      Point3.prototype.jmulAdd = function jmulAdd(k1, p2, k22) {
        return this.curve._wnafMulAdd(1, [this, p2], [k1, k22], 2, true);
      };
      Point3.prototype.normalize = function normalize2() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point3.prototype.neg = function neg() {
        return this.curve.point(
          this.x.redNeg(),
          this.y,
          this.z,
          this.t && this.t.redNeg()
        );
      };
      Point3.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point3.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point3.prototype.eq = function eq2(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point3.prototype.eqXToP = function eqXToP(x8) {
        var rx = x8.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x8.clone();
        var t3 = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t3);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point3.prototype.toP = Point3.prototype.normalize;
      Point3.prototype.mixedAdd = Point3.prototype.add;
    }
  });

  // node_modules/elliptic/lib/elliptic/curve/index.js
  var require_curve = __commonJS({
    "node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
      "use strict";
      var curve = exports2;
      curve.base = require_base();
      curve.short = require_short();
      curve.mont = require_mont();
      curve.edwards = require_edwards();
    }
  });

  // node_modules/hash.js/lib/hash/utils.js
  var require_utils3 = __commonJS({
    "node_modules/hash.js/lib/hash/utils.js"(exports2) {
      "use strict";
      var assert2 = require_minimalistic_assert();
      var inherits = require_inherits_browser();
      exports2.inherits = inherits;
      function isSurrogatePair(msg, i4) {
        if ((msg.charCodeAt(i4) & 64512) !== 55296) {
          return false;
        }
        if (i4 < 0 || i4 + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i4 + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p2 = 0;
            for (var i4 = 0; i4 < msg.length; i4++) {
              var c3 = msg.charCodeAt(i4);
              if (c3 < 128) {
                res[p2++] = c3;
              } else if (c3 < 2048) {
                res[p2++] = c3 >> 6 | 192;
                res[p2++] = c3 & 63 | 128;
              } else if (isSurrogatePair(msg, i4)) {
                c3 = 65536 + ((c3 & 1023) << 10) + (msg.charCodeAt(++i4) & 1023);
                res[p2++] = c3 >> 18 | 240;
                res[p2++] = c3 >> 12 & 63 | 128;
                res[p2++] = c3 >> 6 & 63 | 128;
                res[p2++] = c3 & 63 | 128;
              } else {
                res[p2++] = c3 >> 12 | 224;
                res[p2++] = c3 >> 6 & 63 | 128;
                res[p2++] = c3 & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i4 = 0; i4 < msg.length; i4 += 2)
              res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
          }
        } else {
          for (i4 = 0; i4 < msg.length; i4++)
            res[i4] = msg[i4] | 0;
        }
        return res;
      }
      exports2.toArray = toArray;
      function toHex2(msg) {
        var res = "";
        for (var i4 = 0; i4 < msg.length; i4++)
          res += zero2(msg[i4].toString(16));
        return res;
      }
      exports2.toHex = toHex2;
      function htonl(w3) {
        var res = w3 >>> 24 | w3 >>> 8 & 65280 | w3 << 8 & 16711680 | (w3 & 255) << 24;
        return res >>> 0;
      }
      exports2.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i4 = 0; i4 < msg.length; i4++) {
          var w3 = msg[i4];
          if (endian === "little")
            w3 = htonl(w3);
          res += zero8(w3.toString(16));
        }
        return res;
      }
      exports2.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports2.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports2.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert2(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i4 = 0, k3 = start; i4 < res.length; i4++, k3 += 4) {
          var w3;
          if (endian === "big")
            w3 = msg[k3] << 24 | msg[k3 + 1] << 16 | msg[k3 + 2] << 8 | msg[k3 + 3];
          else
            w3 = msg[k3 + 3] << 24 | msg[k3 + 2] << 16 | msg[k3 + 1] << 8 | msg[k3];
          res[i4] = w3 >>> 0;
        }
        return res;
      }
      exports2.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i4 = 0, k3 = 0; i4 < msg.length; i4++, k3 += 4) {
          var m5 = msg[i4];
          if (endian === "big") {
            res[k3] = m5 >>> 24;
            res[k3 + 1] = m5 >>> 16 & 255;
            res[k3 + 2] = m5 >>> 8 & 255;
            res[k3 + 3] = m5 & 255;
          } else {
            res[k3 + 3] = m5 >>> 24;
            res[k3 + 2] = m5 >>> 16 & 255;
            res[k3 + 1] = m5 >>> 8 & 255;
            res[k3] = m5 & 255;
          }
        }
        return res;
      }
      exports2.split32 = split32;
      function rotr32(w3, b4) {
        return w3 >>> b4 | w3 << 32 - b4;
      }
      exports2.rotr32 = rotr32;
      function rotl32(w3, b4) {
        return w3 << b4 | w3 >>> 32 - b4;
      }
      exports2.rotl32 = rotl32;
      function sum32(a2, b4) {
        return a2 + b4 >>> 0;
      }
      exports2.sum32 = sum32;
      function sum32_3(a2, b4, c3) {
        return a2 + b4 + c3 >>> 0;
      }
      exports2.sum32_3 = sum32_3;
      function sum32_4(a2, b4, c3, d6) {
        return a2 + b4 + c3 + d6 >>> 0;
      }
      exports2.sum32_4 = sum32_4;
      function sum32_5(a2, b4, c3, d6, e) {
        return a2 + b4 + c3 + d6 + e >>> 0;
      }
      exports2.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports2.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports2.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports2.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports2.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports2.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports2.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports2.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r2 = al << 32 - num | ah >>> num;
        return r2 >>> 0;
      }
      exports2.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r2 = ah << 32 - num | al >>> num;
        return r2 >>> 0;
      }
      exports2.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports2.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r2 = ah << 32 - num | al >>> num;
        return r2 >>> 0;
      }
      exports2.shr64_lo = shr64_lo;
    }
  });

  // node_modules/hash.js/lib/hash/common.js
  var require_common = __commonJS({
    "node_modules/hash.js/lib/hash/common.js"(exports2) {
      "use strict";
      var utils = require_utils3();
      var assert2 = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports2.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r2 = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r2, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r2, this.endian);
          for (var i4 = 0; i4 < msg.length; i4 += this._delta32)
            this._update(msg, i4, i4 + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert2(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad2() {
        var len = this.pendingTotal;
        var bytes2 = this._delta8;
        var k3 = bytes2 - (len + this.padLength) % bytes2;
        var res = new Array(k3 + this.padLength);
        res[0] = 128;
        for (var i4 = 1; i4 < k3; i4++)
          res[i4] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t3 = 8; t3 < this.padLength; t3++)
            res[i4++] = 0;
          res[i4++] = 0;
          res[i4++] = 0;
          res[i4++] = 0;
          res[i4++] = 0;
          res[i4++] = len >>> 24 & 255;
          res[i4++] = len >>> 16 & 255;
          res[i4++] = len >>> 8 & 255;
          res[i4++] = len & 255;
        } else {
          res[i4++] = len & 255;
          res[i4++] = len >>> 8 & 255;
          res[i4++] = len >>> 16 & 255;
          res[i4++] = len >>> 24 & 255;
          res[i4++] = 0;
          res[i4++] = 0;
          res[i4++] = 0;
          res[i4++] = 0;
          for (t3 = 8; t3 < this.padLength; t3++)
            res[i4++] = 0;
        }
        return res;
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/common.js
  var require_common2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
      "use strict";
      var utils = require_utils3();
      var rotr32 = utils.rotr32;
      function ft_1(s4, x8, y4, z5) {
        if (s4 === 0)
          return ch32(x8, y4, z5);
        if (s4 === 1 || s4 === 3)
          return p32(x8, y4, z5);
        if (s4 === 2)
          return maj32(x8, y4, z5);
      }
      exports2.ft_1 = ft_1;
      function ch32(x8, y4, z5) {
        return x8 & y4 ^ ~x8 & z5;
      }
      exports2.ch32 = ch32;
      function maj32(x8, y4, z5) {
        return x8 & y4 ^ x8 & z5 ^ y4 & z5;
      }
      exports2.maj32 = maj32;
      function p32(x8, y4, z5) {
        return x8 ^ y4 ^ z5;
      }
      exports2.p32 = p32;
      function s0_256(x8) {
        return rotr32(x8, 2) ^ rotr32(x8, 13) ^ rotr32(x8, 22);
      }
      exports2.s0_256 = s0_256;
      function s1_256(x8) {
        return rotr32(x8, 6) ^ rotr32(x8, 11) ^ rotr32(x8, 25);
      }
      exports2.s1_256 = s1_256;
      function g0_256(x8) {
        return rotr32(x8, 7) ^ rotr32(x8, 18) ^ x8 >>> 3;
      }
      exports2.g0_256 = g0_256;
      function g1_256(x8) {
        return rotr32(x8, 17) ^ rotr32(x8, 19) ^ x8 >>> 10;
      }
      exports2.g1_256 = g1_256;
    }
  });

  // node_modules/hash.js/lib/hash/sha/1.js
  var require__ = __commonJS({
    "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
      "use strict";
      var utils = require_utils3();
      var common = require_common();
      var shaCommon = require_common2();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module2.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W4 = this.W;
        for (var i4 = 0; i4 < 16; i4++)
          W4[i4] = msg[start + i4];
        for (; i4 < W4.length; i4++)
          W4[i4] = rotl32(W4[i4 - 3] ^ W4[i4 - 8] ^ W4[i4 - 14] ^ W4[i4 - 16], 1);
        var a2 = this.h[0];
        var b4 = this.h[1];
        var c3 = this.h[2];
        var d6 = this.h[3];
        var e = this.h[4];
        for (i4 = 0; i4 < W4.length; i4++) {
          var s4 = ~~(i4 / 20);
          var t3 = sum32_5(rotl32(a2, 5), ft_1(s4, b4, c3, d6), e, W4[i4], sha1_K[s4]);
          e = d6;
          d6 = c3;
          c3 = rotl32(b4, 30);
          b4 = a2;
          a2 = t3;
        }
        this.h[0] = sum32(this.h[0], a2);
        this.h[1] = sum32(this.h[1], b4);
        this.h[2] = sum32(this.h[2], c3);
        this.h[3] = sum32(this.h[3], d6);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/256.js
  var require__2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
      "use strict";
      var utils = require_utils3();
      var common = require_common();
      var shaCommon = require_common2();
      var assert2 = require_minimalistic_assert();
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA2562() {
        if (!(this instanceof SHA2562))
          return new SHA2562();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA2562, BlockHash);
      module2.exports = SHA2562;
      SHA2562.blockSize = 512;
      SHA2562.outSize = 256;
      SHA2562.hmacStrength = 192;
      SHA2562.padLength = 64;
      SHA2562.prototype._update = function _update(msg, start) {
        var W4 = this.W;
        for (var i4 = 0; i4 < 16; i4++)
          W4[i4] = msg[start + i4];
        for (; i4 < W4.length; i4++)
          W4[i4] = sum32_4(g1_256(W4[i4 - 2]), W4[i4 - 7], g0_256(W4[i4 - 15]), W4[i4 - 16]);
        var a2 = this.h[0];
        var b4 = this.h[1];
        var c3 = this.h[2];
        var d6 = this.h[3];
        var e = this.h[4];
        var f5 = this.h[5];
        var g5 = this.h[6];
        var h6 = this.h[7];
        assert2(this.k.length === W4.length);
        for (i4 = 0; i4 < W4.length; i4++) {
          var T1 = sum32_5(h6, s1_256(e), ch32(e, f5, g5), this.k[i4], W4[i4]);
          var T22 = sum32(s0_256(a2), maj32(a2, b4, c3));
          h6 = g5;
          g5 = f5;
          f5 = e;
          e = sum32(d6, T1);
          d6 = c3;
          c3 = b4;
          b4 = a2;
          a2 = sum32(T1, T22);
        }
        this.h[0] = sum32(this.h[0], a2);
        this.h[1] = sum32(this.h[1], b4);
        this.h[2] = sum32(this.h[2], c3);
        this.h[3] = sum32(this.h[3], d6);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f5);
        this.h[6] = sum32(this.h[6], g5);
        this.h[7] = sum32(this.h[7], h6);
      };
      SHA2562.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/224.js
  var require__3 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
      "use strict";
      var utils = require_utils3();
      var SHA2562 = require__2();
      function SHA2242() {
        if (!(this instanceof SHA2242))
          return new SHA2242();
        SHA2562.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils.inherits(SHA2242, SHA2562);
      module2.exports = SHA2242;
      SHA2242.blockSize = 512;
      SHA2242.outSize = 224;
      SHA2242.hmacStrength = 192;
      SHA2242.padLength = 64;
      SHA2242.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/512.js
  var require__4 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
      "use strict";
      var utils = require_utils3();
      var common = require_common();
      var assert2 = require_minimalistic_assert();
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA5122() {
        if (!(this instanceof SHA5122))
          return new SHA5122();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA5122, BlockHash);
      module2.exports = SHA5122;
      SHA5122.blockSize = 1024;
      SHA5122.outSize = 512;
      SHA5122.hmacStrength = 192;
      SHA5122.padLength = 128;
      SHA5122.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W4 = this.W;
        for (var i4 = 0; i4 < 32; i4++)
          W4[i4] = msg[start + i4];
        for (; i4 < W4.length; i4 += 2) {
          var c0_hi = g1_512_hi(W4[i4 - 4], W4[i4 - 3]);
          var c0_lo = g1_512_lo(W4[i4 - 4], W4[i4 - 3]);
          var c1_hi = W4[i4 - 14];
          var c1_lo = W4[i4 - 13];
          var c2_hi = g0_512_hi(W4[i4 - 30], W4[i4 - 29]);
          var c2_lo = g0_512_lo(W4[i4 - 30], W4[i4 - 29]);
          var c3_hi = W4[i4 - 32];
          var c3_lo = W4[i4 - 31];
          W4[i4] = sum64_4_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
          W4[i4 + 1] = sum64_4_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
        }
      };
      SHA5122.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W4 = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert2(this.k.length === W4.length);
        for (var i4 = 0; i4 < W4.length; i4 += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i4];
          var c3_lo = this.k[i4 + 1];
          var c4_hi = W4[i4];
          var c4_lo = W4[i4 + 1];
          var T1_hi = sum64_5_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          var T1_lo = sum64_5_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA5122.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r2 = xh & yh ^ ~xh & zh;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r2 = xl & yl ^ ~xl & zl;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r2 = xh & yh ^ xh & zh ^ yh & zh;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r2 = xl & yl ^ xl & zl ^ yl & zl;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r2 = c0_hi ^ c1_hi ^ c2_hi;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r2 = c0_lo ^ c1_lo ^ c2_lo;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r2 = c0_hi ^ c1_hi ^ c2_hi;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r2 = c0_lo ^ c1_lo ^ c2_lo;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r2 = c0_hi ^ c1_hi ^ c2_hi;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r2 = c0_lo ^ c1_lo ^ c2_lo;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r2 = c0_hi ^ c1_hi ^ c2_hi;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r2 = c0_lo ^ c1_lo ^ c2_lo;
        if (r2 < 0)
          r2 += 4294967296;
        return r2;
      }
    }
  });

  // node_modules/hash.js/lib/hash/sha/384.js
  var require__5 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
      "use strict";
      var utils = require_utils3();
      var SHA5122 = require__4();
      function SHA3842() {
        if (!(this instanceof SHA3842))
          return new SHA3842();
        SHA5122.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils.inherits(SHA3842, SHA5122);
      module2.exports = SHA3842;
      SHA3842.blockSize = 1024;
      SHA3842.outSize = 384;
      SHA3842.hmacStrength = 192;
      SHA3842.padLength = 128;
      SHA3842.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha.js
  var require_sha = __commonJS({
    "node_modules/hash.js/lib/hash/sha.js"(exports2) {
      "use strict";
      exports2.sha1 = require__();
      exports2.sha224 = require__3();
      exports2.sha256 = require__2();
      exports2.sha384 = require__5();
      exports2.sha512 = require__4();
    }
  });

  // node_modules/hash.js/lib/hash/ripemd.js
  var require_ripemd = __commonJS({
    "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
      "use strict";
      var utils = require_utils3();
      var common = require_common();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD1602() {
        if (!(this instanceof RIPEMD1602))
          return new RIPEMD1602();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD1602, BlockHash);
      exports2.ripemd160 = RIPEMD1602;
      RIPEMD1602.blockSize = 512;
      RIPEMD1602.outSize = 160;
      RIPEMD1602.hmacStrength = 192;
      RIPEMD1602.padLength = 64;
      RIPEMD1602.prototype._update = function update(msg, start) {
        var A3 = this.h[0];
        var B5 = this.h[1];
        var C4 = this.h[2];
        var D4 = this.h[3];
        var E4 = this.h[4];
        var Ah = A3;
        var Bh = B5;
        var Ch = C4;
        var Dh = D4;
        var Eh = E4;
        for (var j3 = 0; j3 < 80; j3++) {
          var T4 = sum32(
            rotl32(
              sum32_4(A3, f5(j3, B5, C4, D4), msg[r2[j3] + start], K4(j3)),
              s4[j3]
            ),
            E4
          );
          A3 = E4;
          E4 = D4;
          D4 = rotl32(C4, 10);
          C4 = B5;
          B5 = T4;
          T4 = sum32(
            rotl32(
              sum32_4(Ah, f5(79 - j3, Bh, Ch, Dh), msg[rh[j3] + start], Kh(j3)),
              sh[j3]
            ),
            Eh
          );
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T4;
        }
        T4 = sum32_3(this.h[1], C4, Dh);
        this.h[1] = sum32_3(this.h[2], D4, Eh);
        this.h[2] = sum32_3(this.h[3], E4, Ah);
        this.h[3] = sum32_3(this.h[4], A3, Bh);
        this.h[4] = sum32_3(this.h[0], B5, Ch);
        this.h[0] = T4;
      };
      RIPEMD1602.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f5(j3, x8, y4, z5) {
        if (j3 <= 15)
          return x8 ^ y4 ^ z5;
        else if (j3 <= 31)
          return x8 & y4 | ~x8 & z5;
        else if (j3 <= 47)
          return (x8 | ~y4) ^ z5;
        else if (j3 <= 63)
          return x8 & z5 | y4 & ~z5;
        else
          return x8 ^ (y4 | ~z5);
      }
      function K4(j3) {
        if (j3 <= 15)
          return 0;
        else if (j3 <= 31)
          return 1518500249;
        else if (j3 <= 47)
          return 1859775393;
        else if (j3 <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j3) {
        if (j3 <= 15)
          return 1352829926;
        else if (j3 <= 31)
          return 1548603684;
        else if (j3 <= 47)
          return 1836072691;
        else if (j3 <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r2 = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s4 = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
    }
  });

  // node_modules/hash.js/lib/hash/hmac.js
  var require_hmac = __commonJS({
    "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
      "use strict";
      var utils = require_utils3();
      var assert2 = require_minimalistic_assert();
      function Hmac(hash3, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash3, key, enc);
        this.Hash = hash3;
        this.blockSize = hash3.blockSize / 8;
        this.outSize = hash3.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
      }
      module2.exports = Hmac;
      Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert2(key.length <= this.blockSize);
        for (var i4 = key.length; i4 < this.blockSize; i4++)
          key.push(0);
        for (i4 = 0; i4 < key.length; i4++)
          key[i4] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i4 = 0; i4 < key.length; i4++)
          key[i4] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }
  });

  // node_modules/hash.js/lib/hash.js
  var require_hash = __commonJS({
    "node_modules/hash.js/lib/hash.js"(exports2) {
      var hash3 = exports2;
      hash3.utils = require_utils3();
      hash3.common = require_common();
      hash3.sha = require_sha();
      hash3.ripemd = require_ripemd();
      hash3.hmac = require_hmac();
      hash3.sha1 = hash3.sha.sha1;
      hash3.sha256 = hash3.sha.sha256;
      hash3.sha224 = hash3.sha.sha224;
      hash3.sha384 = hash3.sha.sha384;
      hash3.sha512 = hash3.sha.sha512;
      hash3.ripemd160 = hash3.ripemd.ripemd160;
    }
  });

  // node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
  var require_secp256k1 = __commonJS({
    "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
      module2.exports = {
        doubles: {
          step: 4,
          points: [
            [
              "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
              "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
              "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
              "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
              "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
              "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
              "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
              "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
              "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
              "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
              "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
              "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
              "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
              "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
              "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
              "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
              "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
              "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
              "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
              "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
              "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
              "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
              "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
              "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
              "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
              "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
              "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
              "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
              "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
              "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
              "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
              "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
              "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
              "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
              "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
              "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
              "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
              "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
              "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
              "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
              "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
              "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
              "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
              "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
              "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
              "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
              "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
              "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
              "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
              "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
              "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
              "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
              "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
              "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
              "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
              "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
              "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
              "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
              "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
              "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
              "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
              "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
              "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
              "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
              "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
              "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
              "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
              "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
              "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
              "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
              "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
              "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
              "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
              "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
              "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
              "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
              "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
              "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
              "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
              "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
              "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
              "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
              "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
              "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
              "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
              "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
              "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
              "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
              "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
              "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
              "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
              "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
              "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
              "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
              "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
              "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
              "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
              "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
              "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
              "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
              "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
              "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
              "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
              "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
              "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
              "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
              "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
              "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
              "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
              "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
              "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
              "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
              "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
              "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
              "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
              "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
              "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
              "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
              "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
              "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
              "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
              "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
              "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
              "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
              "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
              "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
              "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
              "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
              "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
              "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            [
              "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
              "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
              "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
              "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
              "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
              "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
              "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
              "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
              "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
              "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
              "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
              "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
              "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
              "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
              "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
              "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
              "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
              "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
              "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
              "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
              "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
              "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
              "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
              "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
              "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
              "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
              "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
              "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
              "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
              "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
              "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
              "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
              "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
              "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
              "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
              "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
              "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
              "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
              "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
              "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
              "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
              "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
              "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
              "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
              "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
              "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
              "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
              "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
              "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
              "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
              "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
              "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
              "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
              "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
              "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
              "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
              "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
              "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
              "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
              "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
              "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
              "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
              "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
              "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
              "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
              "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
              "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
              "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
              "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
              "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
              "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
              "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
              "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
              "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
              "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
              "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
              "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
              "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
              "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
              "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
              "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
              "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
              "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
              "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
              "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
              "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
              "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
              "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
              "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
              "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
              "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
              "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
              "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
              "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
              "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
              "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
              "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
              "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
              "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
              "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
              "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
              "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
              "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
              "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
              "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
              "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
              "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
              "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
              "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
              "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
              "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
              "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
              "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
              "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
              "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
              "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
              "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
              "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
              "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
              "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
              "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
              "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
              "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
              "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
              "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
              "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
              "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
              "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
              "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
              "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
              "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
              "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
              "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
              "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
              "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
              "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
              "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
              "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
              "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
              "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
              "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
              "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
              "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
              "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
              "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
              "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
              "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
              "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
              "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
              "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
              "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
              "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
              "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
              "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
              "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
              "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
              "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
              "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
              "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
              "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
              "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
              "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
              "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
              "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
              "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
              "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
              "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
              "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
              "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
              "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
              "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
              "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
              "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
              "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
              "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
              "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
              "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
              "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
              "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
              "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
              "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
              "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
              "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
              "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
              "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
              "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
              "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
              "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
              "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
              "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
              "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
              "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
              "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
              "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
              "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
              "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
              "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
              "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
              "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
              "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
              "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
              "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
              "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
              "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
              "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
              "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
              "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
              "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
              "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
              "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
              "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
              "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
              "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
              "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
              "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
              "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
              "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
              "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
              "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
              "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
              "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
              "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
              "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
              "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
              "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
              "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
              "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
              "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
              "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
              "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
              "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
              "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
              "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
              "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
              "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
              "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
              "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
              "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
              "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
              "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
              "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
              "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
              "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
              "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
              "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
              "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
              "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
              "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
              "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
              "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
              "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
              "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
              "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
              "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
          ]
        }
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/curves.js
  var require_curves = __commonJS({
    "node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
      "use strict";
      var curves = exports2;
      var hash3 = require_hash();
      var curve = require_curve();
      var utils = require_utils2();
      var assert2 = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert2(this.g.validate(), "Invalid curve");
        assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve2 = new PresetCurve(options);
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              value: curve2
            });
            return curve2;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash3.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash3.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash3.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash3.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash3.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash3.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash3.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require_secp256k1();
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash3.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    }
  });

  // node_modules/hmac-drbg/lib/hmac-drbg.js
  var require_hmac_drbg = __commonJS({
    "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
      "use strict";
      var hash3 = require_hash();
      var utils = require_utils();
      var assert2 = require_minimalistic_assert();
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert2(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._init(entropy, nonce, pers);
      }
      module2.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i4 = 0; i4 < this.V.length; i4++) {
          this.K[i4] = 0;
          this.V[i4] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac2() {
        return new hash3.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add3;
          add3 = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add3 = utils.toArray(add3, addEnc);
        assert2(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._update(entropy.concat(add3 || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add3;
          add3 = enc;
          enc = null;
        }
        if (add3) {
          add3 = utils.toArray(add3, addEnc || "hex");
          this._update(add3);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add3);
        this._reseed++;
        return utils.encode(res, enc);
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/key.js
  var require_key = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
      "use strict";
      var BN = require_bn2();
      var utils = require_utils2();
      var assert2 = utils.assert;
      function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module2.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, {
          pub,
          pubEnc: enc
        });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, {
          priv,
          privEnc: enc
        });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert2(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert2(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert2(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign2(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
      };
      KeyPair.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/signature.js
  var require_signature = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
      "use strict";
      var BN = require_bn2();
      var utils = require_utils2();
      var assert2 = utils.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert2(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module2.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p2) {
        var initial = buf[p2.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        var val = 0;
        for (var i4 = 0, off = p2.place; i4 < octetLen; i4++, off++) {
          val <<= 8;
          val |= buf[off];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p2.place = off;
        return val;
      }
      function rmPadding(buf) {
        var i4 = 0;
        var len = buf.length - 1;
        while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len) {
          i4++;
        }
        if (i4 === 0) {
          return buf;
        }
        return buf.slice(i4);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p2 = new Position();
        if (data[p2.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p2);
        if (len === false) {
          return false;
        }
        if (len + p2.place !== data.length) {
          return false;
        }
        if (data[p2.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p2);
        if (rlen === false) {
          return false;
        }
        var r2 = data.slice(p2.place, rlen + p2.place);
        p2.place += rlen;
        if (data[p2.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p2);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p2.place) {
          return false;
        }
        var s4 = data.slice(p2.place, slen + p2.place);
        if (r2[0] === 0) {
          if (r2[1] & 128) {
            r2 = r2.slice(1);
          } else {
            return false;
          }
        }
        if (s4[0] === 0) {
          if (s4[1] & 128) {
            s4 = s4.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r2);
        this.s = new BN(s4);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r2 = this.r.toArray();
        var s4 = this.s.toArray();
        if (r2[0] & 128)
          r2 = [0].concat(r2);
        if (s4[0] & 128)
          s4 = [0].concat(s4);
        r2 = rmPadding(r2);
        s4 = rmPadding(s4);
        while (!s4[0] && !(s4[1] & 128)) {
          s4 = s4.slice(1);
        }
        var arr = [2];
        constructLength(arr, r2.length);
        arr = arr.concat(r2);
        arr.push(2);
        constructLength(arr, s4.length);
        var backHalf = arr.concat(s4);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/ec/index.js
  var require_ec = __commonJS({
    "node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
      "use strict";
      var BN = require_bn2();
      var HmacDRBG = require_hmac_drbg();
      var utils = require_utils2();
      var curves = require_curves();
      var rand = require_brorand();
      var assert2 = utils.assert;
      var KeyPair = require_key();
      var Signature = require_signature();
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert2(
            Object.prototype.hasOwnProperty.call(curves, options),
            "Unknown curve " + options
          );
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module2.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({
          hash: this.hash,
          pers: options.pers,
          persEnc: options.persEnc || "utf8",
          entropy: options.entropy || rand(this.hash.hmacStrength),
          entropyEnc: options.entropy && options.entropyEnc || "utf8",
          nonce: this.n.toArray()
        });
        var bytes2 = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        for (; ; ) {
          var priv = new BN(drbg.generate(bytes2));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign2(msg, key, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN(msg, 16));
        var bytes2 = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes2);
        var nonce = msg.toArray("be", bytes2);
        var drbg = new HmacDRBG({
          hash: this.hash,
          entropy: bkey,
          nonce,
          pers: options.pers,
          persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; ; iter++) {
          var k3 = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k3 = this._truncateToN(k3, true);
          if (k3.cmpn(1) <= 0 || k3.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k3);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r2 = kpX.umod(this.n);
          if (r2.cmpn(0) === 0)
            continue;
          var s4 = k3.invm(this.n).mul(r2.mul(key.getPrivate()).iadd(msg));
          s4 = s4.umod(this.n);
          if (s4.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
          if (options.canonical && s4.cmp(this.nh) > 0) {
            s4 = this.n.sub(s4);
            recoveryParam ^= 1;
          }
          return new Signature({ r: r2, s: s4, recoveryParam });
        }
      };
      EC.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new BN(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r2 = signature.r;
        var s4 = signature.s;
        if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
          return false;
        if (s4.cmpn(1) < 0 || s4.cmp(this.n) >= 0)
          return false;
        var sinv = s4.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u22 = sinv.mul(r2).umod(this.n);
        var p2;
        if (!this.curve._maxwellTrick) {
          p2 = this.g.mulAdd(u1, key.getPublic(), u22);
          if (p2.isInfinity())
            return false;
          return p2.getX().umod(this.n).cmp(r2) === 0;
        }
        p2 = this.g.jmulAdd(u1, key.getPublic(), u22);
        if (p2.isInfinity())
          return false;
        return p2.eqXToP(r2);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j3, enc) {
        assert2((3 & j3) === j3, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n4 = this.n;
        var e = new BN(msg);
        var r2 = signature.r;
        var s4 = signature.s;
        var isYOdd = j3 & 1;
        var isSecondKey = j3 >> 1;
        if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
        else
          r2 = this.curve.pointFromX(r2, isYOdd);
        var rInv = signature.r.invm(n4);
        var s1 = n4.sub(e).mul(rInv).umod(n4);
        var s22 = s4.mul(rInv).umod(n4);
        return this.g.mulAdd(s1, r2, s22);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q2, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i4 = 0; i4 < 4; i4++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i4);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q2))
            return i4;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/key.js
  var require_key2 = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
      "use strict";
      var utils = require_utils2();
      var assert2 = utils.assert;
      var parseBytes = utils.parseBytes;
      var cachedProperty = utils.cachedProperty;
      function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, { pub });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, { secret });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash3 = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a2 = hash3.slice(0, eddsa.encodingLength);
        a2[0] &= 248;
        a2[lastIx] &= 127;
        a2[lastIx] |= 64;
        return a2;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash3() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign2(message) {
        assert2(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert2(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module2.exports = KeyPair;
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/signature.js
  var require_signature2 = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
      "use strict";
      var BN = require_bn2();
      var utils = require_utils2();
      var assert2 = utils.assert;
      var cachedProperty = utils.cachedProperty;
      var parseBytes = utils.parseBytes;
      function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
          };
        }
        assert2(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S3() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R4() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes4() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex2() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module2.exports = Signature;
    }
  });

  // node_modules/elliptic/lib/elliptic/eddsa/index.js
  var require_eddsa = __commonJS({
    "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
      "use strict";
      var hash3 = require_hash();
      var curves = require_curves();
      var utils = require_utils2();
      var assert2 = utils.assert;
      var parseBytes = utils.parseBytes;
      var KeyPair = require_key2();
      var Signature = require_signature2();
      function EDDSA(curve) {
        assert2(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash3.sha512;
      }
      module2.exports = EDDSA;
      EDDSA.prototype.sign = function sign2(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r2 = this.hashInt(key.messagePrefix(), message);
        var R4 = this.g.mul(r2);
        var Rencoded = this.encodePoint(R4);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S3 = r2.add(s_).umod(this.curve.n);
        return this.makeSignature({ R: R4, S: S3, Rencoded });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h6 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h6));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash4 = this.hash();
        for (var i4 = 0; i4 < arguments.length; i4++)
          hash4.update(arguments[i4]);
        return utils.intFromLE(hash4.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes2) {
        bytes2 = utils.parseBytes(bytes2);
        var lastIx = bytes2.length - 1;
        var normed = bytes2.slice(0, lastIx).concat(bytes2[lastIx] & ~128);
        var xIsOdd = (bytes2[lastIx] & 128) !== 0;
        var y4 = utils.intFromLE(normed);
        return this.curve.pointFromY(y4, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes2) {
        return utils.intFromLE(bytes2);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    }
  });

  // node_modules/elliptic/lib/elliptic.js
  var require_elliptic = __commonJS({
    "node_modules/elliptic/lib/elliptic.js"(exports2) {
      "use strict";
      var elliptic = exports2;
      elliptic.version = require_package().version;
      elliptic.utils = require_utils2();
      elliptic.rand = require_brorand();
      elliptic.curve = require_curve();
      elliptic.curves = require_curves();
      elliptic.ec = require_ec();
      elliptic.eddsa = require_eddsa();
    }
  });

  // node_modules/@ethersproject/signing-key/lib/elliptic.js
  var require_elliptic2 = __commonJS({
    "node_modules/@ethersproject/signing-key/lib/elliptic.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EC = void 0;
      var elliptic_1 = __importDefault(require_elliptic());
      var EC = elliptic_1.default.ec;
      exports2.EC = EC;
    }
  });

  // node_modules/@ethersproject/signing-key/lib/_version.js
  var require_version12 = __commonJS({
    "node_modules/@ethersproject/signing-key/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "signing-key/5.7.0";
    }
  });

  // node_modules/@ethersproject/signing-key/lib/index.js
  var require_lib16 = __commonJS({
    "node_modules/@ethersproject/signing-key/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.computePublicKey = exports2.recoverPublicKey = exports2.SigningKey = void 0;
      var elliptic_1 = require_elliptic2();
      var bytes_1 = require_lib2();
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version12();
      var logger19 = new logger_1.Logger(_version_1.version);
      var _curve = null;
      function getCurve() {
        if (!_curve) {
          _curve = new elliptic_1.EC("secp256k1");
        }
        return _curve;
      }
      var SigningKey2 = (
        /** @class */
        function() {
          function SigningKey3(privateKey) {
            (0, properties_1.defineReadOnly)(this, "curve", "secp256k1");
            (0, properties_1.defineReadOnly)(this, "privateKey", (0, bytes_1.hexlify)(privateKey));
            if ((0, bytes_1.hexDataLength)(this.privateKey) !== 32) {
              logger19.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
            }
            var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
            (0, properties_1.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
            (0, properties_1.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
            (0, properties_1.defineReadOnly)(this, "_isSigningKey", true);
          }
          SigningKey3.prototype._addPoint = function(other) {
            var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));
            var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));
            return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
          };
          SigningKey3.prototype.signDigest = function(digest) {
            var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
            var digestBytes = (0, bytes_1.arrayify)(digest);
            if (digestBytes.length !== 32) {
              logger19.throwArgumentError("bad digest length", "digest", digest);
            }
            var signature = keyPair.sign(digestBytes, { canonical: true });
            return (0, bytes_1.splitSignature)({
              recoveryParam: signature.recoveryParam,
              r: (0, bytes_1.hexZeroPad)("0x" + signature.r.toString(16), 32),
              s: (0, bytes_1.hexZeroPad)("0x" + signature.s.toString(16), 32)
            });
          };
          SigningKey3.prototype.computeSharedSecret = function(otherKey) {
            var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
            var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey2(otherKey)));
            return (0, bytes_1.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
          };
          SigningKey3.isSigningKey = function(value) {
            return !!(value && value._isSigningKey);
          };
          return SigningKey3;
        }()
      );
      exports2.SigningKey = SigningKey2;
      function recoverPublicKey3(digest, signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        var rs = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };
        return "0x" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest), rs, sig.recoveryParam).encode("hex", false);
      }
      exports2.recoverPublicKey = recoverPublicKey3;
      function computePublicKey2(key, compressed) {
        var bytes2 = (0, bytes_1.arrayify)(key);
        if (bytes2.length === 32) {
          var signingKey = new SigningKey2(bytes2);
          if (compressed) {
            return "0x" + getCurve().keyFromPrivate(bytes2).getPublic(true, "hex");
          }
          return signingKey.publicKey;
        } else if (bytes2.length === 33) {
          if (compressed) {
            return (0, bytes_1.hexlify)(bytes2);
          }
          return "0x" + getCurve().keyFromPublic(bytes2).getPublic(false, "hex");
        } else if (bytes2.length === 65) {
          if (!compressed) {
            return (0, bytes_1.hexlify)(bytes2);
          }
          return "0x" + getCurve().keyFromPublic(bytes2).getPublic(true, "hex");
        }
        return logger19.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
      }
      exports2.computePublicKey = computePublicKey2;
    }
  });

  // node_modules/@ethersproject/transactions/lib/_version.js
  var require_version13 = __commonJS({
    "node_modules/@ethersproject/transactions/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "transactions/5.7.0";
    }
  });

  // node_modules/@ethersproject/transactions/lib/index.js
  var require_lib17 = __commonJS({
    "node_modules/@ethersproject/transactions/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        Object.defineProperty(o3, k22, { enumerable: true, get: function() {
          return m5[k3];
        } });
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parse = exports2.serialize = exports2.accessListify = exports2.recoverAddress = exports2.computeAddress = exports2.TransactionTypes = void 0;
      var address_1 = require_lib7();
      var bignumber_1 = require_lib3();
      var bytes_1 = require_lib2();
      var constants_1 = require_lib8();
      var keccak256_1 = require_lib5();
      var properties_1 = require_lib4();
      var RLP2 = __importStar(require_lib6());
      var signing_key_1 = require_lib16();
      var logger_1 = require_lib();
      var _version_1 = require_version13();
      var logger19 = new logger_1.Logger(_version_1.version);
      var TransactionTypes2;
      (function(TransactionTypes3) {
        TransactionTypes3[TransactionTypes3["legacy"] = 0] = "legacy";
        TransactionTypes3[TransactionTypes3["eip2930"] = 1] = "eip2930";
        TransactionTypes3[TransactionTypes3["eip1559"] = 2] = "eip1559";
      })(TransactionTypes2 = exports2.TransactionTypes || (exports2.TransactionTypes = {}));
      function handleAddress(value) {
        if (value === "0x") {
          return null;
        }
        return (0, address_1.getAddress)(value);
      }
      function handleNumber(value) {
        if (value === "0x") {
          return constants_1.Zero;
        }
        return bignumber_1.BigNumber.from(value);
      }
      var transactionFields = [
        { name: "nonce", maxLength: 32, numeric: true },
        { name: "gasPrice", maxLength: 32, numeric: true },
        { name: "gasLimit", maxLength: 32, numeric: true },
        { name: "to", length: 20 },
        { name: "value", maxLength: 32, numeric: true },
        { name: "data" }
      ];
      var allowedTransactionKeys3 = {
        chainId: true,
        data: true,
        gasLimit: true,
        gasPrice: true,
        nonce: true,
        to: true,
        type: true,
        value: true
      };
      function computeAddress2(key) {
        var publicKey = (0, signing_key_1.computePublicKey)(key);
        return (0, address_1.getAddress)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.hexDataSlice)(publicKey, 1)), 12));
      }
      exports2.computeAddress = computeAddress2;
      function recoverAddress3(digest, signature) {
        return computeAddress2((0, signing_key_1.recoverPublicKey)((0, bytes_1.arrayify)(digest), signature));
      }
      exports2.recoverAddress = recoverAddress3;
      function formatNumber(value, name) {
        var result = (0, bytes_1.stripZeros)(bignumber_1.BigNumber.from(value).toHexString());
        if (result.length > 32) {
          logger19.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
        }
        return result;
      }
      function accessSetify(addr, storageKeys) {
        return {
          address: (0, address_1.getAddress)(addr),
          storageKeys: (storageKeys || []).map(function(storageKey, index2) {
            if ((0, bytes_1.hexDataLength)(storageKey) !== 32) {
              logger19.throwArgumentError("invalid access list storageKey", "accessList[" + addr + ":" + index2 + "]", storageKey);
            }
            return storageKey.toLowerCase();
          })
        };
      }
      function accessListify6(value) {
        if (Array.isArray(value)) {
          return value.map(function(set4, index2) {
            if (Array.isArray(set4)) {
              if (set4.length > 2) {
                logger19.throwArgumentError("access list expected to be [ address, storageKeys[] ]", "value[" + index2 + "]", set4);
              }
              return accessSetify(set4[0], set4[1]);
            }
            return accessSetify(set4.address, set4.storageKeys);
          });
        }
        var result = Object.keys(value).map(function(addr) {
          var storageKeys = value[addr].reduce(function(accum, storageKey) {
            accum[storageKey] = true;
            return accum;
          }, {});
          return accessSetify(addr, Object.keys(storageKeys).sort());
        });
        result.sort(function(a2, b4) {
          return a2.address.localeCompare(b4.address);
        });
        return result;
      }
      exports2.accessListify = accessListify6;
      function formatAccessList(value) {
        return accessListify6(value).map(function(set4) {
          return [set4.address, set4.storageKeys];
        });
      }
      function _serializeEip1559(transaction2, signature) {
        if (transaction2.gasPrice != null) {
          var gasPrice = bignumber_1.BigNumber.from(transaction2.gasPrice);
          var maxFeePerGas = bignumber_1.BigNumber.from(transaction2.maxFeePerGas || 0);
          if (!gasPrice.eq(maxFeePerGas)) {
            logger19.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
              gasPrice,
              maxFeePerGas
            });
          }
        }
        var fields = [
          formatNumber(transaction2.chainId || 0, "chainId"),
          formatNumber(transaction2.nonce || 0, "nonce"),
          formatNumber(transaction2.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
          formatNumber(transaction2.maxFeePerGas || 0, "maxFeePerGas"),
          formatNumber(transaction2.gasLimit || 0, "gasLimit"),
          transaction2.to != null ? (0, address_1.getAddress)(transaction2.to) : "0x",
          formatNumber(transaction2.value || 0, "value"),
          transaction2.data || "0x",
          formatAccessList(transaction2.accessList || [])
        ];
        if (signature) {
          var sig = (0, bytes_1.splitSignature)(signature);
          fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
          fields.push((0, bytes_1.stripZeros)(sig.r));
          fields.push((0, bytes_1.stripZeros)(sig.s));
        }
        return (0, bytes_1.hexConcat)(["0x02", RLP2.encode(fields)]);
      }
      function _serializeEip2930(transaction2, signature) {
        var fields = [
          formatNumber(transaction2.chainId || 0, "chainId"),
          formatNumber(transaction2.nonce || 0, "nonce"),
          formatNumber(transaction2.gasPrice || 0, "gasPrice"),
          formatNumber(transaction2.gasLimit || 0, "gasLimit"),
          transaction2.to != null ? (0, address_1.getAddress)(transaction2.to) : "0x",
          formatNumber(transaction2.value || 0, "value"),
          transaction2.data || "0x",
          formatAccessList(transaction2.accessList || [])
        ];
        if (signature) {
          var sig = (0, bytes_1.splitSignature)(signature);
          fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
          fields.push((0, bytes_1.stripZeros)(sig.r));
          fields.push((0, bytes_1.stripZeros)(sig.s));
        }
        return (0, bytes_1.hexConcat)(["0x01", RLP2.encode(fields)]);
      }
      function _serialize(transaction2, signature) {
        (0, properties_1.checkProperties)(transaction2, allowedTransactionKeys3);
        var raw = [];
        transactionFields.forEach(function(fieldInfo) {
          var value = transaction2[fieldInfo.name] || [];
          var options = {};
          if (fieldInfo.numeric) {
            options.hexPad = "left";
          }
          value = (0, bytes_1.arrayify)((0, bytes_1.hexlify)(value, options));
          if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
            logger19.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
          }
          if (fieldInfo.maxLength) {
            value = (0, bytes_1.stripZeros)(value);
            if (value.length > fieldInfo.maxLength) {
              logger19.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
            }
          }
          raw.push((0, bytes_1.hexlify)(value));
        });
        var chainId = 0;
        if (transaction2.chainId != null) {
          chainId = transaction2.chainId;
          if (typeof chainId !== "number") {
            logger19.throwArgumentError("invalid transaction.chainId", "transaction", transaction2);
          }
        } else if (signature && !(0, bytes_1.isBytesLike)(signature) && signature.v > 28) {
          chainId = Math.floor((signature.v - 35) / 2);
        }
        if (chainId !== 0) {
          raw.push((0, bytes_1.hexlify)(chainId));
          raw.push("0x");
          raw.push("0x");
        }
        if (!signature) {
          return RLP2.encode(raw);
        }
        var sig = (0, bytes_1.splitSignature)(signature);
        var v7 = 27 + sig.recoveryParam;
        if (chainId !== 0) {
          raw.pop();
          raw.pop();
          raw.pop();
          v7 += chainId * 2 + 8;
          if (sig.v > 28 && sig.v !== v7) {
            logger19.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
          }
        } else if (sig.v !== v7) {
          logger19.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
        raw.push((0, bytes_1.hexlify)(v7));
        raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.r)));
        raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.s)));
        return RLP2.encode(raw);
      }
      function serialize2(transaction2, signature) {
        if (transaction2.type == null || transaction2.type === 0) {
          if (transaction2.accessList != null) {
            logger19.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction2);
          }
          return _serialize(transaction2, signature);
        }
        switch (transaction2.type) {
          case 1:
            return _serializeEip2930(transaction2, signature);
          case 2:
            return _serializeEip1559(transaction2, signature);
          default:
            break;
        }
        return logger19.throwError("unsupported transaction type: " + transaction2.type, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "serializeTransaction",
          transactionType: transaction2.type
        });
      }
      exports2.serialize = serialize2;
      function _parseEipSignature(tx, fields, serialize3) {
        try {
          var recid = handleNumber(fields[0]).toNumber();
          if (recid !== 0 && recid !== 1) {
            throw new Error("bad recid");
          }
          tx.v = recid;
        } catch (error) {
          logger19.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
        }
        tx.r = (0, bytes_1.hexZeroPad)(fields[1], 32);
        tx.s = (0, bytes_1.hexZeroPad)(fields[2], 32);
        try {
          var digest = (0, keccak256_1.keccak256)(serialize3(tx));
          tx.from = recoverAddress3(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
        } catch (error) {
        }
      }
      function _parseEip1559(payload) {
        var transaction2 = RLP2.decode(payload.slice(1));
        if (transaction2.length !== 9 && transaction2.length !== 12) {
          logger19.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, bytes_1.hexlify)(payload));
        }
        var maxPriorityFeePerGas = handleNumber(transaction2[2]);
        var maxFeePerGas = handleNumber(transaction2[3]);
        var tx = {
          type: 2,
          chainId: handleNumber(transaction2[0]).toNumber(),
          nonce: handleNumber(transaction2[1]).toNumber(),
          maxPriorityFeePerGas,
          maxFeePerGas,
          gasPrice: null,
          gasLimit: handleNumber(transaction2[4]),
          to: handleAddress(transaction2[5]),
          value: handleNumber(transaction2[6]),
          data: transaction2[7],
          accessList: accessListify6(transaction2[8])
        };
        if (transaction2.length === 9) {
          return tx;
        }
        tx.hash = (0, keccak256_1.keccak256)(payload);
        _parseEipSignature(tx, transaction2.slice(9), _serializeEip1559);
        return tx;
      }
      function _parseEip2930(payload) {
        var transaction2 = RLP2.decode(payload.slice(1));
        if (transaction2.length !== 8 && transaction2.length !== 11) {
          logger19.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, bytes_1.hexlify)(payload));
        }
        var tx = {
          type: 1,
          chainId: handleNumber(transaction2[0]).toNumber(),
          nonce: handleNumber(transaction2[1]).toNumber(),
          gasPrice: handleNumber(transaction2[2]),
          gasLimit: handleNumber(transaction2[3]),
          to: handleAddress(transaction2[4]),
          value: handleNumber(transaction2[5]),
          data: transaction2[6],
          accessList: accessListify6(transaction2[7])
        };
        if (transaction2.length === 8) {
          return tx;
        }
        tx.hash = (0, keccak256_1.keccak256)(payload);
        _parseEipSignature(tx, transaction2.slice(8), _serializeEip2930);
        return tx;
      }
      function _parse(rawTransaction) {
        var transaction2 = RLP2.decode(rawTransaction);
        if (transaction2.length !== 9 && transaction2.length !== 6) {
          logger19.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
        }
        var tx = {
          nonce: handleNumber(transaction2[0]).toNumber(),
          gasPrice: handleNumber(transaction2[1]),
          gasLimit: handleNumber(transaction2[2]),
          to: handleAddress(transaction2[3]),
          value: handleNumber(transaction2[4]),
          data: transaction2[5],
          chainId: 0
        };
        if (transaction2.length === 6) {
          return tx;
        }
        try {
          tx.v = bignumber_1.BigNumber.from(transaction2[6]).toNumber();
        } catch (error) {
          return tx;
        }
        tx.r = (0, bytes_1.hexZeroPad)(transaction2[7], 32);
        tx.s = (0, bytes_1.hexZeroPad)(transaction2[8], 32);
        if (bignumber_1.BigNumber.from(tx.r).isZero() && bignumber_1.BigNumber.from(tx.s).isZero()) {
          tx.chainId = tx.v;
          tx.v = 0;
        } else {
          tx.chainId = Math.floor((tx.v - 35) / 2);
          if (tx.chainId < 0) {
            tx.chainId = 0;
          }
          var recoveryParam = tx.v - 27;
          var raw = transaction2.slice(0, 6);
          if (tx.chainId !== 0) {
            raw.push((0, bytes_1.hexlify)(tx.chainId));
            raw.push("0x");
            raw.push("0x");
            recoveryParam -= tx.chainId * 2 + 8;
          }
          var digest = (0, keccak256_1.keccak256)(RLP2.encode(raw));
          try {
            tx.from = recoverAddress3(digest, { r: (0, bytes_1.hexlify)(tx.r), s: (0, bytes_1.hexlify)(tx.s), recoveryParam });
          } catch (error) {
          }
          tx.hash = (0, keccak256_1.keccak256)(rawTransaction);
        }
        tx.type = null;
        return tx;
      }
      function parse2(rawTransaction) {
        var payload = (0, bytes_1.arrayify)(rawTransaction);
        if (payload[0] > 127) {
          return _parse(payload);
        }
        switch (payload[0]) {
          case 1:
            return _parseEip2930(payload);
          case 2:
            return _parseEip1559(payload);
          default:
            break;
        }
        return logger19.throwError("unsupported transaction type: " + payload[0], logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "parseTransaction",
          transactionType: payload[0]
        });
      }
      exports2.parse = parse2;
    }
  });

  // node_modules/@ethersproject/basex/lib/index.js
  var require_lib18 = __commonJS({
    "node_modules/@ethersproject/basex/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Base58 = exports2.Base32 = exports2.BaseX = void 0;
      var bytes_1 = require_lib2();
      var properties_1 = require_lib4();
      var BaseX = (
        /** @class */
        function() {
          function BaseX2(alphabet2) {
            (0, properties_1.defineReadOnly)(this, "alphabet", alphabet2);
            (0, properties_1.defineReadOnly)(this, "base", alphabet2.length);
            (0, properties_1.defineReadOnly)(this, "_alphabetMap", {});
            (0, properties_1.defineReadOnly)(this, "_leader", alphabet2.charAt(0));
            for (var i4 = 0; i4 < alphabet2.length; i4++) {
              this._alphabetMap[alphabet2.charAt(i4)] = i4;
            }
          }
          BaseX2.prototype.encode = function(value) {
            var source = (0, bytes_1.arrayify)(value);
            if (source.length === 0) {
              return "";
            }
            var digits = [0];
            for (var i4 = 0; i4 < source.length; ++i4) {
              var carry = source[i4];
              for (var j3 = 0; j3 < digits.length; ++j3) {
                carry += digits[j3] << 8;
                digits[j3] = carry % this.base;
                carry = carry / this.base | 0;
              }
              while (carry > 0) {
                digits.push(carry % this.base);
                carry = carry / this.base | 0;
              }
            }
            var string = "";
            for (var k3 = 0; source[k3] === 0 && k3 < source.length - 1; ++k3) {
              string += this._leader;
            }
            for (var q4 = digits.length - 1; q4 >= 0; --q4) {
              string += this.alphabet[digits[q4]];
            }
            return string;
          };
          BaseX2.prototype.decode = function(value) {
            if (typeof value !== "string") {
              throw new TypeError("Expected String");
            }
            var bytes2 = [];
            if (value.length === 0) {
              return new Uint8Array(bytes2);
            }
            bytes2.push(0);
            for (var i4 = 0; i4 < value.length; i4++) {
              var byte = this._alphabetMap[value[i4]];
              if (byte === void 0) {
                throw new Error("Non-base" + this.base + " character");
              }
              var carry = byte;
              for (var j3 = 0; j3 < bytes2.length; ++j3) {
                carry += bytes2[j3] * this.base;
                bytes2[j3] = carry & 255;
                carry >>= 8;
              }
              while (carry > 0) {
                bytes2.push(carry & 255);
                carry >>= 8;
              }
            }
            for (var k3 = 0; value[k3] === this._leader && k3 < value.length - 1; ++k3) {
              bytes2.push(0);
            }
            return (0, bytes_1.arrayify)(new Uint8Array(bytes2.reverse()));
          };
          return BaseX2;
        }()
      );
      exports2.BaseX = BaseX;
      var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
      exports2.Base32 = Base32;
      var Base582 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
      exports2.Base58 = Base582;
    }
  });

  // node_modules/@ethersproject/sha2/lib/types.js
  var require_types = __commonJS({
    "node_modules/@ethersproject/sha2/lib/types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SupportedAlgorithm = void 0;
      var SupportedAlgorithm2;
      (function(SupportedAlgorithm3) {
        SupportedAlgorithm3["sha256"] = "sha256";
        SupportedAlgorithm3["sha512"] = "sha512";
      })(SupportedAlgorithm2 = exports2.SupportedAlgorithm || (exports2.SupportedAlgorithm = {}));
    }
  });

  // node_modules/@ethersproject/sha2/lib/_version.js
  var require_version14 = __commonJS({
    "node_modules/@ethersproject/sha2/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "sha2/5.7.0";
    }
  });

  // node_modules/@ethersproject/sha2/lib/browser-sha2.js
  var require_browser_sha2 = __commonJS({
    "node_modules/@ethersproject/sha2/lib/browser-sha2.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.computeHmac = exports2.sha512 = exports2.sha256 = exports2.ripemd160 = void 0;
      var hash_js_1 = __importDefault(require_hash());
      var bytes_1 = require_lib2();
      var types_1 = require_types();
      var logger_1 = require_lib();
      var _version_1 = require_version14();
      var logger19 = new logger_1.Logger(_version_1.version);
      function ripemd1603(data) {
        return "0x" + hash_js_1.default.ripemd160().update((0, bytes_1.arrayify)(data)).digest("hex");
      }
      exports2.ripemd160 = ripemd1603;
      function sha2564(data) {
        return "0x" + hash_js_1.default.sha256().update((0, bytes_1.arrayify)(data)).digest("hex");
      }
      exports2.sha256 = sha2564;
      function sha5123(data) {
        return "0x" + hash_js_1.default.sha512().update((0, bytes_1.arrayify)(data)).digest("hex");
      }
      exports2.sha512 = sha5123;
      function computeHmac2(algorithm, key, data) {
        if (!types_1.SupportedAlgorithm[algorithm]) {
          logger19.throwError("unsupported algorithm " + algorithm, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "hmac",
            algorithm
          });
        }
        return "0x" + hash_js_1.default.hmac(hash_js_1.default[algorithm], (0, bytes_1.arrayify)(key)).update((0, bytes_1.arrayify)(data)).digest("hex");
      }
      exports2.computeHmac = computeHmac2;
    }
  });

  // node_modules/@ethersproject/sha2/lib/index.js
  var require_lib19 = __commonJS({
    "node_modules/@ethersproject/sha2/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SupportedAlgorithm = exports2.sha512 = exports2.sha256 = exports2.ripemd160 = exports2.computeHmac = void 0;
      var sha2_1 = require_browser_sha2();
      Object.defineProperty(exports2, "computeHmac", { enumerable: true, get: function() {
        return sha2_1.computeHmac;
      } });
      Object.defineProperty(exports2, "ripemd160", { enumerable: true, get: function() {
        return sha2_1.ripemd160;
      } });
      Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
        return sha2_1.sha256;
      } });
      Object.defineProperty(exports2, "sha512", { enumerable: true, get: function() {
        return sha2_1.sha512;
      } });
      var types_1 = require_types();
      Object.defineProperty(exports2, "SupportedAlgorithm", { enumerable: true, get: function() {
        return types_1.SupportedAlgorithm;
      } });
    }
  });

  // node_modules/@ethersproject/pbkdf2/lib/browser-pbkdf2.js
  var require_browser_pbkdf2 = __commonJS({
    "node_modules/@ethersproject/pbkdf2/lib/browser-pbkdf2.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.pbkdf2 = void 0;
      var bytes_1 = require_lib2();
      var sha2_1 = require_lib19();
      function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
        password = (0, bytes_1.arrayify)(password);
        salt = (0, bytes_1.arrayify)(salt);
        var hLen;
        var l4 = 1;
        var DK = new Uint8Array(keylen);
        var block1 = new Uint8Array(salt.length + 4);
        block1.set(salt);
        var r2;
        var T4;
        for (var i4 = 1; i4 <= l4; i4++) {
          block1[salt.length] = i4 >> 24 & 255;
          block1[salt.length + 1] = i4 >> 16 & 255;
          block1[salt.length + 2] = i4 >> 8 & 255;
          block1[salt.length + 3] = i4 & 255;
          var U7 = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(hashAlgorithm, password, block1));
          if (!hLen) {
            hLen = U7.length;
            T4 = new Uint8Array(hLen);
            l4 = Math.ceil(keylen / hLen);
            r2 = keylen - (l4 - 1) * hLen;
          }
          T4.set(U7);
          for (var j3 = 1; j3 < iterations; j3++) {
            U7 = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(hashAlgorithm, password, U7));
            for (var k3 = 0; k3 < hLen; k3++)
              T4[k3] ^= U7[k3];
          }
          var destPos = (i4 - 1) * hLen;
          var len = i4 === l4 ? r2 : hLen;
          DK.set((0, bytes_1.arrayify)(T4).slice(0, len), destPos);
        }
        return (0, bytes_1.hexlify)(DK);
      }
      exports2.pbkdf2 = pbkdf2;
    }
  });

  // node_modules/@ethersproject/pbkdf2/lib/index.js
  var require_lib20 = __commonJS({
    "node_modules/@ethersproject/pbkdf2/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.pbkdf2 = void 0;
      var pbkdf2_1 = require_browser_pbkdf2();
      Object.defineProperty(exports2, "pbkdf2", { enumerable: true, get: function() {
        return pbkdf2_1.pbkdf2;
      } });
    }
  });

  // node_modules/@ethersproject/wordlists/lib/_version.js
  var require_version15 = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "wordlists/5.7.0";
    }
  });

  // node_modules/@ethersproject/wordlists/lib/wordlist.js
  var require_wordlist = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/wordlist.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Wordlist = exports2.logger = void 0;
      var exportWordlist = false;
      var hash_1 = require_lib12();
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version15();
      exports2.logger = new logger_1.Logger(_version_1.version);
      var Wordlist2 = (
        /** @class */
        function() {
          function Wordlist3(locale) {
            var _newTarget = this.constructor;
            exports2.logger.checkAbstract(_newTarget, Wordlist3);
            (0, properties_1.defineReadOnly)(this, "locale", locale);
          }
          Wordlist3.prototype.split = function(mnemonic) {
            return mnemonic.toLowerCase().split(/ +/g);
          };
          Wordlist3.prototype.join = function(words) {
            return words.join(" ");
          };
          Wordlist3.check = function(wordlist10) {
            var words = [];
            for (var i4 = 0; i4 < 2048; i4++) {
              var word = wordlist10.getWord(i4);
              if (i4 !== wordlist10.getWordIndex(word)) {
                return "0x";
              }
              words.push(word);
            }
            return (0, hash_1.id)(words.join("\n") + "\n");
          };
          Wordlist3.register = function(lang, name) {
            if (!name) {
              name = lang.locale;
            }
            if (exportWordlist) {
              try {
                var anyGlobal = window;
                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
                  if (!anyGlobal._ethers.wordlists[name]) {
                    (0, properties_1.defineReadOnly)(anyGlobal._ethers.wordlists, name, lang);
                  }
                }
              } catch (error) {
              }
            }
          };
          return Wordlist3;
        }()
      );
      exports2.Wordlist = Wordlist2;
    }
  });

  // node_modules/@ethersproject/wordlists/lib/lang-cz.js
  var require_lang_cz = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/lang-cz.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.langCz = void 0;
      var wordlist_1 = require_wordlist();
      var words = "AbdikaceAbecedaAdresaAgreseAkceAktovkaAlejAlkoholAmputaceAnanasAndulkaAnekdotaAnketaAntikaAnulovatArchaAroganceAsfaltAsistentAspiraceAstmaAstronomAtlasAtletikaAtolAutobusAzylBabkaBachorBacilBaculkaBadatelBagetaBagrBahnoBakterieBaladaBaletkaBalkonBalonekBalvanBalzaBambusBankomatBarbarBaretBarmanBarokoBarvaBaterkaBatohBavlnaBazalkaBazilikaBazukaBednaBeranBesedaBestieBetonBezinkaBezmocBeztakBicyklBidloBiftekBikinyBilanceBiografBiologBitvaBizonBlahobytBlatouchBlechaBleduleBleskBlikatBliznaBlokovatBlouditBludBobekBobrBodlinaBodnoutBohatostBojkotBojovatBokorysBolestBorecBoroviceBotaBoubelBouchatBoudaBouleBouratBoxerBradavkaBramboraBrankaBratrBreptaBriketaBrkoBrlohBronzBroskevBrunetkaBrusinkaBrzdaBrzyBublinaBubnovatBuchtaBuditelBudkaBudovaBufetBujarostBukviceBuldokBulvaBundaBunkrBurzaButikBuvolBuzolaBydletBylinaBytovkaBzukotCapartCarevnaCedrCeduleCejchCejnCelaCelerCelkemCelniceCeninaCennostCenovkaCentrumCenzorCestopisCetkaChalupaChapadloCharitaChataChechtatChemieChichotChirurgChladChlebaChlubitChmelChmuraChobotChocholChodbaCholeraChomoutChopitChorobaChovChrapotChrlitChrtChrupChtivostChudinaChutnatChvatChvilkaChvostChybaChystatChytitCibuleCigaretaCihelnaCihlaCinkotCirkusCisternaCitaceCitrusCizinecCizostClonaCokolivCouvatCtitelCtnostCudnostCuketaCukrCupotCvaknoutCvalCvikCvrkotCyklistaDalekoDarebaDatelDatumDceraDebataDechovkaDecibelDeficitDeflaceDeklDekretDemokratDepreseDerbyDeskaDetektivDikobrazDiktovatDiodaDiplomDiskDisplejDivadloDivochDlahaDlouhoDluhopisDnesDobroDobytekDocentDochutitDodnesDohledDohodaDohraDojemDojniceDokladDokolaDoktorDokumentDolarDolevaDolinaDomaDominantDomluvitDomovDonutitDopadDopisDoplnitDoposudDoprovodDopustitDorazitDorostDortDosahDoslovDostatekDosudDosytaDotazDotekDotknoutDoufatDoutnatDovozceDozaduDoznatDozorceDrahotaDrakDramatikDravecDrazeDrdolDrobnostDrogerieDrozdDrsnostDrtitDrzostDubenDuchovnoDudekDuhaDuhovkaDusitDusnoDutostDvojiceDvorecDynamitEkologEkonomieElektronElipsaEmailEmiseEmoceEmpatieEpizodaEpochaEpopejEposEsejEsenceEskortaEskymoEtiketaEuforieEvoluceExekuceExkurzeExpediceExplozeExportExtraktFackaFajfkaFakultaFanatikFantazieFarmacieFavoritFazoleFederaceFejetonFenkaFialkaFigurantFilozofFiltrFinanceFintaFixaceFjordFlanelFlirtFlotilaFondFosforFotbalFotkaFotonFrakceFreskaFrontaFukarFunkceFyzikaGalejeGarantGenetikaGeologGilotinaGlazuraGlejtGolemGolfistaGotikaGrafGramofonGranuleGrepGrilGrogGroteskaGumaHadiceHadrHalaHalenkaHanbaHanopisHarfaHarpunaHavranHebkostHejkalHejnoHejtmanHektarHelmaHematomHerecHernaHesloHezkyHistorikHladovkaHlasivkyHlavaHledatHlenHlodavecHlohHloupostHltatHlubinaHluchotaHmatHmotaHmyzHnisHnojivoHnoutHoblinaHobojHochHodinyHodlatHodnotaHodovatHojnostHokejHolinkaHolkaHolubHomoleHonitbaHonoraceHoralHordaHorizontHorkoHorlivecHormonHorninaHoroskopHorstvoHospodaHostinaHotovostHoubaHoufHoupatHouskaHovorHradbaHraniceHravostHrazdaHrbolekHrdinaHrdloHrdostHrnekHrobkaHromadaHrotHroudaHrozenHrstkaHrubostHryzatHubenostHubnoutHudbaHukotHumrHusitaHustotaHvozdHybnostHydrantHygienaHymnaHysterikIdylkaIhnedIkonaIluzeImunitaInfekceInflaceInkasoInovaceInspekceInternetInvalidaInvestorInzerceIronieJablkoJachtaJahodaJakmileJakostJalovecJantarJarmarkJaroJasanJasnoJatkaJavorJazykJedinecJedleJednatelJehlanJekotJelenJelitoJemnostJenomJepiceJeseterJevitJezdecJezeroJinakJindyJinochJiskraJistotaJitrniceJizvaJmenovatJogurtJurtaKabaretKabelKabinetKachnaKadetKadidloKahanKajakKajutaKakaoKaktusKalamitaKalhotyKalibrKalnostKameraKamkolivKamnaKanibalKanoeKantorKapalinaKapelaKapitolaKapkaKapleKapotaKaprKapustaKapybaraKaramelKarotkaKartonKasaKatalogKatedraKauceKauzaKavalecKazajkaKazetaKazivostKdekolivKdesiKedlubenKempKeramikaKinoKlacekKladivoKlamKlapotKlasikaKlaunKlecKlenbaKlepatKlesnoutKlidKlimaKlisnaKloboukKlokanKlopaKloubKlubovnaKlusatKluzkostKmenKmitatKmotrKnihaKnotKoaliceKoberecKobkaKoblihaKobylaKocourKohoutKojenecKokosKoktejlKolapsKoledaKolizeKoloKomandoKometaKomikKomnataKomoraKompasKomunitaKonatKonceptKondiceKonecKonfeseKongresKoninaKonkursKontaktKonzervaKopanecKopieKopnoutKoprovkaKorbelKorektorKormidloKoroptevKorpusKorunaKorytoKorzetKosatecKostkaKotelKotletaKotoulKoukatKoupelnaKousekKouzloKovbojKozaKozorohKrabiceKrachKrajinaKralovatKrasopisKravataKreditKrejcarKresbaKrevetaKriketKritikKrizeKrkavecKrmelecKrmivoKrocanKrokKronikaKropitKroupaKrovkaKrtekKruhadloKrupiceKrutostKrvinkaKrychleKryptaKrystalKrytKudlankaKufrKujnostKuklaKulajdaKulichKulkaKulometKulturaKunaKupodivuKurtKurzorKutilKvalitaKvasinkaKvestorKynologKyselinaKytaraKyticeKytkaKytovecKyvadloLabradorLachtanLadnostLaikLakomecLamelaLampaLanovkaLasiceLasoLasturaLatinkaLavinaLebkaLeckdyLedenLedniceLedovkaLedvinaLegendaLegieLegraceLehceLehkostLehnoutLektvarLenochodLentilkaLepenkaLepidloLetadloLetecLetmoLetokruhLevhartLevitaceLevobokLibraLichotkaLidojedLidskostLihovinaLijavecLilekLimetkaLinieLinkaLinoleumListopadLitinaLitovatLobistaLodivodLogikaLogopedLokalitaLoketLomcovatLopataLopuchLordLososLotrLoudalLouhLoukaLouskatLovecLstivostLucernaLuciferLumpLuskLustraceLviceLyraLyrikaLysinaMadamMadloMagistrMahagonMajetekMajitelMajoritaMakakMakoviceMakrelaMalbaMalinaMalovatMalviceMaminkaMandleMankoMarnostMasakrMaskotMasopustMaticeMatrikaMaturitaMazanecMazivoMazlitMazurkaMdlobaMechanikMeditaceMedovinaMelasaMelounMentolkaMetlaMetodaMetrMezeraMigraceMihnoutMihuleMikinaMikrofonMilenecMilimetrMilostMimikaMincovnaMinibarMinometMinulostMiskaMistrMixovatMladostMlhaMlhovinaMlokMlsatMluvitMnichMnohemMobilMocnostModelkaModlitbaMohylaMokroMolekulaMomentkaMonarchaMonoklMonstrumMontovatMonzunMosazMoskytMostMotivaceMotorkaMotykaMouchaMoudrostMozaikaMozekMozolMramorMravenecMrkevMrtvolaMrzetMrzutostMstitelMudrcMuflonMulatMumieMuniceMusetMutaceMuzeumMuzikantMyslivecMzdaNabouratNachytatNadaceNadbytekNadhozNadobroNadpisNahlasNahnatNahodileNahraditNaivitaNajednouNajistoNajmoutNaklonitNakonecNakrmitNalevoNamazatNamluvitNanometrNaokoNaopakNaostroNapadatNapevnoNaplnitNapnoutNaposledNaprostoNaroditNarubyNarychloNasaditNasekatNaslepoNastatNatolikNavenekNavrchNavzdoryNazvatNebeNechatNeckyNedalekoNedbatNeduhNegaceNehetNehodaNejenNejprveNeklidNelibostNemilostNemocNeochotaNeonkaNepokojNerostNervNesmyslNesouladNetvorNeuronNevinaNezvykleNicotaNijakNikamNikdyNiklNikterakNitroNoclehNohaviceNominaceNoraNorekNositelNosnostNouzeNovinyNovotaNozdraNudaNudleNugetNutitNutnostNutrieNymfaObalObarvitObavaObdivObecObehnatObejmoutObezitaObhajobaObilniceObjasnitObjektObklopitOblastOblekOblibaOblohaObludaObnosObohatitObojekOboutObrazecObrnaObrubaObrysObsahObsluhaObstaratObuvObvazObvinitObvodObvykleObyvatelObzorOcasOcelOcenitOchladitOchotaOchranaOcitnoutOdbojOdbytOdchodOdcizitOdebratOdeslatOdevzdatOdezvaOdhadceOdhoditOdjetOdjinudOdkazOdkoupitOdlivOdlukaOdmlkaOdolnostOdpadOdpisOdploutOdporOdpustitOdpykatOdrazkaOdsouditOdstupOdsunOdtokOdtudOdvahaOdvetaOdvolatOdvracetOdznakOfinaOfsajdOhlasOhniskoOhradaOhrozitOhryzekOkapOkeniceOklikaOknoOkouzlitOkovyOkrasaOkresOkrsekOkruhOkupantOkurkaOkusitOlejninaOlizovatOmakOmeletaOmezitOmladinaOmlouvatOmluvaOmylOnehdyOpakovatOpasekOperaceOpiceOpilostOpisovatOporaOpoziceOpravduOprotiOrbitalOrchestrOrgieOrliceOrlojOrtelOsadaOschnoutOsikaOsivoOslavaOslepitOslnitOslovitOsnovaOsobaOsolitOspalecOstenOstrahaOstudaOstychOsvojitOteplitOtiskOtopOtrhatOtrlostOtrokOtrubyOtvorOvanoutOvarOvesOvlivnitOvoceOxidOzdobaPachatelPacientPadouchPahorekPaktPalandaPalecPalivoPalubaPamfletPamlsekPanenkaPanikaPannaPanovatPanstvoPantoflePaprikaParketaParodiePartaParukaParybaPasekaPasivitaPastelkaPatentPatronaPavoukPaznehtPazourekPeckaPedagogPejsekPekloPelotonPenaltaPendrekPenzePeriskopPeroPestrostPetardaPeticePetrolejPevninaPexesoPianistaPihaPijavicePiklePiknikPilinaPilnostPilulkaPinzetaPipetaPisatelPistolePitevnaPivnicePivovarPlacentaPlakatPlamenPlanetaPlastikaPlatitPlavidloPlazPlechPlemenoPlentaPlesPletivoPlevelPlivatPlnitPlnoPlochaPlodinaPlombaPloutPlukPlynPobavitPobytPochodPocitPoctivecPodatPodcenitPodepsatPodhledPodivitPodkladPodmanitPodnikPodobaPodporaPodrazPodstataPodvodPodzimPoeziePohankaPohnutkaPohovorPohromaPohybPointaPojistkaPojmoutPokazitPoklesPokojPokrokPokutaPokynPolednePolibekPolknoutPolohaPolynomPomaluPominoutPomlkaPomocPomstaPomysletPonechatPonorkaPonurostPopadatPopelPopisekPoplachPoprositPopsatPopudPoradcePorcePorodPoruchaPoryvPosaditPosedPosilaPoskokPoslanecPosouditPospoluPostavaPosudekPosypPotahPotkanPotleskPotomekPotravaPotupaPotvoraPoukazPoutoPouzdroPovahaPovidlaPovlakPovozPovrchPovstatPovykPovzdechPozdravPozemekPoznatekPozorPozvatPracovatPrahoryPraktikaPralesPraotecPraporekPrasePravdaPrincipPrknoProbuditProcentoProdejProfeseProhraProjektProlomitPromilePronikatPropadProrokProsbaProtonProutekProvazPrskavkaPrstenPrudkostPrutPrvekPrvohoryPsanecPsovodPstruhPtactvoPubertaPuchPudlPukavecPuklinaPukrlePultPumpaPuncPupenPusaPusinkaPustinaPutovatPutykaPyramidaPyskPytelRacekRachotRadiaceRadniceRadonRaftRagbyRaketaRakovinaRamenoRampouchRandeRarachRaritaRasovnaRastrRatolestRazanceRazidloReagovatReakceReceptRedaktorReferentReflexRejnokReklamaRekordRekrutRektorReputaceRevizeRevmaRevolverRezervaRiskovatRizikoRobotikaRodokmenRohovkaRokleRokokoRomanetoRopovodRopuchaRorejsRosolRostlinaRotmistrRotopedRotundaRoubenkaRouchoRoupRouraRovinaRovniceRozborRozchodRozdatRozeznatRozhodceRozinkaRozjezdRozkazRozlohaRozmarRozpadRozruchRozsahRoztokRozumRozvodRubrikaRuchadloRukaviceRukopisRybaRybolovRychlostRydloRypadloRytinaRyzostSadistaSahatSakoSamecSamizdatSamotaSanitkaSardinkaSasankaSatelitSazbaSazeniceSborSchovatSebrankaSeceseSedadloSedimentSedloSehnatSejmoutSekeraSektaSekundaSekvojeSemenoSenoServisSesaditSeshoraSeskokSeslatSestraSesuvSesypatSetbaSetinaSetkatSetnoutSetrvatSeverSeznamShodaShrnoutSifonSilniceSirkaSirotekSirupSituaceSkafandrSkaliskoSkanzenSkautSkeptikSkicaSkladbaSkleniceSkloSkluzSkobaSkokanSkoroSkriptaSkrzSkupinaSkvostSkvrnaSlabikaSladidloSlaninaSlastSlavnostSledovatSlepecSlevaSlezinaSlibSlinaSlizniceSlonSloupekSlovoSluchSluhaSlunceSlupkaSlzaSmaragdSmetanaSmilstvoSmlouvaSmogSmradSmrkSmrtkaSmutekSmyslSnadSnahaSnobSobotaSochaSodovkaSokolSopkaSotvaSoubojSoucitSoudceSouhlasSouladSoumrakSoupravaSousedSoutokSouvisetSpalovnaSpasitelSpisSplavSpodekSpojenecSpoluSponzorSpornostSpoustaSprchaSpustitSrandaSrazSrdceSrnaSrnecSrovnatSrpenSrstSrubStaniceStarostaStatikaStavbaStehnoStezkaStodolaStolekStopaStornoStoupatStrachStresStrhnoutStromStrunaStudnaStupniceStvolStykSubjektSubtropySucharSudostSuknoSundatSunoutSurikataSurovinaSvahSvalstvoSvetrSvatbaSvazekSvisleSvitekSvobodaSvodidloSvorkaSvrabSykavkaSykotSynekSynovecSypatSypkostSyrovostSyselSytostTabletkaTabuleTahounTajemnoTajfunTajgaTajitTajnostTaktikaTamhleTamponTancovatTanecTankerTapetaTaveninaTazatelTechnikaTehdyTekutinaTelefonTemnotaTendenceTenistaTenorTeplotaTepnaTeprveTerapieTermoskaTextilTichoTiskopisTitulekTkadlecTkaninaTlapkaTleskatTlukotTlupaTmelToaletaTopinkaTopolTorzoTouhaToulecTradiceTraktorTrampTrasaTraverzaTrefitTrestTrezorTrhavinaTrhlinaTrochuTrojiceTroskaTroubaTrpceTrpitelTrpkostTrubecTruchlitTruhliceTrusTrvatTudyTuhnoutTuhostTundraTuristaTurnajTuzemskoTvarohTvorbaTvrdostTvrzTygrTykevUbohostUbozeUbratUbrousekUbrusUbytovnaUchoUctivostUdivitUhraditUjednatUjistitUjmoutUkazatelUklidnitUklonitUkotvitUkrojitUliceUlitaUlovitUmyvadloUnavitUniformaUniknoutUpadnoutUplatnitUplynoutUpoutatUpravitUranUrazitUsednoutUsilovatUsmrtitUsnadnitUsnoutUsouditUstlatUstrnoutUtahovatUtkatUtlumitUtonoutUtopenecUtrousitUvalitUvolnitUvozovkaUzdravitUzelUzeninaUzlinaUznatVagonValchaValounVanaVandalVanilkaVaranVarhanyVarovatVcelkuVchodVdovaVedroVegetaceVejceVelbloudVeletrhVelitelVelmocVelrybaVenkovVerandaVerzeVeselkaVeskrzeVesniceVespoduVestaVeterinaVeverkaVibraceVichrVideohraVidinaVidleVilaViniceVisetVitalitaVizeVizitkaVjezdVkladVkusVlajkaVlakVlasecVlevoVlhkostVlivVlnovkaVloupatVnucovatVnukVodaVodivostVodoznakVodstvoVojenskyVojnaVojskoVolantVolbaVolitVolnoVoskovkaVozidloVozovnaVpravoVrabecVracetVrahVrataVrbaVrcholekVrhatVrstvaVrtuleVsaditVstoupitVstupVtipVybavitVybratVychovatVydatVydraVyfotitVyhledatVyhnoutVyhoditVyhraditVyhubitVyjasnitVyjetVyjmoutVyklopitVykonatVylekatVymazatVymezitVymizetVymysletVynechatVynikatVynutitVypadatVyplatitVypravitVypustitVyrazitVyrovnatVyrvatVyslovitVysokoVystavitVysunoutVysypatVytasitVytesatVytratitVyvinoutVyvolatVyvrhelVyzdobitVyznatVzaduVzbuditVzchopitVzdorVzduchVzdychatVzestupVzhledemVzkazVzlykatVznikVzorekVzpouraVztahVztekXylofonZabratZabydletZachovatZadarmoZadusitZafoukatZahltitZahoditZahradaZahynoutZajatecZajetZajistitZaklepatZakoupitZalepitZamezitZamotatZamysletZanechatZanikatZaplatitZapojitZapsatZarazitZastavitZasunoutZatajitZatemnitZatknoutZaujmoutZavalitZaveletZavinitZavolatZavrtatZazvonitZbavitZbrusuZbudovatZbytekZdalekaZdarmaZdatnostZdivoZdobitZdrojZdvihZdymadloZeleninaZemanZeminaZeptatZezaduZezdolaZhatitZhltnoutZhlubokaZhotovitZhrubaZimaZimniceZjemnitZklamatZkoumatZkratkaZkumavkaZlatoZlehkaZlobaZlomZlostZlozvykZmapovatZmarZmatekZmijeZmizetZmocnitZmodratZmrzlinaZmutovatZnakZnalostZnamenatZnovuZobrazitZotavitZoubekZoufaleZploditZpomalitZpravaZprostitZprudkaZprvuZradaZranitZrcadloZrnitostZrnoZrovnaZrychlitZrzavostZtichaZtratitZubovinaZubrZvednoutZvenkuZveselaZvonZvratZvukovodZvyk";
      var wordlist10 = null;
      function loadWords(lang) {
        if (wordlist10 != null) {
          return;
        }
        wordlist10 = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
        if (wordlist_1.Wordlist.check(lang) !== "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a") {
          wordlist10 = null;
          throw new Error("BIP39 Wordlist for en (English) FAILED");
        }
      }
      var LangCz = (
        /** @class */
        function(_super) {
          __extends2(LangCz2, _super);
          function LangCz2() {
            return _super.call(this, "cz") || this;
          }
          LangCz2.prototype.getWord = function(index2) {
            loadWords(this);
            return wordlist10[index2];
          };
          LangCz2.prototype.getWordIndex = function(word) {
            loadWords(this);
            return wordlist10.indexOf(word);
          };
          return LangCz2;
        }(wordlist_1.Wordlist)
      );
      var langCz = new LangCz();
      exports2.langCz = langCz;
      wordlist_1.Wordlist.register(langCz);
    }
  });

  // node_modules/@ethersproject/wordlists/lib/lang-en.js
  var require_lang_en = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/lang-en.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.langEn = void 0;
      var wordlist_1 = require_wordlist();
      var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
      var wordlist10 = null;
      function loadWords(lang) {
        if (wordlist10 != null) {
          return;
        }
        wordlist10 = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
        if (wordlist_1.Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
          wordlist10 = null;
          throw new Error("BIP39 Wordlist for en (English) FAILED");
        }
      }
      var LangEn = (
        /** @class */
        function(_super) {
          __extends2(LangEn2, _super);
          function LangEn2() {
            return _super.call(this, "en") || this;
          }
          LangEn2.prototype.getWord = function(index2) {
            loadWords(this);
            return wordlist10[index2];
          };
          LangEn2.prototype.getWordIndex = function(word) {
            loadWords(this);
            return wordlist10.indexOf(word);
          };
          return LangEn2;
        }(wordlist_1.Wordlist)
      );
      var langEn = new LangEn();
      exports2.langEn = langEn;
      wordlist_1.Wordlist.register(langEn);
    }
  });

  // node_modules/@ethersproject/wordlists/lib/lang-es.js
  var require_lang_es = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/lang-es.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.langEs = void 0;
      var strings_1 = require_lib9();
      var wordlist_1 = require_wordlist();
      var words = "A/bacoAbdomenAbejaAbiertoAbogadoAbonoAbortoAbrazoAbrirAbueloAbusoAcabarAcademiaAccesoAccio/nAceiteAcelgaAcentoAceptarA/cidoAclararAcne/AcogerAcosoActivoActoActrizActuarAcudirAcuerdoAcusarAdictoAdmitirAdoptarAdornoAduanaAdultoAe/reoAfectarAficio/nAfinarAfirmarA/gilAgitarAgoni/aAgostoAgotarAgregarAgrioAguaAgudoA/guilaAgujaAhogoAhorroAireAislarAjedrezAjenoAjusteAlacra/nAlambreAlarmaAlbaA/lbumAlcaldeAldeaAlegreAlejarAlertaAletaAlfilerAlgaAlgodo/nAliadoAlientoAlivioAlmaAlmejaAlmi/barAltarAltezaAltivoAltoAlturaAlumnoAlzarAmableAmanteAmapolaAmargoAmasarA/mbarA/mbitoAmenoAmigoAmistadAmorAmparoAmplioAnchoAncianoAnclaAndarAnde/nAnemiaA/nguloAnilloA/nimoAni/sAnotarAntenaAntiguoAntojoAnualAnularAnuncioA~adirA~ejoA~oApagarAparatoApetitoApioAplicarApodoAporteApoyoAprenderAprobarApuestaApuroAradoAra~aArarA/rbitroA/rbolArbustoArchivoArcoArderArdillaArduoA/reaA/ridoAriesArmoni/aArne/sAromaArpaArpo/nArregloArrozArrugaArteArtistaAsaAsadoAsaltoAscensoAsegurarAseoAsesorAsientoAsiloAsistirAsnoAsombroA/speroAstillaAstroAstutoAsumirAsuntoAtajoAtaqueAtarAtentoAteoA/ticoAtletaA/tomoAtraerAtrozAtu/nAudazAudioAugeAulaAumentoAusenteAutorAvalAvanceAvaroAveAvellanaAvenaAvestruzAvio/nAvisoAyerAyudaAyunoAzafra/nAzarAzoteAzu/carAzufreAzulBabaBaborBacheBahi/aBaileBajarBalanzaBalco/nBaldeBambu/BancoBandaBa~oBarbaBarcoBarnizBarroBa/sculaBasto/nBasuraBatallaBateri/aBatirBatutaBau/lBazarBebe/BebidaBelloBesarBesoBestiaBichoBienBingoBlancoBloqueBlusaBoaBobinaBoboBocaBocinaBodaBodegaBoinaBolaBoleroBolsaBombaBondadBonitoBonoBonsa/iBordeBorrarBosqueBoteBoti/nBo/vedaBozalBravoBrazoBrechaBreveBrilloBrincoBrisaBrocaBromaBronceBroteBrujaBruscoBrutoBuceoBucleBuenoBueyBufandaBufo/nBu/hoBuitreBultoBurbujaBurlaBurroBuscarButacaBuzo/nCaballoCabezaCabinaCabraCacaoCada/verCadenaCaerCafe/Cai/daCaima/nCajaCajo/nCalCalamarCalcioCaldoCalidadCalleCalmaCalorCalvoCamaCambioCamelloCaminoCampoCa/ncerCandilCanelaCanguroCanicaCantoCa~aCa~o/nCaobaCaosCapazCapita/nCapoteCaptarCapuchaCaraCarbo/nCa/rcelCaretaCargaCari~oCarneCarpetaCarroCartaCasaCascoCaseroCaspaCastorCatorceCatreCaudalCausaCazoCebollaCederCedroCeldaCe/lebreCelosoCe/lulaCementoCenizaCentroCercaCerdoCerezaCeroCerrarCertezaCe/spedCetroChacalChalecoChampu/ChanclaChapaCharlaChicoChisteChivoChoqueChozaChuletaChuparCiclo/nCiegoCieloCienCiertoCifraCigarroCimaCincoCineCintaCipre/sCircoCiruelaCisneCitaCiudadClamorClanClaroClaseClaveClienteClimaCli/nicaCobreCoccio/nCochinoCocinaCocoCo/digoCodoCofreCogerCoheteCoji/nCojoColaColchaColegioColgarColinaCollarColmoColumnaCombateComerComidaCo/modoCompraCondeConejoCongaConocerConsejoContarCopaCopiaCorazo/nCorbataCorchoCordo/nCoronaCorrerCoserCosmosCostaCra/neoCra/terCrearCrecerCrei/doCremaCri/aCrimenCriptaCrisisCromoCro/nicaCroquetaCrudoCruzCuadroCuartoCuatroCuboCubrirCucharaCuelloCuentoCuerdaCuestaCuevaCuidarCulebraCulpaCultoCumbreCumplirCunaCunetaCuotaCupo/nCu/pulaCurarCuriosoCursoCurvaCutisDamaDanzaDarDardoDa/tilDeberDe/bilDe/cadaDecirDedoDefensaDefinirDejarDelfi/nDelgadoDelitoDemoraDensoDentalDeporteDerechoDerrotaDesayunoDeseoDesfileDesnudoDestinoDesvi/oDetalleDetenerDeudaDi/aDiabloDiademaDiamanteDianaDiarioDibujoDictarDienteDietaDiezDifi/cilDignoDilemaDiluirDineroDirectoDirigirDiscoDise~oDisfrazDivaDivinoDobleDoceDolorDomingoDonDonarDoradoDormirDorsoDosDosisDrago/nDrogaDuchaDudaDueloDue~oDulceDu/oDuqueDurarDurezaDuroE/banoEbrioEcharEcoEcuadorEdadEdicio/nEdificioEditorEducarEfectoEficazEjeEjemploElefanteElegirElementoElevarElipseE/liteElixirElogioEludirEmbudoEmitirEmocio/nEmpateEmpe~oEmpleoEmpresaEnanoEncargoEnchufeEnci/aEnemigoEneroEnfadoEnfermoEnga~oEnigmaEnlaceEnormeEnredoEnsayoEnse~arEnteroEntrarEnvaseEnvi/oE/pocaEquipoErizoEscalaEscenaEscolarEscribirEscudoEsenciaEsferaEsfuerzoEspadaEspejoEspi/aEsposaEspumaEsqui/EstarEsteEstiloEstufaEtapaEternoE/ticaEtniaEvadirEvaluarEventoEvitarExactoExamenExcesoExcusaExentoExigirExilioExistirE/xitoExpertoExplicarExponerExtremoFa/bricaFa/bulaFachadaFa/cilFactorFaenaFajaFaldaFalloFalsoFaltarFamaFamiliaFamosoFarao/nFarmaciaFarolFarsaFaseFatigaFaunaFavorFaxFebreroFechaFelizFeoFeriaFerozFe/rtilFervorFesti/nFiableFianzaFiarFibraFiccio/nFichaFideoFiebreFielFieraFiestaFiguraFijarFijoFilaFileteFilialFiltroFinFincaFingirFinitoFirmaFlacoFlautaFlechaFlorFlotaFluirFlujoFlu/orFobiaFocaFogataFogo/nFolioFolletoFondoFormaForroFortunaForzarFosaFotoFracasoFra/gilFranjaFraseFraudeFrei/rFrenoFresaFri/oFritoFrutaFuegoFuenteFuerzaFugaFumarFuncio/nFundaFurgo/nFuriaFusilFu/tbolFuturoGacelaGafasGaitaGajoGalaGaleri/aGalloGambaGanarGanchoGangaGansoGarajeGarzaGasolinaGastarGatoGavila/nGemeloGemirGenGe/neroGenioGenteGeranioGerenteGermenGestoGiganteGimnasioGirarGiroGlaciarGloboGloriaGolGolfoGolosoGolpeGomaGordoGorilaGorraGotaGoteoGozarGradaGra/ficoGranoGrasaGratisGraveGrietaGrilloGripeGrisGritoGrosorGru/aGruesoGrumoGrupoGuanteGuapoGuardiaGuerraGui/aGui~oGuionGuisoGuitarraGusanoGustarHaberHa/bilHablarHacerHachaHadaHallarHamacaHarinaHazHaza~aHebillaHebraHechoHeladoHelioHembraHerirHermanoHe/roeHervirHieloHierroHi/gadoHigieneHijoHimnoHistoriaHocicoHogarHogueraHojaHombreHongoHonorHonraHoraHormigaHornoHostilHoyoHuecoHuelgaHuertaHuesoHuevoHuidaHuirHumanoHu/medoHumildeHumoHundirHuraca/nHurtoIconoIdealIdiomaI/doloIglesiaIglu/IgualIlegalIlusio/nImagenIma/nImitarImparImperioImponerImpulsoIncapazI/ndiceInerteInfielInformeIngenioInicioInmensoInmuneInnatoInsectoInstanteIntere/sI/ntimoIntuirInu/tilInviernoIraIrisIroni/aIslaIsloteJabali/Jabo/nJamo/nJarabeJardi/nJarraJaulaJazmi/nJefeJeringaJineteJornadaJorobaJovenJoyaJuergaJuevesJuezJugadorJugoJugueteJuicioJuncoJunglaJunioJuntarJu/piterJurarJustoJuvenilJuzgarKiloKoalaLabioLacioLacraLadoLadro/nLagartoLa/grimaLagunaLaicoLamerLa/minaLa/mparaLanaLanchaLangostaLanzaLa/pizLargoLarvaLa/stimaLataLa/texLatirLaurelLavarLazoLealLeccio/nLecheLectorLeerLegio/nLegumbreLejanoLenguaLentoLe~aLeo/nLeopardoLesio/nLetalLetraLeveLeyendaLibertadLibroLicorLi/derLidiarLienzoLigaLigeroLimaLi/miteLimo/nLimpioLinceLindoLi/neaLingoteLinoLinternaLi/quidoLisoListaLiteraLitioLitroLlagaLlamaLlantoLlaveLlegarLlenarLlevarLlorarLloverLluviaLoboLocio/nLocoLocuraLo/gicaLogroLombrizLomoLonjaLoteLuchaLucirLugarLujoLunaLunesLupaLustroLutoLuzMacetaMachoMaderaMadreMaduroMaestroMafiaMagiaMagoMai/zMaldadMaletaMallaMaloMama/MamboMamutMancoMandoManejarMangaManiqui/ManjarManoMansoMantaMa~anaMapaMa/quinaMarMarcoMareaMarfilMargenMaridoMa/rmolMarro/nMartesMarzoMasaMa/scaraMasivoMatarMateriaMatizMatrizMa/ximoMayorMazorcaMechaMedallaMedioMe/dulaMejillaMejorMelenaMelo/nMemoriaMenorMensajeMenteMenu/MercadoMerengueMe/ritoMesMeso/nMetaMeterMe/todoMetroMezclaMiedoMielMiembroMigaMilMilagroMilitarMillo/nMimoMinaMineroMi/nimoMinutoMiopeMirarMisaMiseriaMisilMismoMitadMitoMochilaMocio/nModaModeloMohoMojarMoldeMolerMolinoMomentoMomiaMonarcaMonedaMonjaMontoMo~oMoradaMorderMorenoMorirMorroMorsaMortalMoscaMostrarMotivoMoverMo/vilMozoMuchoMudarMuebleMuelaMuerteMuestraMugreMujerMulaMuletaMultaMundoMu~ecaMuralMuroMu/sculoMuseoMusgoMu/sicaMusloNa/carNacio/nNadarNaipeNaranjaNarizNarrarNasalNatalNativoNaturalNa/useaNavalNaveNavidadNecioNe/ctarNegarNegocioNegroNeo/nNervioNetoNeutroNevarNeveraNichoNidoNieblaNietoNi~ezNi~oNi/tidoNivelNoblezaNocheNo/minaNoriaNormaNorteNotaNoticiaNovatoNovelaNovioNubeNucaNu/cleoNudilloNudoNueraNueveNuezNuloNu/meroNutriaOasisObesoObispoObjetoObraObreroObservarObtenerObvioOcaOcasoOce/anoOchentaOchoOcioOcreOctavoOctubreOcultoOcuparOcurrirOdiarOdioOdiseaOesteOfensaOfertaOficioOfrecerOgroOi/doOi/rOjoOlaOleadaOlfatoOlivoOllaOlmoOlorOlvidoOmbligoOndaOnzaOpacoOpcio/nO/peraOpinarOponerOptarO/pticaOpuestoOracio/nOradorOralO/rbitaOrcaOrdenOrejaO/rganoOrgi/aOrgulloOrienteOrigenOrillaOroOrquestaOrugaOsadi/aOscuroOseznoOsoOstraOto~oOtroOvejaO/vuloO/xidoOxi/genoOyenteOzonoPactoPadrePaellaPa/ginaPagoPai/sPa/jaroPalabraPalcoPaletaPa/lidoPalmaPalomaPalparPanPanalPa/nicoPanteraPa~ueloPapa/PapelPapillaPaquetePararParcelaParedParirParoPa/rpadoParquePa/rrafoPartePasarPaseoPasio/nPasoPastaPataPatioPatriaPausaPautaPavoPayasoPeato/nPecadoPeceraPechoPedalPedirPegarPeinePelarPelda~oPeleaPeligroPellejoPeloPelucaPenaPensarPe~o/nPeo/nPeorPepinoPeque~oPeraPerchaPerderPerezaPerfilPericoPerlaPermisoPerroPersonaPesaPescaPe/simoPesta~aPe/taloPetro/leoPezPezu~aPicarPicho/nPiePiedraPiernaPiezaPijamaPilarPilotoPimientaPinoPintorPinzaPi~aPiojoPipaPirataPisarPiscinaPisoPistaPito/nPizcaPlacaPlanPlataPlayaPlazaPleitoPlenoPlomoPlumaPluralPobrePocoPoderPodioPoemaPoesi/aPoetaPolenPolici/aPolloPolvoPomadaPomeloPomoPompaPonerPorcio/nPortalPosadaPoseerPosiblePostePotenciaPotroPozoPradoPrecozPreguntaPremioPrensaPresoPrevioPrimoPri/ncipePrisio/nPrivarProaProbarProcesoProductoProezaProfesorProgramaProlePromesaProntoPropioPro/ximoPruebaPu/blicoPucheroPudorPuebloPuertaPuestoPulgaPulirPulmo/nPulpoPulsoPumaPuntoPu~alPu~oPupaPupilaPure/QuedarQuejaQuemarQuererQuesoQuietoQui/micaQuinceQuitarRa/banoRabiaRaboRacio/nRadicalRai/zRamaRampaRanchoRangoRapazRa/pidoRaptoRasgoRaspaRatoRayoRazaRazo/nReaccio/nRealidadReba~oReboteRecaerRecetaRechazoRecogerRecreoRectoRecursoRedRedondoReducirReflejoReformaRefra/nRefugioRegaloRegirReglaRegresoRehe/nReinoRei/rRejaRelatoRelevoRelieveRellenoRelojRemarRemedioRemoRencorRendirRentaRepartoRepetirReposoReptilResRescateResinaRespetoRestoResumenRetiroRetornoRetratoReunirReve/sRevistaReyRezarRicoRiegoRiendaRiesgoRifaRi/gidoRigorRinco/nRi~o/nRi/oRiquezaRisaRitmoRitoRizoRobleRoceRociarRodarRodeoRodillaRoerRojizoRojoRomeroRomperRonRoncoRondaRopaRoperoRosaRoscaRostroRotarRubi/RuborRudoRuedaRugirRuidoRuinaRuletaRuloRumboRumorRupturaRutaRutinaSa/badoSaberSabioSableSacarSagazSagradoSalaSaldoSaleroSalirSalmo/nSalo/nSalsaSaltoSaludSalvarSambaSancio/nSandi/aSanearSangreSanidadSanoSantoSapoSaqueSardinaSarte/nSastreSata/nSaunaSaxofo/nSeccio/nSecoSecretoSectaSedSeguirSeisSelloSelvaSemanaSemillaSendaSensorSe~alSe~orSepararSepiaSequi/aSerSerieSermo/nServirSesentaSesio/nSetaSetentaSeveroSexoSextoSidraSiestaSieteSigloSignoSi/labaSilbarSilencioSillaSi/mboloSimioSirenaSistemaSitioSituarSobreSocioSodioSolSolapaSoldadoSoledadSo/lidoSoltarSolucio/nSombraSondeoSonidoSonoroSonrisaSopaSoplarSoporteSordoSorpresaSorteoSoste/nSo/tanoSuaveSubirSucesoSudorSuegraSueloSue~oSuerteSufrirSujetoSulta/nSumarSuperarSuplirSuponerSupremoSurSurcoSure~oSurgirSustoSutilTabacoTabiqueTablaTabu/TacoTactoTajoTalarTalcoTalentoTallaTalo/nTama~oTamborTangoTanqueTapaTapeteTapiaTapo/nTaquillaTardeTareaTarifaTarjetaTarotTarroTartaTatuajeTauroTazaTazo/nTeatroTechoTeclaTe/cnicaTejadoTejerTejidoTelaTele/fonoTemaTemorTemploTenazTenderTenerTenisTensoTeori/aTerapiaTercoTe/rminoTernuraTerrorTesisTesoroTestigoTeteraTextoTezTibioTiburo/nTiempoTiendaTierraTiesoTigreTijeraTildeTimbreTi/midoTimoTintaTi/oTi/picoTipoTiraTiro/nTita/nTi/tereTi/tuloTizaToallaTobilloTocarTocinoTodoTogaToldoTomarTonoTontoToparTopeToqueTo/raxToreroTormentaTorneoToroTorpedoTorreTorsoTortugaTosToscoToserTo/xicoTrabajoTractorTraerTra/ficoTragoTrajeTramoTranceTratoTraumaTrazarTre/bolTreguaTreintaTrenTreparTresTribuTrigoTripaTristeTriunfoTrofeoTrompaTroncoTropaTroteTrozoTrucoTruenoTrufaTuberi/aTuboTuertoTumbaTumorTu/nelTu/nicaTurbinaTurismoTurnoTutorUbicarU/lceraUmbralUnidadUnirUniversoUnoUntarU~aUrbanoUrbeUrgenteUrnaUsarUsuarioU/tilUtopi/aUvaVacaVaci/oVacunaVagarVagoVainaVajillaValeVa/lidoValleValorVa/lvulaVampiroVaraVariarVaro/nVasoVecinoVectorVehi/culoVeinteVejezVelaVeleroVelozVenaVencerVendaVenenoVengarVenirVentaVenusVerVeranoVerboVerdeVeredaVerjaVersoVerterVi/aViajeVibrarVicioVi/ctimaVidaVi/deoVidrioViejoViernesVigorVilVillaVinagreVinoVi~edoVioli/nViralVirgoVirtudVisorVi/speraVistaVitaminaViudoVivazViveroVivirVivoVolca/nVolumenVolverVorazVotarVotoVozVueloVulgarYacerYateYeguaYemaYernoYesoYodoYogaYogurZafiroZanjaZapatoZarzaZonaZorroZumoZurdo";
      var lookup = {};
      var wordlist10 = null;
      function dropDiacritic(word) {
        wordlist_1.logger.checkNormalize();
        return (0, strings_1.toUtf8String)(Array.prototype.filter.call((0, strings_1.toUtf8Bytes)(word.normalize("NFD").toLowerCase()), function(c3) {
          return c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 123;
        }));
      }
      function expand(word) {
        var output2 = [];
        Array.prototype.forEach.call((0, strings_1.toUtf8Bytes)(word), function(c3) {
          if (c3 === 47) {
            output2.push(204);
            output2.push(129);
          } else if (c3 === 126) {
            output2.push(110);
            output2.push(204);
            output2.push(131);
          } else {
            output2.push(c3);
          }
        });
        return (0, strings_1.toUtf8String)(output2);
      }
      function loadWords(lang) {
        if (wordlist10 != null) {
          return;
        }
        wordlist10 = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(function(w3) {
          return expand(w3);
        });
        wordlist10.forEach(function(word, index2) {
          lookup[dropDiacritic(word)] = index2;
        });
        if (wordlist_1.Wordlist.check(lang) !== "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300") {
          wordlist10 = null;
          throw new Error("BIP39 Wordlist for es (Spanish) FAILED");
        }
      }
      var LangEs = (
        /** @class */
        function(_super) {
          __extends2(LangEs2, _super);
          function LangEs2() {
            return _super.call(this, "es") || this;
          }
          LangEs2.prototype.getWord = function(index2) {
            loadWords(this);
            return wordlist10[index2];
          };
          LangEs2.prototype.getWordIndex = function(word) {
            loadWords(this);
            return lookup[dropDiacritic(word)];
          };
          return LangEs2;
        }(wordlist_1.Wordlist)
      );
      var langEs = new LangEs();
      exports2.langEs = langEs;
      wordlist_1.Wordlist.register(langEs);
    }
  });

  // node_modules/@ethersproject/wordlists/lib/lang-fr.js
  var require_lang_fr = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/lang-fr.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.langFr = void 0;
      var strings_1 = require_lib9();
      var wordlist_1 = require_wordlist();
      var words = "AbaisserAbandonAbdiquerAbeilleAbolirAborderAboutirAboyerAbrasifAbreuverAbriterAbrogerAbruptAbsenceAbsoluAbsurdeAbusifAbyssalAcade/mieAcajouAcarienAccablerAccepterAcclamerAccoladeAccrocheAccuserAcerbeAchatAcheterAcidulerAcierAcompteAcque/rirAcronymeActeurActifActuelAdepteAde/quatAdhe/sifAdjectifAdjugerAdmettreAdmirerAdopterAdorerAdoucirAdresseAdroitAdulteAdverbeAe/rerAe/ronefAffaireAffecterAfficheAffreuxAffublerAgacerAgencerAgileAgiterAgraferAgre/ableAgrumeAiderAiguilleAilierAimableAisanceAjouterAjusterAlarmerAlchimieAlerteAlge-breAlgueAlie/nerAlimentAlle/gerAlliageAllouerAllumerAlourdirAlpagaAltesseAlve/oleAmateurAmbiguAmbreAme/nagerAmertumeAmidonAmiralAmorcerAmourAmovibleAmphibieAmpleurAmusantAnalyseAnaphoreAnarchieAnatomieAncienAne/antirAngleAngoisseAnguleuxAnimalAnnexerAnnonceAnnuelAnodinAnomalieAnonymeAnormalAntenneAntidoteAnxieuxApaiserApe/ritifAplanirApologieAppareilAppelerApporterAppuyerAquariumAqueducArbitreArbusteArdeurArdoiseArgentArlequinArmatureArmementArmoireArmureArpenterArracherArriverArroserArsenicArte/rielArticleAspectAsphalteAspirerAssautAsservirAssietteAssocierAssurerAsticotAstreAstuceAtelierAtomeAtriumAtroceAttaqueAttentifAttirerAttraperAubaineAubergeAudaceAudibleAugurerAuroreAutomneAutrucheAvalerAvancerAvariceAvenirAverseAveugleAviateurAvideAvionAviserAvoineAvouerAvrilAxialAxiomeBadgeBafouerBagageBaguetteBaignadeBalancerBalconBaleineBalisageBambinBancaireBandageBanlieueBannie-reBanquierBarbierBarilBaronBarqueBarrageBassinBastionBatailleBateauBatterieBaudrierBavarderBeletteBe/lierBeloteBe/ne/ficeBerceauBergerBerlineBermudaBesaceBesogneBe/tailBeurreBiberonBicycleBiduleBijouBilanBilingueBillardBinaireBiologieBiopsieBiotypeBiscuitBisonBistouriBitumeBizarreBlafardBlagueBlanchirBlessantBlinderBlondBloquerBlousonBobardBobineBoireBoiserBolideBonbonBondirBonheurBonifierBonusBordureBorneBotteBoucleBoueuxBougieBoulonBouquinBourseBoussoleBoutiqueBoxeurBrancheBrasierBraveBrebisBre-cheBreuvageBricolerBrigadeBrillantBriocheBriqueBrochureBroderBronzerBrousseBroyeurBrumeBrusqueBrutalBruyantBuffleBuissonBulletinBureauBurinBustierButinerButoirBuvableBuvetteCabanonCabineCachetteCadeauCadreCafe/ineCaillouCaissonCalculerCalepinCalibreCalmerCalomnieCalvaireCamaradeCame/raCamionCampagneCanalCanetonCanonCantineCanularCapableCaporalCapriceCapsuleCapterCapucheCarabineCarboneCaresserCaribouCarnageCarotteCarreauCartonCascadeCasierCasqueCassureCauserCautionCavalierCaverneCaviarCe/dilleCeintureCe/lesteCelluleCendrierCensurerCentralCercleCe/re/bralCeriseCernerCerveauCesserChagrinChaiseChaleurChambreChanceChapitreCharbonChasseurChatonChaussonChavirerChemiseChenilleChe/quierChercherChevalChienChiffreChignonChime-reChiotChlorureChocolatChoisirChoseChouetteChromeChuteCigareCigogneCimenterCine/maCintrerCirculerCirerCirqueCiterneCitoyenCitronCivilClaironClameurClaquerClasseClavierClientClignerClimatClivageClocheClonageCloporteCobaltCobraCocasseCocotierCoderCodifierCoffreCognerCohe/sionCoifferCoincerCole-reColibriCollineColmaterColonelCombatCome/dieCommandeCompactConcertConduireConfierCongelerConnoterConsonneContactConvexeCopainCopieCorailCorbeauCordageCornicheCorpusCorrectCorte-geCosmiqueCostumeCotonCoudeCoupureCourageCouteauCouvrirCoyoteCrabeCrainteCravateCrayonCre/atureCre/diterCre/meuxCreuserCrevetteCriblerCrierCristalCrite-reCroireCroquerCrotaleCrucialCruelCrypterCubiqueCueillirCuille-reCuisineCuivreCulminerCultiverCumulerCupideCuratifCurseurCyanureCycleCylindreCyniqueDaignerDamierDangerDanseurDauphinDe/battreDe/biterDe/borderDe/briderDe/butantDe/calerDe/cembreDe/chirerDe/ciderDe/clarerDe/corerDe/crireDe/cuplerDe/daleDe/ductifDe/esseDe/fensifDe/filerDe/frayerDe/gagerDe/givrerDe/glutirDe/graferDe/jeunerDe/liceDe/logerDemanderDemeurerDe/molirDe/nicherDe/nouerDentelleDe/nuderDe/partDe/penserDe/phaserDe/placerDe/poserDe/rangerDe/roberDe/sastreDescenteDe/sertDe/signerDe/sobe/irDessinerDestrierDe/tacherDe/testerDe/tourerDe/tresseDevancerDevenirDevinerDevoirDiableDialogueDiamantDicterDiffe/rerDige/rerDigitalDigneDiluerDimancheDiminuerDioxydeDirectifDirigerDiscuterDisposerDissiperDistanceDivertirDiviserDocileDocteurDogmeDoigtDomaineDomicileDompterDonateurDonjonDonnerDopamineDortoirDorureDosageDoseurDossierDotationDouanierDoubleDouceurDouterDoyenDragonDraperDresserDribblerDroitureDuperieDuplexeDurableDurcirDynastieE/blouirE/carterE/charpeE/chelleE/clairerE/clipseE/cloreE/cluseE/coleE/conomieE/corceE/couterE/craserE/cre/merE/crivainE/crouE/cumeE/cureuilE/difierE/duquerEffacerEffectifEffigieEffortEffrayerEffusionE/galiserE/garerE/jecterE/laborerE/largirE/lectronE/le/gantE/le/phantE/le-veE/ligibleE/litismeE/logeE/luciderE/luderEmballerEmbellirEmbryonE/meraudeE/missionEmmenerE/motionE/mouvoirEmpereurEmployerEmporterEmpriseE/mulsionEncadrerEnche-reEnclaveEncocheEndiguerEndosserEndroitEnduireE/nergieEnfanceEnfermerEnfouirEngagerEnginEngloberE/nigmeEnjamberEnjeuEnleverEnnemiEnnuyeuxEnrichirEnrobageEnseigneEntasserEntendreEntierEntourerEntraverE/nume/rerEnvahirEnviableEnvoyerEnzymeE/olienE/paissirE/pargneE/patantE/pauleE/picerieE/pide/mieE/pierE/pilogueE/pineE/pisodeE/pitapheE/poqueE/preuveE/prouverE/puisantE/querreE/quipeE/rigerE/rosionErreurE/ruptionEscalierEspadonEspe-ceEspie-gleEspoirEspritEsquiverEssayerEssenceEssieuEssorerEstimeEstomacEstradeE/tage-reE/talerE/tancheE/tatiqueE/teindreE/tendoirE/ternelE/thanolE/thiqueEthnieE/tirerE/tofferE/toileE/tonnantE/tourdirE/trangeE/troitE/tudeEuphorieE/valuerE/vasionE/ventailE/videnceE/viterE/volutifE/voquerExactExage/rerExaucerExcellerExcitantExclusifExcuseExe/cuterExempleExercerExhalerExhorterExigenceExilerExisterExotiqueExpe/dierExplorerExposerExprimerExquisExtensifExtraireExulterFableFabuleuxFacetteFacileFactureFaiblirFalaiseFameuxFamilleFarceurFarfeluFarineFaroucheFascinerFatalFatigueFauconFautifFaveurFavoriFe/brileFe/conderFe/de/rerFe/linFemmeFe/murFendoirFe/odalFermerFe/roceFerveurFestivalFeuilleFeutreFe/vrierFiascoFicelerFictifFide-leFigureFilatureFiletageFilie-reFilleulFilmerFilouFiltrerFinancerFinirFioleFirmeFissureFixerFlairerFlammeFlasqueFlatteurFle/auFle-cheFleurFlexionFloconFloreFluctuerFluideFluvialFolieFonderieFongibleFontaineForcerForgeronFormulerFortuneFossileFoudreFouge-reFouillerFoulureFourmiFragileFraiseFranchirFrapperFrayeurFre/gateFreinerFrelonFre/mirFre/ne/sieFre-reFriableFrictionFrissonFrivoleFroidFromageFrontalFrotterFruitFugitifFuiteFureurFurieuxFurtifFusionFuturGagnerGalaxieGalerieGambaderGarantirGardienGarnirGarrigueGazelleGazonGe/antGe/latineGe/luleGendarmeGe/ne/ralGe/nieGenouGentilGe/ologieGe/ome-treGe/raniumGermeGestuelGeyserGibierGiclerGirafeGivreGlaceGlaiveGlisserGlobeGloireGlorieuxGolfeurGommeGonflerGorgeGorilleGoudronGouffreGoulotGoupilleGourmandGoutteGraduelGraffitiGraineGrandGrappinGratuitGravirGrenatGriffureGrillerGrimperGrognerGronderGrotteGroupeGrugerGrutierGruye-reGue/pardGuerrierGuideGuimauveGuitareGustatifGymnasteGyrostatHabitudeHachoirHalteHameauHangarHannetonHaricotHarmonieHarponHasardHe/liumHe/matomeHerbeHe/rissonHermineHe/ronHe/siterHeureuxHibernerHibouHilarantHistoireHiverHomardHommageHomoge-neHonneurHonorerHonteuxHordeHorizonHorlogeHormoneHorribleHouleuxHousseHublotHuileuxHumainHumbleHumideHumourHurlerHydromelHygie-neHymneHypnoseIdylleIgnorerIguaneIlliciteIllusionImageImbiberImiterImmenseImmobileImmuableImpactImpe/rialImplorerImposerImprimerImputerIncarnerIncendieIncidentInclinerIncoloreIndexerIndiceInductifIne/ditIneptieInexactInfiniInfligerInformerInfusionInge/rerInhalerInhiberInjecterInjureInnocentInoculerInonderInscrireInsecteInsigneInsoliteInspirerInstinctInsulterIntactIntenseIntimeIntrigueIntuitifInutileInvasionInventerInviterInvoquerIroniqueIrradierIrre/elIrriterIsolerIvoireIvresseJaguarJaillirJambeJanvierJardinJaugerJauneJavelotJetableJetonJeudiJeunesseJoindreJoncherJonglerJoueurJouissifJournalJovialJoyauJoyeuxJubilerJugementJuniorJuponJuristeJusticeJuteuxJuve/nileKayakKimonoKiosqueLabelLabialLabourerLace/rerLactoseLaguneLaineLaisserLaitierLambeauLamelleLampeLanceurLangageLanterneLapinLargeurLarmeLaurierLavaboLavoirLectureLe/galLe/gerLe/gumeLessiveLettreLevierLexiqueLe/zardLiasseLibe/rerLibreLicenceLicorneLie-geLie-vreLigatureLigoterLigueLimerLimiteLimonadeLimpideLine/aireLingotLionceauLiquideLisie-reListerLithiumLitigeLittoralLivreurLogiqueLointainLoisirLombricLoterieLouerLourdLoutreLouveLoyalLubieLucideLucratifLueurLugubreLuisantLumie-reLunaireLundiLuronLutterLuxueuxMachineMagasinMagentaMagiqueMaigreMaillonMaintienMairieMaisonMajorerMalaxerMale/ficeMalheurMaliceMalletteMammouthMandaterManiableManquantManteauManuelMarathonMarbreMarchandMardiMaritimeMarqueurMarronMartelerMascotteMassifMate/rielMatie-reMatraqueMaudireMaussadeMauveMaximalMe/chantMe/connuMe/dailleMe/decinMe/diterMe/duseMeilleurMe/langeMe/lodieMembreMe/moireMenacerMenerMenhirMensongeMentorMercrediMe/riteMerleMessagerMesureMe/talMe/te/oreMe/thodeMe/tierMeubleMiaulerMicrobeMietteMignonMigrerMilieuMillionMimiqueMinceMine/ralMinimalMinorerMinuteMiracleMiroiterMissileMixteMobileModerneMoelleuxMondialMoniteurMonnaieMonotoneMonstreMontagneMonumentMoqueurMorceauMorsureMortierMoteurMotifMoucheMoufleMoulinMoussonMoutonMouvantMultipleMunitionMurailleMure-neMurmureMuscleMuse/umMusicienMutationMuterMutuelMyriadeMyrtilleMyste-reMythiqueNageurNappeNarquoisNarrerNatationNationNatureNaufrageNautiqueNavireNe/buleuxNectarNe/fasteNe/gationNe/gligerNe/gocierNeigeNerveuxNettoyerNeuroneNeutronNeveuNicheNickelNitrateNiveauNobleNocifNocturneNoirceurNoisetteNomadeNombreuxNommerNormatifNotableNotifierNotoireNourrirNouveauNovateurNovembreNoviceNuageNuancerNuireNuisibleNume/roNuptialNuqueNutritifObe/irObjectifObligerObscurObserverObstacleObtenirObturerOccasionOccuperOce/anOctobreOctroyerOctuplerOculaireOdeurOdorantOffenserOfficierOffrirOgiveOiseauOisillonOlfactifOlivierOmbrageOmettreOnctueuxOndulerOne/reuxOniriqueOpaleOpaqueOpe/rerOpinionOpportunOpprimerOpterOptiqueOrageuxOrangeOrbiteOrdonnerOreilleOrganeOrgueilOrificeOrnementOrqueOrtieOscillerOsmoseOssatureOtarieOuraganOursonOutilOutragerOuvrageOvationOxydeOxyge-neOzonePaisiblePalacePalmare-sPalourdePalperPanachePandaPangolinPaniquerPanneauPanoramaPantalonPapayePapierPapoterPapyrusParadoxeParcelleParesseParfumerParlerParoleParrainParsemerPartagerParureParvenirPassionPaste-quePaternelPatiencePatronPavillonPavoiserPayerPaysagePeignePeintrePelagePe/licanPellePelousePeluchePendulePe/ne/trerPe/niblePensifPe/nuriePe/pitePe/plumPerdrixPerforerPe/riodePermuterPerplexePersilPertePeserPe/talePetitPe/trirPeuplePharaonPhobiePhoquePhotonPhrasePhysiquePianoPicturalPie-cePierrePieuvrePilotePinceauPipettePiquerPiroguePiscinePistonPivoterPixelPizzaPlacardPlafondPlaisirPlanerPlaquePlastronPlateauPleurerPlexusPliagePlombPlongerPluiePlumagePochettePoe/siePoe-tePointePoirierPoissonPoivrePolairePolicierPollenPolygonePommadePompierPonctuelPonde/rerPoneyPortiquePositionPosse/derPosturePotagerPoteauPotionPoucePoulainPoumonPourprePoussinPouvoirPrairiePratiquePre/cieuxPre/direPre/fixePre/ludePre/nomPre/sencePre/textePre/voirPrimitifPrincePrisonPriverProble-meProce/derProdigeProfondProgre-sProieProjeterProloguePromenerPropreProspe-reProte/gerProuesseProverbePrudencePruneauPsychosePublicPuceronPuiserPulpePulsarPunaisePunitifPupitrePurifierPuzzlePyramideQuasarQuerelleQuestionQuie/tudeQuitterQuotientRacineRaconterRadieuxRagondinRaideurRaisinRalentirRallongeRamasserRapideRasageRatisserRavagerRavinRayonnerRe/actifRe/agirRe/aliserRe/animerRecevoirRe/citerRe/clamerRe/colterRecruterReculerRecyclerRe/digerRedouterRefaireRe/flexeRe/formerRefrainRefugeRe/galienRe/gionRe/glageRe/gulierRe/ite/rerRejeterRejouerRelatifReleverReliefRemarqueReme-deRemiseRemonterRemplirRemuerRenardRenfortReniflerRenoncerRentrerRenvoiReplierReporterRepriseReptileRequinRe/serveRe/sineuxRe/soudreRespectResterRe/sultatRe/tablirRetenirRe/ticuleRetomberRetracerRe/unionRe/ussirRevancheRevivreRe/volteRe/vulsifRichesseRideauRieurRigideRigolerRincerRiposterRisibleRisqueRituelRivalRivie-reRocheuxRomanceRompreRonceRondinRoseauRosierRotatifRotorRotuleRougeRouilleRouleauRoutineRoyaumeRubanRubisRucheRuelleRugueuxRuinerRuisseauRuserRustiqueRythmeSablerSaboterSabreSacocheSafariSagesseSaisirSaladeSaliveSalonSaluerSamediSanctionSanglierSarcasmeSardineSaturerSaugrenuSaumonSauterSauvageSavantSavonnerScalpelScandaleSce/le/ratSce/narioSceptreSche/maScienceScinderScoreScrutinSculpterSe/anceSe/cableSe/cherSecouerSe/cre/terSe/datifSe/duireSeigneurSe/jourSe/lectifSemaineSemblerSemenceSe/minalSe/nateurSensibleSentenceSe/parerSe/quenceSereinSergentSe/rieuxSerrureSe/rumServiceSe/sameSe/virSevrageSextupleSide/ralSie-cleSie/gerSifflerSigleSignalSilenceSiliciumSimpleSince-reSinistreSiphonSiropSismiqueSituerSkierSocialSocleSodiumSoigneuxSoldatSoleilSolitudeSolubleSombreSommeilSomnolerSondeSongeurSonnetteSonoreSorcierSortirSosieSottiseSoucieuxSoudureSouffleSouleverSoupapeSourceSoutirerSouvenirSpacieuxSpatialSpe/cialSphe-reSpiralStableStationSternumStimulusStipulerStrictStudieuxStupeurStylisteSublimeSubstratSubtilSubvenirSucce-sSucreSuffixeSugge/rerSuiveurSulfateSuperbeSupplierSurfaceSuricateSurmenerSurpriseSursautSurvieSuspectSyllabeSymboleSyme/trieSynapseSyntaxeSyste-meTabacTablierTactileTaillerTalentTalismanTalonnerTambourTamiserTangibleTapisTaquinerTarderTarifTartineTasseTatamiTatouageTaupeTaureauTaxerTe/moinTemporelTenailleTendreTeneurTenirTensionTerminerTerneTerribleTe/tineTexteThe-meThe/orieThe/rapieThoraxTibiaTie-deTimideTirelireTiroirTissuTitaneTitreTituberTobogganTole/rantTomateToniqueTonneauToponymeTorcheTordreTornadeTorpilleTorrentTorseTortueTotemToucherTournageTousserToxineTractionTraficTragiqueTrahirTrainTrancherTravailTre-fleTremperTre/sorTreuilTriageTribunalTricoterTrilogieTriompheTriplerTriturerTrivialTromboneTroncTropicalTroupeauTuileTulipeTumulteTunnelTurbineTuteurTutoyerTuyauTympanTyphonTypiqueTyranUbuesqueUltimeUltrasonUnanimeUnifierUnionUniqueUnitaireUniversUraniumUrbainUrticantUsageUsineUsuelUsureUtileUtopieVacarmeVaccinVagabondVagueVaillantVaincreVaisseauValableValiseVallonValveVampireVanilleVapeurVarierVaseuxVassalVasteVecteurVedetteVe/ge/talVe/hiculeVeinardVe/loceVendrediVe/ne/rerVengerVenimeuxVentouseVerdureVe/rinVernirVerrouVerserVertuVestonVe/te/ranVe/tusteVexantVexerViaducViandeVictoireVidangeVide/oVignetteVigueurVilainVillageVinaigreViolonVipe-reVirementVirtuoseVirusVisageViseurVisionVisqueuxVisuelVitalVitesseViticoleVitrineVivaceVivipareVocationVoguerVoileVoisinVoitureVolailleVolcanVoltigerVolumeVoraceVortexVoterVouloirVoyageVoyelleWagonXe/nonYachtZe-breZe/nithZesteZoologie";
      var wordlist10 = null;
      var lookup = {};
      function dropDiacritic(word) {
        wordlist_1.logger.checkNormalize();
        return (0, strings_1.toUtf8String)(Array.prototype.filter.call((0, strings_1.toUtf8Bytes)(word.normalize("NFD").toLowerCase()), function(c3) {
          return c3 >= 65 && c3 <= 90 || c3 >= 97 && c3 <= 123;
        }));
      }
      function expand(word) {
        var output2 = [];
        Array.prototype.forEach.call((0, strings_1.toUtf8Bytes)(word), function(c3) {
          if (c3 === 47) {
            output2.push(204);
            output2.push(129);
          } else if (c3 === 45) {
            output2.push(204);
            output2.push(128);
          } else {
            output2.push(c3);
          }
        });
        return (0, strings_1.toUtf8String)(output2);
      }
      function loadWords(lang) {
        if (wordlist10 != null) {
          return;
        }
        wordlist10 = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(function(w3) {
          return expand(w3);
        });
        wordlist10.forEach(function(word, index2) {
          lookup[dropDiacritic(word)] = index2;
        });
        if (wordlist_1.Wordlist.check(lang) !== "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045") {
          wordlist10 = null;
          throw new Error("BIP39 Wordlist for fr (French) FAILED");
        }
      }
      var LangFr = (
        /** @class */
        function(_super) {
          __extends2(LangFr2, _super);
          function LangFr2() {
            return _super.call(this, "fr") || this;
          }
          LangFr2.prototype.getWord = function(index2) {
            loadWords(this);
            return wordlist10[index2];
          };
          LangFr2.prototype.getWordIndex = function(word) {
            loadWords(this);
            return lookup[dropDiacritic(word)];
          };
          return LangFr2;
        }(wordlist_1.Wordlist)
      );
      var langFr = new LangFr();
      exports2.langFr = langFr;
      wordlist_1.Wordlist.register(langFr);
    }
  });

  // node_modules/@ethersproject/wordlists/lib/lang-ja.js
  var require_lang_ja = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/lang-ja.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.langJa = void 0;
      var bytes_1 = require_lib2();
      var strings_1 = require_lib9();
      var wordlist_1 = require_wordlist();
      var data = [
        // 4-kana words
        "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
        // 5-kana words
        "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
        // 6-kana words
        "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
        // 7-kana words
        "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
        // 8-kana words
        "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
        // 9-kana words
        "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
        // 10-kana words
        "IJBEJqXZJ"
      ];
      var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
      var wordlist10 = null;
      function hex2(word) {
        return (0, bytes_1.hexlify)((0, strings_1.toUtf8Bytes)(word));
      }
      var KiYoKu = "0xe3818de38284e3818f";
      var KyoKu = "0xe3818de38283e3818f";
      function loadWords(lang) {
        if (wordlist10 !== null) {
          return;
        }
        wordlist10 = [];
        var transform = {};
        transform[(0, strings_1.toUtf8String)([227, 130, 154])] = false;
        transform[(0, strings_1.toUtf8String)([227, 130, 153])] = false;
        transform[(0, strings_1.toUtf8String)([227, 130, 133])] = (0, strings_1.toUtf8String)([227, 130, 134]);
        transform[(0, strings_1.toUtf8String)([227, 129, 163])] = (0, strings_1.toUtf8String)([227, 129, 164]);
        transform[(0, strings_1.toUtf8String)([227, 130, 131])] = (0, strings_1.toUtf8String)([227, 130, 132]);
        transform[(0, strings_1.toUtf8String)([227, 130, 135])] = (0, strings_1.toUtf8String)([227, 130, 136]);
        function normalize2(word2) {
          var result = "";
          for (var i5 = 0; i5 < word2.length; i5++) {
            var kana = word2[i5];
            var target = transform[kana];
            if (target === false) {
              continue;
            }
            if (target) {
              kana = target;
            }
            result += kana;
          }
          return result;
        }
        function sortJapanese(a2, b4) {
          a2 = normalize2(a2);
          b4 = normalize2(b4);
          if (a2 < b4) {
            return -1;
          }
          if (a2 > b4) {
            return 1;
          }
          return 0;
        }
        for (var length_1 = 3; length_1 <= 9; length_1++) {
          var d6 = data[length_1 - 3];
          for (var offset = 0; offset < d6.length; offset += length_1) {
            var word = [];
            for (var i4 = 0; i4 < length_1; i4++) {
              var k3 = mapping.indexOf(d6[offset + i4]);
              word.push(227);
              word.push(k3 & 64 ? 130 : 129);
              word.push((k3 & 63) + 128);
            }
            wordlist10.push((0, strings_1.toUtf8String)(word));
          }
        }
        wordlist10.sort(sortJapanese);
        if (hex2(wordlist10[442]) === KiYoKu && hex2(wordlist10[443]) === KyoKu) {
          var tmp = wordlist10[442];
          wordlist10[442] = wordlist10[443];
          wordlist10[443] = tmp;
        }
        if (wordlist_1.Wordlist.check(lang) !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
          wordlist10 = null;
          throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
        }
      }
      var LangJa = (
        /** @class */
        function(_super) {
          __extends2(LangJa2, _super);
          function LangJa2() {
            return _super.call(this, "ja") || this;
          }
          LangJa2.prototype.getWord = function(index2) {
            loadWords(this);
            return wordlist10[index2];
          };
          LangJa2.prototype.getWordIndex = function(word) {
            loadWords(this);
            return wordlist10.indexOf(word);
          };
          LangJa2.prototype.split = function(mnemonic) {
            wordlist_1.logger.checkNormalize();
            return mnemonic.split(/(?:\u3000| )+/g);
          };
          LangJa2.prototype.join = function(words) {
            return words.join("\u3000");
          };
          return LangJa2;
        }(wordlist_1.Wordlist)
      );
      var langJa = new LangJa();
      exports2.langJa = langJa;
      wordlist_1.Wordlist.register(langJa);
    }
  });

  // node_modules/@ethersproject/wordlists/lib/lang-ko.js
  var require_lang_ko = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/lang-ko.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.langKo = void 0;
      var strings_1 = require_lib9();
      var wordlist_1 = require_wordlist();
      var data = [
        "OYAa",
        "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
        "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
        "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
        "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
        "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
        "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
        "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
      ];
      var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
      function getHangul(code) {
        if (code >= 40) {
          code = code + 168 - 40;
        } else if (code >= 19) {
          code = code + 97 - 19;
        }
        return (0, strings_1.toUtf8String)([225, (code >> 6) + 132, (code & 63) + 128]);
      }
      var wordlist10 = null;
      function loadWords(lang) {
        if (wordlist10 != null) {
          return;
        }
        wordlist10 = [];
        data.forEach(function(data2, length) {
          length += 4;
          for (var i4 = 0; i4 < data2.length; i4 += length) {
            var word = "";
            for (var j3 = 0; j3 < length; j3++) {
              word += getHangul(codes.indexOf(data2[i4 + j3]));
            }
            wordlist10.push(word);
          }
        });
        wordlist10.sort();
        if (wordlist_1.Wordlist.check(lang) !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
          wordlist10 = null;
          throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
        }
      }
      var LangKo = (
        /** @class */
        function(_super) {
          __extends2(LangKo2, _super);
          function LangKo2() {
            return _super.call(this, "ko") || this;
          }
          LangKo2.prototype.getWord = function(index2) {
            loadWords(this);
            return wordlist10[index2];
          };
          LangKo2.prototype.getWordIndex = function(word) {
            loadWords(this);
            return wordlist10.indexOf(word);
          };
          return LangKo2;
        }(wordlist_1.Wordlist)
      );
      var langKo = new LangKo();
      exports2.langKo = langKo;
      wordlist_1.Wordlist.register(langKo);
    }
  });

  // node_modules/@ethersproject/wordlists/lib/lang-it.js
  var require_lang_it = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/lang-it.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.langIt = void 0;
      var wordlist_1 = require_wordlist();
      var words = "AbacoAbbaglioAbbinatoAbeteAbissoAbolireAbrasivoAbrogatoAccadereAccennoAccusatoAcetoneAchilleAcidoAcquaAcreAcrilicoAcrobataAcutoAdagioAddebitoAddomeAdeguatoAderireAdipeAdottareAdulareAffabileAffettoAffissoAffrantoAforismaAfosoAfricanoAgaveAgenteAgevoleAggancioAgireAgitareAgonismoAgricoloAgrumetoAguzzoAlabardaAlatoAlbatroAlberatoAlboAlbumeAlceAlcolicoAlettoneAlfaAlgebraAlianteAlibiAlimentoAllagatoAllegroAllievoAllodolaAllusivoAlmenoAlogenoAlpacaAlpestreAltalenaAlternoAlticcioAltroveAlunnoAlveoloAlzareAmalgamaAmanitaAmarenaAmbitoAmbratoAmebaAmericaAmetistaAmicoAmmassoAmmendaAmmirareAmmonitoAmoreAmpioAmpliareAmuletoAnacardoAnagrafeAnalistaAnarchiaAnatraAncaAncellaAncoraAndareAndreaAnelloAngeloAngolareAngustoAnimaAnnegareAnnidatoAnnoAnnuncioAnonimoAnticipoAnziApaticoAperturaApodeApparireAppetitoAppoggioApprodoAppuntoAprileArabicaArachideAragostaAraldicaArancioAraturaArazzoArbitroArchivioArditoArenileArgentoArgineArgutoAriaArmoniaArneseArredatoArringaArrostoArsenicoArsoArteficeArzilloAsciuttoAscoltoAsepsiAsetticoAsfaltoAsinoAsolaAspiratoAsproAssaggioAsseAssolutoAssurdoAstaAstenutoAsticeAstrattoAtavicoAteismoAtomicoAtonoAttesaAttivareAttornoAttritoAttualeAusilioAustriaAutistaAutonomoAutunnoAvanzatoAvereAvvenireAvvisoAvvolgereAzioneAzotoAzzimoAzzurroBabeleBaccanoBacinoBacoBadessaBadilataBagnatoBaitaBalconeBaldoBalenaBallataBalzanoBambinoBandireBaraondaBarbaroBarcaBaritonoBarlumeBaroccoBasilicoBassoBatostaBattutoBauleBavaBavosaBeccoBeffaBelgioBelvaBendaBenevoleBenignoBenzinaBereBerlinaBetaBibitaBiciBidoneBifidoBigaBilanciaBimboBinocoloBiologoBipedeBipolareBirbanteBirraBiscottoBisestoBisnonnoBisonteBisturiBizzarroBlandoBlattaBollitoBonificoBordoBoscoBotanicoBottinoBozzoloBraccioBradipoBramaBrancaBravuraBretellaBrevettoBrezzaBrigliaBrillanteBrindareBroccoloBrodoBronzinaBrulloBrunoBubboneBucaBudinoBuffoneBuioBulboBuonoBurloneBurrascaBussolaBustaCadettoCaducoCalamaroCalcoloCalesseCalibroCalmoCaloriaCambusaCamerataCamiciaCamminoCamolaCampaleCanapaCandelaCaneCaninoCanottoCantinaCapaceCapelloCapitoloCapogiroCapperoCapraCapsulaCarapaceCarcassaCardoCarismaCarovanaCarrettoCartolinaCasaccioCascataCasermaCasoCassoneCastelloCasualeCatastaCatenaCatrameCautoCavilloCedibileCedrataCefaloCelebreCellulareCenaCenoneCentesimoCeramicaCercareCertoCerumeCervelloCesoiaCespoCetoChelaChiaroChiccaChiedereChimeraChinaChirurgoChitarraCiaoCiclismoCifrareCignoCilindroCiottoloCircaCirrosiCitricoCittadinoCiuffoCivettaCivileClassicoClinicaCloroCoccoCodardoCodiceCoerenteCognomeCollareColmatoColoreColposoColtivatoColzaComaCometaCommandoComodoComputerComuneConcisoCondurreConfermaCongelareConiugeConnessoConoscereConsumoContinuoConvegnoCopertoCopioneCoppiaCopricapoCorazzaCordataCoricatoCorniceCorollaCorpoCorredoCorsiaCorteseCosmicoCostanteCotturaCovatoCratereCravattaCreatoCredereCremosoCrescitaCretaCricetoCrinaleCrisiCriticoCroceCronacaCrostataCrucialeCruscaCucireCuculoCuginoCullatoCupolaCuratoreCursoreCurvoCuscinoCustodeDadoDainoDalmataDamerinoDanielaDannosoDanzareDatatoDavantiDavveroDebuttoDecennioDecisoDeclinoDecolloDecretoDedicatoDefinitoDeformeDegnoDelegareDelfinoDelirioDeltaDemenzaDenotatoDentroDepositoDerapataDerivareDerogaDescrittoDesertoDesiderioDesumereDetersivoDevotoDiametroDicembreDiedroDifesoDiffusoDigerireDigitaleDiluvioDinamicoDinnanziDipintoDiplomaDipoloDiradareDireDirottoDirupoDisagioDiscretoDisfareDisgeloDispostoDistanzaDisumanoDitoDivanoDiveltoDividereDivoratoDobloneDocenteDoganaleDogmaDolceDomatoDomenicaDominareDondoloDonoDormireDoteDottoreDovutoDozzinaDragoDruidoDubbioDubitareDucaleDunaDuomoDupliceDuraturoEbanoEccessoEccoEclissiEconomiaEderaEdicolaEdileEditoriaEducareEgemoniaEgliEgoismoEgregioElaboratoElargireEleganteElencatoElettoElevareElficoElicaElmoElsaElusoEmanatoEmblemaEmessoEmiroEmotivoEmozioneEmpiricoEmuloEndemicoEnduroEnergiaEnfasiEnotecaEntrareEnzimaEpatiteEpilogoEpisodioEpocaleEppureEquatoreErarioErbaErbosoEredeEremitaErigereErmeticoEroeErosivoErranteEsagonoEsameEsanimeEsaudireEscaEsempioEsercitoEsibitoEsigenteEsistereEsitoEsofagoEsortatoEsosoEspansoEspressoEssenzaEssoEstesoEstimareEstoniaEstrosoEsultareEtilicoEtnicoEtruscoEttoEuclideoEuropaEvasoEvidenzaEvitatoEvolutoEvvivaFabbricaFaccendaFachiroFalcoFamigliaFanaleFanfaraFangoFantasmaFareFarfallaFarinosoFarmacoFasciaFastosoFasulloFaticareFatoFavolosoFebbreFecolaFedeFegatoFelpaFeltroFemminaFendereFenomenoFermentoFerroFertileFessuraFestivoFettaFeudoFiabaFiduciaFifaFiguratoFiloFinanzaFinestraFinireFioreFiscaleFisicoFiumeFlaconeFlamencoFleboFlemmaFloridoFluenteFluoroFobicoFocacciaFocosoFoderatoFoglioFolataFolcloreFolgoreFondenteFoneticoFoniaFontanaForbitoForchettaForestaFormicaFornaioForoFortezzaForzareFosfatoFossoFracassoFranaFrassinoFratelloFreccettaFrenataFrescoFrigoFrollinoFrondeFrugaleFruttaFucilataFucsiaFuggenteFulmineFulvoFumanteFumettoFumosoFuneFunzioneFuocoFurboFurgoneFuroreFusoFutileGabbianoGaffeGalateoGallinaGaloppoGamberoGammaGaranziaGarboGarofanoGarzoneGasdottoGasolioGastricoGattoGaudioGazeboGazzellaGecoGelatinaGelsoGemelloGemmatoGeneGenitoreGennaioGenotipoGergoGhepardoGhiaccioGhisaGialloGildaGineproGiocareGioielloGiornoGioveGiratoGironeGittataGiudizioGiuratoGiustoGlobuloGlutineGnomoGobbaGolfGomitoGommoneGonfioGonnaGovernoGracileGradoGraficoGrammoGrandeGrattareGravosoGraziaGrecaGreggeGrifoneGrigioGrinzaGrottaGruppoGuadagnoGuaioGuantoGuardareGufoGuidareIbernatoIconaIdenticoIdillioIdoloIdraIdricoIdrogenoIgieneIgnaroIgnoratoIlareIllesoIllogicoIlludereImballoImbevutoImboccoImbutoImmaneImmersoImmolatoImpaccoImpetoImpiegoImportoImprontaInalareInarcareInattivoIncantoIncendioInchinoIncisivoInclusoIncontroIncrocioIncuboIndagineIndiaIndoleIneditoInfattiInfilareInflittoIngaggioIngegnoIngleseIngordoIngrossoInnescoInodoreInoltrareInondatoInsanoInsettoInsiemeInsonniaInsulinaIntasatoInteroIntonacoIntuitoInumidireInvalidoInveceInvitoIperboleIpnoticoIpotesiIppicaIrideIrlandaIronicoIrrigatoIrrorareIsolatoIsotopoIstericoIstitutoIstriceItaliaIterareLabbroLabirintoLaccaLaceratoLacrimaLacunaLaddoveLagoLampoLancettaLanternaLardosoLargaLaringeLastraLatenzaLatinoLattugaLavagnaLavoroLegaleLeggeroLemboLentezzaLenzaLeoneLepreLesivoLessatoLestoLetteraleLevaLevigatoLiberoLidoLievitoLillaLimaturaLimitareLimpidoLineareLinguaLiquidoLiraLiricaLiscaLiteLitigioLivreaLocandaLodeLogicaLombareLondraLongevoLoquaceLorenzoLotoLotteriaLuceLucidatoLumacaLuminosoLungoLupoLuppoloLusingaLussoLuttoMacabroMacchinaMaceroMacinatoMadamaMagicoMagliaMagneteMagroMaiolicaMalafedeMalgradoMalintesoMalsanoMaltoMalumoreManaManciaMandorlaMangiareManifestoMannaroManovraMansardaMantideManubrioMappaMaratonaMarcireMarettaMarmoMarsupioMascheraMassaiaMastinoMaterassoMatricolaMattoneMaturoMazurcaMeandroMeccanicoMecenateMedesimoMeditareMegaMelassaMelisMelodiaMeningeMenoMensolaMercurioMerendaMerloMeschinoMeseMessereMestoloMetalloMetodoMettereMiagolareMicaMicelioMicheleMicroboMidolloMieleMiglioreMilanoMiliteMimosaMineraleMiniMinoreMirinoMirtilloMiscelaMissivaMistoMisurareMitezzaMitigareMitraMittenteMnemonicoModelloModificaModuloMoganoMogioMoleMolossoMonasteroMoncoMondinaMonetarioMonileMonotonoMonsoneMontatoMonvisoMoraMordereMorsicatoMostroMotivatoMotosegaMottoMovenzaMovimentoMozzoMuccaMucosaMuffaMughettoMugnaioMulattoMulinelloMultiploMummiaMuntoMuovereMuraleMusaMuscoloMusicaMutevoleMutoNababboNaftaNanometroNarcisoNariceNarratoNascereNastrareNaturaleNauticaNaviglioNebulosaNecrosiNegativoNegozioNemmenoNeofitaNerettoNervoNessunoNettunoNeutraleNeveNevroticoNicchiaNinfaNitidoNobileNocivoNodoNomeNominaNordicoNormaleNorvegeseNostranoNotareNotiziaNotturnoNovellaNucleoNullaNumeroNuovoNutrireNuvolaNuzialeOasiObbedireObbligoObeliscoOblioOboloObsoletoOccasioneOcchioOccidenteOccorrereOccultareOcraOculatoOdiernoOdorareOffertaOffrireOffuscatoOggettoOggiOgnunoOlandeseOlfattoOliatoOlivaOlogrammaOltreOmaggioOmbelicoOmbraOmegaOmissioneOndosoOnereOniceOnnivoroOnorevoleOntaOperatoOpinioneOppostoOracoloOrafoOrdineOrecchinoOreficeOrfanoOrganicoOrigineOrizzonteOrmaOrmeggioOrnativoOrologioOrrendoOrribileOrtensiaOrticaOrzataOrzoOsareOscurareOsmosiOspedaleOspiteOssaOssidareOstacoloOsteOtiteOtreOttagonoOttimoOttobreOvaleOvestOvinoOviparoOvocitoOvunqueOvviareOzioPacchettoPacePacificoPadellaPadronePaesePagaPaginaPalazzinaPalesarePallidoPaloPaludePandoroPannelloPaoloPaonazzoPapricaParabolaParcellaParerePargoloPariParlatoParolaPartireParvenzaParzialePassivoPasticcaPataccaPatologiaPattumePavonePeccatoPedalarePedonalePeggioPelosoPenarePendicePenisolaPennutoPenombraPensarePentolaPepePepitaPerbenePercorsoPerdonatoPerforarePergamenaPeriodoPermessoPernoPerplessoPersuasoPertugioPervasoPesatorePesistaPesoPestiferoPetaloPettinePetulantePezzoPiacerePiantaPiattinoPiccinoPicozzaPiegaPietraPifferoPigiamaPigolioPigroPilaPiliferoPillolaPilotaPimpantePinetaPinnaPinoloPioggiaPiomboPiramidePireticoPiritePirolisiPitonePizzicoPlaceboPlanarePlasmaPlatanoPlenarioPochezzaPoderosoPodismoPoesiaPoggiarePolentaPoligonoPollicePolmonitePolpettaPolsoPoltronaPolverePomicePomodoroPontePopolosoPorfidoPorosoPorporaPorrePortataPosaPositivoPossessoPostulatoPotassioPoterePranzoPrassiPraticaPreclusoPredicaPrefissoPregiatoPrelievoPremerePrenotarePreparatoPresenzaPretestoPrevalsoPrimaPrincipePrivatoProblemaProcuraProdurreProfumoProgettoProlungaPromessaPronomePropostaProrogaProtesoProvaPrudentePrugnaPruritoPsichePubblicoPudicaPugilatoPugnoPulcePulitoPulsantePuntarePupazzoPupillaPuroQuadroQualcosaQuasiQuerelaQuotaRaccoltoRaddoppioRadicaleRadunatoRafficaRagazzoRagioneRagnoRamarroRamingoRamoRandagioRantolareRapatoRapinaRappresoRasaturaRaschiatoRasenteRassegnaRastrelloRataRavvedutoRealeRecepireRecintoReclutaReconditoRecuperoRedditoRedimereRegalatoRegistroRegolaRegressoRelazioneRemareRemotoRennaReplicaReprimereReputareResaResidenteResponsoRestauroReteRetinaRetoricaRettificaRevocatoRiassuntoRibadireRibelleRibrezzoRicaricaRiccoRicevereRiciclatoRicordoRicredutoRidicoloRidurreRifasareRiflessoRiformaRifugioRigareRigettatoRighelloRilassatoRilevatoRimanereRimbalzoRimedioRimorchioRinascitaRincaroRinforzoRinnovoRinomatoRinsavitoRintoccoRinunciaRinvenireRiparatoRipetutoRipienoRiportareRipresaRipulireRisataRischioRiservaRisibileRisoRispettoRistoroRisultatoRisvoltoRitardoRitegnoRitmicoRitrovoRiunioneRivaRiversoRivincitaRivoltoRizomaRobaRoboticoRobustoRocciaRocoRodaggioRodereRoditoreRogitoRollioRomanticoRompereRonzioRosolareRospoRotanteRotondoRotulaRovescioRubizzoRubricaRugaRullinoRumineRumorosoRuoloRupeRussareRusticoSabatoSabbiareSabotatoSagomaSalassoSaldaturaSalgemmaSalivareSalmoneSaloneSaltareSalutoSalvoSapereSapidoSaporitoSaracenoSarcasmoSartoSassosoSatelliteSatiraSatolloSaturnoSavanaSavioSaziatoSbadiglioSbalzoSbancatoSbarraSbattereSbavareSbendareSbirciareSbloccatoSbocciatoSbrinareSbruffoneSbuffareScabrosoScadenzaScalaScambiareScandaloScapolaScarsoScatenareScavatoSceltoScenicoScettroSchedaSchienaSciarpaScienzaScindereScippoSciroppoScivoloSclerareScodellaScolpitoScompartoSconfortoScoprireScortaScossoneScozzeseScribaScrollareScrutinioScuderiaScultoreScuolaScuroScusareSdebitareSdoganareSeccaturaSecondoSedanoSeggiolaSegnalatoSegregatoSeguitoSelciatoSelettivoSellaSelvaggioSemaforoSembrareSemeSeminatoSempreSensoSentireSepoltoSequenzaSerataSerbatoSerenoSerioSerpenteSerraglioServireSestinaSetolaSettimanaSfaceloSfaldareSfamatoSfarzosoSfaticatoSferaSfidaSfilatoSfingeSfocatoSfoderareSfogoSfoltireSforzatoSfrattoSfruttatoSfuggitoSfumareSfusoSgabelloSgarbatoSgonfiareSgorbioSgrassatoSguardoSibiloSiccomeSierraSiglaSignoreSilenzioSillabaSimboloSimpaticoSimulatoSinfoniaSingoloSinistroSinoSintesiSinusoideSiparioSismaSistoleSituatoSlittaSlogaturaSlovenoSmarritoSmemoratoSmentitoSmeraldoSmilzoSmontareSmottatoSmussatoSnellireSnervatoSnodoSobbalzoSobrioSoccorsoSocialeSodaleSoffittoSognoSoldatoSolenneSolidoSollazzoSoloSolubileSolventeSomaticoSommaSondaSonettoSonniferoSopireSoppesoSopraSorgereSorpassoSorrisoSorsoSorteggioSorvolatoSospiroSostaSottileSpadaSpallaSpargereSpatolaSpaventoSpazzolaSpecieSpedireSpegnereSpelaturaSperanzaSpessoreSpettraleSpezzatoSpiaSpigolosoSpillatoSpinosoSpiraleSplendidoSportivoSposoSprangaSprecareSpronatoSpruzzoSpuntinoSquilloSradicareSrotolatoStabileStaccoStaffaStagnareStampatoStantioStarnutoStaseraStatutoSteloSteppaSterzoStilettoStimaStirpeStivaleStizzosoStonatoStoricoStrappoStregatoStriduloStrozzareStruttoStuccareStufoStupendoSubentroSuccosoSudoreSuggeritoSugoSultanoSuonareSuperboSupportoSurgelatoSurrogatoSussurroSuturaSvagareSvedeseSveglioSvelareSvenutoSveziaSviluppoSvistaSvizzeraSvoltaSvuotareTabaccoTabulatoTacciareTaciturnoTaleTalismanoTamponeTanninoTaraTardivoTargatoTariffaTarpareTartarugaTastoTatticoTavernaTavolataTazzaTecaTecnicoTelefonoTemerarioTempoTemutoTendoneTeneroTensioneTentacoloTeoremaTermeTerrazzoTerzettoTesiTesseratoTestatoTetroTettoiaTifareTigellaTimbroTintoTipicoTipografoTiraggioTiroTitanioTitoloTitubanteTizioTizzoneToccareTollerareToltoTombolaTomoTonfoTonsillaTopazioTopologiaToppaTorbaTornareTorroneTortoraToscanoTossireTostaturaTotanoTraboccoTracheaTrafilaTragediaTralcioTramontoTransitoTrapanoTrarreTraslocoTrattatoTraveTrecciaTremolioTrespoloTributoTrichecoTrifoglioTrilloTrinceaTrioTristezzaTrituratoTrivellaTrombaTronoTroppoTrottolaTrovareTruccatoTubaturaTuffatoTulipanoTumultoTunisiaTurbareTurchinoTutaTutelaUbicatoUccelloUccisoreUdireUditivoUffaUfficioUgualeUlisseUltimatoUmanoUmileUmorismoUncinettoUngereUnghereseUnicornoUnificatoUnisonoUnitarioUnteUovoUpupaUraganoUrgenzaUrloUsanzaUsatoUscitoUsignoloUsuraioUtensileUtilizzoUtopiaVacanteVaccinatoVagabondoVagliatoValangaValgoValicoVallettaValorosoValutareValvolaVampataVangareVanitosoVanoVantaggioVanveraVaporeVaranoVarcatoVarianteVascaVedettaVedovaVedutoVegetaleVeicoloVelcroVelinaVellutoVeloceVenatoVendemmiaVentoVeraceVerbaleVergognaVerificaVeroVerrucaVerticaleVescicaVessilloVestaleVeteranoVetrinaVetustoViandanteVibranteVicendaVichingoVicinanzaVidimareVigiliaVignetoVigoreVileVillanoViminiVincitoreViolaViperaVirgolaVirologoVirulentoViscosoVisioneVispoVissutoVisuraVitaVitelloVittimaVivandaVividoViziareVoceVogaVolatileVolereVolpeVoragineVulcanoZampognaZannaZappatoZatteraZavorraZefiroZelanteZeloZenzeroZerbinoZibettoZincoZirconeZittoZollaZoticoZuccheroZufoloZuluZuppa";
      var wordlist10 = null;
      function loadWords(lang) {
        if (wordlist10 != null) {
          return;
        }
        wordlist10 = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
        if (wordlist_1.Wordlist.check(lang) !== "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620") {
          wordlist10 = null;
          throw new Error("BIP39 Wordlist for it (Italian) FAILED");
        }
      }
      var LangIt = (
        /** @class */
        function(_super) {
          __extends2(LangIt2, _super);
          function LangIt2() {
            return _super.call(this, "it") || this;
          }
          LangIt2.prototype.getWord = function(index2) {
            loadWords(this);
            return wordlist10[index2];
          };
          LangIt2.prototype.getWordIndex = function(word) {
            loadWords(this);
            return wordlist10.indexOf(word);
          };
          return LangIt2;
        }(wordlist_1.Wordlist)
      );
      var langIt = new LangIt();
      exports2.langIt = langIt;
      wordlist_1.Wordlist.register(langIt);
    }
  });

  // node_modules/@ethersproject/wordlists/lib/lang-zh.js
  var require_lang_zh = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/lang-zh.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.langZhTw = exports2.langZhCn = void 0;
      var strings_1 = require_lib9();
      var wordlist_1 = require_wordlist();
      var data = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
      var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
      var wordlist10 = {
        zh_cn: null,
        zh_tw: null
      };
      var Checks = {
        zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
        zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
      };
      var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
      function loadWords(lang) {
        if (wordlist10[lang.locale] !== null) {
          return;
        }
        wordlist10[lang.locale] = [];
        var deltaOffset = 0;
        for (var i4 = 0; i4 < 2048; i4++) {
          var s4 = style.indexOf(data[i4 * 3]);
          var bytes2 = [
            228 + (s4 >> 2),
            128 + codes.indexOf(data[i4 * 3 + 1]),
            128 + codes.indexOf(data[i4 * 3 + 2])
          ];
          if (lang.locale === "zh_tw") {
            var common = s4 % 4;
            for (var i_1 = common; i_1 < 3; i_1++) {
              bytes2[i_1] = codes.indexOf(deltaData[deltaOffset++]) + (i_1 == 0 ? 228 : 128);
            }
          }
          wordlist10[lang.locale].push((0, strings_1.toUtf8String)(bytes2));
        }
        if (wordlist_1.Wordlist.check(lang) !== Checks[lang.locale]) {
          wordlist10[lang.locale] = null;
          throw new Error("BIP39 Wordlist for " + lang.locale + " (Chinese) FAILED");
        }
      }
      var LangZh = (
        /** @class */
        function(_super) {
          __extends2(LangZh2, _super);
          function LangZh2(country) {
            return _super.call(this, "zh_" + country) || this;
          }
          LangZh2.prototype.getWord = function(index2) {
            loadWords(this);
            return wordlist10[this.locale][index2];
          };
          LangZh2.prototype.getWordIndex = function(word) {
            loadWords(this);
            return wordlist10[this.locale].indexOf(word);
          };
          LangZh2.prototype.split = function(mnemonic) {
            mnemonic = mnemonic.replace(/(?:\u3000| )+/g, "");
            return mnemonic.split("");
          };
          return LangZh2;
        }(wordlist_1.Wordlist)
      );
      var langZhCn = new LangZh("cn");
      exports2.langZhCn = langZhCn;
      wordlist_1.Wordlist.register(langZhCn);
      wordlist_1.Wordlist.register(langZhCn, "zh");
      var langZhTw = new LangZh("tw");
      exports2.langZhTw = langZhTw;
      wordlist_1.Wordlist.register(langZhTw);
    }
  });

  // node_modules/@ethersproject/wordlists/lib/wordlists.js
  var require_wordlists = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/wordlists.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlists = void 0;
      var lang_cz_1 = require_lang_cz();
      var lang_en_1 = require_lang_en();
      var lang_es_1 = require_lang_es();
      var lang_fr_1 = require_lang_fr();
      var lang_ja_1 = require_lang_ja();
      var lang_ko_1 = require_lang_ko();
      var lang_it_1 = require_lang_it();
      var lang_zh_1 = require_lang_zh();
      exports2.wordlists = {
        cz: lang_cz_1.langCz,
        en: lang_en_1.langEn,
        es: lang_es_1.langEs,
        fr: lang_fr_1.langFr,
        it: lang_it_1.langIt,
        ja: lang_ja_1.langJa,
        ko: lang_ko_1.langKo,
        zh: lang_zh_1.langZhCn,
        zh_cn: lang_zh_1.langZhCn,
        zh_tw: lang_zh_1.langZhTw
      };
    }
  });

  // node_modules/@ethersproject/wordlists/lib/index.js
  var require_lib21 = __commonJS({
    "node_modules/@ethersproject/wordlists/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlists = exports2.Wordlist = exports2.logger = void 0;
      var wordlist_1 = require_wordlist();
      Object.defineProperty(exports2, "logger", { enumerable: true, get: function() {
        return wordlist_1.logger;
      } });
      Object.defineProperty(exports2, "Wordlist", { enumerable: true, get: function() {
        return wordlist_1.Wordlist;
      } });
      var wordlists_1 = require_wordlists();
      Object.defineProperty(exports2, "wordlists", { enumerable: true, get: function() {
        return wordlists_1.wordlists;
      } });
    }
  });

  // node_modules/@ethersproject/hdnode/lib/_version.js
  var require_version16 = __commonJS({
    "node_modules/@ethersproject/hdnode/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "hdnode/5.7.0";
    }
  });

  // node_modules/@ethersproject/hdnode/lib/index.js
  var require_lib22 = __commonJS({
    "node_modules/@ethersproject/hdnode/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getAccountPath = exports2.isValidMnemonic = exports2.entropyToMnemonic = exports2.mnemonicToEntropy = exports2.mnemonicToSeed = exports2.HDNode = exports2.defaultPath = void 0;
      var basex_1 = require_lib18();
      var bytes_1 = require_lib2();
      var bignumber_1 = require_lib3();
      var strings_1 = require_lib9();
      var pbkdf2_1 = require_lib20();
      var properties_1 = require_lib4();
      var signing_key_1 = require_lib16();
      var sha2_1 = require_lib19();
      var transactions_1 = require_lib17();
      var wordlists_1 = require_lib21();
      var logger_1 = require_lib();
      var _version_1 = require_version16();
      var logger19 = new logger_1.Logger(_version_1.version);
      var N2 = bignumber_1.BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      var MasterSecret = (0, strings_1.toUtf8Bytes)("Bitcoin seed");
      var HardenedBit = 2147483648;
      function getUpperMask(bits) {
        return (1 << bits) - 1 << 8 - bits;
      }
      function getLowerMask(bits) {
        return (1 << bits) - 1;
      }
      function bytes32(value) {
        return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
      }
      function base58check3(data) {
        return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));
      }
      function getWordlist(wordlist10) {
        if (wordlist10 == null) {
          return wordlists_1.wordlists["en"];
        }
        if (typeof wordlist10 === "string") {
          var words = wordlists_1.wordlists[wordlist10];
          if (words == null) {
            logger19.throwArgumentError("unknown locale", "wordlist", wordlist10);
          }
          return words;
        }
        return wordlist10;
      }
      var _constructorGuard2 = {};
      exports2.defaultPath = "m/44'/60'/0'/0/0";
      var HDNode2 = (
        /** @class */
        function() {
          function HDNode3(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index2, depth, mnemonicOrPath) {
            if (constructorGuard !== _constructorGuard2) {
              throw new Error("HDNode constructor cannot be called directly");
            }
            if (privateKey) {
              var signingKey = new signing_key_1.SigningKey(privateKey);
              (0, properties_1.defineReadOnly)(this, "privateKey", signingKey.privateKey);
              (0, properties_1.defineReadOnly)(this, "publicKey", signingKey.compressedPublicKey);
            } else {
              (0, properties_1.defineReadOnly)(this, "privateKey", null);
              (0, properties_1.defineReadOnly)(this, "publicKey", (0, bytes_1.hexlify)(publicKey));
            }
            (0, properties_1.defineReadOnly)(this, "parentFingerprint", parentFingerprint);
            (0, properties_1.defineReadOnly)(this, "fingerprint", (0, bytes_1.hexDataSlice)((0, sha2_1.ripemd160)((0, sha2_1.sha256)(this.publicKey)), 0, 4));
            (0, properties_1.defineReadOnly)(this, "address", (0, transactions_1.computeAddress)(this.publicKey));
            (0, properties_1.defineReadOnly)(this, "chainCode", chainCode);
            (0, properties_1.defineReadOnly)(this, "index", index2);
            (0, properties_1.defineReadOnly)(this, "depth", depth);
            if (mnemonicOrPath == null) {
              (0, properties_1.defineReadOnly)(this, "mnemonic", null);
              (0, properties_1.defineReadOnly)(this, "path", null);
            } else if (typeof mnemonicOrPath === "string") {
              (0, properties_1.defineReadOnly)(this, "mnemonic", null);
              (0, properties_1.defineReadOnly)(this, "path", mnemonicOrPath);
            } else {
              (0, properties_1.defineReadOnly)(this, "mnemonic", mnemonicOrPath);
              (0, properties_1.defineReadOnly)(this, "path", mnemonicOrPath.path);
            }
          }
          Object.defineProperty(HDNode3.prototype, "extendedKey", {
            get: function() {
              if (this.depth >= 256) {
                throw new Error("Depth too large!");
              }
              return base58check3((0, bytes_1.concat)([
                this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
                (0, bytes_1.hexlify)(this.depth),
                this.parentFingerprint,
                (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(this.index), 4),
                this.chainCode,
                this.privateKey != null ? (0, bytes_1.concat)(["0x00", this.privateKey]) : this.publicKey
              ]));
            },
            enumerable: false,
            configurable: true
          });
          HDNode3.prototype.neuter = function() {
            return new HDNode3(_constructorGuard2, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
          };
          HDNode3.prototype._derive = function(index2) {
            if (index2 > 4294967295) {
              throw new Error("invalid index - " + String(index2));
            }
            var path = this.path;
            if (path) {
              path += "/" + (index2 & ~HardenedBit);
            }
            var data = new Uint8Array(37);
            if (index2 & HardenedBit) {
              if (!this.privateKey) {
                throw new Error("cannot derive child of neutered node");
              }
              data.set((0, bytes_1.arrayify)(this.privateKey), 1);
              if (path) {
                path += "'";
              }
            } else {
              data.set((0, bytes_1.arrayify)(this.publicKey));
            }
            for (var i4 = 24; i4 >= 0; i4 -= 8) {
              data[33 + (i4 >> 3)] = index2 >> 24 - i4 & 255;
            }
            var I4 = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, this.chainCode, data));
            var IL = I4.slice(0, 32);
            var IR = I4.slice(32);
            var ki = null;
            var Ki = null;
            if (this.privateKey) {
              ki = bytes32(bignumber_1.BigNumber.from(IL).add(this.privateKey).mod(N2));
            } else {
              var ek = new signing_key_1.SigningKey((0, bytes_1.hexlify)(IL));
              Ki = ek._addPoint(this.publicKey);
            }
            var mnemonicOrPath = path;
            var srcMnemonic = this.mnemonic;
            if (srcMnemonic) {
              mnemonicOrPath = Object.freeze({
                phrase: srcMnemonic.phrase,
                path,
                locale: srcMnemonic.locale || "en"
              });
            }
            return new HDNode3(_constructorGuard2, ki, Ki, this.fingerprint, bytes32(IR), index2, this.depth + 1, mnemonicOrPath);
          };
          HDNode3.prototype.derivePath = function(path) {
            var components = path.split("/");
            if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
              throw new Error("invalid path - " + path);
            }
            if (components[0] === "m") {
              components.shift();
            }
            var result = this;
            for (var i4 = 0; i4 < components.length; i4++) {
              var component = components[i4];
              if (component.match(/^[0-9]+'$/)) {
                var index2 = parseInt(component.substring(0, component.length - 1));
                if (index2 >= HardenedBit) {
                  throw new Error("invalid path index - " + component);
                }
                result = result._derive(HardenedBit + index2);
              } else if (component.match(/^[0-9]+$/)) {
                var index2 = parseInt(component);
                if (index2 >= HardenedBit) {
                  throw new Error("invalid path index - " + component);
                }
                result = result._derive(index2);
              } else {
                throw new Error("invalid path component - " + component);
              }
            }
            return result;
          };
          HDNode3._fromSeed = function(seed, mnemonic) {
            var seedArray = (0, bytes_1.arrayify)(seed);
            if (seedArray.length < 16 || seedArray.length > 64) {
              throw new Error("invalid seed");
            }
            var I4 = (0, bytes_1.arrayify)((0, sha2_1.computeHmac)(sha2_1.SupportedAlgorithm.sha512, MasterSecret, seedArray));
            return new HDNode3(_constructorGuard2, bytes32(I4.slice(0, 32)), null, "0x00000000", bytes32(I4.slice(32)), 0, 0, mnemonic);
          };
          HDNode3.fromMnemonic = function(mnemonic, password, wordlist10) {
            wordlist10 = getWordlist(wordlist10);
            mnemonic = entropyToMnemonic2(mnemonicToEntropy2(mnemonic, wordlist10), wordlist10);
            return HDNode3._fromSeed(mnemonicToSeed2(mnemonic, password), {
              phrase: mnemonic,
              path: "m",
              locale: wordlist10.locale
            });
          };
          HDNode3.fromSeed = function(seed) {
            return HDNode3._fromSeed(seed, null);
          };
          HDNode3.fromExtendedKey = function(extendedKey) {
            var bytes2 = basex_1.Base58.decode(extendedKey);
            if (bytes2.length !== 82 || base58check3(bytes2.slice(0, 78)) !== extendedKey) {
              logger19.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
            }
            var depth = bytes2[4];
            var parentFingerprint = (0, bytes_1.hexlify)(bytes2.slice(5, 9));
            var index2 = parseInt((0, bytes_1.hexlify)(bytes2.slice(9, 13)).substring(2), 16);
            var chainCode = (0, bytes_1.hexlify)(bytes2.slice(13, 45));
            var key = bytes2.slice(45, 78);
            switch ((0, bytes_1.hexlify)(bytes2.slice(0, 4))) {
              case "0x0488b21e":
              case "0x043587cf":
                return new HDNode3(_constructorGuard2, null, (0, bytes_1.hexlify)(key), parentFingerprint, chainCode, index2, depth, null);
              case "0x0488ade4":
              case "0x04358394 ":
                if (key[0] !== 0) {
                  break;
                }
                return new HDNode3(_constructorGuard2, (0, bytes_1.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index2, depth, null);
            }
            return logger19.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
          };
          return HDNode3;
        }()
      );
      exports2.HDNode = HDNode2;
      function mnemonicToSeed2(mnemonic, password) {
        if (!password) {
          password = "";
        }
        var salt = (0, strings_1.toUtf8Bytes)("mnemonic" + password, strings_1.UnicodeNormalizationForm.NFKD);
        return (0, pbkdf2_1.pbkdf2)((0, strings_1.toUtf8Bytes)(mnemonic, strings_1.UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
      }
      exports2.mnemonicToSeed = mnemonicToSeed2;
      function mnemonicToEntropy2(mnemonic, wordlist10) {
        wordlist10 = getWordlist(wordlist10);
        logger19.checkNormalize();
        var words = wordlist10.split(mnemonic);
        if (words.length % 3 !== 0) {
          throw new Error("invalid mnemonic");
        }
        var entropy = (0, bytes_1.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));
        var offset = 0;
        for (var i4 = 0; i4 < words.length; i4++) {
          var index2 = wordlist10.getWordIndex(words[i4].normalize("NFKD"));
          if (index2 === -1) {
            throw new Error("invalid mnemonic");
          }
          for (var bit = 0; bit < 11; bit++) {
            if (index2 & 1 << 10 - bit) {
              entropy[offset >> 3] |= 1 << 7 - offset % 8;
            }
            offset++;
          }
        }
        var entropyBits = 32 * words.length / 3;
        var checksumBits = words.length / 3;
        var checksumMask = getUpperMask(checksumBits);
        var checksum2 = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
        if (checksum2 !== (entropy[entropy.length - 1] & checksumMask)) {
          throw new Error("invalid checksum");
        }
        return (0, bytes_1.hexlify)(entropy.slice(0, entropyBits / 8));
      }
      exports2.mnemonicToEntropy = mnemonicToEntropy2;
      function entropyToMnemonic2(entropy, wordlist10) {
        wordlist10 = getWordlist(wordlist10);
        entropy = (0, bytes_1.arrayify)(entropy);
        if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
          throw new Error("invalid entropy");
        }
        var indices = [0];
        var remainingBits = 11;
        for (var i4 = 0; i4 < entropy.length; i4++) {
          if (remainingBits > 8) {
            indices[indices.length - 1] <<= 8;
            indices[indices.length - 1] |= entropy[i4];
            remainingBits -= 8;
          } else {
            indices[indices.length - 1] <<= remainingBits;
            indices[indices.length - 1] |= entropy[i4] >> 8 - remainingBits;
            indices.push(entropy[i4] & getLowerMask(8 - remainingBits));
            remainingBits += 3;
          }
        }
        var checksumBits = entropy.length / 4;
        var checksum2 = (0, bytes_1.arrayify)((0, sha2_1.sha256)(entropy))[0] & getUpperMask(checksumBits);
        indices[indices.length - 1] <<= checksumBits;
        indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
        return wordlist10.join(indices.map(function(index2) {
          return wordlist10.getWord(index2);
        }));
      }
      exports2.entropyToMnemonic = entropyToMnemonic2;
      function isValidMnemonic2(mnemonic, wordlist10) {
        try {
          mnemonicToEntropy2(mnemonic, wordlist10);
          return true;
        } catch (error) {
        }
        return false;
      }
      exports2.isValidMnemonic = isValidMnemonic2;
      function getAccountPath2(index2) {
        if (typeof index2 !== "number" || index2 < 0 || index2 >= HardenedBit || index2 % 1) {
          logger19.throwArgumentError("invalid account index", "index", index2);
        }
        return "m/44'/60'/" + index2 + "'/0/0";
      }
      exports2.getAccountPath = getAccountPath2;
    }
  });

  // node_modules/@ethersproject/random/lib/_version.js
  var require_version17 = __commonJS({
    "node_modules/@ethersproject/random/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "random/5.7.0";
    }
  });

  // node_modules/@ethersproject/random/lib/browser-random.js
  var require_browser_random = __commonJS({
    "node_modules/@ethersproject/random/lib/browser-random.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = void 0;
      var bytes_1 = require_lib2();
      var logger_1 = require_lib();
      var _version_1 = require_version17();
      var logger19 = new logger_1.Logger(_version_1.version);
      function getGlobal2() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw new Error("unable to locate global object");
      }
      var anyGlobal = getGlobal2();
      var crypto3 = anyGlobal.crypto || anyGlobal.msCrypto;
      if (!crypto3 || !crypto3.getRandomValues) {
        logger19.warn("WARNING: Missing strong random number source");
        crypto3 = {
          getRandomValues: function(buffer2) {
            return logger19.throwError("no secure random source avaialble", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "crypto.getRandomValues"
            });
          }
        };
      }
      function randomBytes3(length) {
        if (length <= 0 || length > 1024 || length % 1 || length != length) {
          logger19.throwArgumentError("invalid length", "length", length);
        }
        var result = new Uint8Array(length);
        crypto3.getRandomValues(result);
        return (0, bytes_1.arrayify)(result);
      }
      exports2.randomBytes = randomBytes3;
    }
  });

  // node_modules/@ethersproject/random/lib/shuffle.js
  var require_shuffle = __commonJS({
    "node_modules/@ethersproject/random/lib/shuffle.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.shuffled = void 0;
      function shuffled3(array2) {
        array2 = array2.slice();
        for (var i4 = array2.length - 1; i4 > 0; i4--) {
          var j3 = Math.floor(Math.random() * (i4 + 1));
          var tmp = array2[i4];
          array2[i4] = array2[j3];
          array2[j3] = tmp;
        }
        return array2;
      }
      exports2.shuffled = shuffled3;
    }
  });

  // node_modules/@ethersproject/random/lib/index.js
  var require_lib23 = __commonJS({
    "node_modules/@ethersproject/random/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.shuffled = exports2.randomBytes = void 0;
      var random_1 = require_browser_random();
      Object.defineProperty(exports2, "randomBytes", { enumerable: true, get: function() {
        return random_1.randomBytes;
      } });
      var shuffle_1 = require_shuffle();
      Object.defineProperty(exports2, "shuffled", { enumerable: true, get: function() {
        return shuffle_1.shuffled;
      } });
    }
  });

  // node_modules/aes-js/index.js
  var require_aes_js = __commonJS({
    "node_modules/aes-js/index.js"(exports2, module2) {
      "use strict";
      (function(root) {
        function checkInt(value) {
          return parseInt(value) === value;
        }
        function checkInts(arrayish) {
          if (!checkInt(arrayish.length)) {
            return false;
          }
          for (var i4 = 0; i4 < arrayish.length; i4++) {
            if (!checkInt(arrayish[i4]) || arrayish[i4] < 0 || arrayish[i4] > 255) {
              return false;
            }
          }
          return true;
        }
        function coerceArray(arg, copy) {
          if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
            if (copy) {
              if (arg.slice) {
                arg = arg.slice();
              } else {
                arg = Array.prototype.slice.call(arg);
              }
            }
            return arg;
          }
          if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
              throw new Error("Array contains invalid value: " + arg);
            }
            return new Uint8Array(arg);
          }
          if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
          }
          throw new Error("unsupported array-like object");
        }
        function createArray(length) {
          return new Uint8Array(length);
        }
        function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
          if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
              sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
              sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
          }
          targetArray.set(sourceArray, targetStart);
        }
        var convertUtf8 = function() {
          function toBytes4(text) {
            var result = [], i4 = 0;
            text = encodeURI(text);
            while (i4 < text.length) {
              var c3 = text.charCodeAt(i4++);
              if (c3 === 37) {
                result.push(parseInt(text.substr(i4, 2), 16));
                i4 += 2;
              } else {
                result.push(c3);
              }
            }
            return coerceArray(result);
          }
          function fromBytes3(bytes2) {
            var result = [], i4 = 0;
            while (i4 < bytes2.length) {
              var c3 = bytes2[i4];
              if (c3 < 128) {
                result.push(String.fromCharCode(c3));
                i4++;
              } else if (c3 > 191 && c3 < 224) {
                result.push(String.fromCharCode((c3 & 31) << 6 | bytes2[i4 + 1] & 63));
                i4 += 2;
              } else {
                result.push(String.fromCharCode((c3 & 15) << 12 | (bytes2[i4 + 1] & 63) << 6 | bytes2[i4 + 2] & 63));
                i4 += 3;
              }
            }
            return result.join("");
          }
          return {
            toBytes: toBytes4,
            fromBytes: fromBytes3
          };
        }();
        var convertHex = function() {
          function toBytes4(text) {
            var result = [];
            for (var i4 = 0; i4 < text.length; i4 += 2) {
              result.push(parseInt(text.substr(i4, 2), 16));
            }
            return result;
          }
          var Hex = "0123456789abcdef";
          function fromBytes3(bytes2) {
            var result = [];
            for (var i4 = 0; i4 < bytes2.length; i4++) {
              var v7 = bytes2[i4];
              result.push(Hex[(v7 & 240) >> 4] + Hex[v7 & 15]);
            }
            return result.join("");
          }
          return {
            toBytes: toBytes4,
            fromBytes: fromBytes3
          };
        }();
        var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
        var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
        var S3 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
        var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
        var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
        var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
        var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
        var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
        var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
        var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
        var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
        var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
        var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
        var U22 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
        var U32 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
        var U42 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
        function convertToInt32(bytes2) {
          var result = [];
          for (var i4 = 0; i4 < bytes2.length; i4 += 4) {
            result.push(
              bytes2[i4] << 24 | bytes2[i4 + 1] << 16 | bytes2[i4 + 2] << 8 | bytes2[i4 + 3]
            );
          }
          return result;
        }
        var AES = function(key) {
          if (!(this instanceof AES)) {
            throw Error("AES must be instanitated with `new`");
          }
          Object.defineProperty(this, "key", {
            value: coerceArray(key, true)
          });
          this._prepare();
        };
        AES.prototype._prepare = function() {
          var rounds = numberOfRounds[this.key.length];
          if (rounds == null) {
            throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
          }
          this._Ke = [];
          this._Kd = [];
          for (var i4 = 0; i4 <= rounds; i4++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
          }
          var roundKeyCount = (rounds + 1) * 4;
          var KC = this.key.length / 4;
          var tk = convertToInt32(this.key);
          var index2;
          for (var i4 = 0; i4 < KC; i4++) {
            index2 = i4 >> 2;
            this._Ke[index2][i4 % 4] = tk[i4];
            this._Kd[rounds - index2][i4 % 4] = tk[i4];
          }
          var rconpointer = 0;
          var t3 = KC, tt2;
          while (t3 < roundKeyCount) {
            tt2 = tk[KC - 1];
            tk[0] ^= S3[tt2 >> 16 & 255] << 24 ^ S3[tt2 >> 8 & 255] << 16 ^ S3[tt2 & 255] << 8 ^ S3[tt2 >> 24 & 255] ^ rcon[rconpointer] << 24;
            rconpointer += 1;
            if (KC != 8) {
              for (var i4 = 1; i4 < KC; i4++) {
                tk[i4] ^= tk[i4 - 1];
              }
            } else {
              for (var i4 = 1; i4 < KC / 2; i4++) {
                tk[i4] ^= tk[i4 - 1];
              }
              tt2 = tk[KC / 2 - 1];
              tk[KC / 2] ^= S3[tt2 & 255] ^ S3[tt2 >> 8 & 255] << 8 ^ S3[tt2 >> 16 & 255] << 16 ^ S3[tt2 >> 24 & 255] << 24;
              for (var i4 = KC / 2 + 1; i4 < KC; i4++) {
                tk[i4] ^= tk[i4 - 1];
              }
            }
            var i4 = 0, r2, c3;
            while (i4 < KC && t3 < roundKeyCount) {
              r2 = t3 >> 2;
              c3 = t3 % 4;
              this._Ke[r2][c3] = tk[i4];
              this._Kd[rounds - r2][c3] = tk[i4++];
              t3++;
            }
          }
          for (var r2 = 1; r2 < rounds; r2++) {
            for (var c3 = 0; c3 < 4; c3++) {
              tt2 = this._Kd[r2][c3];
              this._Kd[r2][c3] = U1[tt2 >> 24 & 255] ^ U22[tt2 >> 16 & 255] ^ U32[tt2 >> 8 & 255] ^ U42[tt2 & 255];
            }
          }
        };
        AES.prototype.encrypt = function(plaintext) {
          if (plaintext.length != 16) {
            throw new Error("invalid plaintext size (must be 16 bytes)");
          }
          var rounds = this._Ke.length - 1;
          var a2 = [0, 0, 0, 0];
          var t3 = convertToInt32(plaintext);
          for (var i4 = 0; i4 < 4; i4++) {
            t3[i4] ^= this._Ke[0][i4];
          }
          for (var r2 = 1; r2 < rounds; r2++) {
            for (var i4 = 0; i4 < 4; i4++) {
              a2[i4] = T1[t3[i4] >> 24 & 255] ^ T22[t3[(i4 + 1) % 4] >> 16 & 255] ^ T32[t3[(i4 + 2) % 4] >> 8 & 255] ^ T4[t3[(i4 + 3) % 4] & 255] ^ this._Ke[r2][i4];
            }
            t3 = a2.slice();
          }
          var result = createArray(16), tt2;
          for (var i4 = 0; i4 < 4; i4++) {
            tt2 = this._Ke[rounds][i4];
            result[4 * i4] = (S3[t3[i4] >> 24 & 255] ^ tt2 >> 24) & 255;
            result[4 * i4 + 1] = (S3[t3[(i4 + 1) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
            result[4 * i4 + 2] = (S3[t3[(i4 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
            result[4 * i4 + 3] = (S3[t3[(i4 + 3) % 4] & 255] ^ tt2) & 255;
          }
          return result;
        };
        AES.prototype.decrypt = function(ciphertext) {
          if (ciphertext.length != 16) {
            throw new Error("invalid ciphertext size (must be 16 bytes)");
          }
          var rounds = this._Kd.length - 1;
          var a2 = [0, 0, 0, 0];
          var t3 = convertToInt32(ciphertext);
          for (var i4 = 0; i4 < 4; i4++) {
            t3[i4] ^= this._Kd[0][i4];
          }
          for (var r2 = 1; r2 < rounds; r2++) {
            for (var i4 = 0; i4 < 4; i4++) {
              a2[i4] = T5[t3[i4] >> 24 & 255] ^ T6[t3[(i4 + 3) % 4] >> 16 & 255] ^ T7[t3[(i4 + 2) % 4] >> 8 & 255] ^ T8[t3[(i4 + 1) % 4] & 255] ^ this._Kd[r2][i4];
            }
            t3 = a2.slice();
          }
          var result = createArray(16), tt2;
          for (var i4 = 0; i4 < 4; i4++) {
            tt2 = this._Kd[rounds][i4];
            result[4 * i4] = (Si[t3[i4] >> 24 & 255] ^ tt2 >> 24) & 255;
            result[4 * i4 + 1] = (Si[t3[(i4 + 3) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
            result[4 * i4 + 2] = (Si[t3[(i4 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
            result[4 * i4 + 3] = (Si[t3[(i4 + 1) % 4] & 255] ^ tt2) & 255;
          }
          return result;
        };
        var ModeOfOperationECB = function(key) {
          if (!(this instanceof ModeOfOperationECB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Electronic Code Block";
          this.name = "ecb";
          this._aes = new AES(key);
        };
        ModeOfOperationECB.prototype.encrypt = function(plaintext) {
          plaintext = coerceArray(plaintext);
          if (plaintext.length % 16 !== 0) {
            throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
          }
          var ciphertext = createArray(plaintext.length);
          var block = createArray(16);
          for (var i4 = 0; i4 < plaintext.length; i4 += 16) {
            copyArray(plaintext, block, 0, i4, i4 + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i4);
          }
          return ciphertext;
        };
        ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
          ciphertext = coerceArray(ciphertext);
          if (ciphertext.length % 16 !== 0) {
            throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          var plaintext = createArray(ciphertext.length);
          var block = createArray(16);
          for (var i4 = 0; i4 < ciphertext.length; i4 += 16) {
            copyArray(ciphertext, block, 0, i4, i4 + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i4);
          }
          return plaintext;
        };
        var ModeOfOperationCBC = function(key, iv) {
          if (!(this instanceof ModeOfOperationCBC)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Cipher Block Chaining";
          this.name = "cbc";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 bytes)");
          }
          this._lastCipherblock = coerceArray(iv, true);
          this._aes = new AES(key);
        };
        ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
          plaintext = coerceArray(plaintext);
          if (plaintext.length % 16 !== 0) {
            throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
          }
          var ciphertext = createArray(plaintext.length);
          var block = createArray(16);
          for (var i4 = 0; i4 < plaintext.length; i4 += 16) {
            copyArray(plaintext, block, 0, i4, i4 + 16);
            for (var j3 = 0; j3 < 16; j3++) {
              block[j3] ^= this._lastCipherblock[j3];
            }
            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i4);
          }
          return ciphertext;
        };
        ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
          ciphertext = coerceArray(ciphertext);
          if (ciphertext.length % 16 !== 0) {
            throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          var plaintext = createArray(ciphertext.length);
          var block = createArray(16);
          for (var i4 = 0; i4 < ciphertext.length; i4 += 16) {
            copyArray(ciphertext, block, 0, i4, i4 + 16);
            block = this._aes.decrypt(block);
            for (var j3 = 0; j3 < 16; j3++) {
              plaintext[i4 + j3] = block[j3] ^ this._lastCipherblock[j3];
            }
            copyArray(ciphertext, this._lastCipherblock, 0, i4, i4 + 16);
          }
          return plaintext;
        };
        var ModeOfOperationCFB = function(key, iv, segmentSize) {
          if (!(this instanceof ModeOfOperationCFB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Cipher Feedback";
          this.name = "cfb";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 size)");
          }
          if (!segmentSize) {
            segmentSize = 1;
          }
          this.segmentSize = segmentSize;
          this._shiftRegister = coerceArray(iv, true);
          this._aes = new AES(key);
        };
        ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
          if (plaintext.length % this.segmentSize != 0) {
            throw new Error("invalid plaintext size (must be segmentSize bytes)");
          }
          var encrypted = coerceArray(plaintext, true);
          var xorSegment;
          for (var i4 = 0; i4 < encrypted.length; i4 += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j3 = 0; j3 < this.segmentSize; j3++) {
              encrypted[i4 + j3] ^= xorSegment[j3];
            }
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i4, i4 + this.segmentSize);
          }
          return encrypted;
        };
        ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
          if (ciphertext.length % this.segmentSize != 0) {
            throw new Error("invalid ciphertext size (must be segmentSize bytes)");
          }
          var plaintext = coerceArray(ciphertext, true);
          var xorSegment;
          for (var i4 = 0; i4 < plaintext.length; i4 += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j3 = 0; j3 < this.segmentSize; j3++) {
              plaintext[i4 + j3] ^= xorSegment[j3];
            }
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i4, i4 + this.segmentSize);
          }
          return plaintext;
        };
        var ModeOfOperationOFB = function(key, iv) {
          if (!(this instanceof ModeOfOperationOFB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Output Feedback";
          this.name = "ofb";
          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 bytes)");
          }
          this._lastPrecipher = coerceArray(iv, true);
          this._lastPrecipherIndex = 16;
          this._aes = new AES(key);
        };
        ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
          var encrypted = coerceArray(plaintext, true);
          for (var i4 = 0; i4 < encrypted.length; i4++) {
            if (this._lastPrecipherIndex === 16) {
              this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
              this._lastPrecipherIndex = 0;
            }
            encrypted[i4] ^= this._lastPrecipher[this._lastPrecipherIndex++];
          }
          return encrypted;
        };
        ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
        var Counter = function(initialValue) {
          if (!(this instanceof Counter)) {
            throw Error("Counter must be instanitated with `new`");
          }
          if (initialValue !== 0 && !initialValue) {
            initialValue = 1;
          }
          if (typeof initialValue === "number") {
            this._counter = createArray(16);
            this.setValue(initialValue);
          } else {
            this.setBytes(initialValue);
          }
        };
        Counter.prototype.setValue = function(value) {
          if (typeof value !== "number" || parseInt(value) != value) {
            throw new Error("invalid counter value (must be an integer)");
          }
          for (var index2 = 15; index2 >= 0; --index2) {
            this._counter[index2] = value % 256;
            value = value >> 8;
          }
        };
        Counter.prototype.setBytes = function(bytes2) {
          bytes2 = coerceArray(bytes2, true);
          if (bytes2.length != 16) {
            throw new Error("invalid counter bytes size (must be 16 bytes)");
          }
          this._counter = bytes2;
        };
        Counter.prototype.increment = function() {
          for (var i4 = 15; i4 >= 0; i4--) {
            if (this._counter[i4] === 255) {
              this._counter[i4] = 0;
            } else {
              this._counter[i4]++;
              break;
            }
          }
        };
        var ModeOfOperationCTR = function(key, counter) {
          if (!(this instanceof ModeOfOperationCTR)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Counter";
          this.name = "ctr";
          if (!(counter instanceof Counter)) {
            counter = new Counter(counter);
          }
          this._counter = counter;
          this._remainingCounter = null;
          this._remainingCounterIndex = 16;
          this._aes = new AES(key);
        };
        ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
          var encrypted = coerceArray(plaintext, true);
          for (var i4 = 0; i4 < encrypted.length; i4++) {
            if (this._remainingCounterIndex === 16) {
              this._remainingCounter = this._aes.encrypt(this._counter._counter);
              this._remainingCounterIndex = 0;
              this._counter.increment();
            }
            encrypted[i4] ^= this._remainingCounter[this._remainingCounterIndex++];
          }
          return encrypted;
        };
        ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
        function pkcs7pad(data) {
          data = coerceArray(data, true);
          var padder = 16 - data.length % 16;
          var result = createArray(data.length + padder);
          copyArray(data, result);
          for (var i4 = data.length; i4 < result.length; i4++) {
            result[i4] = padder;
          }
          return result;
        }
        function pkcs7strip(data) {
          data = coerceArray(data, true);
          if (data.length < 16) {
            throw new Error("PKCS#7 invalid length");
          }
          var padder = data[data.length - 1];
          if (padder > 16) {
            throw new Error("PKCS#7 padding byte out of range");
          }
          var length = data.length - padder;
          for (var i4 = 0; i4 < padder; i4++) {
            if (data[length + i4] !== padder) {
              throw new Error("PKCS#7 invalid padding byte");
            }
          }
          var result = createArray(length);
          copyArray(data, result, 0, 0, length);
          return result;
        }
        var aesjs = {
          AES,
          Counter,
          ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
          },
          utils: {
            hex: convertHex,
            utf8: convertUtf8
          },
          padding: {
            pkcs7: {
              pad: pkcs7pad,
              strip: pkcs7strip
            }
          },
          _arrayTest: {
            coerceArray,
            createArray,
            copyArray
          }
        };
        if (typeof exports2 !== "undefined") {
          module2.exports = aesjs;
        } else if (typeof define === "function" && define.amd) {
          define(aesjs);
        } else {
          if (root.aesjs) {
            aesjs._aesjs = root.aesjs;
          }
          root.aesjs = aesjs;
        }
      })(exports2);
    }
  });

  // node_modules/@ethersproject/json-wallets/lib/_version.js
  var require_version18 = __commonJS({
    "node_modules/@ethersproject/json-wallets/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "json-wallets/5.7.0";
    }
  });

  // node_modules/@ethersproject/json-wallets/lib/utils.js
  var require_utils4 = __commonJS({
    "node_modules/@ethersproject/json-wallets/lib/utils.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.uuidV4 = exports2.searchPath = exports2.getPassword = exports2.zpad = exports2.looseArrayify = void 0;
      var bytes_1 = require_lib2();
      var strings_1 = require_lib9();
      function looseArrayify(hexString) {
        if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
          hexString = "0x" + hexString;
        }
        return (0, bytes_1.arrayify)(hexString);
      }
      exports2.looseArrayify = looseArrayify;
      function zpad(value, length) {
        value = String(value);
        while (value.length < length) {
          value = "0" + value;
        }
        return value;
      }
      exports2.zpad = zpad;
      function getPassword(password) {
        if (typeof password === "string") {
          return (0, strings_1.toUtf8Bytes)(password, strings_1.UnicodeNormalizationForm.NFKC);
        }
        return (0, bytes_1.arrayify)(password);
      }
      exports2.getPassword = getPassword;
      function searchPath(object2, path) {
        var currentChild = object2;
        var comps = path.toLowerCase().split("/");
        for (var i4 = 0; i4 < comps.length; i4++) {
          var matchingChild = null;
          for (var key in currentChild) {
            if (key.toLowerCase() === comps[i4]) {
              matchingChild = currentChild[key];
              break;
            }
          }
          if (matchingChild === null) {
            return null;
          }
          currentChild = matchingChild;
        }
        return currentChild;
      }
      exports2.searchPath = searchPath;
      function uuidV4(randomBytes3) {
        var bytes2 = (0, bytes_1.arrayify)(randomBytes3);
        bytes2[6] = bytes2[6] & 15 | 64;
        bytes2[8] = bytes2[8] & 63 | 128;
        var value = (0, bytes_1.hexlify)(bytes2);
        return [
          value.substring(2, 10),
          value.substring(10, 14),
          value.substring(14, 18),
          value.substring(18, 22),
          value.substring(22, 34)
        ].join("-");
      }
      exports2.uuidV4 = uuidV4;
    }
  });

  // node_modules/@ethersproject/json-wallets/lib/crowdsale.js
  var require_crowdsale = __commonJS({
    "node_modules/@ethersproject/json-wallets/lib/crowdsale.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decrypt = exports2.CrowdsaleAccount = void 0;
      var aes_js_1 = __importDefault(require_aes_js());
      var address_1 = require_lib7();
      var bytes_1 = require_lib2();
      var keccak256_1 = require_lib5();
      var pbkdf2_1 = require_lib20();
      var strings_1 = require_lib9();
      var properties_1 = require_lib4();
      var logger_1 = require_lib();
      var _version_1 = require_version18();
      var logger19 = new logger_1.Logger(_version_1.version);
      var utils_1 = require_utils4();
      var CrowdsaleAccount = (
        /** @class */
        function(_super) {
          __extends2(CrowdsaleAccount2, _super);
          function CrowdsaleAccount2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          CrowdsaleAccount2.prototype.isCrowdsaleAccount = function(value) {
            return !!(value && value._isCrowdsaleAccount);
          };
          return CrowdsaleAccount2;
        }(properties_1.Description)
      );
      exports2.CrowdsaleAccount = CrowdsaleAccount;
      function decrypt(json, password) {
        var data = JSON.parse(json);
        password = (0, utils_1.getPassword)(password);
        var ethaddr = (0, address_1.getAddress)((0, utils_1.searchPath)(data, "ethaddr"));
        var encseed = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "encseed"));
        if (!encseed || encseed.length % 16 !== 0) {
          logger19.throwArgumentError("invalid encseed", "json", json);
        }
        var key = (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(password, password, 2e3, 32, "sha256")).slice(0, 16);
        var iv = encseed.slice(0, 16);
        var encryptedSeed = encseed.slice(16);
        var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);
        var seed = aes_js_1.default.padding.pkcs7.strip((0, bytes_1.arrayify)(aesCbc.decrypt(encryptedSeed)));
        var seedHex = "";
        for (var i4 = 0; i4 < seed.length; i4++) {
          seedHex += String.fromCharCode(seed[i4]);
        }
        var seedHexBytes = (0, strings_1.toUtf8Bytes)(seedHex);
        var privateKey = (0, keccak256_1.keccak256)(seedHexBytes);
        return new CrowdsaleAccount({
          _isCrowdsaleAccount: true,
          address: ethaddr,
          privateKey
        });
      }
      exports2.decrypt = decrypt;
    }
  });

  // node_modules/@ethersproject/json-wallets/lib/inspect.js
  var require_inspect = __commonJS({
    "node_modules/@ethersproject/json-wallets/lib/inspect.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getJsonWalletAddress = exports2.isKeystoreWallet = exports2.isCrowdsaleWallet = void 0;
      var address_1 = require_lib7();
      function isCrowdsaleWallet(json) {
        var data = null;
        try {
          data = JSON.parse(json);
        } catch (error) {
          return false;
        }
        return data.encseed && data.ethaddr;
      }
      exports2.isCrowdsaleWallet = isCrowdsaleWallet;
      function isKeystoreWallet(json) {
        var data = null;
        try {
          data = JSON.parse(json);
        } catch (error) {
          return false;
        }
        if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
          return false;
        }
        return true;
      }
      exports2.isKeystoreWallet = isKeystoreWallet;
      function getJsonWalletAddress2(json) {
        if (isCrowdsaleWallet(json)) {
          try {
            return (0, address_1.getAddress)(JSON.parse(json).ethaddr);
          } catch (error) {
            return null;
          }
        }
        if (isKeystoreWallet(json)) {
          try {
            return (0, address_1.getAddress)(JSON.parse(json).address);
          } catch (error) {
            return null;
          }
        }
        return null;
      }
      exports2.getJsonWalletAddress = getJsonWalletAddress2;
    }
  });

  // node_modules/scrypt-js/scrypt.js
  var require_scrypt = __commonJS({
    "node_modules/scrypt-js/scrypt.js"(exports2, module2) {
      "use strict";
      (function(root) {
        const MAX_VALUE2 = 2147483647;
        function SHA2562(m5) {
          const K4 = new Uint32Array([
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ]);
          let h0 = 1779033703, h1 = 3144134277, h22 = 1013904242, h32 = 2773480762;
          let h42 = 1359893119, h52 = 2600822924, h6 = 528734635, h7 = 1541459225;
          const w3 = new Uint32Array(64);
          function blocks(p3) {
            let off = 0, len = p3.length;
            while (len >= 64) {
              let a2 = h0, b4 = h1, c3 = h22, d6 = h32, e = h42, f5 = h52, g5 = h6, h8 = h7, u3, i5, j3, t1, t22;
              for (i5 = 0; i5 < 16; i5++) {
                j3 = off + i5 * 4;
                w3[i5] = (p3[j3] & 255) << 24 | (p3[j3 + 1] & 255) << 16 | (p3[j3 + 2] & 255) << 8 | p3[j3 + 3] & 255;
              }
              for (i5 = 16; i5 < 64; i5++) {
                u3 = w3[i5 - 2];
                t1 = (u3 >>> 17 | u3 << 32 - 17) ^ (u3 >>> 19 | u3 << 32 - 19) ^ u3 >>> 10;
                u3 = w3[i5 - 15];
                t22 = (u3 >>> 7 | u3 << 32 - 7) ^ (u3 >>> 18 | u3 << 32 - 18) ^ u3 >>> 3;
                w3[i5] = (t1 + w3[i5 - 7] | 0) + (t22 + w3[i5 - 16] | 0) | 0;
              }
              for (i5 = 0; i5 < 64; i5++) {
                t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f5 ^ ~e & g5) | 0) + (h8 + (K4[i5] + w3[i5] | 0) | 0) | 0;
                t22 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b4 ^ a2 & c3 ^ b4 & c3) | 0;
                h8 = g5;
                g5 = f5;
                f5 = e;
                e = d6 + t1 | 0;
                d6 = c3;
                c3 = b4;
                b4 = a2;
                a2 = t1 + t22 | 0;
              }
              h0 = h0 + a2 | 0;
              h1 = h1 + b4 | 0;
              h22 = h22 + c3 | 0;
              h32 = h32 + d6 | 0;
              h42 = h42 + e | 0;
              h52 = h52 + f5 | 0;
              h6 = h6 + g5 | 0;
              h7 = h7 + h8 | 0;
              off += 64;
              len -= 64;
            }
          }
          blocks(m5);
          let i4, bytesLeft = m5.length % 64, bitLenHi = m5.length / 536870912 | 0, bitLenLo = m5.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p2 = m5.slice(m5.length - bytesLeft, m5.length);
          p2.push(128);
          for (i4 = bytesLeft + 1; i4 < numZeros; i4++) {
            p2.push(0);
          }
          p2.push(bitLenHi >>> 24 & 255);
          p2.push(bitLenHi >>> 16 & 255);
          p2.push(bitLenHi >>> 8 & 255);
          p2.push(bitLenHi >>> 0 & 255);
          p2.push(bitLenLo >>> 24 & 255);
          p2.push(bitLenLo >>> 16 & 255);
          p2.push(bitLenLo >>> 8 & 255);
          p2.push(bitLenLo >>> 0 & 255);
          blocks(p2);
          return [
            h0 >>> 24 & 255,
            h0 >>> 16 & 255,
            h0 >>> 8 & 255,
            h0 >>> 0 & 255,
            h1 >>> 24 & 255,
            h1 >>> 16 & 255,
            h1 >>> 8 & 255,
            h1 >>> 0 & 255,
            h22 >>> 24 & 255,
            h22 >>> 16 & 255,
            h22 >>> 8 & 255,
            h22 >>> 0 & 255,
            h32 >>> 24 & 255,
            h32 >>> 16 & 255,
            h32 >>> 8 & 255,
            h32 >>> 0 & 255,
            h42 >>> 24 & 255,
            h42 >>> 16 & 255,
            h42 >>> 8 & 255,
            h42 >>> 0 & 255,
            h52 >>> 24 & 255,
            h52 >>> 16 & 255,
            h52 >>> 8 & 255,
            h52 >>> 0 & 255,
            h6 >>> 24 & 255,
            h6 >>> 16 & 255,
            h6 >>> 8 & 255,
            h6 >>> 0 & 255,
            h7 >>> 24 & 255,
            h7 >>> 16 & 255,
            h7 >>> 8 & 255,
            h7 >>> 0 & 255
          ];
        }
        function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
          password = password.length <= 64 ? password : SHA2562(password);
          const innerLen = 64 + salt.length + 4;
          const inner = new Array(innerLen);
          const outerKey = new Array(64);
          let i4;
          let dk = [];
          for (i4 = 0; i4 < 64; i4++) {
            inner[i4] = 54;
          }
          for (i4 = 0; i4 < password.length; i4++) {
            inner[i4] ^= password[i4];
          }
          for (i4 = 0; i4 < salt.length; i4++) {
            inner[64 + i4] = salt[i4];
          }
          for (i4 = innerLen - 4; i4 < innerLen; i4++) {
            inner[i4] = 0;
          }
          for (i4 = 0; i4 < 64; i4++)
            outerKey[i4] = 92;
          for (i4 = 0; i4 < password.length; i4++)
            outerKey[i4] ^= password[i4];
          function incrementCounter() {
            for (let i5 = innerLen - 1; i5 >= innerLen - 4; i5--) {
              inner[i5]++;
              if (inner[i5] <= 255)
                return;
              inner[i5] = 0;
            }
          }
          while (dkLen >= 32) {
            incrementCounter();
            dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))));
            dkLen -= 32;
          }
          if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))).slice(0, dkLen));
          }
          return dk;
        }
        function blockmix_salsa8(BY, Yi, r2, x8, _X) {
          let i4;
          arraycopy(BY, (2 * r2 - 1) * 16, _X, 0, 16);
          for (i4 = 0; i4 < 2 * r2; i4++) {
            blockxor(BY, i4 * 16, _X, 16);
            salsa20_8(_X, x8);
            arraycopy(_X, 0, BY, Yi + i4 * 16, 16);
          }
          for (i4 = 0; i4 < r2; i4++) {
            arraycopy(BY, Yi + i4 * 2 * 16, BY, i4 * 16, 16);
          }
          for (i4 = 0; i4 < r2; i4++) {
            arraycopy(BY, Yi + (i4 * 2 + 1) * 16, BY, (i4 + r2) * 16, 16);
          }
        }
        function R4(a2, b4) {
          return a2 << b4 | a2 >>> 32 - b4;
        }
        function salsa20_8(B5, x8) {
          arraycopy(B5, 0, x8, 0, 16);
          for (let i4 = 8; i4 > 0; i4 -= 2) {
            x8[4] ^= R4(x8[0] + x8[12], 7);
            x8[8] ^= R4(x8[4] + x8[0], 9);
            x8[12] ^= R4(x8[8] + x8[4], 13);
            x8[0] ^= R4(x8[12] + x8[8], 18);
            x8[9] ^= R4(x8[5] + x8[1], 7);
            x8[13] ^= R4(x8[9] + x8[5], 9);
            x8[1] ^= R4(x8[13] + x8[9], 13);
            x8[5] ^= R4(x8[1] + x8[13], 18);
            x8[14] ^= R4(x8[10] + x8[6], 7);
            x8[2] ^= R4(x8[14] + x8[10], 9);
            x8[6] ^= R4(x8[2] + x8[14], 13);
            x8[10] ^= R4(x8[6] + x8[2], 18);
            x8[3] ^= R4(x8[15] + x8[11], 7);
            x8[7] ^= R4(x8[3] + x8[15], 9);
            x8[11] ^= R4(x8[7] + x8[3], 13);
            x8[15] ^= R4(x8[11] + x8[7], 18);
            x8[1] ^= R4(x8[0] + x8[3], 7);
            x8[2] ^= R4(x8[1] + x8[0], 9);
            x8[3] ^= R4(x8[2] + x8[1], 13);
            x8[0] ^= R4(x8[3] + x8[2], 18);
            x8[6] ^= R4(x8[5] + x8[4], 7);
            x8[7] ^= R4(x8[6] + x8[5], 9);
            x8[4] ^= R4(x8[7] + x8[6], 13);
            x8[5] ^= R4(x8[4] + x8[7], 18);
            x8[11] ^= R4(x8[10] + x8[9], 7);
            x8[8] ^= R4(x8[11] + x8[10], 9);
            x8[9] ^= R4(x8[8] + x8[11], 13);
            x8[10] ^= R4(x8[9] + x8[8], 18);
            x8[12] ^= R4(x8[15] + x8[14], 7);
            x8[13] ^= R4(x8[12] + x8[15], 9);
            x8[14] ^= R4(x8[13] + x8[12], 13);
            x8[15] ^= R4(x8[14] + x8[13], 18);
          }
          for (let i4 = 0; i4 < 16; ++i4) {
            B5[i4] += x8[i4];
          }
        }
        function blockxor(S3, Si, D4, len) {
          for (let i4 = 0; i4 < len; i4++) {
            D4[i4] ^= S3[Si + i4];
          }
        }
        function arraycopy(src, srcPos, dest, destPos, length) {
          while (length--) {
            dest[destPos++] = src[srcPos++];
          }
        }
        function checkBufferish(o3) {
          if (!o3 || typeof o3.length !== "number") {
            return false;
          }
          for (let i4 = 0; i4 < o3.length; i4++) {
            const v7 = o3[i4];
            if (typeof v7 !== "number" || v7 % 1 || v7 < 0 || v7 >= 256) {
              return false;
            }
          }
          return true;
        }
        function ensureInteger(value, name) {
          if (typeof value !== "number" || value % 1) {
            throw new Error("invalid " + name);
          }
          return value;
        }
        function _scrypt(password, salt, N2, r2, p2, dkLen, callback) {
          N2 = ensureInteger(N2, "N");
          r2 = ensureInteger(r2, "r");
          p2 = ensureInteger(p2, "p");
          dkLen = ensureInteger(dkLen, "dkLen");
          if (N2 === 0 || (N2 & N2 - 1) !== 0) {
            throw new Error("N must be power of 2");
          }
          if (N2 > MAX_VALUE2 / 128 / r2) {
            throw new Error("N too large");
          }
          if (r2 > MAX_VALUE2 / 128 / p2) {
            throw new Error("r too large");
          }
          if (!checkBufferish(password)) {
            throw new Error("password must be an array or buffer");
          }
          password = Array.prototype.slice.call(password);
          if (!checkBufferish(salt)) {
            throw new Error("salt must be an array or buffer");
          }
          salt = Array.prototype.slice.call(salt);
          let b4 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p2 * 128 * r2);
          const B5 = new Uint32Array(p2 * 32 * r2);
          for (let i4 = 0; i4 < B5.length; i4++) {
            const j3 = i4 * 4;
            B5[i4] = (b4[j3 + 3] & 255) << 24 | (b4[j3 + 2] & 255) << 16 | (b4[j3 + 1] & 255) << 8 | (b4[j3 + 0] & 255) << 0;
          }
          const XY = new Uint32Array(64 * r2);
          const V7 = new Uint32Array(32 * r2 * N2);
          const Yi = 32 * r2;
          const x8 = new Uint32Array(16);
          const _X = new Uint32Array(16);
          const totalOps = p2 * N2 * 2;
          let currentOp = 0;
          let lastPercent10 = null;
          let stop = false;
          let state = 0;
          let i0 = 0, i1;
          let Bi;
          const limit = callback ? parseInt(1e3 / r2) : 4294967295;
          const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
          const incrementalSMix = function() {
            if (stop) {
              return callback(new Error("cancelled"), currentOp / totalOps);
            }
            let steps;
            switch (state) {
              case 0:
                Bi = i0 * 32 * r2;
                arraycopy(B5, Bi, XY, 0, Yi);
                state = 1;
                i1 = 0;
              case 1:
                steps = N2 - i1;
                if (steps > limit) {
                  steps = limit;
                }
                for (let i4 = 0; i4 < steps; i4++) {
                  arraycopy(XY, 0, V7, (i1 + i4) * Yi, Yi);
                  blockmix_salsa8(XY, Yi, r2, x8, _X);
                }
                i1 += steps;
                currentOp += steps;
                if (callback) {
                  const percent10 = parseInt(1e3 * currentOp / totalOps);
                  if (percent10 !== lastPercent10) {
                    stop = callback(null, currentOp / totalOps);
                    if (stop) {
                      break;
                    }
                    lastPercent10 = percent10;
                  }
                }
                if (i1 < N2) {
                  break;
                }
                i1 = 0;
                state = 2;
              case 2:
                steps = N2 - i1;
                if (steps > limit) {
                  steps = limit;
                }
                for (let i4 = 0; i4 < steps; i4++) {
                  const offset = (2 * r2 - 1) * 16;
                  const j3 = XY[offset] & N2 - 1;
                  blockxor(V7, j3 * Yi, XY, Yi);
                  blockmix_salsa8(XY, Yi, r2, x8, _X);
                }
                i1 += steps;
                currentOp += steps;
                if (callback) {
                  const percent10 = parseInt(1e3 * currentOp / totalOps);
                  if (percent10 !== lastPercent10) {
                    stop = callback(null, currentOp / totalOps);
                    if (stop) {
                      break;
                    }
                    lastPercent10 = percent10;
                  }
                }
                if (i1 < N2) {
                  break;
                }
                arraycopy(XY, 0, B5, Bi, Yi);
                i0++;
                if (i0 < p2) {
                  state = 0;
                  break;
                }
                b4 = [];
                for (let i4 = 0; i4 < B5.length; i4++) {
                  b4.push(B5[i4] >> 0 & 255);
                  b4.push(B5[i4] >> 8 & 255);
                  b4.push(B5[i4] >> 16 & 255);
                  b4.push(B5[i4] >> 24 & 255);
                }
                const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b4, dkLen);
                if (callback) {
                  callback(null, 1, derivedKey);
                }
                return derivedKey;
            }
            if (callback) {
              nextTick(incrementalSMix);
            }
          };
          if (!callback) {
            while (true) {
              const derivedKey = incrementalSMix();
              if (derivedKey != void 0) {
                return derivedKey;
              }
            }
          }
          incrementalSMix();
        }
        const lib = {
          scrypt: function(password, salt, N2, r2, p2, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
              let lastProgress = 0;
              if (progressCallback) {
                progressCallback(0);
              }
              _scrypt(password, salt, N2, r2, p2, dkLen, function(error, progress, key) {
                if (error) {
                  reject(error);
                } else if (key) {
                  if (progressCallback && lastProgress !== 1) {
                    progressCallback(1);
                  }
                  resolve(new Uint8Array(key));
                } else if (progressCallback && progress !== lastProgress) {
                  lastProgress = progress;
                  return progressCallback(progress);
                }
              });
            });
          },
          syncScrypt: function(password, salt, N2, r2, p2, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N2, r2, p2, dkLen));
          }
        };
        if (typeof exports2 !== "undefined") {
          module2.exports = lib;
        } else if (typeof define === "function" && define.amd) {
          define(lib);
        } else if (root) {
          if (root.scrypt) {
            root._scrypt = root.scrypt;
          }
          root.scrypt = lib;
        }
      })(exports2);
    }
  });

  // node_modules/@ethersproject/json-wallets/lib/keystore.js
  var require_keystore = __commonJS({
    "node_modules/@ethersproject/json-wallets/lib/keystore.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      var __awaiter10 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n4) {
          return function(v7) {
            return step([n4, v7]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t3[1]) {
                    _18.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _18.label < t3[2]) {
                    _18.label = t3[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e) {
              op = [6, e];
              y4 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.encrypt = exports2.decrypt = exports2.decryptSync = exports2.KeystoreAccount = void 0;
      var aes_js_1 = __importDefault(require_aes_js());
      var scrypt_js_1 = __importDefault(require_scrypt());
      var address_1 = require_lib7();
      var bytes_1 = require_lib2();
      var hdnode_1 = require_lib22();
      var keccak256_1 = require_lib5();
      var pbkdf2_1 = require_lib20();
      var random_1 = require_lib23();
      var properties_1 = require_lib4();
      var transactions_1 = require_lib17();
      var utils_1 = require_utils4();
      var logger_1 = require_lib();
      var _version_1 = require_version18();
      var logger19 = new logger_1.Logger(_version_1.version);
      function hasMnemonic(value) {
        return value != null && value.mnemonic && value.mnemonic.phrase;
      }
      var KeystoreAccount = (
        /** @class */
        function(_super) {
          __extends2(KeystoreAccount2, _super);
          function KeystoreAccount2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          KeystoreAccount2.prototype.isKeystoreAccount = function(value) {
            return !!(value && value._isKeystoreAccount);
          };
          return KeystoreAccount2;
        }(properties_1.Description)
      );
      exports2.KeystoreAccount = KeystoreAccount;
      function _decrypt(data, key, ciphertext) {
        var cipher = (0, utils_1.searchPath)(data, "crypto/cipher");
        if (cipher === "aes-128-ctr") {
          var iv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/cipherparams/iv"));
          var counter = new aes_js_1.default.Counter(iv);
          var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);
          return (0, bytes_1.arrayify)(aesCtr.decrypt(ciphertext));
        }
        return null;
      }
      function _getAccount(data, key) {
        var ciphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/ciphertext"));
        var computedMAC = (0, bytes_1.hexlify)((0, keccak256_1.keccak256)((0, bytes_1.concat)([key.slice(16, 32), ciphertext]))).substring(2);
        if (computedMAC !== (0, utils_1.searchPath)(data, "crypto/mac").toLowerCase()) {
          throw new Error("invalid password");
        }
        var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
        if (!privateKey) {
          logger19.throwError("unsupported cipher", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "decrypt"
          });
        }
        var mnemonicKey = key.slice(32, 64);
        var address = (0, transactions_1.computeAddress)(privateKey);
        if (data.address) {
          var check = data.address.toLowerCase();
          if (check.substring(0, 2) !== "0x") {
            check = "0x" + check;
          }
          if ((0, address_1.getAddress)(check) !== address) {
            throw new Error("address mismatch");
          }
        }
        var account = {
          _isKeystoreAccount: true,
          address,
          privateKey: (0, bytes_1.hexlify)(privateKey)
        };
        if ((0, utils_1.searchPath)(data, "x-ethers/version") === "0.1") {
          var mnemonicCiphertext = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCiphertext"));
          var mnemonicIv = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "x-ethers/mnemonicCounter"));
          var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
          var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
          var path = (0, utils_1.searchPath)(data, "x-ethers/path") || hdnode_1.defaultPath;
          var locale = (0, utils_1.searchPath)(data, "x-ethers/locale") || "en";
          var entropy = (0, bytes_1.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
          try {
            var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, locale);
            var node = hdnode_1.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
            if (node.privateKey != account.privateKey) {
              throw new Error("mnemonic mismatch");
            }
            account.mnemonic = node.mnemonic;
          } catch (error) {
            if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
              throw error;
            }
          }
        }
        return new KeystoreAccount(account);
      }
      function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
        return (0, bytes_1.arrayify)((0, pbkdf2_1.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));
      }
      function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
        return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
      }
      function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
        var passwordBytes = (0, utils_1.getPassword)(password);
        var kdf = (0, utils_1.searchPath)(data, "crypto/kdf");
        if (kdf && typeof kdf === "string") {
          var throwError = function(name, value) {
            return logger19.throwArgumentError("invalid key-derivation function parameters", name, value);
          };
          if (kdf.toLowerCase() === "scrypt") {
            var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/kdfparams/salt"));
            var N2 = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/n"));
            var r2 = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/r"));
            var p2 = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/p"));
            if (!N2 || !r2 || !p2) {
              throwError("kdf", kdf);
            }
            if ((N2 & N2 - 1) !== 0) {
              throwError("N", N2);
            }
            var dkLen = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
              throwError("dklen", dkLen);
            }
            return scryptFunc(passwordBytes, salt, N2, r2, p2, 64, progressCallback);
          } else if (kdf.toLowerCase() === "pbkdf2") {
            var salt = (0, utils_1.looseArrayify)((0, utils_1.searchPath)(data, "crypto/kdfparams/salt"));
            var prfFunc = null;
            var prf = (0, utils_1.searchPath)(data, "crypto/kdfparams/prf");
            if (prf === "hmac-sha256") {
              prfFunc = "sha256";
            } else if (prf === "hmac-sha512") {
              prfFunc = "sha512";
            } else {
              throwError("prf", prf);
            }
            var count = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/c"));
            var dkLen = parseInt((0, utils_1.searchPath)(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
              throwError("dklen", dkLen);
            }
            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
          }
        }
        return logger19.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
      }
      function decryptSync(json, password) {
        var data = JSON.parse(json);
        var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt_js_1.default.syncScrypt);
        return _getAccount(data, key);
      }
      exports2.decryptSync = decryptSync;
      function decrypt(json, password, progressCallback) {
        return __awaiter10(this, void 0, void 0, function() {
          var data, key;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                data = JSON.parse(json);
                return [4, _computeKdfKey(data, password, pbkdf2, scrypt_js_1.default.scrypt, progressCallback)];
              case 1:
                key = _a.sent();
                return [2, _getAccount(data, key)];
            }
          });
        });
      }
      exports2.decrypt = decrypt;
      function encrypt(account, password, options, progressCallback) {
        try {
          if ((0, address_1.getAddress)(account.address) !== (0, transactions_1.computeAddress)(account.privateKey)) {
            throw new Error("address/privateKey mismatch");
          }
          if (hasMnemonic(account)) {
            var mnemonic = account.mnemonic;
            var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || hdnode_1.defaultPath);
            if (node.privateKey != account.privateKey) {
              throw new Error("mnemonic mismatch");
            }
          }
        } catch (e) {
          return Promise.reject(e);
        }
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (!options) {
          options = {};
        }
        var privateKey = (0, bytes_1.arrayify)(account.privateKey);
        var passwordBytes = (0, utils_1.getPassword)(password);
        var entropy = null;
        var path = null;
        var locale = null;
        if (hasMnemonic(account)) {
          var srcMnemonic = account.mnemonic;
          entropy = (0, bytes_1.arrayify)((0, hdnode_1.mnemonicToEntropy)(srcMnemonic.phrase, srcMnemonic.locale || "en"));
          path = srcMnemonic.path || hdnode_1.defaultPath;
          locale = srcMnemonic.locale || "en";
        }
        var client = options.client;
        if (!client) {
          client = "ethers.js";
        }
        var salt = null;
        if (options.salt) {
          salt = (0, bytes_1.arrayify)(options.salt);
        } else {
          salt = (0, random_1.randomBytes)(32);
          ;
        }
        var iv = null;
        if (options.iv) {
          iv = (0, bytes_1.arrayify)(options.iv);
          if (iv.length !== 16) {
            throw new Error("invalid iv");
          }
        } else {
          iv = (0, random_1.randomBytes)(16);
        }
        var uuidRandom = null;
        if (options.uuid) {
          uuidRandom = (0, bytes_1.arrayify)(options.uuid);
          if (uuidRandom.length !== 16) {
            throw new Error("invalid uuid");
          }
        } else {
          uuidRandom = (0, random_1.randomBytes)(16);
        }
        var N2 = 1 << 17, r2 = 8, p2 = 1;
        if (options.scrypt) {
          if (options.scrypt.N) {
            N2 = options.scrypt.N;
          }
          if (options.scrypt.r) {
            r2 = options.scrypt.r;
          }
          if (options.scrypt.p) {
            p2 = options.scrypt.p;
          }
        }
        return scrypt_js_1.default.scrypt(passwordBytes, salt, N2, r2, p2, 64, progressCallback).then(function(key) {
          key = (0, bytes_1.arrayify)(key);
          var derivedKey = key.slice(0, 16);
          var macPrefix = key.slice(16, 32);
          var mnemonicKey = key.slice(32, 64);
          var counter = new aes_js_1.default.Counter(iv);
          var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);
          var ciphertext = (0, bytes_1.arrayify)(aesCtr.encrypt(privateKey));
          var mac = (0, keccak256_1.keccak256)((0, bytes_1.concat)([macPrefix, ciphertext]));
          var data = {
            address: account.address.substring(2).toLowerCase(),
            id: (0, utils_1.uuidV4)(uuidRandom),
            version: 3,
            crypto: {
              cipher: "aes-128-ctr",
              cipherparams: {
                iv: (0, bytes_1.hexlify)(iv).substring(2)
              },
              ciphertext: (0, bytes_1.hexlify)(ciphertext).substring(2),
              kdf: "scrypt",
              kdfparams: {
                salt: (0, bytes_1.hexlify)(salt).substring(2),
                n: N2,
                dklen: 32,
                p: p2,
                r: r2
              },
              mac: mac.substring(2)
            }
          };
          if (entropy) {
            var mnemonicIv = (0, random_1.randomBytes)(16);
            var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);
            var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
            var mnemonicCiphertext = (0, bytes_1.arrayify)(mnemonicAesCtr.encrypt(entropy));
            var now2 = /* @__PURE__ */ new Date();
            var timestamp2 = now2.getUTCFullYear() + "-" + (0, utils_1.zpad)(now2.getUTCMonth() + 1, 2) + "-" + (0, utils_1.zpad)(now2.getUTCDate(), 2) + "T" + (0, utils_1.zpad)(now2.getUTCHours(), 2) + "-" + (0, utils_1.zpad)(now2.getUTCMinutes(), 2) + "-" + (0, utils_1.zpad)(now2.getUTCSeconds(), 2) + ".0Z";
            data["x-ethers"] = {
              client,
              gethFilename: "UTC--" + timestamp2 + "--" + data.address,
              mnemonicCounter: (0, bytes_1.hexlify)(mnemonicIv).substring(2),
              mnemonicCiphertext: (0, bytes_1.hexlify)(mnemonicCiphertext).substring(2),
              path,
              locale,
              version: "0.1"
            };
          }
          return JSON.stringify(data);
        });
      }
      exports2.encrypt = encrypt;
    }
  });

  // node_modules/@ethersproject/json-wallets/lib/index.js
  var require_lib24 = __commonJS({
    "node_modules/@ethersproject/json-wallets/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decryptJsonWalletSync = exports2.decryptJsonWallet = exports2.getJsonWalletAddress = exports2.isKeystoreWallet = exports2.isCrowdsaleWallet = exports2.encryptKeystore = exports2.decryptKeystoreSync = exports2.decryptKeystore = exports2.decryptCrowdsale = void 0;
      var crowdsale_1 = require_crowdsale();
      Object.defineProperty(exports2, "decryptCrowdsale", { enumerable: true, get: function() {
        return crowdsale_1.decrypt;
      } });
      var inspect_1 = require_inspect();
      Object.defineProperty(exports2, "getJsonWalletAddress", { enumerable: true, get: function() {
        return inspect_1.getJsonWalletAddress;
      } });
      Object.defineProperty(exports2, "isCrowdsaleWallet", { enumerable: true, get: function() {
        return inspect_1.isCrowdsaleWallet;
      } });
      Object.defineProperty(exports2, "isKeystoreWallet", { enumerable: true, get: function() {
        return inspect_1.isKeystoreWallet;
      } });
      var keystore_1 = require_keystore();
      Object.defineProperty(exports2, "decryptKeystore", { enumerable: true, get: function() {
        return keystore_1.decrypt;
      } });
      Object.defineProperty(exports2, "decryptKeystoreSync", { enumerable: true, get: function() {
        return keystore_1.decryptSync;
      } });
      Object.defineProperty(exports2, "encryptKeystore", { enumerable: true, get: function() {
        return keystore_1.encrypt;
      } });
      function decryptJsonWallet(json, password, progressCallback) {
        if ((0, inspect_1.isCrowdsaleWallet)(json)) {
          if (progressCallback) {
            progressCallback(0);
          }
          var account = (0, crowdsale_1.decrypt)(json, password);
          if (progressCallback) {
            progressCallback(1);
          }
          return Promise.resolve(account);
        }
        if ((0, inspect_1.isKeystoreWallet)(json)) {
          return (0, keystore_1.decrypt)(json, password, progressCallback);
        }
        return Promise.reject(new Error("invalid JSON wallet"));
      }
      exports2.decryptJsonWallet = decryptJsonWallet;
      function decryptJsonWalletSync(json, password) {
        if ((0, inspect_1.isCrowdsaleWallet)(json)) {
          return (0, crowdsale_1.decrypt)(json, password);
        }
        if ((0, inspect_1.isKeystoreWallet)(json)) {
          return (0, keystore_1.decryptSync)(json, password);
        }
        throw new Error("invalid JSON wallet");
      }
      exports2.decryptJsonWalletSync = decryptJsonWalletSync;
    }
  });

  // node_modules/@ethersproject/wallet/lib/_version.js
  var require_version19 = __commonJS({
    "node_modules/@ethersproject/wallet/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "wallet/5.7.0";
    }
  });

  // node_modules/@ethersproject/wallet/lib/index.js
  var require_lib25 = __commonJS({
    "node_modules/@ethersproject/wallet/lib/index.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics2 = function(d6, b4) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
            d7.__proto__ = b5;
          } || function(d7, b5) {
            for (var p2 in b5)
              if (Object.prototype.hasOwnProperty.call(b5, p2))
                d7[p2] = b5[p2];
          };
          return extendStatics2(d6, b4);
        };
        return function(d6, b4) {
          if (typeof b4 !== "function" && b4 !== null)
            throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
          extendStatics2(d6, b4);
          function __() {
            this.constructor = d6;
          }
          d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
        };
      }();
      var __awaiter10 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n4) {
          return function(v7) {
            return step([n4, v7]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t3[1]) {
                    _18.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _18.label < t3[2]) {
                    _18.label = t3[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e) {
              op = [6, e];
              y4 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.verifyTypedData = exports2.verifyMessage = exports2.Wallet = void 0;
      var address_1 = require_lib7();
      var abstract_provider_1 = require_lib14();
      var abstract_signer_1 = require_lib15();
      var bytes_1 = require_lib2();
      var hash_1 = require_lib12();
      var hdnode_1 = require_lib22();
      var keccak256_1 = require_lib5();
      var properties_1 = require_lib4();
      var random_1 = require_lib23();
      var signing_key_1 = require_lib16();
      var json_wallets_1 = require_lib24();
      var transactions_1 = require_lib17();
      var logger_1 = require_lib();
      var _version_1 = require_version19();
      var logger19 = new logger_1.Logger(_version_1.version);
      function isAccount(value) {
        return value != null && (0, bytes_1.isHexString)(value.privateKey, 32) && value.address != null;
      }
      function hasMnemonic(value) {
        var mnemonic = value.mnemonic;
        return mnemonic && mnemonic.phrase;
      }
      var Wallet2 = (
        /** @class */
        function(_super) {
          __extends2(Wallet3, _super);
          function Wallet3(privateKey, provider) {
            var _this = _super.call(this) || this;
            if (isAccount(privateKey)) {
              var signingKey_1 = new signing_key_1.SigningKey(privateKey.privateKey);
              (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
                return signingKey_1;
              });
              (0, properties_1.defineReadOnly)(_this, "address", (0, transactions_1.computeAddress)(_this.publicKey));
              if (_this.address !== (0, address_1.getAddress)(privateKey.address)) {
                logger19.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
              }
              if (hasMnemonic(privateKey)) {
                var srcMnemonic_1 = privateKey.mnemonic;
                (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
                  return {
                    phrase: srcMnemonic_1.phrase,
                    path: srcMnemonic_1.path || hdnode_1.defaultPath,
                    locale: srcMnemonic_1.locale || "en"
                  };
                });
                var mnemonic = _this.mnemonic;
                var node = hdnode_1.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
                if ((0, transactions_1.computeAddress)(node.privateKey) !== _this.address) {
                  logger19.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
                }
              } else {
                (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
                  return null;
                });
              }
            } else {
              if (signing_key_1.SigningKey.isSigningKey(privateKey)) {
                if (privateKey.curve !== "secp256k1") {
                  logger19.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
                }
                (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
                  return privateKey;
                });
              } else {
                if (typeof privateKey === "string") {
                  if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                    privateKey = "0x" + privateKey;
                  }
                }
                var signingKey_2 = new signing_key_1.SigningKey(privateKey);
                (0, properties_1.defineReadOnly)(_this, "_signingKey", function() {
                  return signingKey_2;
                });
              }
              (0, properties_1.defineReadOnly)(_this, "_mnemonic", function() {
                return null;
              });
              (0, properties_1.defineReadOnly)(_this, "address", (0, transactions_1.computeAddress)(_this.publicKey));
            }
            if (provider && !abstract_provider_1.Provider.isProvider(provider)) {
              logger19.throwArgumentError("invalid provider", "provider", provider);
            }
            (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
            return _this;
          }
          Object.defineProperty(Wallet3.prototype, "mnemonic", {
            get: function() {
              return this._mnemonic();
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Wallet3.prototype, "privateKey", {
            get: function() {
              return this._signingKey().privateKey;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Wallet3.prototype, "publicKey", {
            get: function() {
              return this._signingKey().publicKey;
            },
            enumerable: false,
            configurable: true
          });
          Wallet3.prototype.getAddress = function() {
            return Promise.resolve(this.address);
          };
          Wallet3.prototype.connect = function(provider) {
            return new Wallet3(this, provider);
          };
          Wallet3.prototype.signTransaction = function(transaction2) {
            var _this = this;
            return (0, properties_1.resolveProperties)(transaction2).then(function(tx) {
              if (tx.from != null) {
                if ((0, address_1.getAddress)(tx.from) !== _this.address) {
                  logger19.throwArgumentError("transaction from address mismatch", "transaction.from", transaction2.from);
                }
                delete tx.from;
              }
              var signature = _this._signingKey().signDigest((0, keccak256_1.keccak256)((0, transactions_1.serialize)(tx)));
              return (0, transactions_1.serialize)(tx, signature);
            });
          };
          Wallet3.prototype.signMessage = function(message) {
            return __awaiter10(this, void 0, void 0, function() {
              return __generator2(this, function(_a) {
                return [2, (0, bytes_1.joinSignature)(this._signingKey().signDigest((0, hash_1.hashMessage)(message)))];
              });
            });
          };
          Wallet3.prototype._signTypedData = function(domain, types, value) {
            return __awaiter10(this, void 0, void 0, function() {
              var populated;
              var _this = this;
              return __generator2(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, hash_1._TypedDataEncoder.resolveNames(domain, types, value, function(name) {
                      if (_this.provider == null) {
                        logger19.throwError("cannot resolve ENS names without a provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                          operation: "resolveName",
                          value: name
                        });
                      }
                      return _this.provider.resolveName(name);
                    })];
                  case 1:
                    populated = _a.sent();
                    return [2, (0, bytes_1.joinSignature)(this._signingKey().signDigest(hash_1._TypedDataEncoder.hash(populated.domain, types, populated.value)))];
                }
              });
            });
          };
          Wallet3.prototype.encrypt = function(password, options, progressCallback) {
            if (typeof options === "function" && !progressCallback) {
              progressCallback = options;
              options = {};
            }
            if (progressCallback && typeof progressCallback !== "function") {
              throw new Error("invalid callback");
            }
            if (!options) {
              options = {};
            }
            return (0, json_wallets_1.encryptKeystore)(this, password, options, progressCallback);
          };
          Wallet3.createRandom = function(options) {
            var entropy = (0, random_1.randomBytes)(16);
            if (!options) {
              options = {};
            }
            if (options.extraEntropy) {
              entropy = (0, bytes_1.arrayify)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)([entropy, options.extraEntropy])), 0, 16));
            }
            var mnemonic = (0, hdnode_1.entropyToMnemonic)(entropy, options.locale);
            return Wallet3.fromMnemonic(mnemonic, options.path, options.locale);
          };
          Wallet3.fromEncryptedJson = function(json, password, progressCallback) {
            return (0, json_wallets_1.decryptJsonWallet)(json, password, progressCallback).then(function(account) {
              return new Wallet3(account);
            });
          };
          Wallet3.fromEncryptedJsonSync = function(json, password) {
            return new Wallet3((0, json_wallets_1.decryptJsonWalletSync)(json, password));
          };
          Wallet3.fromMnemonic = function(mnemonic, path, wordlist10) {
            if (!path) {
              path = hdnode_1.defaultPath;
            }
            return new Wallet3(hdnode_1.HDNode.fromMnemonic(mnemonic, null, wordlist10).derivePath(path));
          };
          return Wallet3;
        }(abstract_signer_1.Signer)
      );
      exports2.Wallet = Wallet2;
      function verifyMessage4(message, signature) {
        return (0, transactions_1.recoverAddress)((0, hash_1.hashMessage)(message), signature);
      }
      exports2.verifyMessage = verifyMessage4;
      function verifyTypedData4(domain, types, value, signature) {
        return (0, transactions_1.recoverAddress)(hash_1._TypedDataEncoder.hash(domain, types, value), signature);
      }
      exports2.verifyTypedData = verifyTypedData4;
    }
  });

  // node_modules/@ethersproject/web/lib/_version.js
  var require_version20 = __commonJS({
    "node_modules/@ethersproject/web/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "web/5.7.1";
    }
  });

  // node_modules/@ethersproject/web/lib/browser-geturl.js
  var require_browser_geturl = __commonJS({
    "node_modules/@ethersproject/web/lib/browser-geturl.js"(exports2) {
      "use strict";
      var __awaiter10 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n4) {
          return function(v7) {
            return step([n4, v7]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t3[1]) {
                    _18.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _18.label < t3[2]) {
                    _18.label = t3[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e) {
              op = [6, e];
              y4 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getUrl = void 0;
      var bytes_1 = require_lib2();
      function getUrl2(href, options) {
        return __awaiter10(this, void 0, void 0, function() {
          var request, opts, response, body, headers;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (options == null) {
                  options = {};
                }
                request = {
                  method: options.method || "GET",
                  headers: options.headers || {},
                  body: options.body || void 0
                };
                if (options.skipFetchSetup !== true) {
                  request.mode = "cors";
                  request.cache = "no-cache";
                  request.credentials = "same-origin";
                  request.redirect = "follow";
                  request.referrer = "client";
                }
                ;
                if (options.fetchOptions != null) {
                  opts = options.fetchOptions;
                  if (opts.mode) {
                    request.mode = opts.mode;
                  }
                  if (opts.cache) {
                    request.cache = opts.cache;
                  }
                  if (opts.credentials) {
                    request.credentials = opts.credentials;
                  }
                  if (opts.redirect) {
                    request.redirect = opts.redirect;
                  }
                  if (opts.referrer) {
                    request.referrer = opts.referrer;
                  }
                }
                return [4, fetch(href, request)];
              case 1:
                response = _a.sent();
                return [4, response.arrayBuffer()];
              case 2:
                body = _a.sent();
                headers = {};
                if (response.headers.forEach) {
                  response.headers.forEach(function(value, key) {
                    headers[key.toLowerCase()] = value;
                  });
                } else {
                  response.headers.keys().forEach(function(key) {
                    headers[key.toLowerCase()] = response.headers.get(key);
                  });
                }
                return [2, {
                  headers,
                  statusCode: response.status,
                  statusMessage: response.statusText,
                  body: (0, bytes_1.arrayify)(new Uint8Array(body))
                }];
            }
          });
        });
      }
      exports2.getUrl = getUrl2;
    }
  });

  // node_modules/@ethersproject/web/lib/index.js
  var require_lib26 = __commonJS({
    "node_modules/@ethersproject/web/lib/index.js"(exports2) {
      "use strict";
      var __awaiter10 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P4, generator) {
        function adopt(value) {
          return value instanceof P4 ? value : new P4(function(resolve) {
            resolve(value);
          });
        }
        return new (P4 || (P4 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {
        var _18 = { label: 0, sent: function() {
          if (t3[0] & 1)
            throw t3[1];
          return t3[1];
        }, trys: [], ops: [] }, f5, y4, t3, g5;
        return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
          return this;
        }), g5;
        function verb(n4) {
          return function(v7) {
            return step([n4, v7]);
          };
        }
        function step(op) {
          if (f5)
            throw new TypeError("Generator is already executing.");
          while (_18)
            try {
              if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
                return t3;
              if (y4 = 0, t3)
                op = [op[0] & 2, t3.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t3 = op;
                  break;
                case 4:
                  _18.label++;
                  return { value: op[1], done: false };
                case 5:
                  _18.label++;
                  y4 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _18.ops.pop();
                  _18.trys.pop();
                  continue;
                default:
                  if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _18 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                    _18.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _18.label < t3[1]) {
                    _18.label = t3[1];
                    t3 = op;
                    break;
                  }
                  if (t3 && _18.label < t3[2]) {
                    _18.label = t3[2];
                    _18.ops.push(op);
                    break;
                  }
                  if (t3[2])
                    _18.ops.pop();
                  _18.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _18);
            } catch (e) {
              op = [6, e];
              y4 = 0;
            } finally {
              f5 = t3 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.poll = exports2.fetchJson = exports2._fetchData = void 0;
      var base64_1 = require_lib10();
      var bytes_1 = require_lib2();
      var properties_1 = require_lib4();
      var strings_1 = require_lib9();
      var logger_1 = require_lib();
      var _version_1 = require_version20();
      var logger19 = new logger_1.Logger(_version_1.version);
      var geturl_1 = require_browser_geturl();
      function staller(duration) {
        return new Promise(function(resolve) {
          setTimeout(resolve, duration);
        });
      }
      function bodyify(value, type) {
        if (value == null) {
          return null;
        }
        if (typeof value === "string") {
          return value;
        }
        if ((0, bytes_1.isBytesLike)(value)) {
          if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
            try {
              return (0, strings_1.toUtf8String)(value);
            } catch (error) {
            }
            ;
          }
          return (0, bytes_1.hexlify)(value);
        }
        return value;
      }
      function unpercent(value) {
        return (0, strings_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function(all, code) {
          return String.fromCharCode(parseInt(code, 16));
        }));
      }
      function _fetchData2(connection, body, processFunc) {
        var attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
        logger19.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
        var throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
        var throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
        logger19.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
        var errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
        var headers = {};
        var url = null;
        var options = {
          method: "GET"
        };
        var allow304 = false;
        var timeout = 2 * 60 * 1e3;
        if (typeof connection === "string") {
          url = connection;
        } else if (typeof connection === "object") {
          if (connection == null || connection.url == null) {
            logger19.throwArgumentError("missing URL", "connection.url", connection);
          }
          url = connection.url;
          if (typeof connection.timeout === "number" && connection.timeout > 0) {
            timeout = connection.timeout;
          }
          if (connection.headers) {
            for (var key in connection.headers) {
              headers[key.toLowerCase()] = { key, value: String(connection.headers[key]) };
              if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
                allow304 = true;
              }
            }
          }
          options.allowGzip = !!connection.allowGzip;
          if (connection.user != null && connection.password != null) {
            if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
              logger19.throwError("basic authentication requires a secure https url", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
            }
            var authorization = connection.user + ":" + connection.password;
            headers["authorization"] = {
              key: "Authorization",
              value: "Basic " + (0, base64_1.encode)((0, strings_1.toUtf8Bytes)(authorization))
            };
          }
          if (connection.skipFetchSetup != null) {
            options.skipFetchSetup = !!connection.skipFetchSetup;
          }
          if (connection.fetchOptions != null) {
            options.fetchOptions = (0, properties_1.shallowCopy)(connection.fetchOptions);
          }
        }
        var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
        var dataMatch = url ? url.match(reData) : null;
        if (dataMatch) {
          try {
            var response = {
              statusCode: 200,
              statusMessage: "OK",
              headers: { "content-type": dataMatch[1] || "text/plain" },
              body: dataMatch[2] ? (0, base64_1.decode)(dataMatch[3]) : unpercent(dataMatch[3])
            };
            var result = response.body;
            if (processFunc) {
              result = processFunc(response.body, response);
            }
            return Promise.resolve(result);
          } catch (error) {
            logger19.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
              body: bodyify(dataMatch[1], dataMatch[2]),
              error,
              requestBody: null,
              requestMethod: "GET",
              url
            });
          }
        }
        if (body) {
          options.method = "POST";
          options.body = body;
          if (headers["content-type"] == null) {
            headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
          }
          if (headers["content-length"] == null) {
            headers["content-length"] = { key: "Content-Length", value: String(body.length) };
          }
        }
        var flatHeaders = {};
        Object.keys(headers).forEach(function(key2) {
          var header = headers[key2];
          flatHeaders[header.key] = header.value;
        });
        options.headers = flatHeaders;
        var runningTimeout = function() {
          var timer3 = null;
          var promise = new Promise(function(resolve, reject) {
            if (timeout) {
              timer3 = setTimeout(function() {
                if (timer3 == null) {
                  return;
                }
                timer3 = null;
                reject(logger19.makeError("timeout", logger_1.Logger.errors.TIMEOUT, {
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  timeout,
                  url
                }));
              }, timeout);
            }
          });
          var cancel = function() {
            if (timer3 == null) {
              return;
            }
            clearTimeout(timer3);
            timer3 = null;
          };
          return { promise, cancel };
        }();
        var runningFetch = function() {
          return __awaiter10(this, void 0, void 0, function() {
            var attempt, response2, location_1, tryAgain, stall3, retryAfter, error_1, body_1, result2, error_2, tryAgain, timeout_1;
            return __generator2(this, function(_a) {
              switch (_a.label) {
                case 0:
                  attempt = 0;
                  _a.label = 1;
                case 1:
                  if (!(attempt < attemptLimit))
                    return [3, 20];
                  response2 = null;
                  _a.label = 2;
                case 2:
                  _a.trys.push([2, 9, , 10]);
                  return [4, (0, geturl_1.getUrl)(url, options)];
                case 3:
                  response2 = _a.sent();
                  if (!(attempt < attemptLimit))
                    return [3, 8];
                  if (!(response2.statusCode === 301 || response2.statusCode === 302))
                    return [3, 4];
                  location_1 = response2.headers.location || "";
                  if (options.method === "GET" && location_1.match(/^https:/)) {
                    url = response2.headers.location;
                    return [3, 19];
                  }
                  return [3, 8];
                case 4:
                  if (!(response2.statusCode === 429))
                    return [3, 8];
                  tryAgain = true;
                  if (!throttleCallback)
                    return [3, 6];
                  return [4, throttleCallback(attempt, url)];
                case 5:
                  tryAgain = _a.sent();
                  _a.label = 6;
                case 6:
                  if (!tryAgain)
                    return [3, 8];
                  stall3 = 0;
                  retryAfter = response2.headers["retry-after"];
                  if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                    stall3 = parseInt(retryAfter) * 1e3;
                  } else {
                    stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                  }
                  return [4, staller(stall3)];
                case 7:
                  _a.sent();
                  return [3, 19];
                case 8:
                  return [3, 10];
                case 9:
                  error_1 = _a.sent();
                  response2 = error_1.response;
                  if (response2 == null) {
                    runningTimeout.cancel();
                    logger19.throwError("missing response", logger_1.Logger.errors.SERVER_ERROR, {
                      requestBody: bodyify(options.body, flatHeaders["content-type"]),
                      requestMethod: options.method,
                      serverError: error_1,
                      url
                    });
                  }
                  return [3, 10];
                case 10:
                  body_1 = response2.body;
                  if (allow304 && response2.statusCode === 304) {
                    body_1 = null;
                  } else if (!errorPassThrough && (response2.statusCode < 200 || response2.statusCode >= 300)) {
                    runningTimeout.cancel();
                    logger19.throwError("bad response", logger_1.Logger.errors.SERVER_ERROR, {
                      status: response2.statusCode,
                      headers: response2.headers,
                      body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                      requestBody: bodyify(options.body, flatHeaders["content-type"]),
                      requestMethod: options.method,
                      url
                    });
                  }
                  if (!processFunc)
                    return [3, 18];
                  _a.label = 11;
                case 11:
                  _a.trys.push([11, 13, , 18]);
                  return [4, processFunc(body_1, response2)];
                case 12:
                  result2 = _a.sent();
                  runningTimeout.cancel();
                  return [2, result2];
                case 13:
                  error_2 = _a.sent();
                  if (!(error_2.throttleRetry && attempt < attemptLimit))
                    return [3, 17];
                  tryAgain = true;
                  if (!throttleCallback)
                    return [3, 15];
                  return [4, throttleCallback(attempt, url)];
                case 14:
                  tryAgain = _a.sent();
                  _a.label = 15;
                case 15:
                  if (!tryAgain)
                    return [3, 17];
                  timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                  return [4, staller(timeout_1)];
                case 16:
                  _a.sent();
                  return [3, 19];
                case 17:
                  runningTimeout.cancel();
                  logger19.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
                    body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                    error: error_2,
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    url
                  });
                  return [3, 18];
                case 18:
                  runningTimeout.cancel();
                  return [2, body_1];
                case 19:
                  attempt++;
                  return [3, 1];
                case 20:
                  return [2, logger19.throwError("failed response", logger_1.Logger.errors.SERVER_ERROR, {
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    url
                  })];
              }
            });
          });
        }();
        return Promise.race([runningTimeout.promise, runningFetch]);
      }
      exports2._fetchData = _fetchData2;
      function fetchJson6(connection, json, processFunc) {
        var processJsonFunc = function(value, response) {
          var result = null;
          if (value != null) {
            try {
              result = JSON.parse((0, strings_1.toUtf8String)(value));
            } catch (error) {
              logger19.throwError("invalid JSON", logger_1.Logger.errors.SERVER_ERROR, {
                body: value,
                error
              });
            }
          }
          if (processFunc) {
            result = processFunc(result, response);
          }
          return result;
        };
        var body = null;
        if (json != null) {
          body = (0, strings_1.toUtf8Bytes)(json);
          var updated = typeof connection === "string" ? { url: connection } : (0, properties_1.shallowCopy)(connection);
          if (updated.headers) {
            var hasContentType = Object.keys(updated.headers).filter(function(k3) {
              return k3.toLowerCase() === "content-type";
            }).length !== 0;
            if (!hasContentType) {
              updated.headers = (0, properties_1.shallowCopy)(updated.headers);
              updated.headers["content-type"] = "application/json";
            }
          } else {
            updated.headers = { "content-type": "application/json" };
          }
          connection = updated;
        }
        return _fetchData2(connection, body, processJsonFunc);
      }
      exports2.fetchJson = fetchJson6;
      function poll6(func, options) {
        if (!options) {
          options = {};
        }
        options = (0, properties_1.shallowCopy)(options);
        if (options.floor == null) {
          options.floor = 0;
        }
        if (options.ceiling == null) {
          options.ceiling = 1e4;
        }
        if (options.interval == null) {
          options.interval = 250;
        }
        return new Promise(function(resolve, reject) {
          var timer3 = null;
          var done = false;
          var cancel = function() {
            if (done) {
              return false;
            }
            done = true;
            if (timer3) {
              clearTimeout(timer3);
            }
            return true;
          };
          if (options.timeout) {
            timer3 = setTimeout(function() {
              if (cancel()) {
                reject(new Error("timeout"));
              }
            }, options.timeout);
          }
          var retryLimit = options.retryLimit;
          var attempt = 0;
          function check() {
            return func().then(function(result) {
              if (result !== void 0) {
                if (cancel()) {
                  resolve(result);
                }
              } else if (options.oncePoll) {
                options.oncePoll.once("poll", check);
              } else if (options.onceBlock) {
                options.onceBlock.once("block", check);
              } else if (!done) {
                attempt++;
                if (attempt > retryLimit) {
                  if (cancel()) {
                    reject(new Error("retry limit reached"));
                  }
                  return;
                }
                var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                if (timeout < options.floor) {
                  timeout = options.floor;
                }
                if (timeout > options.ceiling) {
                  timeout = options.ceiling;
                }
                setTimeout(check, timeout);
              }
              return null;
            }, function(error) {
              if (cancel()) {
                reject(error);
              }
            });
          }
          check();
        });
      }
      exports2.poll = poll6;
    }
  });

  // node_modules/bech32/index.js
  var require_bech32 = __commonJS({
    "node_modules/bech32/index.js"(exports2, module2) {
      "use strict";
      var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      var ALPHABET_MAP = {};
      for (z5 = 0; z5 < ALPHABET.length; z5++) {
        x8 = ALPHABET.charAt(z5);
        if (ALPHABET_MAP[x8] !== void 0)
          throw new TypeError(x8 + " is ambiguous");
        ALPHABET_MAP[x8] = z5;
      }
      var x8;
      var z5;
      function polymodStep(pre) {
        var b4 = pre >> 25;
        return (pre & 33554431) << 5 ^ -(b4 >> 0 & 1) & 996825010 ^ -(b4 >> 1 & 1) & 642813549 ^ -(b4 >> 2 & 1) & 513874426 ^ -(b4 >> 3 & 1) & 1027748829 ^ -(b4 >> 4 & 1) & 705979059;
      }
      function prefixChk(prefix) {
        var chk = 1;
        for (var i4 = 0; i4 < prefix.length; ++i4) {
          var c3 = prefix.charCodeAt(i4);
          if (c3 < 33 || c3 > 126)
            return "Invalid prefix (" + prefix + ")";
          chk = polymodStep(chk) ^ c3 >> 5;
        }
        chk = polymodStep(chk);
        for (i4 = 0; i4 < prefix.length; ++i4) {
          var v7 = prefix.charCodeAt(i4);
          chk = polymodStep(chk) ^ v7 & 31;
        }
        return chk;
      }
      function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        var chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        var result = prefix + "1";
        for (var i4 = 0; i4 < words.length; ++i4) {
          var x9 = words[i4];
          if (x9 >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x9;
          result += ALPHABET.charAt(x9);
        }
        for (i4 = 0; i4 < 6; ++i4) {
          chk = polymodStep(chk);
        }
        chk ^= 1;
        for (i4 = 0; i4 < 6; ++i4) {
          var v7 = chk >> (5 - i4) * 5 & 31;
          result += ALPHABET.charAt(v7);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        var lowered = str.toLowerCase();
        var uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        var split2 = str.lastIndexOf("1");
        if (split2 === -1)
          return "No separator character for " + str;
        if (split2 === 0)
          return "Missing prefix for " + str;
        var prefix = str.slice(0, split2);
        var wordChars = str.slice(split2 + 1);
        if (wordChars.length < 6)
          return "Data too short";
        var chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        var words = [];
        for (var i4 = 0; i4 < wordChars.length; ++i4) {
          var c3 = wordChars.charAt(i4);
          var v7 = ALPHABET_MAP[c3];
          if (v7 === void 0)
            return "Unknown character " + c3;
          chk = polymodStep(chk) ^ v7;
          if (i4 + 6 >= wordChars.length)
            continue;
          words.push(v7);
        }
        if (chk !== 1)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe() {
        var res = __decode.apply(null, arguments);
        if (typeof res === "object")
          return res;
      }
      function decode(str) {
        var res = __decode.apply(null, arguments);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      function convert(data, inBits, outBits, pad2) {
        var value = 0;
        var bits = 0;
        var maxV = (1 << outBits) - 1;
        var result = [];
        for (var i4 = 0; i4 < data.length; ++i4) {
          value = value << inBits | data[i4];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push(value >> bits & maxV);
          }
        }
        if (pad2) {
          if (bits > 0) {
            result.push(value << outBits - bits & maxV);
          }
        } else {
          if (bits >= inBits)
            return "Excess padding";
          if (value << outBits - bits & maxV)
            return "Non-zero padding";
        }
        return result;
      }
      function toWordsUnsafe(bytes2) {
        var res = convert(bytes2, 8, 5, true);
        if (Array.isArray(res))
          return res;
      }
      function toWords(bytes2) {
        var res = convert(bytes2, 8, 5, true);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      function fromWordsUnsafe(words) {
        var res = convert(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
      }
      function fromWords(words) {
        var res = convert(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      module2.exports = {
        decodeUnsafe,
        decode,
        encode,
        toWordsUnsafe,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
  });

  // node_modules/@ethersproject/solidity/lib/_version.js
  var require_version21 = __commonJS({
    "node_modules/@ethersproject/solidity/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "solidity/5.7.0";
    }
  });

  // node_modules/@ethersproject/solidity/lib/index.js
  var require_lib27 = __commonJS({
    "node_modules/@ethersproject/solidity/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha256 = exports2.keccak256 = exports2.pack = void 0;
      var bignumber_1 = require_lib3();
      var bytes_1 = require_lib2();
      var keccak256_1 = require_lib5();
      var sha2_1 = require_lib19();
      var strings_1 = require_lib9();
      var regexBytes = new RegExp("^bytes([0-9]+)$");
      var regexNumber = new RegExp("^(u?int)([0-9]*)$");
      var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
      var Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
      var logger_1 = require_lib();
      var _version_1 = require_version21();
      var logger19 = new logger_1.Logger(_version_1.version);
      function _pack(type, value, isArray3) {
        switch (type) {
          case "address":
            if (isArray3) {
              return (0, bytes_1.zeroPad)(value, 32);
            }
            return (0, bytes_1.arrayify)(value);
          case "string":
            return (0, strings_1.toUtf8Bytes)(value);
          case "bytes":
            return (0, bytes_1.arrayify)(value);
          case "bool":
            value = value ? "0x01" : "0x00";
            if (isArray3) {
              return (0, bytes_1.zeroPad)(value, 32);
            }
            return (0, bytes_1.arrayify)(value);
        }
        var match = type.match(regexNumber);
        if (match) {
          var size3 = parseInt(match[2] || "256");
          if (match[2] && String(size3) !== match[2] || size3 % 8 !== 0 || size3 === 0 || size3 > 256) {
            logger19.throwArgumentError("invalid number type", "type", type);
          }
          if (isArray3) {
            size3 = 256;
          }
          value = bignumber_1.BigNumber.from(value).toTwos(size3);
          return (0, bytes_1.zeroPad)(value, size3 / 8);
        }
        match = type.match(regexBytes);
        if (match) {
          var size3 = parseInt(match[1]);
          if (String(size3) !== match[1] || size3 === 0 || size3 > 32) {
            logger19.throwArgumentError("invalid bytes type", "type", type);
          }
          if ((0, bytes_1.arrayify)(value).byteLength !== size3) {
            logger19.throwArgumentError("invalid value for " + type, "value", value);
          }
          if (isArray3) {
            return (0, bytes_1.arrayify)((value + Zeros).substring(0, 66));
          }
          return value;
        }
        match = type.match(regexArray);
        if (match && Array.isArray(value)) {
          var baseType_1 = match[1];
          var count = parseInt(match[2] || String(value.length));
          if (count != value.length) {
            logger19.throwArgumentError("invalid array length for " + type, "value", value);
          }
          var result_1 = [];
          value.forEach(function(value2) {
            result_1.push(_pack(baseType_1, value2, true));
          });
          return (0, bytes_1.concat)(result_1);
        }
        return logger19.throwArgumentError("invalid type", "type", type);
      }
      function pack(types, values) {
        if (types.length != values.length) {
          logger19.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
        }
        var tight = [];
        types.forEach(function(type, index2) {
          tight.push(_pack(type, values[index2]));
        });
        return (0, bytes_1.hexlify)((0, bytes_1.concat)(tight));
      }
      exports2.pack = pack;
      function keccak2563(types, values) {
        return (0, keccak256_1.keccak256)(pack(types, values));
      }
      exports2.keccak256 = keccak2563;
      function sha2564(types, values) {
        return (0, sha2_1.sha256)(pack(types, values));
      }
      exports2.sha256 = sha2564;
    }
  });

  // node_modules/@ethersproject/units/lib/_version.js
  var require_version22 = __commonJS({
    "node_modules/@ethersproject/units/lib/_version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.version = void 0;
      exports2.version = "units/5.7.0";
    }
  });

  // node_modules/@ethersproject/units/lib/index.js
  var require_lib28 = __commonJS({
    "node_modules/@ethersproject/units/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseEther = exports2.formatEther = exports2.parseUnits = exports2.formatUnits = exports2.commify = void 0;
      var bignumber_1 = require_lib3();
      var logger_1 = require_lib();
      var _version_1 = require_version22();
      var logger19 = new logger_1.Logger(_version_1.version);
      var names = [
        "wei",
        "kwei",
        "mwei",
        "gwei",
        "szabo",
        "finney",
        "ether"
      ];
      function commify2(value) {
        var comps = String(value).split(".");
        if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
          logger19.throwArgumentError("invalid value", "value", value);
        }
        var whole = comps[0];
        var negative = "";
        if (whole.substring(0, 1) === "-") {
          negative = "-";
          whole = whole.substring(1);
        }
        while (whole.substring(0, 1) === "0") {
          whole = whole.substring(1);
        }
        if (whole === "") {
          whole = "0";
        }
        var suffix = "";
        if (comps.length === 2) {
          suffix = "." + (comps[1] || "0");
        }
        while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
          suffix = suffix.substring(0, suffix.length - 1);
        }
        var formatted = [];
        while (whole.length) {
          if (whole.length <= 3) {
            formatted.unshift(whole);
            break;
          } else {
            var index2 = whole.length - 3;
            formatted.unshift(whole.substring(index2));
            whole = whole.substring(0, index2);
          }
        }
        return negative + formatted.join(",") + suffix;
      }
      exports2.commify = commify2;
      function formatUnits3(value, unitName) {
        if (typeof unitName === "string") {
          var index2 = names.indexOf(unitName);
          if (index2 !== -1) {
            unitName = 3 * index2;
          }
        }
        return (0, bignumber_1.formatFixed)(value, unitName != null ? unitName : 18);
      }
      exports2.formatUnits = formatUnits3;
      function parseUnits3(value, unitName) {
        if (typeof value !== "string") {
          logger19.throwArgumentError("value must be a string", "value", value);
        }
        if (typeof unitName === "string") {
          var index2 = names.indexOf(unitName);
          if (index2 !== -1) {
            unitName = 3 * index2;
          }
        }
        return (0, bignumber_1.parseFixed)(value, unitName != null ? unitName : 18);
      }
      exports2.parseUnits = parseUnits3;
      function formatEther3(wei) {
        return formatUnits3(wei, 18);
      }
      exports2.formatEther = formatEther3;
      function parseEther3(ether) {
        return parseUnits3(ether, 18);
      }
      exports2.parseEther = parseEther3;
    }
  });

  // node_modules/ethers/lib/utils.js
  var require_utils5 = __commonJS({
    "node_modules/ethers/lib/utils.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        Object.defineProperty(o3, k22, { enumerable: true, get: function() {
          return m5[k3];
        } });
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.formatBytes32String = exports2.Utf8ErrorFuncs = exports2.toUtf8String = exports2.toUtf8CodePoints = exports2.toUtf8Bytes = exports2._toEscapedUtf8String = exports2.nameprep = exports2.hexDataSlice = exports2.hexDataLength = exports2.hexZeroPad = exports2.hexValue = exports2.hexStripZeros = exports2.hexConcat = exports2.isHexString = exports2.hexlify = exports2.base64 = exports2.base58 = exports2.TransactionDescription = exports2.LogDescription = exports2.Interface = exports2.SigningKey = exports2.HDNode = exports2.defaultPath = exports2.isBytesLike = exports2.isBytes = exports2.zeroPad = exports2.stripZeros = exports2.concat = exports2.arrayify = exports2.shallowCopy = exports2.resolveProperties = exports2.getStatic = exports2.defineReadOnly = exports2.deepCopy = exports2.checkProperties = exports2.poll = exports2.fetchJson = exports2._fetchData = exports2.RLP = exports2.Logger = exports2.checkResultErrors = exports2.FormatTypes = exports2.ParamType = exports2.FunctionFragment = exports2.EventFragment = exports2.ErrorFragment = exports2.ConstructorFragment = exports2.Fragment = exports2.defaultAbiCoder = exports2.AbiCoder = void 0;
      exports2.Indexed = exports2.Utf8ErrorReason = exports2.UnicodeNormalizationForm = exports2.SupportedAlgorithm = exports2.mnemonicToSeed = exports2.isValidMnemonic = exports2.entropyToMnemonic = exports2.mnemonicToEntropy = exports2.getAccountPath = exports2.verifyTypedData = exports2.verifyMessage = exports2.recoverPublicKey = exports2.computePublicKey = exports2.recoverAddress = exports2.computeAddress = exports2.getJsonWalletAddress = exports2.TransactionTypes = exports2.serializeTransaction = exports2.parseTransaction = exports2.accessListify = exports2.joinSignature = exports2.splitSignature = exports2.soliditySha256 = exports2.solidityKeccak256 = exports2.solidityPack = exports2.shuffled = exports2.randomBytes = exports2.sha512 = exports2.sha256 = exports2.ripemd160 = exports2.keccak256 = exports2.computeHmac = exports2.commify = exports2.parseUnits = exports2.formatUnits = exports2.parseEther = exports2.formatEther = exports2.isAddress = exports2.getCreate2Address = exports2.getContractAddress = exports2.getIcapAddress = exports2.getAddress = exports2._TypedDataEncoder = exports2.id = exports2.isValidName = exports2.namehash = exports2.hashMessage = exports2.dnsEncode = exports2.parseBytes32String = void 0;
      var abi_1 = require_lib13();
      Object.defineProperty(exports2, "AbiCoder", { enumerable: true, get: function() {
        return abi_1.AbiCoder;
      } });
      Object.defineProperty(exports2, "checkResultErrors", { enumerable: true, get: function() {
        return abi_1.checkResultErrors;
      } });
      Object.defineProperty(exports2, "ConstructorFragment", { enumerable: true, get: function() {
        return abi_1.ConstructorFragment;
      } });
      Object.defineProperty(exports2, "defaultAbiCoder", { enumerable: true, get: function() {
        return abi_1.defaultAbiCoder;
      } });
      Object.defineProperty(exports2, "ErrorFragment", { enumerable: true, get: function() {
        return abi_1.ErrorFragment;
      } });
      Object.defineProperty(exports2, "EventFragment", { enumerable: true, get: function() {
        return abi_1.EventFragment;
      } });
      Object.defineProperty(exports2, "FormatTypes", { enumerable: true, get: function() {
        return abi_1.FormatTypes;
      } });
      Object.defineProperty(exports2, "Fragment", { enumerable: true, get: function() {
        return abi_1.Fragment;
      } });
      Object.defineProperty(exports2, "FunctionFragment", { enumerable: true, get: function() {
        return abi_1.FunctionFragment;
      } });
      Object.defineProperty(exports2, "Indexed", { enumerable: true, get: function() {
        return abi_1.Indexed;
      } });
      Object.defineProperty(exports2, "Interface", { enumerable: true, get: function() {
        return abi_1.Interface;
      } });
      Object.defineProperty(exports2, "LogDescription", { enumerable: true, get: function() {
        return abi_1.LogDescription;
      } });
      Object.defineProperty(exports2, "ParamType", { enumerable: true, get: function() {
        return abi_1.ParamType;
      } });
      Object.defineProperty(exports2, "TransactionDescription", { enumerable: true, get: function() {
        return abi_1.TransactionDescription;
      } });
      var address_1 = require_lib7();
      Object.defineProperty(exports2, "getAddress", { enumerable: true, get: function() {
        return address_1.getAddress;
      } });
      Object.defineProperty(exports2, "getCreate2Address", { enumerable: true, get: function() {
        return address_1.getCreate2Address;
      } });
      Object.defineProperty(exports2, "getContractAddress", { enumerable: true, get: function() {
        return address_1.getContractAddress;
      } });
      Object.defineProperty(exports2, "getIcapAddress", { enumerable: true, get: function() {
        return address_1.getIcapAddress;
      } });
      Object.defineProperty(exports2, "isAddress", { enumerable: true, get: function() {
        return address_1.isAddress;
      } });
      var base643 = __importStar(require_lib10());
      exports2.base64 = base643;
      var basex_1 = require_lib18();
      Object.defineProperty(exports2, "base58", { enumerable: true, get: function() {
        return basex_1.Base58;
      } });
      var bytes_1 = require_lib2();
      Object.defineProperty(exports2, "arrayify", { enumerable: true, get: function() {
        return bytes_1.arrayify;
      } });
      Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
        return bytes_1.concat;
      } });
      Object.defineProperty(exports2, "hexConcat", { enumerable: true, get: function() {
        return bytes_1.hexConcat;
      } });
      Object.defineProperty(exports2, "hexDataSlice", { enumerable: true, get: function() {
        return bytes_1.hexDataSlice;
      } });
      Object.defineProperty(exports2, "hexDataLength", { enumerable: true, get: function() {
        return bytes_1.hexDataLength;
      } });
      Object.defineProperty(exports2, "hexlify", { enumerable: true, get: function() {
        return bytes_1.hexlify;
      } });
      Object.defineProperty(exports2, "hexStripZeros", { enumerable: true, get: function() {
        return bytes_1.hexStripZeros;
      } });
      Object.defineProperty(exports2, "hexValue", { enumerable: true, get: function() {
        return bytes_1.hexValue;
      } });
      Object.defineProperty(exports2, "hexZeroPad", { enumerable: true, get: function() {
        return bytes_1.hexZeroPad;
      } });
      Object.defineProperty(exports2, "isBytes", { enumerable: true, get: function() {
        return bytes_1.isBytes;
      } });
      Object.defineProperty(exports2, "isBytesLike", { enumerable: true, get: function() {
        return bytes_1.isBytesLike;
      } });
      Object.defineProperty(exports2, "isHexString", { enumerable: true, get: function() {
        return bytes_1.isHexString;
      } });
      Object.defineProperty(exports2, "joinSignature", { enumerable: true, get: function() {
        return bytes_1.joinSignature;
      } });
      Object.defineProperty(exports2, "zeroPad", { enumerable: true, get: function() {
        return bytes_1.zeroPad;
      } });
      Object.defineProperty(exports2, "splitSignature", { enumerable: true, get: function() {
        return bytes_1.splitSignature;
      } });
      Object.defineProperty(exports2, "stripZeros", { enumerable: true, get: function() {
        return bytes_1.stripZeros;
      } });
      var hash_1 = require_lib12();
      Object.defineProperty(exports2, "_TypedDataEncoder", { enumerable: true, get: function() {
        return hash_1._TypedDataEncoder;
      } });
      Object.defineProperty(exports2, "dnsEncode", { enumerable: true, get: function() {
        return hash_1.dnsEncode;
      } });
      Object.defineProperty(exports2, "hashMessage", { enumerable: true, get: function() {
        return hash_1.hashMessage;
      } });
      Object.defineProperty(exports2, "id", { enumerable: true, get: function() {
        return hash_1.id;
      } });
      Object.defineProperty(exports2, "isValidName", { enumerable: true, get: function() {
        return hash_1.isValidName;
      } });
      Object.defineProperty(exports2, "namehash", { enumerable: true, get: function() {
        return hash_1.namehash;
      } });
      var hdnode_1 = require_lib22();
      Object.defineProperty(exports2, "defaultPath", { enumerable: true, get: function() {
        return hdnode_1.defaultPath;
      } });
      Object.defineProperty(exports2, "entropyToMnemonic", { enumerable: true, get: function() {
        return hdnode_1.entropyToMnemonic;
      } });
      Object.defineProperty(exports2, "getAccountPath", { enumerable: true, get: function() {
        return hdnode_1.getAccountPath;
      } });
      Object.defineProperty(exports2, "HDNode", { enumerable: true, get: function() {
        return hdnode_1.HDNode;
      } });
      Object.defineProperty(exports2, "isValidMnemonic", { enumerable: true, get: function() {
        return hdnode_1.isValidMnemonic;
      } });
      Object.defineProperty(exports2, "mnemonicToEntropy", { enumerable: true, get: function() {
        return hdnode_1.mnemonicToEntropy;
      } });
      Object.defineProperty(exports2, "mnemonicToSeed", { enumerable: true, get: function() {
        return hdnode_1.mnemonicToSeed;
      } });
      var json_wallets_1 = require_lib24();
      Object.defineProperty(exports2, "getJsonWalletAddress", { enumerable: true, get: function() {
        return json_wallets_1.getJsonWalletAddress;
      } });
      var keccak256_1 = require_lib5();
      Object.defineProperty(exports2, "keccak256", { enumerable: true, get: function() {
        return keccak256_1.keccak256;
      } });
      var logger_1 = require_lib();
      Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
        return logger_1.Logger;
      } });
      var sha2_1 = require_lib19();
      Object.defineProperty(exports2, "computeHmac", { enumerable: true, get: function() {
        return sha2_1.computeHmac;
      } });
      Object.defineProperty(exports2, "ripemd160", { enumerable: true, get: function() {
        return sha2_1.ripemd160;
      } });
      Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
        return sha2_1.sha256;
      } });
      Object.defineProperty(exports2, "sha512", { enumerable: true, get: function() {
        return sha2_1.sha512;
      } });
      var solidity_1 = require_lib27();
      Object.defineProperty(exports2, "solidityKeccak256", { enumerable: true, get: function() {
        return solidity_1.keccak256;
      } });
      Object.defineProperty(exports2, "solidityPack", { enumerable: true, get: function() {
        return solidity_1.pack;
      } });
      Object.defineProperty(exports2, "soliditySha256", { enumerable: true, get: function() {
        return solidity_1.sha256;
      } });
      var random_1 = require_lib23();
      Object.defineProperty(exports2, "randomBytes", { enumerable: true, get: function() {
        return random_1.randomBytes;
      } });
      Object.defineProperty(exports2, "shuffled", { enumerable: true, get: function() {
        return random_1.shuffled;
      } });
      var properties_1 = require_lib4();
      Object.defineProperty(exports2, "checkProperties", { enumerable: true, get: function() {
        return properties_1.checkProperties;
      } });
      Object.defineProperty(exports2, "deepCopy", { enumerable: true, get: function() {
        return properties_1.deepCopy;
      } });
      Object.defineProperty(exports2, "defineReadOnly", { enumerable: true, get: function() {
        return properties_1.defineReadOnly;
      } });
      Object.defineProperty(exports2, "getStatic", { enumerable: true, get: function() {
        return properties_1.getStatic;
      } });
      Object.defineProperty(exports2, "resolveProperties", { enumerable: true, get: function() {
        return properties_1.resolveProperties;
      } });
      Object.defineProperty(exports2, "shallowCopy", { enumerable: true, get: function() {
        return properties_1.shallowCopy;
      } });
      var RLP2 = __importStar(require_lib6());
      exports2.RLP = RLP2;
      var signing_key_1 = require_lib16();
      Object.defineProperty(exports2, "computePublicKey", { enumerable: true, get: function() {
        return signing_key_1.computePublicKey;
      } });
      Object.defineProperty(exports2, "recoverPublicKey", { enumerable: true, get: function() {
        return signing_key_1.recoverPublicKey;
      } });
      Object.defineProperty(exports2, "SigningKey", { enumerable: true, get: function() {
        return signing_key_1.SigningKey;
      } });
      var strings_1 = require_lib9();
      Object.defineProperty(exports2, "formatBytes32String", { enumerable: true, get: function() {
        return strings_1.formatBytes32String;
      } });
      Object.defineProperty(exports2, "nameprep", { enumerable: true, get: function() {
        return strings_1.nameprep;
      } });
      Object.defineProperty(exports2, "parseBytes32String", { enumerable: true, get: function() {
        return strings_1.parseBytes32String;
      } });
      Object.defineProperty(exports2, "_toEscapedUtf8String", { enumerable: true, get: function() {
        return strings_1._toEscapedUtf8String;
      } });
      Object.defineProperty(exports2, "toUtf8Bytes", { enumerable: true, get: function() {
        return strings_1.toUtf8Bytes;
      } });
      Object.defineProperty(exports2, "toUtf8CodePoints", { enumerable: true, get: function() {
        return strings_1.toUtf8CodePoints;
      } });
      Object.defineProperty(exports2, "toUtf8String", { enumerable: true, get: function() {
        return strings_1.toUtf8String;
      } });
      Object.defineProperty(exports2, "Utf8ErrorFuncs", { enumerable: true, get: function() {
        return strings_1.Utf8ErrorFuncs;
      } });
      var transactions_1 = require_lib17();
      Object.defineProperty(exports2, "accessListify", { enumerable: true, get: function() {
        return transactions_1.accessListify;
      } });
      Object.defineProperty(exports2, "computeAddress", { enumerable: true, get: function() {
        return transactions_1.computeAddress;
      } });
      Object.defineProperty(exports2, "parseTransaction", { enumerable: true, get: function() {
        return transactions_1.parse;
      } });
      Object.defineProperty(exports2, "recoverAddress", { enumerable: true, get: function() {
        return transactions_1.recoverAddress;
      } });
      Object.defineProperty(exports2, "serializeTransaction", { enumerable: true, get: function() {
        return transactions_1.serialize;
      } });
      Object.defineProperty(exports2, "TransactionTypes", { enumerable: true, get: function() {
        return transactions_1.TransactionTypes;
      } });
      var units_1 = require_lib28();
      Object.defineProperty(exports2, "commify", { enumerable: true, get: function() {
        return units_1.commify;
      } });
      Object.defineProperty(exports2, "formatEther", { enumerable: true, get: function() {
        return units_1.formatEther;
      } });
      Object.defineProperty(exports2, "parseEther", { enumerable: true, get: function() {
        return units_1.parseEther;
      } });
      Object.defineProperty(exports2, "formatUnits", { enumerable: true, get: function() {
        return units_1.formatUnits;
      } });
      Object.defineProperty(exports2, "parseUnits", { enumerable: true, get: function() {
        return units_1.parseUnits;
      } });
      var wallet_1 = require_lib25();
      Object.defineProperty(exports2, "verifyMessage", { enumerable: true, get: function() {
        return wallet_1.verifyMessage;
      } });
      Object.defineProperty(exports2, "verifyTypedData", { enumerable: true, get: function() {
        return wallet_1.verifyTypedData;
      } });
      var web_1 = require_lib26();
      Object.defineProperty(exports2, "_fetchData", { enumerable: true, get: function() {
        return web_1._fetchData;
      } });
      Object.defineProperty(exports2, "fetchJson", { enumerable: true, get: function() {
        return web_1.fetchJson;
      } });
      Object.defineProperty(exports2, "poll", { enumerable: true, get: function() {
        return web_1.poll;
      } });
      var sha2_2 = require_lib19();
      Object.defineProperty(exports2, "SupportedAlgorithm", { enumerable: true, get: function() {
        return sha2_2.SupportedAlgorithm;
      } });
      var strings_2 = require_lib9();
      Object.defineProperty(exports2, "UnicodeNormalizationForm", { enumerable: true, get: function() {
        return strings_2.UnicodeNormalizationForm;
      } });
      Object.defineProperty(exports2, "Utf8ErrorReason", { enumerable: true, get: function() {
        return strings_2.Utf8ErrorReason;
      } });
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports2, module2) {
      var s4 = 1e3;
      var m5 = s4 * 60;
      var h6 = m5 * 60;
      var d6 = h6 * 24;
      var w3 = d6 * 7;
      var y4 = d6 * 365.25;
      module2.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse2(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n4 = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n4 * y4;
          case "weeks":
          case "week":
          case "w":
            return n4 * w3;
          case "days":
          case "day":
          case "d":
            return n4 * d6;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n4 * h6;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n4 * m5;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n4 * s4;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n4;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d6) {
          return Math.round(ms / d6) + "d";
        }
        if (msAbs >= h6) {
          return Math.round(ms / h6) + "h";
        }
        if (msAbs >= m5) {
          return Math.round(ms / m5) + "m";
        }
        if (msAbs >= s4) {
          return Math.round(ms / s4) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d6) {
          return plural(ms, msAbs, d6, "day");
        }
        if (msAbs >= h6) {
          return plural(ms, msAbs, h6, "hour");
        }
        if (msAbs >= m5) {
          return plural(ms, msAbs, m5, "minute");
        }
        if (msAbs >= s4) {
          return plural(ms, msAbs, s4, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n4, name) {
        var isPlural = msAbs >= n4 * 1.5;
        return Math.round(ms / n4) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common3 = __commonJS({
    "node_modules/debug/src/common.js"(exports2, module2) {
      function setup2(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce2;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash3 = 0;
          for (let i4 = 0; i4 < namespace.length; i4++) {
            hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i4);
            hash3 |= 0;
          }
          return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index2 = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
              if (match === "%%") {
                return "%";
              }
              index2++;
              const formatter = createDebug.formatters[format3];
              if (typeof formatter === "function") {
                const val = args[index2];
                match = formatter.call(self2, val);
                args.splice(index2, 1);
                index2--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v7) => {
              enableOverride = v7;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i4;
          const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split2.length;
          for (i4 = 0; i4 < len; i4++) {
            if (!split2[i4]) {
              continue;
            }
            namespaces = split2[i4].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i4;
          let len;
          for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
            if (createDebug.skips[i4].test(name)) {
              return false;
            }
          }
          for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
            if (createDebug.names[i4].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce2(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module2.exports = setup2;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "node_modules/debug/src/browser.js"(exports2, module2) {
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c3 = "color: " + this.color;
        args.splice(1, 0, c3, "color: inherit");
        let index2 = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index2++;
          if (match === "%c") {
            lastC = index2;
          }
        });
        args.splice(lastC, 0, c3);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r2;
        try {
          r2 = exports2.storage.getItem("debug");
        } catch (error) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = process.env.DEBUG;
        }
        return r2;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module2.exports = require_common3()(exports2);
      var { formatters } = module2.exports;
      formatters.j = function(v7) {
        try {
          return JSON.stringify(v7);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js"(exports2, module2) {
      function arrayMap(array2, iteratee) {
        var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array2[index2], index2, array2);
        }
        return result;
      }
      module2.exports = arrayMap;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports2, module2) {
      var isArray3 = Array.isArray;
      module2.exports = isArray3;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module2.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports2, module2) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module2.exports = root;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports2, module2) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module2.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      var nativeObjectToString = objectProto2.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module2.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports2, module2) {
      var objectProto2 = Object.prototype;
      var nativeObjectToString = objectProto2.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module2.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module2.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports2, module2) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module2.exports = isObjectLike;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module2.exports = isSymbol;
    }
  });

  // node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "node_modules/lodash/_isKey.js"(exports2, module2) {
      var isArray3 = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray3(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      module2.exports = isKey;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports2, module2) {
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module2.exports = isObject2;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction3(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module2.exports = isFunction3;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports2, module2) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module2.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports2, module2) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module2.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports2, module2) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module2.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
      var isFunction3 = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto2 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module2.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports2, module2) {
      function getValue(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      module2.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports2, module2) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      module2.exports = getNative;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module2.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module2.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports2, module2) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module2.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module2.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module2.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports2, module2) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      Hash2.prototype.clear = hashClear;
      Hash2.prototype["delete"] = hashDelete;
      Hash2.prototype.get = hashGet;
      Hash2.prototype.has = hashHas;
      Hash2.prototype.set = hashSet;
      module2.exports = Hash2;
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module2.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports2, module2) {
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      module2.exports = eq2;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
      var eq2 = require_eq();
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq2(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module2.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice2 = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      module2.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      module2.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module2.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      module2.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports2, module2) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module2.exports = ListCache;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module2.exports = Map2;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
      var Hash2 = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash2()
        };
      }
      module2.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports2, module2) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module2.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports2, module2) {
      var isKeyable = require_isKeyable();
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module2.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module2.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module2.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size3 = data.size;
        data.set(key, value);
        this.size += data.size == size3 ? 0 : 1;
        return this;
      }
      module2.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports2, module2) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module2.exports = MapCache;
    }
  });

  // node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/lodash/memoize.js"(exports2, module2) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module2.exports = memoize;
    }
  });

  // node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      module2.exports = memoizeCapped;
    }
  });

  // node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "node_modules/lodash/_stringToPath.js"(exports2, module2) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number2, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
        });
        return result;
      });
      module2.exports = stringToPath;
    }
  });

  // node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "node_modules/lodash/_baseToString.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray3 = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray3(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module2.exports = baseToString;
    }
  });

  // node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "node_modules/lodash/toString.js"(exports2, module2) {
      var baseToString = require_baseToString();
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      module2.exports = toString3;
    }
  });

  // node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "node_modules/lodash/_castPath.js"(exports2, module2) {
      var isArray3 = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString3 = require_toString();
      function castPath(value, object2) {
        if (isArray3(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath(toString3(value));
      }
      module2.exports = castPath;
    }
  });

  // node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "node_modules/lodash/_toKey.js"(exports2, module2) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module2.exports = toKey;
    }
  });

  // node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "node_modules/lodash/_baseGet.js"(exports2, module2) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object2, path) {
        path = castPath(path, object2);
        var index2 = 0, length = path.length;
        while (object2 != null && index2 < length) {
          object2 = object2[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object2 : void 0;
      }
      module2.exports = baseGet;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports2, module2) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module2.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports2, module2) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module2.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports2, module2) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module2.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports2, module2) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module2.exports = stackHas;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports2, module2) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module2.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports2, module2) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module2.exports = Stack;
    }
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module2.exports = setCacheAdd;
    }
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module2.exports = setCacheHas;
    }
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js"(exports2, module2) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index2 = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values[index2]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module2.exports = SetCache;
    }
  });

  // node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js"(exports2, module2) {
      function arraySome(array2, predicate) {
        var index2 = -1, length = array2 == null ? 0 : array2.length;
        while (++index2 < length) {
          if (predicate(array2[index2], index2, array2)) {
            return true;
          }
        }
        return false;
      }
      module2.exports = arraySome;
    }
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js"(exports2, module2) {
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      module2.exports = cacheHas;
    }
  });

  // node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js"(exports2, module2) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index2 < arrLength) {
          var arrValue = array2[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      module2.exports = equalArrays;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module2.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js"(exports2, module2) {
      function mapToArray(map3) {
        var index2 = -1, result = Array(map3.size);
        map3.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      module2.exports = mapToArray;
    }
  });

  // node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js"(exports2, module2) {
      function setToArray(set4) {
        var index2 = -1, result = Array(set4.size);
        set4.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      module2.exports = setToArray;
    }
  });

  // node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq2 = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq2(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module2.exports = equalByTag;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports2, module2) {
      function arrayPush(array2, values) {
        var index2 = -1, length = values.length, offset = array2.length;
        while (++index2 < length) {
          array2[offset + index2] = values[index2];
        }
        return array2;
      }
      module2.exports = arrayPush;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
      var arrayPush = require_arrayPush();
      var isArray3 = require_isArray();
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray3(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      module2.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
      function arrayFilter(array2, predicate) {
        var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array2[index2];
          if (predicate(value, index2, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module2.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports2, module2) {
      function stubArray() {
        return [];
      }
      module2.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports2, module2) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto2 = Object.prototype;
      var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      module2.exports = getSymbols;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports2, module2) {
      function baseTimes(n4, iteratee) {
        var index2 = -1, result = Array(n4);
        while (++index2 < n4) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      module2.exports = baseTimes;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module2.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports2, module2) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module2.exports = isArguments;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports2, module2) {
      function stubFalse() {
        return false;
      }
      module2.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports2, module2) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module2.exports = isBuffer;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports2, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module2.exports = isIndex;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports2, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module2.exports = isLength;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module2.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports2, module2) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module2.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module2.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports2, module2) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module2.exports = isTypedArray;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray3 = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports2, module2) {
      var objectProto2 = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto2;
      }
      module2.exports = isPrototype;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports2, module2) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module2.exports = overArg;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module2.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports2, module2) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = baseKeys;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports2, module2) {
      var isFunction3 = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike2(value) {
        return value != null && isLength(value.length) && !isFunction3(value);
      }
      module2.exports = isArrayLike2;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/lodash/keys.js"(exports2, module2) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike2 = require_isArrayLike();
      function keys(object2) {
        return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      module2.exports = keys;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys();
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols);
      }
      module2.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js"(exports2, module2) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result;
      }
      module2.exports = equalObjects;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView2 = getNative(root, "DataView");
      module2.exports = DataView2;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module2.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module2.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module2.exports = WeakMap2;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports2, module2) {
      var DataView2 = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module2.exports = getTag;
    }
  });

  // node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
      var Stack = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray3 = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray3(object2), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      module2.exports = baseIsEqualDeep;
    }
  });

  // node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module2.exports = baseIsEqual;
    }
  });

  // node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
      var Stack = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object2, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object2 == null) {
          return !length;
        }
        object2 = Object(object2);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object2[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object2)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object2, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module2.exports = baseIsMatch;
    }
  });

  // node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
      var isObject2 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      module2.exports = isStrictComparable;
    }
  });

  // node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "node_modules/lodash/_getMatchData.js"(exports2, module2) {
      var isStrictComparable = require_isStrictComparable();
      var keys = require_keys();
      function getMatchData(object2) {
        var result = keys(object2), length = result.length;
        while (length--) {
          var key = result[length], value = object2[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module2.exports = getMatchData;
    }
  });

  // node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
        };
      }
      module2.exports = matchesStrictComparable;
    }
  });

  // node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "node_modules/lodash/_baseMatches.js"(exports2, module2) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      module2.exports = baseMatches;
    }
  });

  // node_modules/lodash/get.js
  var require_get = __commonJS({
    "node_modules/lodash/get.js"(exports2, module2) {
      var baseGet = require_baseGet();
      function get3(object2, path, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path);
        return result === void 0 ? defaultValue : result;
      }
      module2.exports = get3;
    }
  });

  // node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      module2.exports = baseHasIn;
    }
  });

  // node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "node_modules/lodash/_hasPath.js"(exports2, module2) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray3 = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object2, path, hasFunc) {
        path = castPath(path, object2);
        var index2 = -1, length = path.length, result = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result || ++index2 != length) {
          return result;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray3(object2) || isArguments(object2));
      }
      module2.exports = hasPath;
    }
  });

  // node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "node_modules/lodash/hasIn.js"(exports2, module2) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object2, path) {
        return object2 != null && hasPath(object2, path, baseHasIn);
      }
      module2.exports = hasIn;
    }
  });

  // node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
      var baseIsEqual = require_baseIsEqual();
      var get3 = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object2) {
          var objValue = get3(object2, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module2.exports = baseMatchesProperty;
    }
  });

  // node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "node_modules/lodash/identity.js"(exports2, module2) {
      function identity2(value) {
        return value;
      }
      module2.exports = identity2;
    }
  });

  // node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "node_modules/lodash/_baseProperty.js"(exports2, module2) {
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      module2.exports = baseProperty;
    }
  });

  // node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path) {
        return function(object2) {
          return baseGet(object2, path);
        };
      }
      module2.exports = basePropertyDeep;
    }
  });

  // node_modules/lodash/property.js
  var require_property = __commonJS({
    "node_modules/lodash/property.js"(exports2, module2) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property7(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module2.exports = property7;
    }
  });

  // node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity2 = require_identity();
      var isArray3 = require_isArray();
      var property7 = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property7(value);
      }
      module2.exports = baseIteratee;
    }
  });

  // node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "node_modules/lodash/_createBaseFor.js"(exports2, module2) {
      function createBaseFor(fromRight) {
        return function(object2, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object2;
        };
      }
      module2.exports = createBaseFor;
    }
  });

  // node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "node_modules/lodash/_baseFor.js"(exports2, module2) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module2.exports = baseFor;
    }
  });

  // node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "node_modules/lodash/_baseForOwn.js"(exports2, module2) {
      var baseFor = require_baseFor();
      var keys = require_keys();
      function baseForOwn(object2, iteratee) {
        return object2 && baseFor(object2, iteratee, keys);
      }
      module2.exports = baseForOwn;
    }
  });

  // node_modules/lodash/_createBaseEach.js
  var require_createBaseEach = __commonJS({
    "node_modules/lodash/_createBaseEach.js"(exports2, module2) {
      var isArrayLike2 = require_isArrayLike();
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      module2.exports = createBaseEach;
    }
  });

  // node_modules/lodash/_baseEach.js
  var require_baseEach = __commonJS({
    "node_modules/lodash/_baseEach.js"(exports2, module2) {
      var baseForOwn = require_baseForOwn();
      var createBaseEach = require_createBaseEach();
      var baseEach = createBaseEach(baseForOwn);
      module2.exports = baseEach;
    }
  });

  // node_modules/lodash/_baseMap.js
  var require_baseMap = __commonJS({
    "node_modules/lodash/_baseMap.js"(exports2, module2) {
      var baseEach = require_baseEach();
      var isArrayLike2 = require_isArrayLike();
      function baseMap(collection, iteratee) {
        var index2 = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index2] = iteratee(value, key, collection2);
        });
        return result;
      }
      module2.exports = baseMap;
    }
  });

  // node_modules/lodash/_baseSortBy.js
  var require_baseSortBy = __commonJS({
    "node_modules/lodash/_baseSortBy.js"(exports2, module2) {
      function baseSortBy(array2, comparer2) {
        var length = array2.length;
        array2.sort(comparer2);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      module2.exports = baseSortBy;
    }
  });

  // node_modules/lodash/_compareAscending.js
  var require_compareAscending = __commonJS({
    "node_modules/lodash/_compareAscending.js"(exports2, module2) {
      var isSymbol = require_isSymbol();
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      module2.exports = compareAscending;
    }
  });

  // node_modules/lodash/_compareMultiple.js
  var require_compareMultiple = __commonJS({
    "node_modules/lodash/_compareMultiple.js"(exports2, module2) {
      var compareAscending = require_compareAscending();
      function compareMultiple(object2, other, orders) {
        var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result) {
            if (index2 >= ordersLength) {
              return result;
            }
            var order = orders[index2];
            return result * (order == "desc" ? -1 : 1);
          }
        }
        return object2.index - other.index;
      }
      module2.exports = compareMultiple;
    }
  });

  // node_modules/lodash/_baseOrderBy.js
  var require_baseOrderBy = __commonJS({
    "node_modules/lodash/_baseOrderBy.js"(exports2, module2) {
      var arrayMap = require_arrayMap();
      var baseGet = require_baseGet();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var baseSortBy = require_baseSortBy();
      var baseUnary = require_baseUnary();
      var compareMultiple = require_compareMultiple();
      var identity2 = require_identity();
      var isArray3 = require_isArray();
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee) {
            if (isArray3(iteratee)) {
              return function(value) {
                return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
              };
            }
            return iteratee;
          });
        } else {
          iteratees = [identity2];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
        var result = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee) {
            return iteratee(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result, function(object2, other) {
          return compareMultiple(object2, other, orders);
        });
      }
      module2.exports = baseOrderBy;
    }
  });

  // node_modules/lodash/orderBy.js
  var require_orderBy = __commonJS({
    "node_modules/lodash/orderBy.js"(exports2, module2) {
      var baseOrderBy = require_baseOrderBy();
      var isArray3 = require_isArray();
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray3(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? void 0 : orders;
        if (!isArray3(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      module2.exports = orderBy;
    }
  });

  // node_modules/viem/dist/esm/utils/abi/formatAbiItem.js
  function formatAbiItem(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
      throw new InvalidDefinitionTypeError(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
  }
  function formatAbiParams(params, { includeName = false } = {}) {
    if (!params)
      return "";
    return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
  }
  function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith("tuple")) {
      return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
  }
  var init_formatAbiItem = __esm({
    "node_modules/viem/dist/esm/utils/abi/formatAbiItem.js"() {
      init_abi();
    }
  });

  // node_modules/viem/dist/esm/utils/data/isHex.js
  function isHex(value, { strict = true } = {}) {
    if (!value)
      return false;
    if (typeof value !== "string")
      return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
  }
  var init_isHex = __esm({
    "node_modules/viem/dist/esm/utils/data/isHex.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/data/size.js
  function size(value) {
    if (isHex(value, { strict: false }))
      return Math.ceil((value.length - 2) / 2);
    return value.length;
  }
  var init_size = __esm({
    "node_modules/viem/dist/esm/utils/data/size.js"() {
      init_isHex();
    }
  });

  // node_modules/viem/dist/esm/errors/version.js
  var version5;
  var init_version = __esm({
    "node_modules/viem/dist/esm/errors/version.js"() {
      version5 = "0.3.37";
    }
  });

  // node_modules/viem/dist/esm/errors/utils.js
  var getContractAddress4, getUrl, getVersion;
  var init_utils = __esm({
    "node_modules/viem/dist/esm/errors/utils.js"() {
      init_version();
      getContractAddress4 = (address) => address;
      getUrl = (url) => url;
      getVersion = () => `viem@${version5}`;
    }
  });

  // node_modules/viem/dist/esm/errors/base.js
  var __classPrivateFieldGet, _BaseError_instances, _BaseError_walk, BaseError;
  var init_base = __esm({
    "node_modules/viem/dist/esm/errors/base.js"() {
      init_utils();
      __classPrivateFieldGet = function(receiver, state, kind, f5) {
        if (kind === "a" && !f5)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
      };
      BaseError = class extends Error {
        constructor(shortMessage, args = {}) {
          super();
          _BaseError_instances.add(this);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ViemError"
          });
          Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: getVersion()
          });
          const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
          const docsPath4 = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
          this.message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [...args.metaMessages, ""] : [],
            ...docsPath4 ? [
              `Docs: https://viem.sh${docsPath4}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
            ] : [],
            ...details ? [`Details: ${details}`] : [],
            `Version: ${this.version}`
          ].join("\n");
          if (args.cause)
            this.cause = args.cause;
          this.details = details;
          this.docsPath = docsPath4;
          this.metaMessages = args.metaMessages;
          this.shortMessage = shortMessage;
        }
        walk(fn) {
          return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn);
        }
      };
      _BaseError_instances = /* @__PURE__ */ new WeakSet(), _BaseError_walk = function _BaseError_walk2(err, fn) {
        if (fn?.(err))
          return err;
        if (err.cause)
          return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk2).call(this, err.cause, fn);
        return err;
      };
    }
  });

  // node_modules/viem/dist/esm/errors/abi.js
  var AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
  var init_abi = __esm({
    "node_modules/viem/dist/esm/errors/abi.js"() {
      init_formatAbiItem();
      init_size();
      init_base();
      AbiConstructorNotFoundError = class extends BaseError {
        constructor({ docsPath: docsPath4 }) {
          super([
            "A constructor was not found on the ABI.",
            "Make sure you are using the correct ABI and that the constructor exists on it."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiConstructorNotFoundError"
          });
        }
      };
      AbiConstructorParamsNotFoundError = class extends BaseError {
        constructor({ docsPath: docsPath4 }) {
          super([
            "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
            "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiConstructorParamsNotFoundError"
          });
        }
      };
      AbiDecodingDataSizeTooSmallError = class extends BaseError {
        constructor({ data, params, size: size3 }) {
          super([`Data size of ${size3} bytes is too small for given parameters.`].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data} (${size3} bytes)`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingDataSizeTooSmallError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data;
          this.params = params;
          this.size = size3;
        }
      };
      AbiDecodingZeroDataError = class extends BaseError {
        constructor() {
          super('Cannot decode zero data ("0x") with ABI parameters.');
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingZeroDataError"
          });
        }
      };
      AbiEncodingArrayLengthMismatchError = class extends BaseError {
        constructor({ expectedLength, givenLength, type }) {
          super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingArrayLengthMismatchError"
          });
        }
      };
      AbiEncodingBytesSizeMismatchError = class extends BaseError {
        constructor({ expectedSize, value }) {
          super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingBytesSizeMismatchError"
          });
        }
      };
      AbiEncodingLengthMismatchError = class extends BaseError {
        constructor({ expectedLength, givenLength }) {
          super([
            "ABI encoding params/values length mismatch.",
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingLengthMismatchError"
          });
        }
      };
      AbiErrorSignatureNotFoundError = class extends BaseError {
        constructor(signature, { docsPath: docsPath4 }) {
          super([
            `Encoded error signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiErrorSignatureNotFoundError"
          });
        }
      };
      AbiEventSignatureEmptyTopicsError = class extends BaseError {
        constructor({ docsPath: docsPath4 }) {
          super("Cannot extract event signature from empty topics.", {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventSignatureEmptyTopicsError"
          });
        }
      };
      AbiEventSignatureNotFoundError = class extends BaseError {
        constructor(signature, { docsPath: docsPath4 }) {
          super([
            `Encoded event signature "${signature}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventSignatureNotFoundError"
          });
        }
      };
      AbiEventNotFoundError = class extends BaseError {
        constructor(eventName, { docsPath: docsPath4 } = {}) {
          super([
            `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventNotFoundError"
          });
        }
      };
      AbiFunctionNotFoundError = class extends BaseError {
        constructor(functionName, { docsPath: docsPath4 } = {}) {
          super([
            `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the function exists on it."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiFunctionNotFoundError"
          });
        }
      };
      AbiFunctionOutputsNotFoundError = class extends BaseError {
        constructor(functionName, { docsPath: docsPath4 }) {
          super([
            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
            "Cannot decode function result without knowing what the parameter types are.",
            "Make sure you are using the correct ABI and that the function exists on it."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiFunctionOutputsNotFoundError"
          });
        }
      };
      BytesSizeMismatchError = class extends BaseError {
        constructor({ expectedSize, givenSize }) {
          super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BytesSizeMismatchError"
          });
        }
      };
      DecodeLogDataMismatch = class extends BaseError {
        constructor({ data, params, size: size3 }) {
          super([
            `Data size of ${size3} bytes is too small for non-indexed event parameters.`
          ].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data} (${size3} bytes)`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeLogDataMismatch"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data;
          this.params = params;
          this.size = size3;
        }
      };
      DecodeLogTopicsMismatch = class extends BaseError {
        constructor({ abiItem, param }) {
          super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem(abiItem, { includeName: true })}".`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeLogTopicsMismatch"
          });
        }
      };
      InvalidAbiEncodingTypeError = class extends BaseError {
        constructor(type, { docsPath: docsPath4 }) {
          super([
            `Type "${type}" is not a valid encoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath4 });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiEncodingType"
          });
        }
      };
      InvalidAbiDecodingTypeError = class extends BaseError {
        constructor(type, { docsPath: docsPath4 }) {
          super([
            `Type "${type}" is not a valid decoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath4 });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiDecodingType"
          });
        }
      };
      InvalidArrayError = class extends BaseError {
        constructor(value) {
          super([`Value "${value}" is not a valid array.`].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidArrayError"
          });
        }
      };
      InvalidDefinitionTypeError = class extends BaseError {
        constructor(type) {
          super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"'
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidDefinitionTypeError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/errors/data.js
  var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError;
  var init_data = __esm({
    "node_modules/viem/dist/esm/errors/data.js"() {
      init_base();
      SliceOffsetOutOfBoundsError = class extends BaseError {
        constructor({ offset, position, size: size3 }) {
          super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size3}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SliceOffsetOutOfBoundsError"
          });
        }
      };
      SizeExceedsPaddingSizeError = class extends BaseError {
        constructor({ size: size3, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size3}) exceeds padding size (${targetSize}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SizeExceedsPaddingSizeError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/data/pad.js
  function pad(hexOrBytes, { dir, size: size3 = 32 } = {}) {
    if (typeof hexOrBytes === "string")
      return padHex(hexOrBytes, { dir, size: size3 });
    return padBytes(hexOrBytes, { dir, size: size3 });
  }
  function padHex(hex_, { dir, size: size3 = 32 } = {}) {
    if (size3 === null)
      return hex_;
    const hex2 = hex_.replace("0x", "");
    if (hex2.length > size3 * 2)
      throw new SizeExceedsPaddingSizeError({
        size: Math.ceil(hex2.length / 2),
        targetSize: size3,
        type: "hex"
      });
    return `0x${hex2[dir === "right" ? "padEnd" : "padStart"](size3 * 2, "0")}`;
  }
  function padBytes(bytes2, { dir, size: size3 = 32 } = {}) {
    if (size3 === null)
      return bytes2;
    if (bytes2.length > size3)
      throw new SizeExceedsPaddingSizeError({
        size: bytes2.length,
        targetSize: size3,
        type: "bytes"
      });
    const paddedBytes = new Uint8Array(size3);
    for (let i4 = 0; i4 < size3; i4++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i4 : size3 - i4 - 1] = bytes2[padEnd ? i4 : bytes2.length - i4 - 1];
    }
    return paddedBytes;
  }
  var init_pad = __esm({
    "node_modules/viem/dist/esm/utils/data/pad.js"() {
      init_data();
    }
  });

  // node_modules/viem/dist/esm/errors/encoding.js
  var IntegerOutOfRangeError, InvalidHexBooleanError, SizeOverflowError;
  var init_encoding = __esm({
    "node_modules/viem/dist/esm/errors/encoding.js"() {
      init_base();
      IntegerOutOfRangeError = class extends BaseError {
        constructor({ max, min, signed, size: size3, value }) {
          super(`Number "${value}" is not in safe ${size3 ? `${size3 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntegerOutOfRangeError"
          });
        }
      };
      InvalidHexBooleanError = class extends BaseError {
        constructor(hex2) {
          super(`Hex value "${hex2}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidHexBooleanError"
          });
        }
      };
      SizeOverflowError = class extends BaseError {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SizeOverflowError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/data/trim.js
  function trim(hexOrBytes, { dir = "left" } = {}) {
    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for (let i4 = 0; i4 < data.length - 1; i4++) {
      if (data[dir === "left" ? i4 : data.length - i4 - 1].toString() === "0")
        sliceLength++;
      else
        break;
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === "string") {
      if (data.length === 1 && dir === "right")
        data = `${data}0`;
      return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
  }
  var init_trim = __esm({
    "node_modules/viem/dist/esm/utils/data/trim.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/encoding/fromHex.js
  function assertSize(hexOrBytes, { size: size3 }) {
    if (size(hexOrBytes) > size3)
      throw new SizeOverflowError({
        givenSize: size(hexOrBytes),
        maxSize: size3
      });
  }
  function hexToBigInt(hex2, opts = {}) {
    const { signed } = opts;
    if (opts.size)
      assertSize(hex2, { size: opts.size });
    const value = BigInt(hex2);
    if (!signed)
      return value;
    const size3 = (hex2.length - 2) / 2;
    const max = (1n << BigInt(size3) * 8n - 1n) - 1n;
    if (value <= max)
      return value;
    return value - BigInt(`0x${"f".padStart(size3 * 2, "f")}`) - 1n;
  }
  function hexToBool(hex_, opts = {}) {
    let hex2 = hex_;
    if (opts.size) {
      assertSize(hex2, { size: opts.size });
      hex2 = trim(hex2);
    }
    if (trim(hex2) === "0x00")
      return false;
    if (trim(hex2) === "0x01")
      return true;
    throw new InvalidHexBooleanError(hex2);
  }
  function hexToNumber(hex2, opts = {}) {
    return Number(hexToBigInt(hex2, opts));
  }
  function hexToString(hex2, opts = {}) {
    let bytes2 = hexToBytes(hex2);
    if (opts.size) {
      assertSize(bytes2, { size: opts.size });
      bytes2 = trim(bytes2, { dir: "right" });
    }
    return new TextDecoder().decode(bytes2);
  }
  var init_fromHex = __esm({
    "node_modules/viem/dist/esm/utils/encoding/fromHex.js"() {
      init_encoding();
      init_size();
      init_trim();
      init_toBytes();
    }
  });

  // node_modules/viem/dist/esm/utils/encoding/toHex.js
  function toHex(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToHex(value, opts);
    if (typeof value === "string") {
      return stringToHex(value, opts);
    }
    if (typeof value === "boolean")
      return boolToHex(value, opts);
    return bytesToHex(value, opts);
  }
  function boolToHex(value, opts = {}) {
    const hex2 = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
      assertSize(hex2, { size: opts.size });
      return pad(hex2, { size: opts.size });
    }
    return hex2;
  }
  function bytesToHex(value, opts = {}) {
    let hexString = "";
    for (let i4 = 0; i4 < value.length; i4++) {
      hexString += hexes[value[i4]];
    }
    const hex2 = `0x${hexString}`;
    if (typeof opts.size === "number") {
      assertSize(hex2, { size: opts.size });
      return pad(hex2, { dir: "right", size: opts.size });
    }
    return hex2;
  }
  function numberToHex(value_, opts = {}) {
    const { signed, size: size3 } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size3) {
      if (signed)
        maxValue = (1n << BigInt(size3) * 8n - 1n) - 1n;
      else
        maxValue = 2n ** (BigInt(size3) * 8n) - 1n;
    } else if (typeof value_ === "number") {
      maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
      const suffix = typeof value_ === "bigint" ? "n" : "";
      throw new IntegerOutOfRangeError({
        max: maxValue ? `${maxValue}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed,
        size: size3,
        value: `${value_}${suffix}`
      });
    }
    const hex2 = `0x${(signed && value < 0 ? (1n << BigInt(size3 * 8)) + BigInt(value) : value).toString(16)}`;
    if (size3)
      return pad(hex2, { size: size3 });
    return hex2;
  }
  function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
  }
  var hexes, encoder;
  var init_toHex = __esm({
    "node_modules/viem/dist/esm/utils/encoding/toHex.js"() {
      init_encoding();
      init_pad();
      init_fromHex();
      hexes = Array.from({ length: 256 }, (_v, i4) => i4.toString(16).padStart(2, "0"));
      encoder = new TextEncoder();
    }
  });

  // node_modules/viem/dist/esm/utils/encoding/toBytes.js
  function toBytes(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToBytes(value, opts);
    if (typeof value === "boolean")
      return boolToBytes(value, opts);
    if (isHex(value))
      return hexToBytes(value, opts);
    return stringToBytes(value, opts);
  }
  function boolToBytes(value, opts = {}) {
    const bytes2 = new Uint8Array(1);
    bytes2[0] = Number(value);
    if (typeof opts.size === "number") {
      assertSize(bytes2, { size: opts.size });
      return pad(bytes2, { size: opts.size });
    }
    return bytes2;
  }
  function hexToBytes(hex_, opts = {}) {
    let hex2 = hex_;
    if (opts.size) {
      assertSize(hex2, { size: opts.size });
      hex2 = pad(hex2, { dir: "right", size: opts.size });
    }
    let hexString = hex2.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const bytes2 = new Uint8Array(hexString.length / 2);
    for (let index2 = 0; index2 < bytes2.length; index2++) {
      const start = index2 * 2;
      const hexByte = hexString.slice(start, start + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new BaseError(`Invalid byte sequence ("${hexByte}" in "${hexString}").`);
      bytes2[index2] = byte;
    }
    return bytes2;
  }
  function numberToBytes(value, opts) {
    const hex2 = numberToHex(value, opts);
    return hexToBytes(hex2);
  }
  function stringToBytes(value, opts = {}) {
    const bytes2 = encoder2.encode(value);
    if (typeof opts.size === "number") {
      assertSize(bytes2, { size: opts.size });
      return pad(bytes2, { dir: "right", size: opts.size });
    }
    return bytes2;
  }
  var encoder2;
  var init_toBytes = __esm({
    "node_modules/viem/dist/esm/utils/encoding/toBytes.js"() {
      init_base();
      init_isHex();
      init_pad();
      init_fromHex();
      init_toHex();
      encoder2 = new TextEncoder();
    }
  });

  // node_modules/viem/dist/esm/utils/contract/extractFunctionParts.js
  function extractFunctionParts(def) {
    const parts = def.match(paramsRegex);
    const type = parts?.[2] || void 0;
    const name = parts?.[3];
    const params = parts?.[5] || void 0;
    return { type, name, params };
  }
  function extractFunctionName(def) {
    return extractFunctionParts(def).name;
  }
  function extractFunctionParams(def) {
    const params = extractFunctionParts(def).params;
    const splitParams = params?.split(",").map((x8) => x8.trim().split(" "));
    return splitParams?.map((param) => ({
      type: param[0],
      name: param[1] === "indexed" ? param[2] : param[1],
      ...param[1] === "indexed" ? { indexed: true } : {}
    }));
  }
  var paramsRegex;
  var init_extractFunctionParts = __esm({
    "node_modules/viem/dist/esm/utils/contract/extractFunctionParts.js"() {
      paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
    }
  });

  // node_modules/@noble/hashes/esm/_assert.js
  function number(n4) {
    if (!Number.isSafeInteger(n4) || n4 < 0)
      throw new Error(`Wrong positive integer: ${n4}`);
  }
  function bool(b4) {
    if (typeof b4 !== "boolean")
      throw new Error(`Expected boolean, not ${b4}`);
  }
  function bytes(b4, ...lengths) {
    if (!(b4 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b4.length))
      throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b4.length}`);
  }
  function hash(hash3) {
    if (typeof hash3 !== "function" || typeof hash3.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash3.outputLen);
    number(hash3.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert, assert_default;
  var init_assert = __esm({
    "node_modules/@noble/hashes/esm/_assert.js"() {
      assert = {
        number,
        bool,
        bytes,
        hash,
        exists,
        output
      };
      assert_default = assert;
    }
  });

  // node_modules/@noble/hashes/esm/_u64.js
  function fromBig(n4, le2 = false) {
    if (le2)
      return { h: Number(n4 & U32_MASK64), l: Number(n4 >> _32n & U32_MASK64) };
    return { h: Number(n4 >> _32n & U32_MASK64) | 0, l: Number(n4 & U32_MASK64) | 0 };
  }
  function split(lst, le2 = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i4 = 0; i4 < lst.length; i4++) {
      const { h: h6, l: l4 } = fromBig(lst[i4], le2);
      [Ah[i4], Al[i4]] = [h6, l4];
    }
    return [Ah, Al];
  }
  function add(Ah, Al, Bh, Bl) {
    const l4 = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l4 / 2 ** 32 | 0) | 0, l: l4 | 0 };
  }
  var U32_MASK64, _32n, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H, u64, u64_default;
  var init_u64 = __esm({
    "node_modules/@noble/hashes/esm/_u64.js"() {
      U32_MASK64 = BigInt(2 ** 32 - 1);
      _32n = BigInt(32);
      toBig = (h6, l4) => BigInt(h6 >>> 0) << _32n | BigInt(l4 >>> 0);
      shrSH = (h6, l4, s4) => h6 >>> s4;
      shrSL = (h6, l4, s4) => h6 << 32 - s4 | l4 >>> s4;
      rotrSH = (h6, l4, s4) => h6 >>> s4 | l4 << 32 - s4;
      rotrSL = (h6, l4, s4) => h6 << 32 - s4 | l4 >>> s4;
      rotrBH = (h6, l4, s4) => h6 << 64 - s4 | l4 >>> s4 - 32;
      rotrBL = (h6, l4, s4) => h6 >>> s4 - 32 | l4 << 64 - s4;
      rotr32H = (h6, l4) => l4;
      rotr32L = (h6, l4) => h6;
      rotlSH = (h6, l4, s4) => h6 << s4 | l4 >>> 32 - s4;
      rotlSL = (h6, l4, s4) => l4 << s4 | h6 >>> 32 - s4;
      rotlBH = (h6, l4, s4) => l4 << s4 - 32 | h6 >>> 64 - s4;
      rotlBL = (h6, l4, s4) => h6 << s4 - 32 | l4 >>> 64 - s4;
      add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      u64 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      u64_default = u64;
    }
  });

  // node_modules/@noble/hashes/esm/crypto.js
  var crypto2;
  var init_crypto = __esm({
    "node_modules/@noble/hashes/esm/crypto.js"() {
      crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/esm/utils.js
  function utf8ToBytes(str) {
    if (typeof str !== "string") {
      throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
  }
  function toBytes2(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
  }
  function concatBytes(...arrays) {
    if (!arrays.every((a2) => a2 instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (arrays.length === 1)
      return arrays[0];
    const length = arrays.reduce((a2, arr) => a2 + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i4 = 0, pad2 = 0; i4 < arrays.length; i4++) {
      const arr = arrays[i4];
      result.set(arr, pad2);
      pad2 += arr.length;
    }
    return result;
  }
  function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes2(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function randomBytes2(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  var u32, createView, rotr, isLE, hexes2, Hash;
  var init_utils2 = __esm({
    "node_modules/@noble/hashes/esm/utils.js"() {
      init_crypto();
      u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      rotr = (word, shift2) => word << 32 - shift2 | word >>> shift2;
      isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!isLE)
        throw new Error("Non little-endian hardware is not supported");
      hexes2 = Array.from({ length: 256 }, (v7, i4) => i4.toString(16).padStart(2, "0"));
      Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
    }
  });

  // node_modules/@noble/hashes/esm/sha3.js
  function keccakP(s4, rounds = 24) {
    const B5 = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x8 = 0; x8 < 10; x8++)
        B5[x8] = s4[x8] ^ s4[x8 + 10] ^ s4[x8 + 20] ^ s4[x8 + 30] ^ s4[x8 + 40];
      for (let x8 = 0; x8 < 10; x8 += 2) {
        const idx1 = (x8 + 8) % 10;
        const idx0 = (x8 + 2) % 10;
        const B0 = B5[idx0];
        const B1 = B5[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B5[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B5[idx1 + 1];
        for (let y4 = 0; y4 < 50; y4 += 10) {
          s4[x8 + y4] ^= Th;
          s4[x8 + y4 + 1] ^= Tl;
        }
      }
      let curH = s4[2];
      let curL = s4[3];
      for (let t3 = 0; t3 < 24; t3++) {
        const shift2 = SHA3_ROTL[t3];
        const Th = rotlH(curH, curL, shift2);
        const Tl = rotlL(curH, curL, shift2);
        const PI = SHA3_PI[t3];
        curH = s4[PI];
        curL = s4[PI + 1];
        s4[PI] = Th;
        s4[PI + 1] = Tl;
      }
      for (let y4 = 0; y4 < 50; y4 += 10) {
        for (let x8 = 0; x8 < 10; x8++)
          B5[x8] = s4[y4 + x8];
        for (let x8 = 0; x8 < 10; x8++)
          s4[y4 + x8] ^= ~B5[(x8 + 2) % 10] & B5[(x8 + 4) % 10];
      }
      s4[0] ^= SHA3_IOTA_H[round];
      s4[1] ^= SHA3_IOTA_L[round];
    }
    B5.fill(0);
  }
  var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
  var init_sha3 = __esm({
    "node_modules/@noble/hashes/esm/sha3.js"() {
      init_assert();
      init_u64();
      init_utils2();
      [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
      _0n = BigInt(0);
      _1n = BigInt(1);
      _2n = BigInt(2);
      _7n = BigInt(7);
      _256n = BigInt(256);
      _0x71n = BigInt(113);
      for (let round = 0, R4 = _1n, x8 = 1, y4 = 0; round < 24; round++) {
        [x8, y4] = [y4, (2 * x8 + 3 * y4) % 5];
        SHA3_PI.push(2 * (5 * y4 + x8));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t3 = _0n;
        for (let j3 = 0; j3 < 7; j3++) {
          R4 = (R4 << _1n ^ (R4 >> _7n) * _0x71n) % _256n;
          if (R4 & _2n)
            t3 ^= _1n << (_1n << BigInt(j3)) - _1n;
        }
        _SHA3_IOTA.push(t3);
      }
      [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
      rotlH = (h6, l4, s4) => s4 > 32 ? u64_default.rotlBH(h6, l4, s4) : u64_default.rotlSH(h6, l4, s4);
      rotlL = (h6, l4, s4) => s4 > 32 ? u64_default.rotlBL(h6, l4, s4) : u64_default.rotlSL(h6, l4, s4);
      Keccak = class extends Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          assert_default.number(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200);
          this.state32 = u32(this.state);
        }
        keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          assert_default.exists(this);
          const { blockLen, state } = this;
          data = toBytes2(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take2 = Math.min(blockLen - this.pos, len - pos);
            for (let i4 = 0; i4 < take2; i4++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          assert_default.exists(this, false);
          assert_default.bytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take2 = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
            this.posOut += take2;
            pos += take2;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes2) {
          assert_default.number(bytes2);
          return this.xofInto(new Uint8Array(bytes2));
        }
        digestInto(out) {
          assert_default.output(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
      sha3_224 = gen(6, 144, 224 / 8);
      sha3_256 = gen(6, 136, 256 / 8);
      sha3_384 = gen(6, 104, 384 / 8);
      sha3_512 = gen(6, 72, 512 / 8);
      keccak_224 = gen(1, 144, 224 / 8);
      keccak_256 = gen(1, 136, 256 / 8);
      keccak_384 = gen(1, 104, 384 / 8);
      keccak_512 = gen(1, 72, 512 / 8);
      genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      shake128 = genShake(31, 168, 128 / 8);
      shake256 = genShake(31, 136, 256 / 8);
    }
  });

  // node_modules/viem/dist/esm/utils/hash/keccak256.js
  function keccak2562(value, to_) {
    const to = to_ || "hex";
    const bytes2 = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
    if (to === "bytes")
      return bytes2;
    return toHex(bytes2);
  }
  var init_keccak256 = __esm({
    "node_modules/viem/dist/esm/utils/hash/keccak256.js"() {
      init_sha3();
      init_isHex();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/dist/esm/utils/hash/hashFunction.js
  function hashFunction(def) {
    const name = extractFunctionName(def);
    const params = extractFunctionParams(def);
    if (!params || params.length === 0)
      return hash2(def.replace(/ /g, ""));
    return hash2(`${name}(${params.map(({ type }) => type).join(",")})`);
  }
  var hash2;
  var init_hashFunction = __esm({
    "node_modules/viem/dist/esm/utils/hash/hashFunction.js"() {
      init_extractFunctionParts();
      init_toBytes();
      init_keccak256();
      hash2 = (value) => keccak2562(toBytes(value));
    }
  });

  // node_modules/viem/dist/esm/errors/address.js
  var InvalidAddressError;
  var init_address = __esm({
    "node_modules/viem/dist/esm/errors/address.js"() {
      init_base();
      InvalidAddressError = class extends BaseError {
        constructor({ address }) {
          super(`Address "${address}" is invalid.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAddressError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/address/isAddress.js
  function isAddress2(address) {
    return addressRegex.test(address);
  }
  var addressRegex;
  var init_isAddress = __esm({
    "node_modules/viem/dist/esm/utils/address/isAddress.js"() {
      addressRegex = /^0x[a-fA-F0-9]{40}$/;
    }
  });

  // node_modules/viem/dist/esm/utils/data/concat.js
  function concat5(values) {
    if (typeof values[0] === "string")
      return concatHex(values);
    return concatBytes2(values);
  }
  function concatBytes2(values) {
    let length = 0;
    for (const arr of values) {
      length += arr.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values) {
      result.set(arr, offset);
      offset += arr.length;
    }
    return result;
  }
  function concatHex(values) {
    return `0x${values.reduce((acc, x8) => acc + x8.replace("0x", ""), "")}`;
  }
  var init_concat = __esm({
    "node_modules/viem/dist/esm/utils/data/concat.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/data/slice.js
  function slice(value, start, end, { strict } = {}) {
    if (isHex(value, { strict: false }))
      return sliceHex(value, start, end, {
        strict
      });
    return sliceBytes(value, start, end, {
      strict
    });
  }
  function assertStartOffset(value, start) {
    if (typeof start === "number" && start > 0 && start > size(value) - 1)
      throw new SliceOffsetOutOfBoundsError({
        offset: start,
        position: "start",
        size: size(value)
      });
  }
  function assertEndOffset(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError({
        offset: end,
        position: "end",
        size: size(value)
      });
    }
  }
  function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  var init_slice = __esm({
    "node_modules/viem/dist/esm/utils/data/slice.js"() {
      init_data();
      init_isHex();
      init_size();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/encodeAbiParameters.js
  function encodeAbiParameters(params, values) {
    if (params.length !== values.length)
      throw new AbiEncodingLengthMismatchError({
        expectedLength: params.length,
        givenLength: values.length
      });
    const preparedParams = prepareParams({
      params,
      values
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0)
      return "0x";
    return data;
  }
  function prepareParams({ params, values }) {
    const preparedParams = [];
    for (let i4 = 0; i4 < params.length; i4++) {
      preparedParams.push(prepareParam({ param: params[i4], value: values[i4] }));
    }
    return preparedParams;
  }
  function prepareParam({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return encodeArray(value, { length, param: { ...param, type } });
    }
    if (param.type === "tuple") {
      return encodeTuple(value, {
        param
      });
    }
    if (param.type === "address") {
      return encodeAddress(value);
    }
    if (param.type === "bool") {
      return encodeBool(value);
    }
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      const signed = param.type.startsWith("int");
      return encodeNumber(value, { signed });
    }
    if (param.type.startsWith("bytes")) {
      return encodeBytes2(value, { param });
    }
    if (param.type === "string") {
      return encodeString(value);
    }
    throw new InvalidAbiEncodingTypeError(param.type, {
      docsPath: "/docs/contract/encodeAbiParameters"
    });
  }
  function encodeParams(preparedParams) {
    let staticSize = 0;
    for (let i4 = 0; i4 < preparedParams.length; i4++) {
      const { dynamic, encoded } = preparedParams[i4];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i4 = 0; i4 < preparedParams.length; i4++) {
      const { dynamic, encoded } = preparedParams[i4];
      if (dynamic) {
        staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
        dynamicParams.push(encoded);
        dynamicSize += size(encoded);
      } else {
        staticParams.push(encoded);
      }
    }
    return concat5([...staticParams, ...dynamicParams]);
  }
  function encodeAddress(value) {
    if (!isAddress2(value))
      throw new InvalidAddressError({ address: value });
    return { dynamic: false, encoded: padHex(value.toLowerCase()) };
  }
  function encodeArray(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError(value);
    if (!dynamic && value.length !== length)
      throw new AbiEncodingArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${param.type}[${length}]`
      });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i4 = 0; i4 < value.length; i4++) {
      const preparedParam = prepareParam({ param, value: value[i4] });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data = encodeParams(preparedParams);
      if (dynamic) {
        const length2 = numberToHex(preparedParams.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParams.length > 0 ? concat5([length2, data]) : length2
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data };
    }
    return {
      dynamic: false,
      encoded: concat5(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes2(value, { param }) {
    const [_18, size_] = param.type.split("bytes");
    if (!size_) {
      const partsLength = Math.ceil(size(value) / 32);
      const parts = [];
      for (let i4 = 0; i4 < partsLength; i4++) {
        parts.push(padHex(slice(value, i4 * 32, (i4 + 1) * 32), {
          dir: "right"
        }));
      }
      return {
        dynamic: true,
        encoded: concat5([
          padHex(numberToHex(size(value), { size: 32 })),
          ...parts
        ])
      };
    }
    if (size(value) !== parseInt(size_))
      throw new AbiEncodingBytesSizeMismatchError({
        expectedSize: parseInt(size_),
        value
      });
    return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
  }
  function encodeBool(value) {
    return { dynamic: false, encoded: padHex(boolToHex(value)) };
  }
  function encodeNumber(value, { signed }) {
    return {
      dynamic: false,
      encoded: numberToHex(value, {
        size: 32,
        signed
      })
    };
  }
  function encodeString(value) {
    const hexValue6 = stringToHex(value);
    const partsLength = Math.ceil(size(hexValue6) / 32);
    const parts = [];
    for (let i4 = 0; i4 < partsLength; i4++) {
      parts.push(padHex(slice(hexValue6, i4 * 32, (i4 + 1) * 32), {
        dir: "right"
      }));
    }
    return {
      dynamic: true,
      encoded: concat5([
        padHex(numberToHex(size(hexValue6), { size: 32 })),
        ...parts
      ])
    };
  }
  function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i4 = 0; i4 < param.components.length; i4++) {
      const param_ = param.components[i4];
      const index2 = Array.isArray(value) ? i4 : param_.name;
      const preparedParam = prepareParam({
        param: param_,
        value: value[index2]
      });
      preparedParams.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encodeParams(preparedParams) : concat5(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
  }
  var init_encodeAbiParameters = __esm({
    "node_modules/viem/dist/esm/utils/abi/encodeAbiParameters.js"() {
      init_abi();
      init_address();
      init_isAddress();
      init_concat();
      init_pad();
      init_size();
      init_slice();
      init_toHex();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/getAbiItem.js
  function getAbiItem({ abi, args = [], name }) {
    const abiItems = abi.filter((x8) => "name" in x8 && x8.name === name);
    if (abiItems.length === 0)
      return void 0;
    if (abiItems.length === 1)
      return abiItems[0];
    for (const abiItem of abiItems) {
      if (!("inputs" in abiItem))
        continue;
      if (!args || args.length === 0) {
        if (!abiItem.inputs || abiItem.inputs.length === 0)
          return abiItem;
        continue;
      }
      if (!abiItem.inputs)
        continue;
      if (abiItem.inputs.length === 0)
        continue;
      const matched = args.every((arg, index2) => {
        const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
        if (!abiParameter)
          return false;
        return isArgOfType(arg, abiParameter);
      });
      if (matched)
        return abiItem;
    }
    return abiItems[0];
  }
  function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
      case "address":
        return isAddress2(arg);
      case "bool":
        return argType === "boolean";
      case "function":
        return argType === "string";
      case "string":
        return argType === "string";
      default: {
        if (abiParameterType === "tuple" && "components" in abiParameter)
          return Object.values(abiParameter.components).every((component, index2) => {
            return isArgOfType(Object.values(arg)[index2], component);
          });
        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
          return argType === "number" || argType === "bigint";
        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
          return argType === "string" || arg instanceof Uint8Array;
        if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
          return Array.isArray(arg) && arg.every((x8) => isArgOfType(x8, {
            ...abiParameter,
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          }));
        }
        return false;
      }
    }
  }
  var init_getAbiItem = __esm({
    "node_modules/viem/dist/esm/utils/abi/getAbiItem.js"() {
      init_isAddress();
    }
  });

  // node_modules/viem/dist/esm/accounts/utils/parseAccount.js
  function parseAccount(account) {
    if (typeof account === "string")
      return { address: account, type: "json-rpc" };
    return account;
  }
  var init_parseAccount = __esm({
    "node_modules/viem/dist/esm/accounts/utils/parseAccount.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/hash/getFunctionSelector.js
  var getFunctionSelector;
  var init_getFunctionSelector = __esm({
    "node_modules/viem/dist/esm/utils/hash/getFunctionSelector.js"() {
      init_slice();
      init_hashFunction();
      getFunctionSelector = (fn) => slice(hashFunction(fn), 0, 4);
    }
  });

  // node_modules/viem/dist/esm/utils/abi/encodeFunctionData.js
  function encodeFunctionData({ abi, args, functionName }) {
    let abiItem = abi[0];
    if (functionName) {
      abiItem = getAbiItem({
        abi,
        args,
        name: functionName
      });
      if (!abiItem)
        throw new AbiFunctionNotFoundError(functionName, {
          docsPath: "/docs/contract/encodeFunctionData"
        });
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, {
        docsPath: "/docs/contract/encodeFunctionData"
      });
    const definition = formatAbiItem(abiItem);
    const signature = getFunctionSelector(definition);
    const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
    return concatHex([signature, data ?? "0x"]);
  }
  var init_encodeFunctionData = __esm({
    "node_modules/viem/dist/esm/utils/abi/encodeFunctionData.js"() {
      init_abi();
      init_concat();
      init_getFunctionSelector();
      init_encodeAbiParameters();
      init_formatAbiItem();
      init_getAbiItem();
    }
  });

  // node_modules/viem/dist/esm/constants/solidity.js
  var panicReasons, solidityError, solidityPanic;
  var init_solidity = __esm({
    "node_modules/viem/dist/esm/constants/solidity.js"() {
      panicReasons = {
        1: "An `assert` condition failed.",
        17: "Arithmic operation resulted in underflow or overflow.",
        18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
        33: "Attempted to convert to an invalid type.",
        34: "Attempted to access a storage byte array that is incorrectly encoded.",
        49: "Performed `.pop()` on an empty array",
        50: "Array index is out of bounds.",
        65: "Allocated too much memory or created an array which is too large.",
        81: "Attempted to call a zero-initialized variable of internal function type."
      };
      solidityError = {
        inputs: [
          {
            name: "message",
            type: "string"
          }
        ],
        name: "Error",
        type: "error"
      };
      solidityPanic = {
        inputs: [
          {
            name: "reason",
            type: "uint256"
          }
        ],
        name: "Panic",
        type: "error"
      };
    }
  });

  // node_modules/viem/dist/esm/utils/address/getAddress.js
  function checksumAddress(address_, chainId) {
    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
    const hash3 = keccak2562(stringToBytes(hexAddress), "bytes");
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
    for (let i4 = 0; i4 < 40; i4 += 2) {
      if (hash3[i4 >> 1] >> 4 >= 8 && address[i4]) {
        address[i4] = address[i4].toUpperCase();
      }
      if ((hash3[i4 >> 1] & 15) >= 8 && address[i4 + 1]) {
        address[i4 + 1] = address[i4 + 1].toUpperCase();
      }
    }
    return `0x${address.join("")}`;
  }
  function getAddress4(address, chainId) {
    if (!isAddress2(address))
      throw new InvalidAddressError({ address });
    return checksumAddress(address, chainId);
  }
  var init_getAddress = __esm({
    "node_modules/viem/dist/esm/utils/address/getAddress.js"() {
      init_address();
      init_toBytes();
      init_keccak256();
      init_isAddress();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/decodeAbiParameters.js
  function decodeAbiParameters(params, data) {
    if (data === "0x" && params.length > 0)
      throw new AbiDecodingZeroDataError();
    if (size(data) && size(data) < 32)
      throw new AbiDecodingDataSizeTooSmallError({
        data,
        params,
        size: size(data)
      });
    return decodeParams({
      data,
      params
    });
  }
  function decodeParams({ data, params }) {
    const decodedValues = [];
    let position = 0;
    for (let i4 = 0; i4 < params.length; i4++) {
      if (position >= size(data))
        throw new AbiDecodingDataSizeTooSmallError({
          data,
          params,
          size: size(data)
        });
      const param = params[i4];
      const { consumed, value } = decodeParam({ data, param, position });
      decodedValues.push(value);
      position += consumed;
    }
    return decodedValues;
  }
  function decodeParam({ data, param, position }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length, type] = arrayComponents;
      return decodeArray(data, {
        length,
        param: { ...param, type },
        position
      });
    }
    if (param.type === "tuple") {
      return decodeTuple(data, { param, position });
    }
    if (param.type === "string") {
      return decodeString(data, { position });
    }
    if (param.type.startsWith("bytes")) {
      return decodeBytes(data, { param, position });
    }
    const value = slice(data, position, position + 32, { strict: true });
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      return decodeNumber(value, { param });
    }
    if (param.type === "address") {
      return decodeAddress(value);
    }
    if (param.type === "bool") {
      return decodeBool(value);
    }
    throw new InvalidAbiDecodingTypeError(param.type, {
      docsPath: "/docs/contract/decodeAbiParameters"
    });
  }
  function decodeAddress(value) {
    return { consumed: 32, value: checksumAddress(slice(value, -20)) };
  }
  function decodeArray(data, { param, length, position }) {
    if (!length) {
      const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
      const length2 = hexToNumber(slice(data, offset, offset + 32, { strict: true }));
      let consumed2 = 0;
      const value2 = [];
      for (let i4 = 0; i4 < length2; ++i4) {
        const decodedChild = decodeParam({
          data: slice(data, offset + 32),
          param,
          position: consumed2
        });
        consumed2 += decodedChild.consumed;
        value2.push(decodedChild.value);
      }
      return { value: value2, consumed: 32 };
    }
    if (hasDynamicChild(param)) {
      const arrayComponents = getArrayComponents(param.type);
      const dynamicChild = !arrayComponents?.[0];
      let consumed2 = 0;
      const value2 = [];
      for (let i4 = 0; i4 < length; ++i4) {
        const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
        const decodedChild = decodeParam({
          data: slice(data, offset),
          param,
          position: dynamicChild ? consumed2 : i4 * 32
        });
        consumed2 += decodedChild.consumed;
        value2.push(decodedChild.value);
      }
      return { value: value2, consumed: 32 };
    }
    let consumed = 0;
    const value = [];
    for (let i4 = 0; i4 < length; ++i4) {
      const decodedChild = decodeParam({
        data,
        param,
        position: position + consumed
      });
      consumed += decodedChild.consumed;
      value.push(decodedChild.value);
    }
    return { value, consumed };
  }
  function decodeBool(value) {
    return { consumed: 32, value: hexToBool(value) };
  }
  function decodeBytes(data, { param, position }) {
    const [_18, size3] = param.type.split("bytes");
    if (!size3) {
      const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
      const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }));
      if (length === 0)
        return { consumed: 32, value: "0x" };
      const value2 = slice(data, offset + 32, offset + 32 + length, {
        strict: true
      });
      return { consumed: 32, value: value2 };
    }
    const value = slice(data, position, position + parseInt(size3), {
      strict: true
    });
    return { consumed: 32, value };
  }
  function decodeNumber(value, { param }) {
    const signed = param.type.startsWith("int");
    const size3 = parseInt(param.type.split("int")[1] || "256");
    return {
      consumed: 32,
      value: size3 > 48 ? hexToBigInt(value, { signed }) : hexToNumber(value, { signed })
    };
  }
  function decodeString(data, { position }) {
    const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
    const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }));
    if (length === 0)
      return { consumed: 32, value: "" };
    const value = hexToString(trim(slice(data, offset + 32, offset + 32 + length, { strict: true })));
    return { consumed: 32, value };
  }
  function decodeTuple(data, { param, position }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
      const offset = hexToNumber(slice(data, position, position + 32, { strict: true }));
      for (let i4 = 0; i4 < param.components.length; ++i4) {
        const component = param.components[i4];
        const decodedChild = decodeParam({
          data: slice(data, offset),
          param: component,
          position: consumed
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i4 : component?.name] = decodedChild.value;
      }
      return { consumed: 32, value };
    }
    for (let i4 = 0; i4 < param.components.length; ++i4) {
      const component = param.components[i4];
      const decodedChild = decodeParam({
        data,
        param: component,
        position: position + consumed
      });
      consumed += decodedChild.consumed;
      value[hasUnnamedChild ? i4 : component?.name] = decodedChild.value;
    }
    return { consumed, value };
  }
  function hasDynamicChild(param) {
    const { type } = param;
    if (type === "string")
      return true;
    if (type === "bytes")
      return true;
    if (type.endsWith("[]"))
      return true;
    if (type === "tuple")
      return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
      return true;
    return false;
  }
  var init_decodeAbiParameters = __esm({
    "node_modules/viem/dist/esm/utils/abi/decodeAbiParameters.js"() {
      init_abi();
      init_getAddress();
      init_size();
      init_slice();
      init_trim();
      init_fromHex();
      init_encodeAbiParameters();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/decodeErrorResult.js
  function decodeErrorResult({ abi, data }) {
    const signature = slice(data, 0, 4);
    if (signature === "0x")
      throw new AbiDecodingZeroDataError();
    const abi_ = [...abi || [], solidityError, solidityPanic];
    const abiItem = abi_.find((x8) => x8.type === "error" && signature === getFunctionSelector(formatAbiItem(x8)));
    if (!abiItem)
      throw new AbiErrorSignatureNotFoundError(signature, {
        docsPath: "/docs/contract/decodeErrorResult"
      });
    return {
      abiItem,
      args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : void 0,
      errorName: abiItem.name
    };
  }
  var init_decodeErrorResult = __esm({
    "node_modules/viem/dist/esm/utils/abi/decodeErrorResult.js"() {
      init_solidity();
      init_abi();
      init_slice();
      init_getFunctionSelector();
      init_decodeAbiParameters();
      init_formatAbiItem();
    }
  });

  // node_modules/viem/dist/esm/utils/stringify.js
  var stringify;
  var init_stringify = __esm({
    "node_modules/viem/dist/esm/utils/stringify.js"() {
      stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
        const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
        return typeof replacer === "function" ? replacer(key, value2) : value2;
      }, space);
    }
  });

  // node_modules/viem/dist/esm/utils/abi/formatAbiItemWithArgs.js
  function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
    if (!("name" in abiItem))
      return;
    if (!("inputs" in abiItem))
      return;
    if (!abiItem.inputs)
      return;
    return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i4) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i4] === "object" ? stringify(args[i4]) : args[i4]}`).join(", ")})`;
  }
  var init_formatAbiItemWithArgs = __esm({
    "node_modules/viem/dist/esm/utils/abi/formatAbiItemWithArgs.js"() {
      init_stringify();
    }
  });

  // node_modules/viem/dist/esm/constants/unit.js
  var etherUnits, gweiUnits;
  var init_unit = __esm({
    "node_modules/viem/dist/esm/constants/unit.js"() {
      etherUnits = {
        gwei: 9,
        wei: 18
      };
      gweiUnits = {
        ether: -9,
        wei: 9
      };
    }
  });

  // node_modules/viem/dist/esm/utils/unit/formatUnits.js
  function formatUnits2(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith("-");
    if (negative)
      display = display.slice(1);
    display = display.padStart(decimals, "0");
    let [integer, fraction] = [
      display.slice(0, display.length - decimals),
      display.slice(display.length - decimals)
    ];
    fraction = fraction.replace(/(0+)$/, "");
    return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
  }
  var init_formatUnits = __esm({
    "node_modules/viem/dist/esm/utils/unit/formatUnits.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/unit/formatEther.js
  function formatEther2(wei, unit = "wei") {
    return formatUnits2(wei, etherUnits[unit]);
  }
  var init_formatEther = __esm({
    "node_modules/viem/dist/esm/utils/unit/formatEther.js"() {
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/dist/esm/utils/unit/formatGwei.js
  function formatGwei(wei, unit = "wei") {
    return formatUnits2(wei, gweiUnits[unit]);
  }
  var init_formatGwei = __esm({
    "node_modules/viem/dist/esm/utils/unit/formatGwei.js"() {
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/dist/esm/errors/transaction.js
  function prettyPrint(args) {
    const entries = Object.entries(args).map(([key, value]) => {
      if (value === void 0 || value === false)
        return null;
      return [key, value];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
  }
  var FeeConflictError, InvalidLegacyVError, InvalidSerializableTransactionError, InvalidStorageKeySizeError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;
  var init_transaction = __esm({
    "node_modules/viem/dist/esm/errors/transaction.js"() {
      init_formatEther();
      init_formatGwei();
      init_base();
      FeeConflictError = class extends BaseError {
        constructor() {
          super([
            "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
            "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeConflictError"
          });
        }
      };
      InvalidLegacyVError = class extends BaseError {
        constructor({ v: v7 }) {
          super(`Invalid \`v\` value "${v7}". Expected 27 or 28.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidLegacyVError"
          });
        }
      };
      InvalidSerializableTransactionError = class extends BaseError {
        constructor({ transaction: transaction2 }) {
          super("Cannot infer a transaction type from provided transaction.", {
            metaMessages: [
              "Provided Transaction:",
              "{",
              prettyPrint(transaction2),
              "}",
              "",
              "To infer the type, either provide:",
              "- a `type` to the Transaction, or",
              "- an EIP-1559 Transaction with `maxFeePerGas`, or",
              "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
              "- a Legacy Transaction with `gasPrice`"
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidSerializableTransactionError"
          });
        }
      };
      InvalidStorageKeySizeError = class extends BaseError {
        constructor({ storageKey }) {
          super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidStorageKeySizeError"
          });
        }
      };
      TransactionExecutionError = class extends BaseError {
        constructor(cause, { account, docsPath: docsPath4, chain: chain2, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
          const prettyArgs = prettyPrint({
            chain: chain2 && `${chain2?.name} (id: ${chain2?.id})`,
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${formatEther2(value)} ${chain2?.nativeCurrency.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath4,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Request Arguments:",
              prettyArgs
            ].filter(Boolean)
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionExecutionError"
          });
          this.cause = cause;
        }
      };
      TransactionNotFoundError = class extends BaseError {
        constructor({ blockHash, blockNumber, blockTag, hash: hash3, index: index2 }) {
          let identifier = "Transaction";
          if (blockTag && index2 !== void 0)
            identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
          if (blockHash && index2 !== void 0)
            identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
          if (blockNumber && index2 !== void 0)
            identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
          if (hash3)
            identifier = `Transaction with hash "${hash3}"`;
          super(`${identifier} could not be found.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionNotFoundError"
          });
        }
      };
      TransactionReceiptNotFoundError = class extends BaseError {
        constructor({ hash: hash3 }) {
          super(`Transaction receipt with hash "${hash3}" could not be found. The Transaction may not be processed on a block yet.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionReceiptNotFoundError"
          });
        }
      };
      WaitForTransactionReceiptTimeoutError = class extends BaseError {
        constructor({ hash: hash3 }) {
          super(`Timed out while waiting for transaction with hash "${hash3}" to be confirmed.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "WaitForTransactionReceiptTimeoutError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/errors/contract.js
  var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, RawContractError;
  var init_contract = __esm({
    "node_modules/viem/dist/esm/errors/contract.js"() {
      init_parseAccount();
      init_solidity();
      init_decodeErrorResult();
      init_formatAbiItem();
      init_formatAbiItemWithArgs();
      init_getAbiItem();
      init_formatEther();
      init_formatGwei();
      init_base();
      init_transaction();
      init_utils();
      CallExecutionError = class extends BaseError {
        constructor(cause, { account: account_, docsPath: docsPath4, chain: chain2, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
          const account = account_ ? parseAccount(account_) : void 0;
          const prettyArgs = prettyPrint({
            from: account?.address,
            to,
            value: typeof value !== "undefined" && `${formatEther2(value)} ${chain2?.nativeCurrency.symbol || "ETH"}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath4,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Raw Call Arguments:",
              prettyArgs
            ].filter(Boolean)
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "CallExecutionError"
          });
          this.cause = cause;
        }
      };
      ContractFunctionExecutionError = class extends BaseError {
        constructor(cause, { abi, args, contractAddress, docsPath: docsPath4, functionName, sender }) {
          const abiItem = getAbiItem({ abi, args, name: functionName });
          const formattedArgs = abiItem ? formatAbiItemWithArgs({
            abiItem,
            args,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          const functionWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
          const prettyArgs = prettyPrint({
            address: contractAddress && getContractAddress4(contractAddress),
            function: functionWithParams,
            args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
            sender
          });
          super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath: docsPath4,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Contract Call:",
              prettyArgs
            ].filter(Boolean)
          });
          Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "contractAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "formattedArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionExecutionError"
          });
          this.abi = abi;
          this.args = args;
          this.cause = cause;
          this.contractAddress = contractAddress;
          this.functionName = functionName;
          this.sender = sender;
        }
      };
      ContractFunctionRevertedError = class extends BaseError {
        constructor({ abi, data, functionName, message }) {
          let decodedData = void 0;
          let metaMessages;
          let reason;
          if (data && data !== "0x") {
            decodedData = decodeErrorResult({ abi, data });
            const { abiItem, errorName, args: errorArgs } = decodedData;
            if (errorName === "Error") {
              reason = errorArgs[0];
            } else if (errorName === "Panic") {
              const [firstArg] = errorArgs;
              reason = panicReasons[firstArg];
            } else {
              const errorWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
              const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
                abiItem,
                args: errorArgs,
                includeFunctionName: false,
                includeName: false
              }) : void 0;
              metaMessages = [
                errorWithParams ? `Error: ${errorWithParams}` : "",
                formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
              ];
            }
          } else if (message)
            reason = message;
          super(reason && reason !== "execution reverted" ? [
            `The contract function "${functionName}" reverted with the following reason:`,
            reason
          ].join("\n") : `The contract function "${functionName}" reverted.`, {
            metaMessages
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionRevertedError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.reason = reason;
          this.data = decodedData;
        }
      };
      ContractFunctionZeroDataError = class extends BaseError {
        constructor({ functionName }) {
          super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
              "This could be due to any of the following:",
              `  - The contract does not have the function "${functionName}",`,
              "  - The parameters passed to the contract function may be invalid, or",
              "  - The address is not a contract."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionZeroDataError"
          });
        }
      };
      RawContractError = class extends BaseError {
        constructor({ data, message }) {
          super(message || "");
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RawContractError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data;
        }
      };
    }
  });

  // node_modules/viem/dist/esm/errors/node.js
  var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
  var init_node = __esm({
    "node_modules/viem/dist/esm/errors/node.js"() {
      init_formatGwei();
      init_base();
      ExecutionRevertedError = class extends BaseError {
        constructor({ cause, message } = {}) {
          const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
          super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ExecutionRevertedError"
          });
        }
      };
      Object.defineProperty(ExecutionRevertedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /execution reverted/
      });
      FeeCapTooHighError = class extends BaseError {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeCapTooHigh"
          });
        }
      };
      Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
      });
      FeeCapTooLowError = class extends BaseError {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeCapTooLow"
          });
        }
      };
      Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
      });
      NonceTooHighError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceTooHighError"
          });
        }
      };
      Object.defineProperty(NonceTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too high/
      });
      NonceTooLowError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
            "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
          ].join("\n"), { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceTooLowError"
          });
        }
      };
      Object.defineProperty(NonceTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too low|transaction already imported/
      });
      NonceMaxValueError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceMaxValueError"
          });
        }
      };
      Object.defineProperty(NonceMaxValueError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce has max value/
      });
      InsufficientFundsError = class extends BaseError {
        constructor({ cause } = {}) {
          super([
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
          ].join("\n"), {
            cause,
            metaMessages: [
              "This error could arise when the account does not have enough funds to:",
              " - pay for the total gas fee,",
              " - pay for the value to send.",
              " ",
              "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
              " - `gas` is the amount of gas needed for transaction to execute,",
              " - `gas fee` is the gas fee,",
              " - `value` is the amount of ether to send to the recipient."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InsufficientFundsError"
          });
        }
      };
      Object.defineProperty(InsufficientFundsError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /insufficient funds/
      });
      IntrinsicGasTooHighError = class extends BaseError {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntrinsicGasTooHighError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too high|gas limit reached/
      });
      IntrinsicGasTooLowError = class extends BaseError {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntrinsicGasTooLowError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too low/
      });
      TransactionTypeNotSupportedError = class extends BaseError {
        constructor({ cause }) {
          super("The transaction type is not supported for this chain.", {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionTypeNotSupportedError"
          });
        }
      };
      Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /transaction type not valid/
      });
      TipAboveFeeCapError = class extends BaseError {
        constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
          super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
          ].join("\n"), {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TipAboveFeeCapError"
          });
        }
      };
      Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
      });
      UnknownNodeError = class extends BaseError {
        constructor({ cause }) {
          super(`An error occurred while executing: ${cause?.message}`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownNodeError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/errors/request.js
  var HttpRequestError, WebSocketRequestError, RpcRequestError, TimeoutError;
  var init_request = __esm({
    "node_modules/viem/dist/esm/errors/request.js"() {
      init_stringify();
      init_base();
      init_utils();
      HttpRequestError = class extends BaseError {
        constructor({ body, details, headers, status, url }) {
          super("HTTP request failed.", {
            details,
            metaMessages: [
              status && `Status: ${status}`,
              `URL: ${getUrl(url)}`,
              body && `Request body: ${stringify(body)}`
            ].filter(Boolean)
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "HttpRequestError"
          });
          Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.body = body;
          this.headers = headers;
          this.status = status;
          this.url = url;
        }
      };
      WebSocketRequestError = class extends BaseError {
        constructor({ body, details, url }) {
          super("WebSocket request failed.", {
            details,
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "WebSocketRequestError"
          });
        }
      };
      RpcRequestError = class extends BaseError {
        constructor({ body, error, url }) {
          super("RPC Request failed.", {
            cause: error,
            details: error.message,
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RpcRequestError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.code = error.code;
        }
      };
      TimeoutError = class extends BaseError {
        constructor({ body, url }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TimeoutError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/errors/rpc.js
  var unknownErrorCode, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnknownRpcError;
  var init_rpc = __esm({
    "node_modules/viem/dist/esm/errors/rpc.js"() {
      init_base();
      init_request();
      unknownErrorCode = -1;
      RpcError = class extends BaseError {
        constructor(cause, { code, docsPath: docsPath4, metaMessages, shortMessage }) {
          super(shortMessage, {
            cause,
            docsPath: docsPath4,
            metaMessages: metaMessages || cause?.metaMessages
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RpcError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.name = cause.name;
          this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
        }
      };
      ProviderRpcError = class extends RpcError {
        constructor(cause, options) {
          super(cause, options);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ProviderRpcError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = options.data;
        }
      };
      ParseRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32700,
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ParseRpcError"
          });
        }
      };
      InvalidRequestRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32600,
            shortMessage: "JSON is not a valid request object."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidRequestRpcError"
          });
        }
      };
      MethodNotFoundRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32601,
            shortMessage: "The method does not exist / is not available."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MethodNotFoundRpcError"
          });
        }
      };
      InvalidParamsRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32602,
            shortMessage: [
              "Invalid parameters were provided to the RPC method.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParamsRpcError"
          });
        }
      };
      InternalRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32603,
            shortMessage: "An internal error was received."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InternalRpcError"
          });
        }
      };
      InvalidInputRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32e3,
            shortMessage: [
              "Missing or invalid parameters.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidInputRpcError"
          });
        }
      };
      ResourceNotFoundRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32001,
            shortMessage: "Requested resource not found."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceNotFoundRpcError"
          });
        }
      };
      ResourceUnavailableRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32002,
            shortMessage: "Requested resource not available."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceUnavailableRpcError"
          });
        }
      };
      TransactionRejectedRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, { code: -32003, shortMessage: "Transaction creation failed." });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionRejectedRpcError"
          });
        }
      };
      MethodNotSupportedRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, { code: -32004, shortMessage: "Method is not implemented." });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MethodNotSupportedRpcError"
          });
        }
      };
      LimitExceededRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32005,
            shortMessage: "Request exceeds defined limit."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "LimitExceededRpcError"
          });
        }
      };
      JsonRpcVersionUnsupportedError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32006,
            shortMessage: "Version of JSON-RPC protocol is not supported."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "JsonRpcVersionUnsupportedError"
          });
        }
      };
      UserRejectedRequestError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4001,
            shortMessage: "User rejected the request."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UserRejectedRequestError"
          });
        }
      };
      UnauthorizedProviderError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4100,
            shortMessage: "The requested method and/or account has not been authorized by the user."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnauthorizedProviderError"
          });
        }
      };
      UnsupportedProviderMethodError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4200,
            shortMessage: "The Provider does not support the requested method."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnsupportedProviderMethodError"
          });
        }
      };
      ProviderDisconnectedError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4900,
            shortMessage: "The Provider is disconnected from all chains."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ProviderDisconnectedError"
          });
        }
      };
      ChainDisconnectedError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4901,
            shortMessage: "The Provider is not connected to the requested chain."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainDisconnectedError"
          });
        }
      };
      SwitchChainError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4902,
            shortMessage: "An error occurred when attempting to switch chain."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SwitchChainError"
          });
        }
      };
      UnknownRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            shortMessage: "An unknown RPC error occurred."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownRpcError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/errors/getNodeError.js
  function containsNodeError(err) {
    return err instanceof TransactionRejectedRpcError || err instanceof InvalidInputRpcError || err instanceof RpcRequestError && err.code === ExecutionRevertedError.code;
  }
  function getNodeError(err, args) {
    const message = err.details.toLowerCase();
    if (FeeCapTooHighError.nodeMessage.test(message))
      return new FeeCapTooHighError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    else if (FeeCapTooLowError.nodeMessage.test(message))
      return new FeeCapTooLowError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    else if (NonceTooHighError.nodeMessage.test(message))
      return new NonceTooHighError({ cause: err, nonce: args?.nonce });
    else if (NonceTooLowError.nodeMessage.test(message))
      return new NonceTooLowError({ cause: err, nonce: args?.nonce });
    else if (NonceMaxValueError.nodeMessage.test(message))
      return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
    else if (InsufficientFundsError.nodeMessage.test(message))
      return new InsufficientFundsError({ cause: err });
    else if (IntrinsicGasTooHighError.nodeMessage.test(message))
      return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
    else if (IntrinsicGasTooLowError.nodeMessage.test(message))
      return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
    else if (TransactionTypeNotSupportedError.nodeMessage.test(message))
      return new TransactionTypeNotSupportedError({ cause: err });
    else if (TipAboveFeeCapError.nodeMessage.test(message))
      return new TipAboveFeeCapError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas,
        maxPriorityFeePerGas: args?.maxPriorityFeePerGas
      });
    else if (message.match(ExecutionRevertedError.nodeMessage) || "code" in err.cause && err.cause?.code === ExecutionRevertedError.code)
      return new ExecutionRevertedError({
        cause: err,
        message: err.cause.details || err.details
      });
    return new UnknownNodeError({
      cause: err.cause.cause
    });
  }
  var init_getNodeError = __esm({
    "node_modules/viem/dist/esm/utils/errors/getNodeError.js"() {
      init_node();
      init_request();
      init_rpc();
    }
  });

  // node_modules/viem/dist/esm/utils/formatters/extract.js
  function extract(value, { formatter }) {
    if (!formatter)
      return {};
    const keys = Object.keys(formatter({}));
    return keys.reduce((data, key) => {
      if (value?.hasOwnProperty(key)) {
        ;
        data[key] = value[key];
      }
      return data;
    }, {});
  }
  var init_extract = __esm({
    "node_modules/viem/dist/esm/utils/formatters/extract.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/formatters/format.js
  function format(data, { formatter }) {
    return formatter(data);
  }
  function defineFormatter({ format: format3 }) {
    return ({ exclude, format: formatOverride }) => (data) => {
      const formatted = format3(data);
      if (exclude) {
        for (const key of exclude) {
          delete formatted[key];
        }
      }
      return {
        ...formatted,
        ...formatOverride?.(data)
      };
    };
  }
  var init_format = __esm({
    "node_modules/viem/dist/esm/utils/formatters/format.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/formatters/transactionRequest.js
  function formatTransactionRequest(transactionRequest) {
    return {
      ...transactionRequest,
      gas: typeof transactionRequest.gas !== "undefined" ? numberToHex(transactionRequest.gas) : void 0,
      gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? numberToHex(transactionRequest.gasPrice) : void 0,
      maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxPriorityFeePerGas) : void 0,
      nonce: typeof transactionRequest.nonce !== "undefined" ? numberToHex(transactionRequest.nonce) : void 0,
      value: typeof transactionRequest.value !== "undefined" ? numberToHex(transactionRequest.value) : void 0
    };
  }
  var defineTransactionRequest;
  var init_transactionRequest = __esm({
    "node_modules/viem/dist/esm/utils/formatters/transactionRequest.js"() {
      init_toHex();
      init_format();
      defineTransactionRequest = defineFormatter({
        format: formatTransactionRequest
      });
    }
  });

  // node_modules/viem/dist/esm/utils/transaction/assertRequest.js
  function assertRequest(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    if (account && !isAddress2(account.address))
      throw new InvalidAddressError({ address: account.address });
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
    if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
      throw new FeeConflictError();
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  var init_assertRequest = __esm({
    "node_modules/viem/dist/esm/utils/transaction/assertRequest.js"() {
      init_parseAccount();
      init_address();
      init_node();
      init_transaction();
      init_isAddress();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/decodeFunctionResult.js
  function decodeFunctionResult({ abi, args, functionName, data }) {
    let abiItem = abi[0];
    if (functionName) {
      abiItem = getAbiItem({
        abi,
        args,
        name: functionName
      });
      if (!abiItem)
        throw new AbiFunctionNotFoundError(functionName, { docsPath });
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, { docsPath });
    if (!abiItem.outputs)
      throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
    const values = decodeAbiParameters(abiItem.outputs, data);
    if (values && values.length > 1)
      return values;
    if (values && values.length === 1)
      return values[0];
    return void 0;
  }
  var docsPath;
  var init_decodeFunctionResult = __esm({
    "node_modules/viem/dist/esm/utils/abi/decodeFunctionResult.js"() {
      init_abi();
      init_decodeAbiParameters();
      init_getAbiItem();
      docsPath = "/docs/contract/decodeFunctionResult";
    }
  });

  // node_modules/viem/dist/esm/constants/abis.js
  var multicall3Abi, universalResolverAbi, textResolverAbi, singleAddressResolverAbi, universalSignatureValidatorAbi;
  var init_abis = __esm({
    "node_modules/viem/dist/esm/constants/abis.js"() {
      multicall3Abi = [
        {
          inputs: [
            {
              components: [
                {
                  name: "target",
                  type: "address"
                },
                {
                  name: "allowFailure",
                  type: "bool"
                },
                {
                  name: "callData",
                  type: "bytes"
                }
              ],
              name: "calls",
              type: "tuple[]"
            }
          ],
          name: "aggregate3",
          outputs: [
            {
              components: [
                {
                  name: "success",
                  type: "bool"
                },
                {
                  name: "returnData",
                  type: "bytes"
                }
              ],
              name: "returnData",
              type: "tuple[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ];
      universalResolverAbi = [
        {
          name: "resolve",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes" },
            { name: "data", type: "bytes" }
          ],
          outputs: [
            { name: "", type: "bytes" },
            { name: "address", type: "address" }
          ]
        }
      ];
      textResolverAbi = [
        {
          name: "text",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes32" },
            { name: "key", type: "string" }
          ],
          outputs: [{ name: "", type: "string" }]
        }
      ];
      singleAddressResolverAbi = [
        {
          name: "addr",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "name", type: "bytes32" }],
          outputs: [{ name: "", type: "address" }]
        }
      ];
      universalSignatureValidatorAbi = [
        {
          inputs: [
            {
              internalType: "address",
              name: "_signer",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "_hash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "constructor"
        }
      ];
    }
  });

  // node_modules/viem/dist/esm/constants/contract.js
  var aggregate3Signature;
  var init_contract2 = __esm({
    "node_modules/viem/dist/esm/constants/contract.js"() {
      aggregate3Signature = "0x82ad56cb";
    }
  });

  // node_modules/viem/dist/esm/errors/chain.js
  var ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError, InvalidChainIdError;
  var init_chain = __esm({
    "node_modules/viem/dist/esm/errors/chain.js"() {
      init_base();
      ChainDoesNotSupportContract = class extends BaseError {
        constructor({ blockNumber, chain: chain2, contract }) {
          super(`Chain "${chain2.name}" does not support contract "${contract.name}".`, {
            metaMessages: [
              "This could be due to any of the following:",
              ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
                `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
              ] : [
                `- The chain does not have the contract "${contract.name}" configured.`
              ]
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainDoesNotSupportContract"
          });
        }
      };
      ChainMismatchError = class extends BaseError {
        constructor({ chain: chain2, currentChainId }) {
          super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain2.id} \u2013 ${chain2.name}).`, {
            metaMessages: [
              `Current Chain ID:  ${currentChainId}`,
              `Expected Chain ID: ${chain2.id} \u2013 ${chain2.name}`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainMismatchError"
          });
        }
      };
      ChainNotFoundError = class extends BaseError {
        constructor() {
          super([
            "No chain was provided to the request.",
            "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainNotFoundError"
          });
        }
      };
      ClientChainNotConfiguredError = class extends BaseError {
        constructor() {
          super("No chain was provided to the Client.");
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ClientChainNotConfiguredError"
          });
        }
      };
      InvalidChainIdError = class extends BaseError {
        constructor({ chainId }) {
          super(`Chain ID "${chainId}" is invalid.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidChainIdError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/chain.js
  function assertCurrentChain({ chain: chain2, currentChainId }) {
    if (!chain2)
      throw new ChainNotFoundError();
    if (currentChainId !== chain2.id)
      throw new ChainMismatchError({ chain: chain2, currentChainId });
  }
  function getChainContractAddress({ blockNumber, chain: chain2, contract: name }) {
    const contract = chain2?.contracts?.[name];
    if (!contract)
      throw new ChainDoesNotSupportContract({
        chain: chain2,
        contract: { name }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new ChainDoesNotSupportContract({
        blockNumber,
        chain: chain2,
        contract: {
          name,
          blockCreated: contract.blockCreated
        }
      });
    return contract.address;
  }
  var init_chain2 = __esm({
    "node_modules/viem/dist/esm/utils/chain.js"() {
      init_chain();
    }
  });

  // node_modules/viem/dist/esm/utils/errors/getCallError.js
  function getCallError(err, { docsPath: docsPath4, ...args }) {
    let cause = err;
    if (containsNodeError(err))
      cause = getNodeError(err, args);
    return new CallExecutionError(cause, {
      docsPath: docsPath4,
      ...args
    });
  }
  var init_getCallError = __esm({
    "node_modules/viem/dist/esm/utils/errors/getCallError.js"() {
      init_contract();
      init_getNodeError();
    }
  });

  // node_modules/viem/dist/esm/utils/promise/createBatchScheduler.js
  function createBatchScheduler({ fn, id: id3, shouldSplitBatch, wait: wait2 = 0 }) {
    const exec = async () => {
      const scheduler = getScheduler();
      flush();
      const args = scheduler.map(({ args: args2 }) => args2);
      if (args.length === 0)
        return;
      fn(args).then((data) => {
        scheduler.forEach(({ pendingPromise }, i4) => pendingPromise.resolve?.([data[i4], data]));
      }).catch((err) => {
        scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err));
      });
    };
    const flush = () => schedulerCache.delete(id3);
    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
    const getScheduler = () => schedulerCache.get(id3) || [];
    const setScheduler = (item) => schedulerCache.set(id3, [...getScheduler(), item]);
    return {
      flush,
      async schedule(args) {
        const pendingPromise = {};
        const promise = new Promise((resolve, reject) => {
          pendingPromise.resolve = resolve;
          pendingPromise.reject = reject;
        });
        const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
        if (split2)
          exec();
        const hasActiveScheduler = getScheduler().length > 0;
        if (hasActiveScheduler) {
          setScheduler({ args, pendingPromise });
          return promise;
        }
        setScheduler({ args, pendingPromise });
        setTimeout(exec, wait2);
        return promise;
      }
    };
  }
  var schedulerCache;
  var init_createBatchScheduler = __esm({
    "node_modules/viem/dist/esm/utils/promise/createBatchScheduler.js"() {
      schedulerCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/viem/dist/esm/errors/ccip.js
  var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
  var init_ccip = __esm({
    "node_modules/viem/dist/esm/errors/ccip.js"() {
      init_stringify();
      init_base();
      init_utils();
      OffchainLookupError = class extends BaseError {
        constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
          super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
            cause,
            metaMessages: [
              ...cause.metaMessages || [],
              cause.metaMessages?.length ? "" : [],
              "Offchain Gateway Call:",
              urls && [
                "  Gateway URL(s):",
                ...urls.map((url) => `    ${getUrl(url)}`)
              ],
              `  Sender: ${sender}`,
              `  Data: ${data}`,
              `  Callback selector: ${callbackSelector}`,
              `  Extra data: ${extraData}`
            ].flat()
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "OffchainLookupError"
          });
        }
      };
      OffchainLookupResponseMalformedError = class extends BaseError {
        constructor({ result, url }) {
          super("Offchain gateway response is malformed. Response data must be a hex value.", {
            metaMessages: [
              `Gateway URL: ${getUrl(url)}`,
              `Response: ${stringify(result)}`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "OffchainLookupResponseMalformedError"
          });
        }
      };
      OffchainLookupSenderMismatchError = class extends BaseError {
        constructor({ sender, to }) {
          super("Reverted sender address does not match target contract address (`to`).", {
            metaMessages: [
              `Contract address: ${to}`,
              `OffchainLookup sender address: ${sender}`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "OffchainLookupSenderMismatchError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/address/isAddressEqual.js
  function isAddressEqual(a2, b4) {
    if (!isAddress2(a2))
      throw new InvalidAddressError({ address: a2 });
    if (!isAddress2(b4))
      throw new InvalidAddressError({ address: b4 });
    return a2.toLowerCase() === b4.toLowerCase();
  }
  var init_isAddressEqual = __esm({
    "node_modules/viem/dist/esm/utils/address/isAddressEqual.js"() {
      init_address();
      init_isAddress();
    }
  });

  // node_modules/viem/dist/esm/utils/ccip.js
  var ccip_exports = {};
  __export(ccip_exports, {
    ccipFetch: () => ccipFetch,
    offchainLookup: () => offchainLookup,
    offchainLookupAbiItem: () => offchainLookupAbiItem,
    offchainLookupSignature: () => offchainLookupSignature
  });
  async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
    const { args } = decodeErrorResult({
      data,
      abi: [offchainLookupAbiItem]
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    try {
      if (!isAddressEqual(to, sender))
        throw new OffchainLookupSenderMismatchError({ sender, to });
      const result = await ccipFetch({ data: callData, sender, urls });
      const { data: data_ } = await call(client, {
        blockNumber,
        blockTag,
        data: concat5([
          callbackSelector,
          encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
        ]),
        to
      });
      return data_;
    } catch (err) {
      throw new OffchainLookupError({
        callbackSelector,
        cause: err,
        data,
        extraData,
        sender,
        urls
      });
    }
  }
  async function ccipFetch({ data, sender, urls }) {
    let error = new Error("An unknown error occurred.");
    for (let i4 = 0; i4 < urls.length; i4++) {
      const url = urls[i4];
      const method = url.includes("{sender}") || url.includes("{data}") ? "GET" : "POST";
      const body = method === "POST" ? { data, sender } : void 0;
      try {
        const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
          body: JSON.stringify(body),
          method
        });
        let result;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          result = (await response.json()).data;
        } else {
          result = await response.text();
        }
        if (!response.ok) {
          error = new HttpRequestError({
            body,
            details: stringify(result.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
          continue;
        }
        if (!isHex(result)) {
          error = new OffchainLookupResponseMalformedError({
            result,
            url
          });
          continue;
        }
        return result;
      } catch (err) {
        error = new HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    throw error;
  }
  var offchainLookupSignature, offchainLookupAbiItem;
  var init_ccip2 = __esm({
    "node_modules/viem/dist/esm/utils/ccip.js"() {
      init_call();
      init_base();
      init_ccip();
      init_request();
      init_decodeErrorResult();
      init_encodeAbiParameters();
      init_isAddressEqual();
      init_concat();
      init_isHex();
      init_stringify();
      offchainLookupSignature = "0x556f1830";
      offchainLookupAbiItem = {
        name: "OffchainLookup",
        type: "error",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "urls",
            type: "string[]"
          },
          {
            name: "callData",
            type: "bytes"
          },
          {
            name: "callbackFunction",
            type: "bytes4"
          },
          {
            name: "extraData",
            type: "bytes"
          }
        ]
      };
    }
  });

  // node_modules/viem/dist/esm/actions/public/call.js
  async function call(client, args) {
    const { account: account_, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    try {
      assertRequest(args);
      const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const formatter = client.chain?.formatters?.transactionRequest;
      const request = format({
        from: account?.address,
        accessList,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...extract(rest, { formatter })
      }, {
        formatter: formatter || formatTransactionRequest
      });
      if (batch && shouldPerformMulticall({ request })) {
        try {
          return await scheduleMulticall(client, {
            ...request,
            blockNumber,
            blockTag
          });
        } catch (err) {
          if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
            throw err;
        }
      }
      const response = await client.request({
        method: "eth_call",
        params: block ? [request, block] : [request]
      });
      if (response === "0x")
        return { data: void 0 };
      return { data: response };
    } catch (err) {
      const data2 = getRevertErrorData(err);
      const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), ccip_exports));
      if (data2?.slice(0, 10) === offchainLookupSignature2 && to) {
        return { data: await offchainLookup2(client, { data: data2, to }) };
      }
      throw getCallError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  function shouldPerformMulticall({ request }) {
    const { data, to, ...request_ } = request;
    if (!data)
      return false;
    if (data.startsWith(aggregate3Signature))
      return false;
    if (!to)
      return false;
    if (Object.values(request_).filter((x8) => typeof x8 !== "undefined").length > 0)
      return false;
    return true;
  }
  async function scheduleMulticall(client, args) {
    const { batchSize = 1024, wait: wait2 = 0 } = typeof client.batch?.multicall === "object" ? client.batch?.multicall : {};
    const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new ClientChainNotConfiguredError();
      multicallAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const { schedule } = createBatchScheduler({
      id: `${client.uid}.${block}`,
      wait: wait2,
      shouldSplitBatch(args2) {
        const size3 = args2.reduce((size4, { data: data2 }) => size4 + (data2.length - 2), 0);
        return size3 > batchSize * 2;
      },
      fn: async (requests) => {
        const calls = requests.map((request) => ({
          allowFailure: true,
          callData: request.data,
          target: request.to
        }));
        const calldata = encodeFunctionData({
          abi: multicall3Abi,
          args: [calls],
          functionName: "aggregate3"
        });
        const data2 = await client.request({
          method: "eth_call",
          params: [
            {
              data: calldata,
              to: multicallAddress
            },
            block
          ]
        });
        return decodeFunctionResult({
          abi: multicall3Abi,
          args: [calls],
          functionName: "aggregate3",
          data: data2 || "0x"
        });
      }
    });
    const [{ returnData, success }] = await schedule({ data, to });
    if (!success)
      throw new RawContractError({ data: returnData });
    if (returnData === "0x")
      return { data: void 0 };
    return { data: returnData };
  }
  function getRevertErrorData(err) {
    if (!(err instanceof BaseError))
      return void 0;
    const error = err.walk();
    return typeof error.data === "object" ? error.data.data : error.data;
  }
  var init_call = __esm({
    "node_modules/viem/dist/esm/actions/public/call.js"() {
      init_parseAccount();
      init_abis();
      init_contract2();
      init_base();
      init_chain();
      init_contract();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_chain2();
      init_toHex();
      init_getCallError();
      init_extract();
      init_format();
      init_transactionRequest();
      init_createBatchScheduler();
      init_assertRequest();
    }
  });

  // node_modules/isomorphic-ws/browser.js
  var browser_exports = {};
  __export(browser_exports, {
    default: () => browser_default
  });
  var ws, browser_default;
  var init_browser = __esm({
    "node_modules/isomorphic-ws/browser.js"() {
      ws = null;
      if (typeof WebSocket !== "undefined") {
        ws = WebSocket;
      } else if (typeof MozWebSocket !== "undefined") {
        ws = MozWebSocket;
      } else if (typeof global !== "undefined") {
        ws = global.WebSocket || global.MozWebSocket;
      } else if (typeof window !== "undefined") {
        ws = window.WebSocket || window.MozWebSocket;
      } else if (typeof self !== "undefined") {
        ws = self.WebSocket || self.MozWebSocket;
      }
      browser_default = ws;
    }
  });

  // node_modules/@noble/curves/esm/abstract/utils.js
  var utils_exports2 = {};
  __export(utils_exports2, {
    bitGet: () => bitGet,
    bitLen: () => bitLen,
    bitMask: () => bitMask,
    bitSet: () => bitSet,
    bytesToHex: () => bytesToHex2,
    bytesToNumberBE: () => bytesToNumberBE,
    bytesToNumberLE: () => bytesToNumberLE,
    concatBytes: () => concatBytes3,
    createHmacDrbg: () => createHmacDrbg,
    ensureBytes: () => ensureBytes,
    equalBytes: () => equalBytes,
    hexToBytes: () => hexToBytes2,
    hexToNumber: () => hexToNumber2,
    numberToBytesBE: () => numberToBytesBE,
    numberToBytesLE: () => numberToBytesLE,
    numberToHexUnpadded: () => numberToHexUnpadded,
    numberToVarBytesBE: () => numberToVarBytesBE,
    utf8ToBytes: () => utf8ToBytes2,
    validateObject: () => validateObject
  });
  function bytesToHex2(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    let hex2 = "";
    for (let i4 = 0; i4 < bytes2.length; i4++) {
      hex2 += hexes3[bytes2[i4]];
    }
    return hex2;
  }
  function numberToHexUnpadded(num) {
    const hex2 = num.toString(16);
    return hex2.length & 1 ? `0${hex2}` : hex2;
  }
  function hexToNumber2(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
  }
  function hexToBytes2(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    if (hex2.length % 2)
      throw new Error("hex string is invalid: unpadded " + hex2.length);
    const array2 = new Uint8Array(hex2.length / 2);
    for (let i4 = 0; i4 < array2.length; i4++) {
      const j3 = i4 * 2;
      const hexByte = hex2.slice(j3, j3 + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("invalid byte sequence");
      array2[i4] = byte;
    }
    return array2;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber2(bytesToHex2(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber2(bytesToHex2(Uint8Array.from(bytes2).reverse()));
  }
  function ensureBytes(title, hex2, expectedLength) {
    let res;
    if (typeof hex2 === "string") {
      try {
        res = hexToBytes2(hex2);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e}`);
      }
    } else if (u8a(hex2)) {
      res = Uint8Array.from(hex2);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes3(...arrs) {
    const r2 = new Uint8Array(arrs.reduce((sum, a2) => sum + a2.length, 0));
    let pad2 = 0;
    arrs.forEach((a2) => {
      if (!u8a(a2))
        throw new Error("Uint8Array expected");
      r2.set(a2, pad2);
      pad2 += a2.length;
    });
    return r2;
  }
  function equalBytes(b1, b22) {
    if (b1.length !== b22.length)
      return false;
    for (let i4 = 0; i4 < b1.length; i4++)
      if (b1[i4] !== b22[i4])
        return false;
    return true;
  }
  function utf8ToBytes2(str) {
    if (typeof str !== "string") {
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
  }
  function bitLen(n4) {
    let len;
    for (len = 0; n4 > _0n2; n4 >>= _1n2, len += 1)
      ;
    return len;
  }
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v7 = u8n(hashLen);
    let k3 = u8n(hashLen);
    let i4 = 0;
    const reset2 = () => {
      v7.fill(1);
      k3.fill(0);
      i4 = 0;
    };
    const h6 = (...b4) => hmacFn(k3, v7, ...b4);
    const reseed = (seed = u8n()) => {
      k3 = h6(u8fr([0]), seed);
      v7 = h6();
      if (seed.length === 0)
        return;
      k3 = h6(u8fr([1]), seed);
      v7 = h6();
    };
    const gen2 = () => {
      if (i4++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v7 = h6();
        const sl = v7.slice();
        out.push(sl);
        len += v7.length;
      }
      return concatBytes3(...out);
    };
    const genUntil = (seed, pred) => {
      reset2();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset2();
      return res;
    };
    return genUntil;
  }
  function validateObject(object2, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object2[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object2)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object2;
  }
  var _0n2, _1n2, _2n2, u8a, hexes3, numberToBytesBE, numberToBytesLE, numberToVarBytesBE, bitGet, bitSet, bitMask, u8n, u8fr, validatorFns;
  var init_utils3 = __esm({
    "node_modules/@noble/curves/esm/abstract/utils.js"() {
      _0n2 = BigInt(0);
      _1n2 = BigInt(1);
      _2n2 = BigInt(2);
      u8a = (a2) => a2 instanceof Uint8Array;
      hexes3 = Array.from({ length: 256 }, (v7, i4) => i4.toString(16).padStart(2, "0"));
      numberToBytesBE = (n4, len) => hexToBytes2(n4.toString(16).padStart(len * 2, "0"));
      numberToBytesLE = (n4, len) => numberToBytesBE(n4, len).reverse();
      numberToVarBytesBE = (n4) => hexToBytes2(numberToHexUnpadded(n4));
      bitGet = (n4, pos) => n4 >> BigInt(pos) & _1n2;
      bitSet = (n4, pos, value) => n4 | (value ? _1n2 : _0n2) << BigInt(pos);
      bitMask = (n4) => (_2n2 << BigInt(n4 - 1)) - _1n2;
      u8n = (data) => new Uint8Array(data);
      u8fr = (arr) => Uint8Array.from(arr);
      validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object2) => object2.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
    }
  });

  // node_modules/@protobufjs/aspromise/index.js
  var require_aspromise = __commonJS({
    "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
      "use strict";
      module2.exports = asPromise;
      function asPromise(fn, ctx) {
        var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
        while (index2 < arguments.length)
          params[offset++] = arguments[index2++];
        return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err) {
            if (pending) {
              pending = false;
              if (err)
                reject(err);
              else {
                var params2 = new Array(arguments.length - 1), offset2 = 0;
                while (offset2 < params2.length)
                  params2[offset2++] = arguments[offset2];
                resolve.apply(null, params2);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }
    }
  });

  // node_modules/@protobufjs/base64/index.js
  var require_base64 = __commonJS({
    "node_modules/@protobufjs/base64/index.js"(exports2) {
      "use strict";
      var base643 = exports2;
      base643.length = function length(string) {
        var p2 = string.length;
        if (!p2)
          return 0;
        var n4 = 0;
        while (--p2 % 4 > 1 && string.charAt(p2) === "=")
          ++n4;
        return Math.ceil(string.length * 3) / 4 - n4;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (i4 = 0; i4 < 64; )
        s64[b64[i4] = i4 < 26 ? i4 + 65 : i4 < 52 ? i4 + 71 : i4 < 62 ? i4 - 4 : i4 - 59 | 43] = i4++;
      var i4;
      base643.encode = function encode(buffer2, start, end) {
        var parts = null, chunk = [];
        var i5 = 0, j3 = 0, t3;
        while (start < end) {
          var b4 = buffer2[start++];
          switch (j3) {
            case 0:
              chunk[i5++] = b64[b4 >> 2];
              t3 = (b4 & 3) << 4;
              j3 = 1;
              break;
            case 1:
              chunk[i5++] = b64[t3 | b4 >> 4];
              t3 = (b4 & 15) << 2;
              j3 = 2;
              break;
            case 2:
              chunk[i5++] = b64[t3 | b4 >> 6];
              chunk[i5++] = b64[b4 & 63];
              j3 = 0;
              break;
          }
          if (i5 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i5 = 0;
          }
        }
        if (j3) {
          chunk[i5++] = b64[t3];
          chunk[i5++] = 61;
          if (j3 === 1)
            chunk[i5++] = 61;
        }
        if (parts) {
          if (i5)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i5)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i5));
      };
      var invalidEncoding = "invalid encoding";
      base643.decode = function decode(string, buffer2, offset) {
        var start = offset;
        var j3 = 0, t3;
        for (var i5 = 0; i5 < string.length; ) {
          var c3 = string.charCodeAt(i5++);
          if (c3 === 61 && j3 > 1)
            break;
          if ((c3 = s64[c3]) === void 0)
            throw Error(invalidEncoding);
          switch (j3) {
            case 0:
              t3 = c3;
              j3 = 1;
              break;
            case 1:
              buffer2[offset++] = t3 << 2 | (c3 & 48) >> 4;
              t3 = c3;
              j3 = 2;
              break;
            case 2:
              buffer2[offset++] = (t3 & 15) << 4 | (c3 & 60) >> 2;
              t3 = c3;
              j3 = 3;
              break;
            case 3:
              buffer2[offset++] = (t3 & 3) << 6 | c3;
              j3 = 0;
              break;
          }
        }
        if (j3 === 1)
          throw Error(invalidEncoding);
        return offset - start;
      };
      base643.test = function test(string) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
      };
    }
  });

  // node_modules/@protobufjs/eventemitter/index.js
  var require_eventemitter = __commonJS({
    "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
      "use strict";
      module2.exports = EventEmitter;
      function EventEmitter() {
        this._listeners = {};
      }
      EventEmitter.prototype.on = function on2(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn,
          ctx: ctx || this
        });
        return this;
      };
      EventEmitter.prototype.off = function off(evt, fn) {
        if (evt === void 0)
          this._listeners = {};
        else {
          if (fn === void 0)
            this._listeners[evt] = [];
          else {
            var listeners = this._listeners[evt];
            for (var i4 = 0; i4 < listeners.length; )
              if (listeners[i4].fn === fn)
                listeners.splice(i4, 1);
              else
                ++i4;
          }
        }
        return this;
      };
      EventEmitter.prototype.emit = function emit(evt) {
        var listeners = this._listeners[evt];
        if (listeners) {
          var args = [], i4 = 1;
          for (; i4 < arguments.length; )
            args.push(arguments[i4++]);
          for (i4 = 0; i4 < listeners.length; )
            listeners[i4].fn.apply(listeners[i4++].ctx, args);
        }
        return this;
      };
    }
  });

  // node_modules/@protobufjs/float/index.js
  var require_float = __commonJS({
    "node_modules/@protobufjs/float/index.js"(exports2, module2) {
      "use strict";
      module2.exports = factory(factory);
      function factory(exports3) {
        if (typeof Float32Array !== "undefined")
          (function() {
            var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
            function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
            }
            function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
            }
            exports3.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
            exports3.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
            function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
            }
            function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
            }
            exports3.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
            exports3.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
          })();
        else
          (function() {
            function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign2 = val < 0 ? 1 : 0;
              if (sign2)
                val = -val;
              if (val === 0)
                writeUint(1 / val > 0 ? (
                  /* positive */
                  0
                ) : (
                  /* negative 0 */
                  2147483648
                ), buf, pos);
              else if (isNaN(val))
                writeUint(2143289344, buf, pos);
              else if (val > 34028234663852886e22)
                writeUint((sign2 << 31 | 2139095040) >>> 0, buf, pos);
              else if (val < 11754943508222875e-54)
                writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
              else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
              }
            }
            exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
            exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
            function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos), sign2 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
              return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
            }
            exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
            exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
          })();
        if (typeof Float64Array !== "undefined")
          (function() {
            var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
            function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
            }
            function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
            }
            exports3.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
            exports3.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
            function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
            }
            function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
            }
            exports3.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
            exports3.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
          })();
        else
          (function() {
            function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign2 = val < 0 ? 1 : 0;
              if (sign2)
                val = -val;
              if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? (
                  /* positive */
                  0
                ) : (
                  /* negative 0 */
                  2147483648
                ), buf, pos + off1);
              } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
              } else if (val > 17976931348623157e292) {
                writeUint(0, buf, pos + off0);
                writeUint((sign2 << 31 | 2146435072) >>> 0, buf, pos + off1);
              } else {
                var mantissa;
                if (val < 22250738585072014e-324) {
                  mantissa = val / 5e-324;
                  writeUint(mantissa >>> 0, buf, pos + off0);
                  writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2);
                  if (exponent === 1024)
                    exponent = 1023;
                  mantissa = val * Math.pow(2, -exponent);
                  writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                  writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
              }
            }
            exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
            exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
            function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
              var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
            }
            exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
            exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
          })();
        return exports3;
      }
      function writeUintLE(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      function writeUintBE(val, buf, pos) {
        buf[pos] = val >>> 24;
        buf[pos + 1] = val >>> 16 & 255;
        buf[pos + 2] = val >>> 8 & 255;
        buf[pos + 3] = val & 255;
      }
      function readUintLE(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
      }
      function readUintBE(buf, pos) {
        return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
      }
    }
  });

  // node_modules/@protobufjs/inquire/index.js
  var require_inquire = __commonJS({
    "node_modules/@protobufjs/inquire/index.js"(exports, module) {
      "use strict";
      module.exports = inquire;
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length))
            return mod;
        } catch (e) {
        }
        return null;
      }
    }
  });

  // node_modules/@protobufjs/utf8/index.js
  var require_utf82 = __commonJS({
    "node_modules/@protobufjs/utf8/index.js"(exports2) {
      "use strict";
      var utf82 = exports2;
      utf82.length = function utf8_length(string) {
        var len = 0, c3 = 0;
        for (var i4 = 0; i4 < string.length; ++i4) {
          c3 = string.charCodeAt(i4);
          if (c3 < 128)
            len += 1;
          else if (c3 < 2048)
            len += 2;
          else if ((c3 & 64512) === 55296 && (string.charCodeAt(i4 + 1) & 64512) === 56320) {
            ++i4;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf82.read = function utf8_read(buffer2, start, end) {
        var len = end - start;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i4 = 0, t3;
        while (start < end) {
          t3 = buffer2[start++];
          if (t3 < 128)
            chunk[i4++] = t3;
          else if (t3 > 191 && t3 < 224)
            chunk[i4++] = (t3 & 31) << 6 | buffer2[start++] & 63;
          else if (t3 > 239 && t3 < 365) {
            t3 = ((t3 & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
            chunk[i4++] = 55296 + (t3 >> 10);
            chunk[i4++] = 56320 + (t3 & 1023);
          } else
            chunk[i4++] = (t3 & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
          if (i4 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i4 = 0;
          }
        }
        if (parts) {
          if (i4)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i4)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i4));
      };
      utf82.write = function utf8_write(string, buffer2, offset) {
        var start = offset, c1, c22;
        for (var i4 = 0; i4 < string.length; ++i4) {
          c1 = string.charCodeAt(i4);
          if (c1 < 128) {
            buffer2[offset++] = c1;
          } else if (c1 < 2048) {
            buffer2[offset++] = c1 >> 6 | 192;
            buffer2[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c22 = string.charCodeAt(i4 + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
            ++i4;
            buffer2[offset++] = c1 >> 18 | 240;
            buffer2[offset++] = c1 >> 12 & 63 | 128;
            buffer2[offset++] = c1 >> 6 & 63 | 128;
            buffer2[offset++] = c1 & 63 | 128;
          } else {
            buffer2[offset++] = c1 >> 12 | 224;
            buffer2[offset++] = c1 >> 6 & 63 | 128;
            buffer2[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start;
      };
    }
  });

  // node_modules/@protobufjs/pool/index.js
  var require_pool = __commonJS({
    "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
      "use strict";
      module2.exports = pool;
      function pool(alloc, slice2, size3) {
        var SIZE = size3 || 8192;
        var MAX = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size4) {
          if (size4 < 1 || size4 > MAX)
            return alloc(size4);
          if (offset + size4 > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
          }
          var buf = slice2.call(slab, offset, offset += size4);
          if (offset & 7)
            offset = (offset | 7) + 1;
          return buf;
        };
      }
    }
  });

  // node_modules/protobufjs/src/util/longbits.js
  var require_longbits = __commonJS({
    "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
      "use strict";
      module2.exports = LongBits;
      var util2 = require_minimal();
      function LongBits(lo, hi) {
        this.lo = lo >>> 0;
        this.hi = hi >>> 0;
      }
      var zero = LongBits.zero = new LongBits(0, 0);
      zero.toNumber = function() {
        return 0;
      };
      zero.zzEncode = zero.zzDecode = function() {
        return this;
      };
      zero.length = function() {
        return 1;
      };
      var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
      LongBits.fromNumber = function fromNumber2(value) {
        if (value === 0)
          return zero;
        var sign2 = value < 0;
        if (sign2)
          value = -value;
        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
        if (sign2) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
              hi = 0;
          }
        }
        return new LongBits(lo, hi);
      };
      LongBits.from = function from2(value) {
        if (typeof value === "number")
          return LongBits.fromNumber(value);
        if (util2.isString(value)) {
          if (util2.Long)
            value = util2.Long.fromString(value);
          else
            return LongBits.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
      };
      LongBits.prototype.toNumber = function toNumber2(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
          if (!lo)
            hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };
      LongBits.prototype.toLong = function toLong(unsigned) {
        return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
      };
      var charCodeAt = String.prototype.charCodeAt;
      LongBits.fromHash = function fromHash(hash3) {
        if (hash3 === zeroHash)
          return zero;
        return new LongBits(
          (charCodeAt.call(hash3, 0) | charCodeAt.call(hash3, 1) << 8 | charCodeAt.call(hash3, 2) << 16 | charCodeAt.call(hash3, 3) << 24) >>> 0,
          (charCodeAt.call(hash3, 4) | charCodeAt.call(hash3, 5) << 8 | charCodeAt.call(hash3, 6) << 16 | charCodeAt.call(hash3, 7) << 24) >>> 0
        );
      };
      LongBits.prototype.toHash = function toHash() {
        return String.fromCharCode(
          this.lo & 255,
          this.lo >>> 8 & 255,
          this.lo >>> 16 & 255,
          this.lo >>> 24,
          this.hi & 255,
          this.hi >>> 8 & 255,
          this.hi >>> 16 & 255,
          this.hi >>> 24
        );
      };
      LongBits.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.length = function length() {
        var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
      };
    }
  });

  // node_modules/protobufjs/src/util/minimal.js
  var require_minimal = __commonJS({
    "node_modules/protobufjs/src/util/minimal.js"(exports2) {
      "use strict";
      var util2 = exports2;
      util2.asPromise = require_aspromise();
      util2.base64 = require_base64();
      util2.EventEmitter = require_eventemitter();
      util2.float = require_float();
      util2.inquire = require_inquire();
      util2.utf8 = require_utf82();
      util2.pool = require_pool();
      util2.LongBits = require_longbits();
      util2.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
      util2.global = util2.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
      util2.emptyArray = Object.freeze ? Object.freeze([]) : (
        /* istanbul ignore next */
        []
      );
      util2.emptyObject = Object.freeze ? Object.freeze({}) : (
        /* istanbul ignore next */
        {}
      );
      util2.isInteger = Number.isInteger || /* istanbul ignore next */
      function isInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util2.isString = function isString(value) {
        return typeof value === "string" || value instanceof String;
      };
      util2.isObject = function isObject2(value) {
        return value && typeof value === "object";
      };
      util2.isset = /**
       * Checks if a property on a message is considered to be present.
       * @param {Object} obj Plain object or message instance
       * @param {string} prop Property name
       * @returns {boolean} `true` if considered to be present, otherwise `false`
       */
      util2.isSet = function isSet(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util2.Buffer = function() {
        try {
          var Buffer2 = util2.inquire("buffer").Buffer;
          return Buffer2.prototype.utf8Write ? Buffer2 : (
            /* istanbul ignore next */
            null
          );
        } catch (e) {
          return null;
        }
      }();
      util2._Buffer_from = null;
      util2._Buffer_allocUnsafe = null;
      util2.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util2.Long = /* istanbul ignore next */
      util2.global.dcodeIO && /* istanbul ignore next */
      util2.global.dcodeIO.Long || /* istanbul ignore next */
      util2.global.Long || util2.inquire("long");
      util2.key2Re = /^true|false|0|1$/;
      util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util2.longToHash = function longToHash(value) {
        return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
      };
      util2.longFromHash = function longFromHash(hash3, unsigned) {
        var bits = util2.LongBits.fromHash(hash3);
        if (util2.Long)
          return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };
      function merge(dst, src, ifNotSet) {
        for (var keys = Object.keys(src), i4 = 0; i4 < keys.length; ++i4)
          if (dst[keys[i4]] === void 0 || !ifNotSet)
            dst[keys[i4]] = src[keys[i4]];
        return dst;
      }
      util2.merge = merge;
      util2.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name) {
        function CustomError(message, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge(this, properties);
        }
        CustomError.prototype = Object.create(Error.prototype, {
          constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
          },
          name: {
            get: function get3() {
              return name;
            },
            set: void 0,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
          },
          toString: {
            value: function value() {
              return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
          }
        });
        return CustomError;
      }
      util2.newError = newError;
      util2.ProtocolError = newError("ProtocolError");
      util2.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i4 = 0; i4 < fieldNames.length; ++i4)
          fieldMap[fieldNames[i4]] = 1;
        return function() {
          for (var keys = Object.keys(this), i5 = keys.length - 1; i5 > -1; --i5)
            if (fieldMap[keys[i5]] === 1 && this[keys[i5]] !== void 0 && this[keys[i5]] !== null)
              return keys[i5];
        };
      };
      util2.oneOfSetter = function setOneOf(fieldNames) {
        return function(name) {
          for (var i4 = 0; i4 < fieldNames.length; ++i4)
            if (fieldNames[i4] !== name)
              delete this[fieldNames[i4]];
        };
      };
      util2.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util2._configure = function() {
        var Buffer2 = util2.Buffer;
        if (!Buffer2) {
          util2._Buffer_from = util2._Buffer_allocUnsafe = null;
          return;
        }
        util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
        function Buffer_from(value, encoding) {
          return new Buffer2(value, encoding);
        };
        util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
        function Buffer_allocUnsafe(size3) {
          return new Buffer2(size3);
        };
      };
    }
  });

  // node_modules/protobufjs/src/writer.js
  var require_writer = __commonJS({
    "node_modules/protobufjs/src/writer.js"(exports2, module2) {
      "use strict";
      module2.exports = Writer;
      var util2 = require_minimal();
      var BufferWriter;
      var LongBits = util2.LongBits;
      var base643 = util2.base64;
      var utf82 = util2.utf8;
      function Op(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      function noop4() {
      }
      function State(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
      function Writer() {
        this.len = 0;
        this.head = new Op(noop4, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      var create = function create2() {
        return util2.Buffer ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
            return new BufferWriter();
          })();
        } : function create_array() {
          return new Writer();
        };
      };
      Writer.create = create();
      Writer.alloc = function alloc(size3) {
        return new util2.Array(size3);
      };
      if (util2.Array !== Array)
        Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
      Writer.prototype._push = function push2(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
      };
      function writeByte(val, buf, pos) {
        buf[pos] = val & 255;
      }
      function writeVarint32(val, buf, pos) {
        while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
        }
        buf[pos] = val;
      }
      function VarintOp(len, val) {
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      VarintOp.prototype = Object.create(Op.prototype);
      VarintOp.prototype.fn = writeVarint32;
      Writer.prototype.uint32 = function write_uint32(value) {
        this.len += (this.tail = this.tail.next = new VarintOp(
          (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
          value
        )).len;
        return this;
      };
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
      };
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      };
      function writeVarint64(val, buf, pos) {
        while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
        }
        buf[pos++] = val.lo;
      }
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits.from(value);
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.int64 = Writer.prototype.uint64;
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits.from(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
      };
      function writeFixed32(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
      };
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits.from(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
      };
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;
      Writer.prototype.float = function write_float(value) {
        return this._push(util2.float.writeFloatLE, 4, value);
      };
      Writer.prototype.double = function write_double(value) {
        return this._push(util2.float.writeDoubleLE, 8, value);
      };
      var writeBytes = util2.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytes_for(val, buf, pos) {
        for (var i4 = 0; i4 < val.length; ++i4)
          buf[pos + i4] = val[i4];
      };
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len)
          return this._push(writeByte, 1, 0);
        if (util2.isString(value)) {
          var buf = Writer.alloc(len = base643.length(value));
          base643.decode(value, buf, 0);
          value = buf;
        }
        return this.uint32(len)._push(writeBytes, len, value);
      };
      Writer.prototype.string = function write_string(value) {
        var len = utf82.length(value);
        return len ? this.uint32(len)._push(utf82.write, len, value) : this._push(writeByte, 1, 0);
      };
      Writer.prototype.fork = function fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop4, 0, 0);
        this.len = 0;
        return this;
      };
      Writer.prototype.reset = function reset2() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(noop4, 0, 0);
          this.len = 0;
        }
        return this;
      };
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      };
      Writer.prototype.finish = function finish() {
        var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
        while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      };
      Writer._configure = function(BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create();
        BufferWriter._configure();
      };
    }
  });

  // node_modules/protobufjs/src/writer_buffer.js
  var require_writer_buffer = __commonJS({
    "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferWriter;
      var Writer = require_writer();
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util2 = require_minimal();
      function BufferWriter() {
        Writer.call(this);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util2._Buffer_allocUnsafe;
        BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos);
        } : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy)
            val.copy(buf, pos, 0, val.length);
          else
            for (var i4 = 0; i4 < val.length; )
              buf[pos++] = val[i4++];
        };
      };
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util2.isString(value))
          value = util2._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };
      function writeStringBuffer(val, buf, pos) {
        if (val.length < 40)
          util2.utf8.write(val, buf, pos);
        else if (buf.utf8Write)
          buf.utf8Write(val, pos);
        else
          buf.write(val, pos);
      }
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util2.Buffer.byteLength(value);
        this.uint32(len);
        if (len)
          this._push(writeStringBuffer, len, value);
        return this;
      };
      BufferWriter._configure();
    }
  });

  // node_modules/protobufjs/src/reader.js
  var require_reader = __commonJS({
    "node_modules/protobufjs/src/reader.js"(exports2, module2) {
      "use strict";
      module2.exports = Reader;
      var util2 = require_minimal();
      var BufferReader;
      var LongBits = util2.LongBits;
      var utf82 = util2.utf8;
      function indexOutOfRange(reader, writeLength) {
        return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
      }
      function Reader(buffer2) {
        this.buf = buffer2;
        this.pos = 0;
        this.len = buffer2.length;
      }
      var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
        if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
          return new Reader(buffer2);
        throw Error("illegal buffer");
      } : function create_array2(buffer2) {
        if (Array.isArray(buffer2))
          return new Reader(buffer2);
        throw Error("illegal buffer");
      };
      var create = function create2() {
        return util2.Buffer ? function create_buffer_setup(buffer2) {
          return (Reader.create = function create_buffer(buffer3) {
            return util2.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
          })(buffer2);
        } : create_array;
      };
      Reader.create = create();
      Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
      util2.Array.prototype.slice;
      Reader.prototype.uint32 = function read_uint32_setup() {
        var value = 4294967295;
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
          }
          return value;
        };
      }();
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
      };
      function readLongVarint() {
        var bits = new LongBits(0, 0);
        var i4 = 0;
        if (this.len - this.pos > 4) {
          for (; i4 < 4; ++i4) {
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i4 * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
          i4 = 0;
        } else {
          for (; i4 < 3; ++i4) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i4 * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i4 * 7) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          for (; i4 < 5; ++i4) {
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i4 * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        } else {
          for (; i4 < 5; ++i4) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i4 * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        }
        throw Error("invalid varint encoding");
      }
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };
      function readFixed32_end(buf, end) {
        return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
      }
      Reader.prototype.fixed32 = function read_fixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      };
      Reader.prototype.sfixed32 = function read_sfixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0;
      };
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader.prototype.float = function read_float() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util2.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };
      Reader.prototype.double = function read_double() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util2.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };
      Reader.prototype.bytes = function read_bytes() {
        var length = this.uint32(), start = this.pos, end = this.pos + length;
        if (end > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
        if (Array.isArray(this.buf))
          return this.buf.slice(start, end);
        return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
      };
      Reader.prototype.string = function read_string() {
        var bytes2 = this.bytes();
        return utf82.read(bytes2, 0, bytes2.length);
      };
      Reader.prototype.skip = function skip(length) {
        if (typeof length === "number") {
          if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
          this.pos += length;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };
      Reader.prototype.skipType = function(wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      };
      Reader._configure = function(BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create();
        BufferReader._configure();
        var fn = util2.Long ? "toLong" : (
          /* istanbul ignore next */
          "toNumber"
        );
        util2.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },
          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },
          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },
          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },
          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          }
        });
      };
    }
  });

  // node_modules/protobufjs/src/reader_buffer.js
  var require_reader_buffer = __commonJS({
    "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferReader;
      var Reader = require_reader();
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util2 = require_minimal();
      function BufferReader(buffer2) {
        Reader.call(this, buffer2);
      }
      BufferReader._configure = function() {
        if (util2.Buffer)
          BufferReader.prototype._slice = util2.Buffer.prototype.slice;
      };
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
      };
      BufferReader._configure();
    }
  });

  // node_modules/protobufjs/src/rpc/service.js
  var require_service = __commonJS({
    "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
      "use strict";
      module2.exports = Service;
      var util2 = require_minimal();
      (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");
        util2.EventEmitter.call(this);
        this.rpcImpl = rpcImpl;
        this.requestDelimited = Boolean(requestDelimited);
        this.responseDelimited = Boolean(responseDelimited);
      }
      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
        if (!request)
          throw TypeError("request must be specified");
        var self2 = this;
        if (!callback)
          return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
        if (!self2.rpcImpl) {
          setTimeout(function() {
            callback(Error("already ended"));
          }, 0);
          return void 0;
        }
        try {
          return self2.rpcImpl(
            method,
            requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {
              if (err) {
                self2.emit("error", err, method);
                return callback(err);
              }
              if (response === null) {
                self2.end(
                  /* endedByRPC */
                  true
                );
                return void 0;
              }
              if (!(response instanceof responseCtor)) {
                try {
                  response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err2) {
                  self2.emit("error", err2, method);
                  return callback(err2);
                }
              }
              self2.emit("data", response, method);
              return callback(null, response);
            }
          );
        } catch (err) {
          self2.emit("error", err, method);
          setTimeout(function() {
            callback(err);
          }, 0);
          return void 0;
        }
      };
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };
    }
  });

  // node_modules/protobufjs/src/rpc.js
  var require_rpc = __commonJS({
    "node_modules/protobufjs/src/rpc.js"(exports2) {
      "use strict";
      var rpc2 = exports2;
      rpc2.Service = require_service();
    }
  });

  // node_modules/protobufjs/src/roots.js
  var require_roots = __commonJS({
    "node_modules/protobufjs/src/roots.js"(exports2, module2) {
      "use strict";
      module2.exports = {};
    }
  });

  // node_modules/protobufjs/src/index-minimal.js
  var require_index_minimal = __commonJS({
    "node_modules/protobufjs/src/index-minimal.js"(exports2) {
      "use strict";
      var protobuf = exports2;
      protobuf.build = "minimal";
      protobuf.Writer = require_writer();
      protobuf.BufferWriter = require_writer_buffer();
      protobuf.Reader = require_reader();
      protobuf.BufferReader = require_reader_buffer();
      protobuf.util = require_minimal();
      protobuf.rpc = require_rpc();
      protobuf.roots = require_roots();
      protobuf.configure = configure;
      function configure() {
        protobuf.util._configure();
        protobuf.Writer._configure(protobuf.BufferWriter);
        protobuf.Reader._configure(protobuf.BufferReader);
      }
      configure();
    }
  });

  // node_modules/protobufjs/minimal.js
  var require_minimal2 = __commonJS({
    "node_modules/protobufjs/minimal.js"(exports2, module2) {
      "use strict";
      module2.exports = require_index_minimal();
    }
  });

  // node_modules/nice-grpc-common/lib/Metadata.js
  var require_Metadata = __commonJS({
    "node_modules/nice-grpc-common/lib/Metadata.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Metadata = void 0;
      exports2.Metadata = function Metadata(init) {
        const data = /* @__PURE__ */ new Map();
        const metadata = {
          set(key, value) {
            key = normalizeKey(key);
            if (Array.isArray(value)) {
              if (value.length === 0) {
                data.delete(key);
              } else {
                for (const item of value) {
                  validate(key, item);
                }
                data.set(key, key.endsWith("-bin") ? value : [value.join(", ")]);
              }
            } else {
              validate(key, value);
              data.set(key, [value]);
            }
            return metadata;
          },
          append(key, value) {
            key = normalizeKey(key);
            validate(key, value);
            let values = data.get(key);
            if (values == null) {
              values = [];
              data.set(key, values);
            }
            values.push(value);
            if (!key.endsWith("-bin")) {
              data.set(key, [values.join(", ")]);
            }
            return metadata;
          },
          delete(key) {
            key = normalizeKey(key);
            data.delete(key);
          },
          get(key) {
            var _a;
            key = normalizeKey(key);
            return (_a = data.get(key)) === null || _a === void 0 ? void 0 : _a[0];
          },
          getAll(key) {
            var _a;
            key = normalizeKey(key);
            return (_a = data.get(key)) !== null && _a !== void 0 ? _a : [];
          },
          has(key) {
            key = normalizeKey(key);
            return data.has(key);
          },
          [Symbol.iterator]() {
            return data[Symbol.iterator]();
          }
        };
        if (init != null) {
          const entries = isIterable2(init) ? init : Object.entries(init);
          for (const [key, value] of entries) {
            metadata.set(key, value);
          }
        }
        return metadata;
      };
      function normalizeKey(key) {
        return key.toLowerCase();
      }
      function validate(key, value) {
        if (!/^[0-9a-z_.-]+$/.test(key)) {
          throw new Error(`Metadata key '${key}' contains illegal characters`);
        }
        if (key.endsWith("-bin")) {
          if (!(value instanceof Uint8Array)) {
            throw new Error(`Metadata key '${key}' ends with '-bin', thus it must have binary value`);
          }
        } else {
          if (typeof value !== "string") {
            throw new Error(`Metadata key '${key}' doesn't end with '-bin', thus it must have string value`);
          }
          if (!/^[ -~]*$/.test(value)) {
            throw new Error(`Metadata value '${value}' of key '${key}' contains illegal characters`);
          }
        }
      }
      function isIterable2(value) {
        return Symbol.iterator in value;
      }
    }
  });

  // node_modules/nice-grpc-common/lib/Status.js
  var require_Status = __commonJS({
    "node_modules/nice-grpc-common/lib/Status.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Status = void 0;
      var Status;
      (function(Status2) {
        Status2[Status2["OK"] = 0] = "OK";
        Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
        Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
        Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
        Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
        Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
        Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
        Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
        Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
        Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
        Status2[Status2["ABORTED"] = 10] = "ABORTED";
        Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
        Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
        Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
        Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
        Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
        Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
      })(Status = exports2.Status || (exports2.Status = {}));
    }
  });

  // node_modules/nice-grpc-common/lib/MethodDescriptor.js
  var require_MethodDescriptor = __commonJS({
    "node_modules/nice-grpc-common/lib/MethodDescriptor.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/nice-grpc-common/lib/client/CallOptions.js
  var require_CallOptions = __commonJS({
    "node_modules/nice-grpc-common/lib/client/CallOptions.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/nice-grpc-common/lib/client/ClientMiddleware.js
  var require_ClientMiddleware = __commonJS({
    "node_modules/nice-grpc-common/lib/client/ClientMiddleware.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/nice-grpc-common/lib/client/composeClientMiddleware.js
  var require_composeClientMiddleware = __commonJS({
    "node_modules/nice-grpc-common/lib/client/composeClientMiddleware.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.composeClientMiddleware = void 0;
      function composeClientMiddleware(middleware1, middleware2) {
        return (call2, options) => {
          return middleware2(Object.assign(Object.assign({}, call2), { next: (request, options2) => {
            return middleware1(Object.assign(Object.assign({}, call2), { request }), options2);
          } }), options);
        };
      }
      exports2.composeClientMiddleware = composeClientMiddleware;
    }
  });

  // node_modules/ts-error/lib/helpers.js
  var require_helpers = __commonJS({
    "node_modules/ts-error/lib/helpers.js"(exports2) {
      "use strict";
      exports2.__esModule = void 0;
      exports2.__esModule = true;
      var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf === "function";
      var objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf === "function";
      var objectDefinePropertyIsDefined = typeof Object.defineProperty === "function";
      var objectCreateIsDefined = typeof Object.create === "function";
      var objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty === "function";
      var setPrototypeOf = function setPrototypeOf2(target, prototype) {
        if (objectSetPrototypeOfIsDefined) {
          Object.setPrototypeOf(target, prototype);
        } else {
          target.__proto__ = prototype;
        }
      };
      exports2.setPrototypeOf = setPrototypeOf;
      var getPrototypeOf2 = function getPrototypeOf3(target) {
        if (objectGetPrototypeOfIsDefined) {
          return Object.getPrototypeOf(target);
        } else {
          return target.__proto__ || target.prototype;
        }
      };
      exports2.getPrototypeOf = getPrototypeOf2;
      var ie8ObjectDefinePropertyBug = false;
      var defineProperty3 = function defineProperty4(target, name, propertyDescriptor) {
        if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug) {
          try {
            Object.defineProperty(target, name, propertyDescriptor);
          } catch (e) {
            ie8ObjectDefinePropertyBug = true;
            defineProperty4(target, name, propertyDescriptor);
          }
        } else {
          target[name] = propertyDescriptor.value;
        }
      };
      exports2.defineProperty = defineProperty3;
      var hasOwnProperty = function hasOwnProperty2(target, name) {
        if (objectHasOwnPropertyIsDefined) {
          return target.hasOwnProperty(target, name);
        } else {
          return target[name] === void 0;
        }
      };
      exports2.hasOwnProperty = hasOwnProperty;
      var objectCreate = function objectCreate2(prototype, propertyDescriptors) {
        if (objectCreateIsDefined) {
          return Object.create(prototype, propertyDescriptors);
        } else {
          var F5 = function F6() {
          };
          F5.prototype = prototype;
          var result = new F5();
          if (typeof propertyDescriptors === "undefined") {
            return result;
          }
          if (typeof propertyDescriptors === "null") {
            throw new Error("PropertyDescriptors must not be null.");
          }
          if (typeof propertyDescriptors === "object") {
            for (var key in propertyDescriptors) {
              if (hasOwnProperty(propertyDescriptors, key)) {
                result[key] = propertyDescriptors[key].value;
              }
            }
          }
          return result;
        }
      };
      exports2.objectCreate = objectCreate;
    }
  });

  // node_modules/ts-error/lib/cjs.js
  var require_cjs = __commonJS({
    "node_modules/ts-error/lib/cjs.js"(exports2) {
      "use strict";
      exports2.__esModule = void 0;
      exports2.__esModule = true;
      var helpers = require_helpers();
      var setPrototypeOf = helpers.setPrototypeOf;
      var getPrototypeOf2 = helpers.getPrototypeOf;
      var defineProperty3 = helpers.defineProperty;
      var objectCreate = helpers.objectCreate;
      var uglyErrorPrinting = new Error().toString() === "[object Error]";
      var extendableErrorName = "";
      function ExtendableError(message) {
        var originalConstructor = this.constructor;
        var constructorName = originalConstructor.name || function() {
          var constructorNameMatch = originalConstructor.toString().match(/^function\s*([^\s(]+)/);
          return constructorNameMatch === null ? extendableErrorName ? extendableErrorName : "Error" : constructorNameMatch[1];
        }();
        var constructorNameIsError = constructorName === "Error";
        var name = constructorNameIsError ? extendableErrorName : constructorName;
        var instance = Error.apply(this, arguments);
        setPrototypeOf(instance, getPrototypeOf2(this));
        if (!(instance instanceof originalConstructor) || !(instance instanceof ExtendableError)) {
          var instance = this;
          Error.apply(this, arguments);
          defineProperty3(instance, "message", {
            configurable: true,
            enumerable: false,
            value: message,
            writable: true
          });
        }
        defineProperty3(instance, "name", {
          configurable: true,
          enumerable: false,
          value: name,
          writable: true
        });
        if (Error.captureStackTrace) {
          Error.captureStackTrace(
            instance,
            constructorNameIsError ? ExtendableError : originalConstructor
          );
        }
        if (instance.stack === void 0) {
          var err = new Error(message);
          err.name = instance.name;
          instance.stack = err.stack;
        }
        if (uglyErrorPrinting) {
          defineProperty3(instance, "toString", {
            configurable: true,
            enumerable: false,
            value: function toString3() {
              return (this.name || "Error") + (typeof this.message === "undefined" ? "" : ": " + this.message);
            },
            writable: true
          });
        }
        return instance;
      }
      extendableErrorName = ExtendableError.name || "ExtendableError";
      ExtendableError.prototype = objectCreate(Error.prototype, {
        constructor: {
          value: Error,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      exports2.ExtendableError = ExtendableError;
      exports2["default"] = exports2.ExtendableError;
    }
  });

  // node_modules/nice-grpc-common/lib/client/ClientError.js
  var require_ClientError = __commonJS({
    "node_modules/nice-grpc-common/lib/client/ClientError.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ClientError = void 0;
      var ts_error_1 = require_cjs();
      var Status_1 = require_Status();
      var ClientError = class extends ts_error_1.ExtendableError {
        constructor(path, code, details) {
          super(`${path} ${Status_1.Status[code]}: ${details}`);
          this.path = path;
          this.code = code;
          this.details = details;
          this.name = "ClientError";
          Object.defineProperty(this, "@@nice-grpc", {
            value: true
          });
          Object.defineProperty(this, "@@nice-grpc:ClientError", {
            value: true
          });
        }
        static [Symbol.hasInstance](instance) {
          if (this !== ClientError) {
            return this.prototype.isPrototypeOf(instance);
          }
          return typeof instance === "object" && instance !== null && (instance.constructor === ClientError || instance["@@nice-grpc:ClientError"] === true || instance.name === "ClientError" && instance["@@nice-grpc"] === true);
        }
      };
      exports2.ClientError = ClientError;
    }
  });

  // node_modules/nice-grpc-common/lib/server/CallContext.js
  var require_CallContext = __commonJS({
    "node_modules/nice-grpc-common/lib/server/CallContext.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/nice-grpc-common/lib/server/ServerMiddleware.js
  var require_ServerMiddleware = __commonJS({
    "node_modules/nice-grpc-common/lib/server/ServerMiddleware.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/nice-grpc-common/lib/server/composeServerMiddleware.js
  var require_composeServerMiddleware = __commonJS({
    "node_modules/nice-grpc-common/lib/server/composeServerMiddleware.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.composeServerMiddleware = void 0;
      function composeServerMiddleware(middleware1, middleware2) {
        return (call2, context2) => {
          return middleware1(Object.assign(Object.assign({}, call2), { next: (request, context1) => {
            return middleware2(Object.assign(Object.assign({}, call2), { request }), context1);
          } }), context2);
        };
      }
      exports2.composeServerMiddleware = composeServerMiddleware;
    }
  });

  // node_modules/nice-grpc-common/lib/server/ServerError.js
  var require_ServerError = __commonJS({
    "node_modules/nice-grpc-common/lib/server/ServerError.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ServerError = void 0;
      var ts_error_1 = require_cjs();
      var Status_1 = require_Status();
      var ServerError = class extends ts_error_1.ExtendableError {
        constructor(code, details) {
          super(`${Status_1.Status[code]}: ${details}`);
          this.code = code;
          this.details = details;
          this.name = "ServerError";
          Object.defineProperty(this, "@@nice-grpc", {
            value: true
          });
          Object.defineProperty(this, "@@nice-grpc:ServerError", {
            value: true
          });
        }
        static [Symbol.hasInstance](instance) {
          if (this !== ServerError) {
            return this.prototype.isPrototypeOf(instance);
          }
          return typeof instance === "object" && instance !== null && (instance.constructor === ServerError || instance["@@nice-grpc:ServerError"] === true || instance.name === "ServerError" && instance["@@nice-grpc"] === true);
        }
      };
      exports2.ServerError = ServerError;
    }
  });

  // node_modules/nice-grpc-common/lib/index.js
  var require_lib29 = __commonJS({
    "node_modules/nice-grpc-common/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m5, exports3) {
        for (var p2 in m5)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m5, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_Metadata(), exports2);
      __exportStar(require_Status(), exports2);
      __exportStar(require_MethodDescriptor(), exports2);
      __exportStar(require_CallOptions(), exports2);
      __exportStar(require_ClientMiddleware(), exports2);
      __exportStar(require_composeClientMiddleware(), exports2);
      __exportStar(require_ClientError(), exports2);
      __exportStar(require_CallContext(), exports2);
      __exportStar(require_ServerMiddleware(), exports2);
      __exportStar(require_composeServerMiddleware(), exports2);
      __exportStar(require_ServerError(), exports2);
    }
  });

  // node_modules/nice-grpc-web/lib/service-definitions/grpc-web.js
  var require_grpc_web = __commonJS({
    "node_modules/nice-grpc-web/lib/service-definitions/grpc-web.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isGrpcWebServiceDefinition = exports2.fromGrpcWebServiceDefinition = void 0;
      function fromGrpcWebServiceDefinition(definition) {
        const result = {};
        for (const [key, value] of Object.entries(definition)) {
          if (key === "serviceName") {
            continue;
          }
          const method = value;
          result[uncapitalize(key)] = {
            path: `/${definition.serviceName}/${key}`,
            requestStream: method.requestStream,
            responseStream: method.responseStream,
            requestDeserialize: method.requestType.deserializeBinary,
            requestSerialize: (value2) => value2.serializeBinary(),
            responseDeserialize: method.responseType.deserializeBinary,
            responseSerialize: (value2) => value2.serializeBinary(),
            options: {}
          };
        }
        return result;
      }
      exports2.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
      function isGrpcWebServiceDefinition(definition) {
        return "prototype" in definition;
      }
      exports2.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
      function uncapitalize(value) {
        if (value.length === 0) {
          return value;
        }
        return value[0].toLowerCase() + value.slice(1);
      }
    }
  });

  // node_modules/nice-grpc-web/lib/service-definitions/ts-proto.js
  var require_ts_proto = __commonJS({
    "node_modules/nice-grpc-web/lib/service-definitions/ts-proto.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isTsProtoServiceDefinition = exports2.fromTsProtoServiceDefinition = void 0;
      function fromTsProtoServiceDefinition(definition) {
        const result = {};
        for (const [key, method] of Object.entries(definition.methods)) {
          const requestEncode = method.requestType.encode;
          const requestFromPartial = method.requestType.fromPartial;
          const responseEncode = method.responseType.encode;
          const responseFromPartial = method.responseType.fromPartial;
          result[key] = {
            path: `/${definition.fullName}/${method.name}`,
            requestStream: method.requestStream,
            responseStream: method.responseStream,
            requestDeserialize: method.requestType.decode,
            requestSerialize: requestFromPartial != null ? (value) => requestEncode(requestFromPartial(value)).finish() : (value) => requestEncode(value).finish(),
            responseDeserialize: method.responseType.decode,
            responseSerialize: responseFromPartial != null ? (value) => responseEncode(responseFromPartial(value)).finish() : (value) => responseEncode(value).finish(),
            options: method.options
          };
        }
        return result;
      }
      exports2.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
      function isTsProtoServiceDefinition(definition) {
        return "name" in definition && "fullName" in definition && "methods" in definition;
      }
      exports2.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
    }
  });

  // node_modules/nice-grpc-web/lib/service-definitions/index.js
  var require_service_definitions = __commonJS({
    "node_modules/nice-grpc-web/lib/service-definitions/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.toGrpcWebMethodDefinition = exports2.normalizeServiceDefinition = void 0;
      var grpc_web_1 = require_grpc_web();
      var ts_proto_1 = require_ts_proto();
      function normalizeServiceDefinition(definition) {
        if ((0, grpc_web_1.isGrpcWebServiceDefinition)(definition)) {
          return (0, grpc_web_1.fromGrpcWebServiceDefinition)(definition);
        } else if ((0, ts_proto_1.isTsProtoServiceDefinition)(definition)) {
          return (0, ts_proto_1.fromTsProtoServiceDefinition)(definition);
        } else {
          return definition;
        }
      }
      exports2.normalizeServiceDefinition = normalizeServiceDefinition;
      function toGrpcWebMethodDefinition(definition) {
        const [, serviceName, methodName] = definition.path.split("/");
        return {
          service: {
            serviceName
          },
          methodName,
          requestStream: definition.requestStream,
          responseStream: definition.responseStream,
          requestType: class {
            constructor() {
              throw new Error("Unexpected instantiation");
            }
            static deserializeBinary(bytes2) {
              return definition.requestDeserialize(bytes2);
            }
          },
          responseType: class {
            constructor() {
              throw new Error("Unexpected instantiation");
            }
            static deserializeBinary(bytes2) {
              return definition.responseDeserialize(bytes2);
            }
          }
        };
      }
      exports2.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
    }
  });

  // node_modules/nice-grpc-web/lib/client/channel.js
  var require_channel = __commonJS({
    "node_modules/nice-grpc-web/lib/client/channel.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createChannel = void 0;
      function createChannel(address, transport) {
        return { address, transport };
      }
      exports2.createChannel = createChannel;
    }
  });

  // node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js
  var require_grpc_web_client_umd = __commonJS({
    "node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js"(exports2, module2) {
      !function(e, t3) {
        if ("object" == typeof exports2 && "object" == typeof module2)
          module2.exports = t3();
        else if ("function" == typeof define && define.amd)
          define([], t3);
        else {
          var r2 = t3();
          for (var n4 in r2)
            ("object" == typeof exports2 ? exports2 : e)[n4] = r2[n4];
        }
      }(exports2, function() {
        return e = { 418: function(e2, t4) {
          !function(e3, t5) {
            for (var r2 in t5)
              e3[r2] = t5[r2];
          }(t4, function(e3) {
            var t5 = {};
            function r2(n4) {
              if (t5[n4])
                return t5[n4].exports;
              var o3 = t5[n4] = { i: n4, l: false, exports: {} };
              return e3[n4].call(o3.exports, o3, o3.exports, r2), o3.l = true, o3.exports;
            }
            return r2.m = e3, r2.c = t5, r2.i = function(e4) {
              return e4;
            }, r2.d = function(e4, t6, n4) {
              r2.o(e4, t6) || Object.defineProperty(e4, t6, { configurable: false, enumerable: true, get: n4 });
            }, r2.n = function(e4) {
              var t6 = e4 && e4.__esModule ? function() {
                return e4.default;
              } : function() {
                return e4;
              };
              return r2.d(t6, "a", t6), t6;
            }, r2.o = function(e4, t6) {
              return Object.prototype.hasOwnProperty.call(e4, t6);
            }, r2.p = "", r2(r2.s = 1);
          }([function(e3, t5, r2) {
            "use strict";
            Object.defineProperty(t5, "__esModule", { value: true });
            var n4 = r2(3), o3 = function() {
              function e4(e5, t6) {
                void 0 === e5 && (e5 = {}), void 0 === t6 && (t6 = { splitValues: false });
                var r3, o4 = this;
                this.headersMap = {}, e5 && ("undefined" != typeof Headers && e5 instanceof Headers ? n4.getHeaderKeys(e5).forEach(function(r4) {
                  n4.getHeaderValues(e5, r4).forEach(function(e6) {
                    t6.splitValues ? o4.append(r4, n4.splitHeaderValue(e6)) : o4.append(r4, e6);
                  });
                }) : "object" == typeof (r3 = e5) && "object" == typeof r3.headersMap && "function" == typeof r3.forEach ? e5.forEach(function(e6, t7) {
                  o4.append(e6, t7);
                }) : "undefined" != typeof Map && e5 instanceof Map ? e5.forEach(function(e6, t7) {
                  o4.append(t7, e6);
                }) : "string" == typeof e5 ? this.appendFromString(e5) : "object" == typeof e5 && Object.getOwnPropertyNames(e5).forEach(function(t7) {
                  var r4 = e5[t7];
                  Array.isArray(r4) ? r4.forEach(function(e6) {
                    o4.append(t7, e6);
                  }) : o4.append(t7, r4);
                }));
              }
              return e4.prototype.appendFromString = function(e5) {
                for (var t6 = e5.split("\r\n"), r3 = 0; r3 < t6.length; r3++) {
                  var n5 = t6[r3], o4 = n5.indexOf(":");
                  if (o4 > 0) {
                    var s4 = n5.substring(0, o4).trim(), i4 = n5.substring(o4 + 1).trim();
                    this.append(s4, i4);
                  }
                }
              }, e4.prototype.delete = function(e5, t6) {
                var r3 = n4.normalizeName(e5);
                if (void 0 === t6)
                  delete this.headersMap[r3];
                else {
                  var o4 = this.headersMap[r3];
                  if (o4) {
                    var s4 = o4.indexOf(t6);
                    s4 >= 0 && o4.splice(s4, 1), 0 === o4.length && delete this.headersMap[r3];
                  }
                }
              }, e4.prototype.append = function(e5, t6) {
                var r3 = this, o4 = n4.normalizeName(e5);
                Array.isArray(this.headersMap[o4]) || (this.headersMap[o4] = []), Array.isArray(t6) ? t6.forEach(function(e6) {
                  r3.headersMap[o4].push(n4.normalizeValue(e6));
                }) : this.headersMap[o4].push(n4.normalizeValue(t6));
              }, e4.prototype.set = function(e5, t6) {
                var r3 = n4.normalizeName(e5);
                if (Array.isArray(t6)) {
                  var o4 = [];
                  t6.forEach(function(e6) {
                    o4.push(n4.normalizeValue(e6));
                  }), this.headersMap[r3] = o4;
                } else
                  this.headersMap[r3] = [n4.normalizeValue(t6)];
              }, e4.prototype.has = function(e5, t6) {
                var r3 = this.headersMap[n4.normalizeName(e5)];
                if (!Array.isArray(r3))
                  return false;
                if (void 0 !== t6) {
                  var o4 = n4.normalizeValue(t6);
                  return r3.indexOf(o4) >= 0;
                }
                return true;
              }, e4.prototype.get = function(e5) {
                var t6 = this.headersMap[n4.normalizeName(e5)];
                return void 0 !== t6 ? t6.concat() : [];
              }, e4.prototype.forEach = function(e5) {
                var t6 = this;
                Object.getOwnPropertyNames(this.headersMap).forEach(function(r3) {
                  e5(r3, t6.headersMap[r3]);
                }, this);
              }, e4.prototype.toHeaders = function() {
                if ("undefined" != typeof Headers) {
                  var e5 = new Headers();
                  return this.forEach(function(t6, r3) {
                    r3.forEach(function(r4) {
                      e5.append(t6, r4);
                    });
                  }), e5;
                }
                throw new Error("Headers class is not defined");
              }, e4;
            }();
            t5.BrowserHeaders = o3;
          }, function(e3, t5, r2) {
            "use strict";
            Object.defineProperty(t5, "__esModule", { value: true });
            var n4 = r2(0);
            t5.BrowserHeaders = n4.BrowserHeaders;
          }, function(e3, t5, r2) {
            "use strict";
            Object.defineProperty(t5, "__esModule", { value: true }), t5.iterateHeaders = function(e4, t6) {
              for (var r3 = e4[Symbol.iterator](), n4 = r3.next(); !n4.done; )
                t6(n4.value[0]), n4 = r3.next();
            }, t5.iterateHeadersKeys = function(e4, t6) {
              for (var r3 = e4.keys(), n4 = r3.next(); !n4.done; )
                t6(n4.value), n4 = r3.next();
            };
          }, function(e3, t5, r2) {
            "use strict";
            Object.defineProperty(t5, "__esModule", { value: true });
            var n4 = r2(2);
            t5.normalizeName = function(e4) {
              if ("string" != typeof e4 && (e4 = String(e4)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e4))
                throw new TypeError("Invalid character in header field name");
              return e4.toLowerCase();
            }, t5.normalizeValue = function(e4) {
              return "string" != typeof e4 && (e4 = String(e4)), e4;
            }, t5.getHeaderValues = function(e4, t6) {
              var r3 = e4;
              if (r3 instanceof Headers && r3.getAll)
                return r3.getAll(t6);
              var n5 = r3.get(t6);
              return n5 && "string" == typeof n5 ? [n5] : n5;
            }, t5.getHeaderKeys = function(e4) {
              var t6 = e4, r3 = {}, o3 = [];
              return t6.keys ? n4.iterateHeadersKeys(t6, function(e5) {
                r3[e5] || (r3[e5] = true, o3.push(e5));
              }) : t6.forEach ? t6.forEach(function(e5, t7) {
                r3[t7] || (r3[t7] = true, o3.push(t7));
              }) : n4.iterateHeaders(t6, function(e5) {
                var t7 = e5[0];
                r3[t7] || (r3[t7] = true, o3.push(t7));
              }), o3;
            }, t5.splitHeaderValue = function(e4) {
              var t6 = [];
              return e4.split(", ").forEach(function(e5) {
                e5.split(",").forEach(function(e6) {
                  t6.push(e6);
                });
              }), t6;
            };
          }]));
        }, 617: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.ChunkParser = t4.ChunkType = t4.encodeASCII = t4.decodeASCII = void 0;
          var n4, o3 = r2(65);
          function s4(e3) {
            return 9 === (t5 = e3) || 10 === t5 || 13 === t5 || e3 >= 32 && e3 <= 126;
            var t5;
          }
          function i4(e3) {
            for (var t5 = 0; t5 !== e3.length; ++t5)
              if (!s4(e3[t5]))
                throw new Error("Metadata is not valid (printable) ASCII");
            return String.fromCharCode.apply(String, Array.prototype.slice.call(e3));
          }
          function a2(e3) {
            return 128 == (128 & e3.getUint8(0));
          }
          function u3(e3) {
            return e3.getUint32(1, false);
          }
          function d6(e3, t5, r3) {
            return e3.byteLength - t5 >= r3;
          }
          function c3(e3, t5, r3) {
            if (e3.slice)
              return e3.slice(t5, r3);
            var n5 = e3.length;
            void 0 !== r3 && (n5 = r3);
            for (var o4 = new Uint8Array(n5 - t5), s5 = 0, i5 = t5; i5 < n5; i5++)
              o4[s5++] = e3[i5];
            return o4;
          }
          t4.decodeASCII = i4, t4.encodeASCII = function(e3) {
            for (var t5 = new Uint8Array(e3.length), r3 = 0; r3 !== e3.length; ++r3) {
              var n5 = e3.charCodeAt(r3);
              if (!s4(n5))
                throw new Error("Metadata contains invalid ASCII");
              t5[r3] = n5;
            }
            return t5;
          }, function(e3) {
            e3[e3.MESSAGE = 1] = "MESSAGE", e3[e3.TRAILERS = 2] = "TRAILERS";
          }(n4 = t4.ChunkType || (t4.ChunkType = {}));
          var p2 = function() {
            function e3() {
              this.buffer = null, this.position = 0;
            }
            return e3.prototype.parse = function(e4, t5) {
              if (0 === e4.length && t5)
                return [];
              var r3, s5 = [];
              if (null == this.buffer)
                this.buffer = e4, this.position = 0;
              else if (this.position === this.buffer.byteLength)
                this.buffer = e4, this.position = 0;
              else {
                var p3 = this.buffer.byteLength - this.position, h6 = new Uint8Array(p3 + e4.byteLength), f5 = c3(this.buffer, this.position);
                h6.set(f5, 0);
                var l4 = new Uint8Array(e4);
                h6.set(l4, p3), this.buffer = h6, this.position = 0;
              }
              for (; ; ) {
                if (!d6(this.buffer, this.position, 5))
                  return s5;
                var g5 = c3(this.buffer, this.position, this.position + 5), b4 = new DataView(g5.buffer, g5.byteOffset, g5.byteLength), y4 = u3(b4);
                if (!d6(this.buffer, this.position, 5 + y4))
                  return s5;
                var v7 = c3(this.buffer, this.position + 5, this.position + 5 + y4);
                if (this.position += 5 + y4, a2(b4))
                  return s5.push({ chunkType: n4.TRAILERS, trailers: (r3 = v7, new o3.Metadata(i4(r3))) }), s5;
                s5.push({ chunkType: n4.MESSAGE, data: v7 });
              }
            }, e3;
          }();
          t4.ChunkParser = p2;
        }, 8: function(e2, t4) {
          "use strict";
          var r2;
          Object.defineProperty(t4, "__esModule", { value: true }), t4.httpStatusToCode = t4.Code = void 0, function(e3) {
            e3[e3.OK = 0] = "OK", e3[e3.Canceled = 1] = "Canceled", e3[e3.Unknown = 2] = "Unknown", e3[e3.InvalidArgument = 3] = "InvalidArgument", e3[e3.DeadlineExceeded = 4] = "DeadlineExceeded", e3[e3.NotFound = 5] = "NotFound", e3[e3.AlreadyExists = 6] = "AlreadyExists", e3[e3.PermissionDenied = 7] = "PermissionDenied", e3[e3.ResourceExhausted = 8] = "ResourceExhausted", e3[e3.FailedPrecondition = 9] = "FailedPrecondition", e3[e3.Aborted = 10] = "Aborted", e3[e3.OutOfRange = 11] = "OutOfRange", e3[e3.Unimplemented = 12] = "Unimplemented", e3[e3.Internal = 13] = "Internal", e3[e3.Unavailable = 14] = "Unavailable", e3[e3.DataLoss = 15] = "DataLoss", e3[e3.Unauthenticated = 16] = "Unauthenticated";
          }(r2 = t4.Code || (t4.Code = {})), t4.httpStatusToCode = function(e3) {
            switch (e3) {
              case 0:
                return r2.Internal;
              case 200:
                return r2.OK;
              case 400:
                return r2.InvalidArgument;
              case 401:
                return r2.Unauthenticated;
              case 403:
                return r2.PermissionDenied;
              case 404:
                return r2.NotFound;
              case 409:
                return r2.Aborted;
              case 412:
                return r2.FailedPrecondition;
              case 429:
                return r2.ResourceExhausted;
              case 499:
                return r2.Canceled;
              case 500:
                return r2.Unknown;
              case 501:
                return r2.Unimplemented;
              case 503:
                return r2.Unavailable;
              case 504:
                return r2.DeadlineExceeded;
              default:
                return r2.Unknown;
            }
          };
        }, 934: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.client = void 0;
          var n4 = r2(65), o3 = r2(617), s4 = r2(8), i4 = r2(346), a2 = r2(57), u3 = r2(882);
          t4.client = function(e3, t5) {
            return new d6(e3, t5);
          };
          var d6 = function() {
            function e3(e4, t5) {
              this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o3.ChunkParser(), this.methodDefinition = e4, this.props = t5, this.createTransport();
            }
            return e3.prototype.createTransport = function() {
              var e4 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t5 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e4, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
              this.props.transport ? this.transport = this.props.transport(t5) : this.transport = a2.makeDefaultTransport(t5);
            }, e3.prototype.onTransportHeaders = function(e4, t5) {
              if (this.props.debug && i4.debug("onHeaders", e4, t5), this.closed)
                this.props.debug && i4.debug("grpc.onHeaders received after request was closed - ignoring");
              else if (0 === t5)
                ;
              else {
                this.responseHeaders = e4, this.props.debug && i4.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
                var r3 = c3(e4);
                this.props.debug && i4.debug("onHeaders.gRPCStatus", r3);
                var n5 = r3 && r3 >= 0 ? r3 : s4.httpStatusToCode(t5);
                this.props.debug && i4.debug("onHeaders.code", n5);
                var o4 = e4.get("grpc-message") || [];
                if (this.props.debug && i4.debug("onHeaders.gRPCMessage", o4), this.rawOnHeaders(e4), n5 !== s4.Code.OK) {
                  var a3 = this.decodeGRPCStatus(o4[0]);
                  this.rawOnError(n5, a3, e4);
                }
              }
            }, e3.prototype.onTransportChunk = function(e4) {
              var t5 = this;
              if (this.closed)
                this.props.debug && i4.debug("grpc.onChunk received after request was closed - ignoring");
              else {
                var r3 = [];
                try {
                  r3 = this.parser.parse(e4);
                } catch (e5) {
                  return this.props.debug && i4.debug("onChunk.parsing error", e5, e5.message), void this.rawOnError(s4.Code.Internal, "parsing error: " + e5.message);
                }
                r3.forEach(function(e5) {
                  if (e5.chunkType === o3.ChunkType.MESSAGE) {
                    var r4 = t5.methodDefinition.responseType.deserializeBinary(e5.data);
                    t5.rawOnMessage(r4);
                  } else
                    e5.chunkType === o3.ChunkType.TRAILERS && (t5.responseHeaders ? (t5.responseTrailers = new n4.Metadata(e5.trailers), t5.props.debug && i4.debug("onChunk.trailers", t5.responseTrailers)) : (t5.responseHeaders = new n4.Metadata(e5.trailers), t5.rawOnHeaders(t5.responseHeaders)));
                });
              }
            }, e3.prototype.onTransportEnd = function() {
              if (this.props.debug && i4.debug("grpc.onEnd"), this.closed)
                this.props.debug && i4.debug("grpc.onEnd received after request was closed - ignoring");
              else if (void 0 !== this.responseTrailers) {
                var e4 = c3(this.responseTrailers);
                if (null !== e4) {
                  var t5 = this.responseTrailers.get("grpc-message"), r3 = this.decodeGRPCStatus(t5[0]);
                  this.rawOnEnd(e4, r3, this.responseTrailers);
                } else
                  this.rawOnError(s4.Code.Internal, "Response closed without grpc-status (Trailers provided)");
              } else {
                if (void 0 === this.responseHeaders)
                  return void this.rawOnError(s4.Code.Unknown, "Response closed without headers");
                var n5 = c3(this.responseHeaders), o4 = this.responseHeaders.get("grpc-message");
                if (this.props.debug && i4.debug("grpc.headers only response ", n5, o4), null === n5)
                  return void this.rawOnEnd(s4.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
                var a3 = this.decodeGRPCStatus(o4[0]);
                this.rawOnEnd(n5, a3, this.responseHeaders);
              }
            }, e3.prototype.decodeGRPCStatus = function(e4) {
              if (!e4)
                return "";
              try {
                return decodeURIComponent(e4);
              } catch (t5) {
                return e4;
              }
            }, e3.prototype.rawOnEnd = function(e4, t5, r3) {
              var n5 = this;
              this.props.debug && i4.debug("rawOnEnd", e4, t5, r3), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(o4) {
                if (!n5.closed)
                  try {
                    o4(e4, t5, r3);
                  } catch (e5) {
                    setTimeout(function() {
                      throw e5;
                    }, 0);
                  }
              }));
            }, e3.prototype.rawOnHeaders = function(e4) {
              this.props.debug && i4.debug("rawOnHeaders", e4), this.completed || this.onHeadersCallbacks.forEach(function(t5) {
                try {
                  t5(e4);
                } catch (e5) {
                  setTimeout(function() {
                    throw e5;
                  }, 0);
                }
              });
            }, e3.prototype.rawOnError = function(e4, t5, r3) {
              var o4 = this;
              void 0 === r3 && (r3 = new n4.Metadata()), this.props.debug && i4.debug("rawOnError", e4, t5), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(n5) {
                if (!o4.closed)
                  try {
                    n5(e4, t5, r3);
                  } catch (e5) {
                    setTimeout(function() {
                      throw e5;
                    }, 0);
                  }
              }));
            }, e3.prototype.rawOnMessage = function(e4) {
              var t5 = this;
              this.props.debug && i4.debug("rawOnMessage", e4.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(r3) {
                if (!t5.closed)
                  try {
                    r3(e4);
                  } catch (e5) {
                    setTimeout(function() {
                      throw e5;
                    }, 0);
                  }
              });
            }, e3.prototype.onHeaders = function(e4) {
              this.onHeadersCallbacks.push(e4);
            }, e3.prototype.onMessage = function(e4) {
              this.onMessageCallbacks.push(e4);
            }, e3.prototype.onEnd = function(e4) {
              this.onEndCallbacks.push(e4);
            }, e3.prototype.start = function(e4) {
              if (this.started)
                throw new Error("Client already started - cannot .start()");
              this.started = true;
              var t5 = new n4.Metadata(e4 || {});
              t5.set("content-type", "application/grpc-web+proto"), t5.set("x-grpc-web", "1"), this.transport.start(t5);
            }, e3.prototype.send = function(e4) {
              if (!this.started)
                throw new Error("Client not started - .start() must be called before .send()");
              if (this.closed)
                throw new Error("Client already closed - cannot .send()");
              if (this.finishedSending)
                throw new Error("Client already finished sending - cannot .send()");
              if (!this.methodDefinition.requestStream && this.sentFirstMessage)
                throw new Error("Message already sent for non-client-streaming method - cannot .send()");
              this.sentFirstMessage = true;
              var t5 = u3.frameRequest(e4);
              this.transport.sendMessage(t5);
            }, e3.prototype.finishSend = function() {
              if (!this.started)
                throw new Error("Client not started - .finishSend() must be called before .close()");
              if (this.closed)
                throw new Error("Client already closed - cannot .send()");
              if (this.finishedSending)
                throw new Error("Client already finished sending - cannot .finishSend()");
              this.finishedSending = true, this.transport.finishSend();
            }, e3.prototype.close = function() {
              if (!this.started)
                throw new Error("Client not started - .start() must be called before .close()");
              if (this.closed)
                throw new Error("Client already closed - cannot .close()");
              this.closed = true, this.props.debug && i4.debug("request.abort aborting request"), this.transport.cancel();
            }, e3;
          }();
          function c3(e3) {
            var t5 = e3.get("grpc-status") || [];
            if (t5.length > 0)
              try {
                var r3 = t5[0];
                return parseInt(r3, 10);
              } catch (e4) {
                return null;
              }
            return null;
          }
        }, 346: function(e2, t4) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.debug = void 0, t4.debug = function() {
            for (var e3 = [], t5 = 0; t5 < arguments.length; t5++)
              e3[t5] = arguments[t5];
            console.debug ? console.debug.apply(null, e3) : console.log.apply(null, e3);
          };
        }, 607: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.grpc = void 0;
          var n4, o3 = r2(418), s4 = r2(57), i4 = r2(229), a2 = r2(540), u3 = r2(210), d6 = r2(859), c3 = r2(8), p2 = r2(938), h6 = r2(35), f5 = r2(934);
          (n4 = t4.grpc || (t4.grpc = {})).setDefaultTransport = s4.setDefaultTransportFactory, n4.CrossBrowserHttpTransport = d6.CrossBrowserHttpTransport, n4.FetchReadableStreamTransport = i4.FetchReadableStreamTransport, n4.XhrTransport = u3.XhrTransport, n4.WebsocketTransport = a2.WebsocketTransport, n4.Code = c3.Code, n4.Metadata = o3.BrowserHeaders, n4.client = function(e3, t5) {
            return f5.client(e3, t5);
          }, n4.invoke = p2.invoke, n4.unary = h6.unary;
        }, 938: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.invoke = void 0;
          var n4 = r2(934);
          t4.invoke = function(e3, t5) {
            if (e3.requestStream)
              throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
            var r3 = n4.client(e3, { host: t5.host, transport: t5.transport, debug: t5.debug });
            return t5.onHeaders && r3.onHeaders(t5.onHeaders), t5.onMessage && r3.onMessage(t5.onMessage), t5.onEnd && r3.onEnd(t5.onEnd), r3.start(t5.metadata), r3.send(t5.request), r3.finishSend(), { close: function() {
              r3.close();
            } };
          };
        }, 65: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.Metadata = void 0;
          var n4 = r2(418);
          Object.defineProperty(t4, "Metadata", { enumerable: true, get: function() {
            return n4.BrowserHeaders;
          } });
        }, 57: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.makeDefaultTransport = t4.setDefaultTransportFactory = void 0;
          var n4 = r2(859), o3 = function(e3) {
            return n4.CrossBrowserHttpTransport({ withCredentials: false })(e3);
          };
          t4.setDefaultTransportFactory = function(e3) {
            o3 = e3;
          }, t4.makeDefaultTransport = function(e3) {
            return o3(e3);
          };
        }, 229: function(e2, t4, r2) {
          "use strict";
          var n4 = this && this.__assign || function() {
            return (n4 = Object.assign || function(e3) {
              for (var t5, r3 = 1, n5 = arguments.length; r3 < n5; r3++)
                for (var o4 in t5 = arguments[r3])
                  Object.prototype.hasOwnProperty.call(t5, o4) && (e3[o4] = t5[o4]);
              return e3;
            }).apply(this, arguments);
          };
          Object.defineProperty(t4, "__esModule", { value: true }), t4.detectFetchSupport = t4.FetchReadableStreamTransport = void 0;
          var o3 = r2(65), s4 = r2(346);
          t4.FetchReadableStreamTransport = function(e3) {
            return function(t5) {
              return function(e4, t6) {
                return e4.debug && s4.debug("fetchRequest", e4), new i4(e4, t6);
              }(t5, e3);
            };
          };
          var i4 = function() {
            function e3(e4, t5) {
              this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e4, this.init = t5;
            }
            return e3.prototype.pump = function(e4, t5) {
              var r3 = this;
              if (this.reader = e4, this.cancelled)
                return this.options.debug && s4.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(e5) {
                  r3.options.debug && s4.debug("Fetch.pump.reader.cancel exception", e5);
                });
              this.reader.read().then(function(e5) {
                if (e5.done)
                  return r3.options.onEnd(), t5;
                r3.options.onChunk(e5.value), r3.pump(r3.reader, t5);
              }).catch(function(e5) {
                r3.cancelled ? r3.options.debug && s4.debug("Fetch.catch - request cancelled") : (r3.cancelled = true, r3.options.debug && s4.debug("Fetch.catch", e5.message), r3.options.onEnd(e5));
              });
            }, e3.prototype.send = function(e4) {
              var t5 = this;
              fetch(this.options.url, n4(n4({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e4, signal: this.controller && this.controller.signal })).then(function(e5) {
                if (t5.options.debug && s4.debug("Fetch.response", e5), t5.options.onHeaders(new o3.Metadata(e5.headers), e5.status), !e5.body)
                  return e5;
                t5.pump(e5.body.getReader(), e5);
              }).catch(function(e5) {
                t5.cancelled ? t5.options.debug && s4.debug("Fetch.catch - request cancelled") : (t5.cancelled = true, t5.options.debug && s4.debug("Fetch.catch", e5.message), t5.options.onEnd(e5));
              });
            }, e3.prototype.sendMessage = function(e4) {
              this.send(e4);
            }, e3.prototype.finishSend = function() {
            }, e3.prototype.start = function(e4) {
              this.metadata = e4;
            }, e3.prototype.cancel = function() {
              var e4 = this;
              this.cancelled ? this.options.debug && s4.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s4.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s4.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s4.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(t5) {
                e4.options.debug && s4.debug("Fetch.cancel.reader.cancel exception", t5);
              })) : this.options.debug && s4.debug("Fetch.cancel before reader"));
            }, e3;
          }();
          t4.detectFetchSupport = function() {
            return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
          };
        }, 859: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.CrossBrowserHttpTransport = void 0;
          var n4 = r2(229), o3 = r2(210);
          t4.CrossBrowserHttpTransport = function(e3) {
            if (n4.detectFetchSupport()) {
              var t5 = { credentials: e3.withCredentials ? "include" : "same-origin" };
              return n4.FetchReadableStreamTransport(t5);
            }
            return o3.XhrTransport({ withCredentials: e3.withCredentials });
          };
        }, 210: function(e2, t4, r2) {
          "use strict";
          var n4, o3 = this && this.__extends || (n4 = function(e3, t5) {
            return (n4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t6) {
              e4.__proto__ = t6;
            } || function(e4, t6) {
              for (var r3 in t6)
                Object.prototype.hasOwnProperty.call(t6, r3) && (e4[r3] = t6[r3]);
            })(e3, t5);
          }, function(e3, t5) {
            function r3() {
              this.constructor = e3;
            }
            n4(e3, t5), e3.prototype = null === t5 ? Object.create(t5) : (r3.prototype = t5.prototype, new r3());
          });
          Object.defineProperty(t4, "__esModule", { value: true }), t4.stringToArrayBuffer = t4.MozChunkedArrayBufferXHR = t4.XHR = t4.XhrTransport = void 0;
          var s4 = r2(65), i4 = r2(346), a2 = r2(849);
          t4.XhrTransport = function(e3) {
            return function(t5) {
              if (a2.detectMozXHRSupport())
                return new d6(t5, e3);
              if (a2.detectXHROverrideMimeTypeSupport())
                return new u3(t5, e3);
              throw new Error("This environment's XHR implementation cannot support binary transfer.");
            };
          };
          var u3 = function() {
            function e3(e4, t5) {
              this.options = e4, this.init = t5;
            }
            return e3.prototype.onProgressEvent = function() {
              this.options.debug && i4.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
              var e4 = this.xhr.response.substr(this.index);
              this.index = this.xhr.response.length;
              var t5 = p2(e4);
              this.options.onChunk(t5);
            }, e3.prototype.onLoadEvent = function() {
              this.options.debug && i4.debug("XHR.onLoadEvent"), this.options.onEnd();
            }, e3.prototype.onStateChange = function() {
              this.options.debug && i4.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s4.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
            }, e3.prototype.sendMessage = function(e4) {
              this.xhr.send(e4);
            }, e3.prototype.finishSend = function() {
            }, e3.prototype.start = function(e4) {
              var t5 = this;
              this.metadata = e4;
              var r3 = new XMLHttpRequest();
              this.xhr = r3, r3.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(e5, t6) {
                r3.setRequestHeader(e5, t6.join(", "));
              }), r3.withCredentials = Boolean(this.init.withCredentials), r3.addEventListener("readystatechange", this.onStateChange.bind(this)), r3.addEventListener("progress", this.onProgressEvent.bind(this)), r3.addEventListener("loadend", this.onLoadEvent.bind(this)), r3.addEventListener("error", function(e5) {
                t5.options.debug && i4.debug("XHR.error", e5), t5.options.onEnd(e5.error);
              });
            }, e3.prototype.configureXhr = function() {
              this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
            }, e3.prototype.cancel = function() {
              this.options.debug && i4.debug("XHR.abort"), this.xhr.abort();
            }, e3;
          }();
          t4.XHR = u3;
          var d6 = function(e3) {
            function t5() {
              return null !== e3 && e3.apply(this, arguments) || this;
            }
            return o3(t5, e3), t5.prototype.configureXhr = function() {
              this.options.debug && i4.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
            }, t5.prototype.onProgressEvent = function() {
              var e4 = this.xhr.response;
              this.options.debug && i4.debug("MozXHR.onProgressEvent: ", new Uint8Array(e4)), this.options.onChunk(new Uint8Array(e4));
            }, t5;
          }(u3);
          function c3(e3, t5) {
            var r3 = e3.charCodeAt(t5);
            if (r3 >= 55296 && r3 <= 56319) {
              var n5 = e3.charCodeAt(t5 + 1);
              n5 >= 56320 && n5 <= 57343 && (r3 = 65536 + (r3 - 55296 << 10) + (n5 - 56320));
            }
            return r3;
          }
          function p2(e3) {
            for (var t5 = new Uint8Array(e3.length), r3 = 0, n5 = 0; n5 < e3.length; n5++) {
              var o4 = String.prototype.codePointAt ? e3.codePointAt(n5) : c3(e3, n5);
              t5[r3++] = 255 & o4;
            }
            return t5;
          }
          t4.MozChunkedArrayBufferXHR = d6, t4.stringToArrayBuffer = p2;
        }, 849: function(e2, t4) {
          "use strict";
          var r2;
          function n4() {
            if (void 0 !== r2)
              return r2;
            if (XMLHttpRequest) {
              r2 = new XMLHttpRequest();
              try {
                r2.open("GET", "https://localhost");
              } catch (e3) {
              }
            }
            return r2;
          }
          function o3(e3) {
            var t5 = n4();
            if (!t5)
              return false;
            try {
              return t5.responseType = e3, t5.responseType === e3;
            } catch (e4) {
            }
            return false;
          }
          Object.defineProperty(t4, "__esModule", { value: true }), t4.detectXHROverrideMimeTypeSupport = t4.detectMozXHRSupport = t4.xhrSupportsResponseType = void 0, t4.xhrSupportsResponseType = o3, t4.detectMozXHRSupport = function() {
            return "undefined" != typeof XMLHttpRequest && o3("moz-chunked-arraybuffer");
          }, t4.detectXHROverrideMimeTypeSupport = function() {
            return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
          };
        }, 540: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.WebsocketTransport = void 0;
          var n4, o3 = r2(346), s4 = r2(617);
          !function(e3) {
            e3[e3.FINISH_SEND = 1] = "FINISH_SEND";
          }(n4 || (n4 = {}));
          var i4 = new Uint8Array([1]);
          t4.WebsocketTransport = function() {
            return function(e3) {
              return function(e4) {
                e4.debug && o3.debug("websocketRequest", e4);
                var t5, r3 = function(e5) {
                  if ("https://" === e5.substr(0, 8))
                    return "wss://" + e5.substr(8);
                  if ("http://" === e5.substr(0, 7))
                    return "ws://" + e5.substr(7);
                  throw new Error("Websocket transport constructed with non-https:// or http:// host.");
                }(e4.url), a2 = [];
                function u3(e5) {
                  if (e5 === n4.FINISH_SEND)
                    t5.send(i4);
                  else {
                    var r4 = e5, o4 = new Int8Array(r4.byteLength + 1);
                    o4.set(new Uint8Array([0])), o4.set(r4, 1), t5.send(o4);
                  }
                }
                return { sendMessage: function(e5) {
                  t5 && t5.readyState !== t5.CONNECTING ? u3(e5) : a2.push(e5);
                }, finishSend: function() {
                  t5 && t5.readyState !== t5.CONNECTING ? u3(n4.FINISH_SEND) : a2.push(n4.FINISH_SEND);
                }, start: function(n5) {
                  (t5 = new WebSocket(r3, ["grpc-websockets"])).binaryType = "arraybuffer", t5.onopen = function() {
                    var r4;
                    e4.debug && o3.debug("websocketRequest.onopen"), t5.send((r4 = "", n5.forEach(function(e5, t6) {
                      r4 += e5 + ": " + t6.join(", ") + "\r\n";
                    }), s4.encodeASCII(r4))), a2.forEach(function(e5) {
                      u3(e5);
                    });
                  }, t5.onclose = function(t6) {
                    e4.debug && o3.debug("websocketRequest.onclose", t6), e4.onEnd();
                  }, t5.onerror = function(t6) {
                    e4.debug && o3.debug("websocketRequest.onerror", t6);
                  }, t5.onmessage = function(t6) {
                    e4.onChunk(new Uint8Array(t6.data));
                  };
                }, cancel: function() {
                  e4.debug && o3.debug("websocket.abort"), t5.close();
                } };
              }(e3);
            };
          };
        }, 35: function(e2, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.unary = void 0;
          var n4 = r2(65), o3 = r2(934);
          t4.unary = function(e3, t5) {
            if (e3.responseStream)
              throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
            if (e3.requestStream)
              throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
            var r3 = null, s4 = null, i4 = o3.client(e3, { host: t5.host, transport: t5.transport, debug: t5.debug });
            return i4.onHeaders(function(e4) {
              r3 = e4;
            }), i4.onMessage(function(e4) {
              s4 = e4;
            }), i4.onEnd(function(e4, o4, i5) {
              t5.onEnd({ status: e4, statusMessage: o4, headers: r3 || new n4.Metadata(), message: s4, trailers: i5 });
            }), i4.start(t5.metadata), i4.send(t5.request), i4.finishSend(), { close: function() {
              i4.close();
            } };
          };
        }, 882: function(e2, t4) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.frameRequest = void 0, t4.frameRequest = function(e3) {
            var t5 = e3.serializeBinary(), r2 = new ArrayBuffer(t5.byteLength + 5);
            return new DataView(r2, 1, 4).setUint32(0, t5.length, false), new Uint8Array(r2, 5).set(t5), new Uint8Array(r2);
          };
        } }, t3 = {}, function r2(n4) {
          if (t3[n4])
            return t3[n4].exports;
          var o3 = t3[n4] = { exports: {} };
          return e[n4].call(o3.exports, o3, o3.exports, r2), o3.exports;
        }(607);
        var e, t3;
      });
    }
  });

  // node_modules/abort-controller-x/lib/AbortError.js
  var require_AbortError = __commonJS({
    "node_modules/abort-controller-x/lib/AbortError.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.catchAbortError = exports2.rethrowAbortError = exports2.throwIfAborted = exports2.isAbortError = exports2.AbortError = void 0;
      var AbortError = class extends Error {
        constructor() {
          super("The operation has been aborted");
          this.message = "The operation has been aborted";
          this.name = "AbortError";
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, this.constructor);
          }
        }
      };
      exports2.AbortError = AbortError;
      function isAbortError(error) {
        return typeof error === "object" && error !== null && error.name === "AbortError";
      }
      exports2.isAbortError = isAbortError;
      function throwIfAborted(signal) {
        if (signal.aborted) {
          throw new AbortError();
        }
      }
      exports2.throwIfAborted = throwIfAborted;
      function rethrowAbortError(error) {
        if (isAbortError(error)) {
          throw error;
        }
        return;
      }
      exports2.rethrowAbortError = rethrowAbortError;
      function catchAbortError(error) {
        if (isAbortError(error)) {
          return;
        }
        throw error;
      }
      exports2.catchAbortError = catchAbortError;
    }
  });

  // node_modules/abort-controller-x/lib/execute.js
  var require_execute = __commonJS({
    "node_modules/abort-controller-x/lib/execute.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.execute = void 0;
      var AbortError_1 = require_AbortError();
      function execute(signal, executor) {
        return new Promise((resolve, reject) => {
          if (signal.aborted) {
            reject(new AbortError_1.AbortError());
            return;
          }
          let removeAbortListener;
          let finished = false;
          function finish() {
            if (!finished) {
              finished = true;
              if (removeAbortListener != null) {
                removeAbortListener();
              }
            }
          }
          const callback = executor((value) => {
            resolve(value);
            finish();
          }, (reason) => {
            reject(reason);
            finish();
          });
          if (!finished) {
            const listener = () => {
              const callbackResult = callback();
              if (callbackResult == null) {
                reject(new AbortError_1.AbortError());
              } else {
                callbackResult.then(() => {
                  reject(new AbortError_1.AbortError());
                }, (reason) => {
                  reject(reason);
                });
              }
              finish();
            };
            signal.addEventListener("abort", listener);
            removeAbortListener = () => {
              signal.removeEventListener("abort", listener);
            };
          }
        });
      }
      exports2.execute = execute;
    }
  });

  // node_modules/abort-controller-x/lib/abortable.js
  var require_abortable = __commonJS({
    "node_modules/abort-controller-x/lib/abortable.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.abortable = void 0;
      var execute_1 = require_execute();
      function abortable(signal, promise) {
        if (signal.aborted) {
          const noop4 = () => {
          };
          promise.then(noop4, noop4);
        }
        return (0, execute_1.execute)(signal, (resolve, reject) => {
          promise.then(resolve, reject);
          return () => {
          };
        });
      }
      exports2.abortable = abortable;
    }
  });

  // node_modules/abort-controller-x/lib/delay.js
  var require_delay = __commonJS({
    "node_modules/abort-controller-x/lib/delay.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.delay = void 0;
      var execute_1 = require_execute();
      function delay2(signal, dueTime) {
        return (0, execute_1.execute)(signal, (resolve) => {
          const ms = typeof dueTime === "number" ? dueTime : dueTime.getTime() - Date.now();
          const timer3 = setTimeout(resolve, ms);
          return () => {
            clearTimeout(timer3);
          };
        });
      }
      exports2.delay = delay2;
    }
  });

  // node_modules/abort-controller-x/lib/forever.js
  var require_forever = __commonJS({
    "node_modules/abort-controller-x/lib/forever.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.forever = void 0;
      var execute_1 = require_execute();
      function forever(signal) {
        return (0, execute_1.execute)(signal, () => () => {
        });
      }
      exports2.forever = forever;
    }
  });

  // node_modules/abort-controller-x/lib/waitForEvent.js
  var require_waitForEvent = __commonJS({
    "node_modules/abort-controller-x/lib/waitForEvent.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.waitForEvent = void 0;
      var execute_1 = require_execute();
      function waitForEvent(signal, target, eventName, options) {
        return (0, execute_1.execute)(signal, (resolve) => {
          let unlisten;
          let finished = false;
          const handler = (...args) => {
            resolve(args.length > 1 ? args : args[0]);
            finished = true;
            if (unlisten != null) {
              unlisten();
            }
          };
          unlisten = listen(target, eventName, handler, options);
          if (finished) {
            unlisten();
          }
          return () => {
            finished = true;
            if (unlisten != null) {
              unlisten();
            }
          };
        });
      }
      exports2.waitForEvent = waitForEvent;
      function listen(target, eventName, handler, options) {
        if (isEventTarget2(target)) {
          target.addEventListener(eventName, handler, options);
          return () => target.removeEventListener(eventName, handler, options);
        }
        if (isJQueryStyleEventEmitter2(target)) {
          target.on(eventName, handler);
          return () => target.off(eventName, handler);
        }
        if (isNodeStyleEventEmitter2(target)) {
          target.addListener(eventName, handler);
          return () => target.removeListener(eventName, handler);
        }
        throw new Error("Invalid event target");
      }
      function isNodeStyleEventEmitter2(sourceObj) {
        return isFunction3(sourceObj.addListener) && isFunction3(sourceObj.removeListener);
      }
      function isJQueryStyleEventEmitter2(sourceObj) {
        return isFunction3(sourceObj.on) && isFunction3(sourceObj.off);
      }
      function isEventTarget2(sourceObj) {
        return isFunction3(sourceObj.addEventListener) && isFunction3(sourceObj.removeEventListener);
      }
      var isFunction3 = (obj) => typeof obj === "function";
    }
  });

  // node_modules/abort-controller-x/lib/all.js
  var require_all = __commonJS({
    "node_modules/abort-controller-x/lib/all.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.all = void 0;
      var AbortError_1 = require_AbortError();
      function all(signal, executor) {
        return new Promise((resolve, reject) => {
          if (signal.aborted) {
            reject(new AbortError_1.AbortError());
            return;
          }
          const innerAbortController = new AbortController();
          const promises = executor(innerAbortController.signal);
          if (promises.length === 0) {
            resolve([]);
            return;
          }
          const abortListener = () => {
            innerAbortController.abort();
          };
          signal.addEventListener("abort", abortListener);
          let rejection;
          const results = new Array(promises.length);
          let settledCount = 0;
          function settled() {
            settledCount += 1;
            if (settledCount === promises.length) {
              signal.removeEventListener("abort", abortListener);
              if (rejection != null) {
                reject(rejection.reason);
              } else {
                resolve(results);
              }
            }
          }
          for (const [i4, promise] of promises.entries()) {
            promise.then((value) => {
              results[i4] = value;
              settled();
            }, (reason) => {
              innerAbortController.abort();
              if (rejection == null || !(0, AbortError_1.isAbortError)(reason) && (0, AbortError_1.isAbortError)(rejection.reason)) {
                rejection = { reason };
              }
              settled();
            });
          }
        });
      }
      exports2.all = all;
    }
  });

  // node_modules/abort-controller-x/lib/race.js
  var require_race = __commonJS({
    "node_modules/abort-controller-x/lib/race.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.race = void 0;
      var AbortError_1 = require_AbortError();
      function race(signal, executor) {
        return new Promise((resolve, reject) => {
          if (signal.aborted) {
            reject(new AbortError_1.AbortError());
            return;
          }
          const innerAbortController = new AbortController();
          const promises = executor(innerAbortController.signal);
          const abortListener = () => {
            innerAbortController.abort();
          };
          signal.addEventListener("abort", abortListener);
          let settledCount = 0;
          function settled(result2) {
            innerAbortController.abort();
            settledCount += 1;
            if (settledCount === promises.length) {
              signal.removeEventListener("abort", abortListener);
              if (result2.status === "fulfilled") {
                resolve(result2.value);
              } else {
                reject(result2.reason);
              }
            }
          }
          let result;
          for (const promise of promises) {
            promise.then((value) => {
              if (result == null) {
                result = { status: "fulfilled", value };
              }
              settled(result);
            }, (reason) => {
              if (result == null || !(0, AbortError_1.isAbortError)(reason) && (result.status === "fulfilled" || (0, AbortError_1.isAbortError)(result.reason))) {
                result = { status: "rejected", reason };
              }
              settled(result);
            });
          }
        });
      }
      exports2.race = race;
    }
  });

  // node_modules/abort-controller-x/lib/retry.js
  var require_retry = __commonJS({
    "node_modules/abort-controller-x/lib/retry.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.retry = void 0;
      var delay_1 = require_delay();
      var AbortError_1 = require_AbortError();
      async function retry(signal, fn, options = {}) {
        const { baseMs = 1e3, maxDelayMs = 3e4, onError, maxAttempts = Infinity } = options;
        let attempt = 0;
        const reset2 = () => {
          attempt = -1;
        };
        while (true) {
          try {
            return await fn(signal, attempt, reset2);
          } catch (error) {
            (0, AbortError_1.rethrowAbortError)(error);
            if (attempt >= maxAttempts) {
              throw error;
            }
            let delayMs;
            if (attempt === -1) {
              delayMs = 0;
            } else {
              const backoff = Math.min(maxDelayMs, Math.pow(2, attempt) * baseMs);
              delayMs = Math.round(backoff * (1 + Math.random()) / 2);
            }
            if (onError) {
              onError(error, attempt, delayMs);
            }
            if (delayMs !== 0) {
              await (0, delay_1.delay)(signal, delayMs);
            }
            attempt += 1;
          }
        }
      }
      exports2.retry = retry;
    }
  });

  // node_modules/abort-controller-x/lib/spawn.js
  var require_spawn = __commonJS({
    "node_modules/abort-controller-x/lib/spawn.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.spawn = void 0;
      var AbortError_1 = require_AbortError();
      function spawn(signal, fn) {
        if (signal.aborted) {
          return Promise.reject(new AbortError_1.AbortError());
        }
        const deferredFunctions = [];
        const spawnAbortController = new AbortController();
        const spawnSignal = spawnAbortController.signal;
        const abortSpawn = () => {
          spawnAbortController.abort();
        };
        signal.addEventListener("abort", abortSpawn);
        const removeAbortListener = () => {
          signal.removeEventListener("abort", abortSpawn);
        };
        const tasks = /* @__PURE__ */ new Set();
        const abortTasks = () => {
          for (const task of tasks) {
            task.abort();
          }
        };
        spawnSignal.addEventListener("abort", abortTasks);
        const removeSpawnAbortListener = () => {
          spawnSignal.removeEventListener("abort", abortTasks);
        };
        let promise = new Promise((resolve, reject) => {
          let result;
          let failure;
          fork((signal2) => fn(signal2, {
            defer(fn2) {
              deferredFunctions.push(fn2);
            },
            fork
          })).join().then((value) => {
            spawnAbortController.abort();
            result = { value };
          }, (error) => {
            spawnAbortController.abort();
            if (!(0, AbortError_1.isAbortError)(error) || failure == null) {
              failure = { error };
            }
          });
          function fork(forkFn) {
            if (spawnSignal.aborted) {
              return {
                abort() {
                },
                async join() {
                  throw new AbortError_1.AbortError();
                }
              };
            }
            const taskAbortController = new AbortController();
            const taskSignal = taskAbortController.signal;
            const taskPromise = forkFn(taskSignal);
            const task = {
              abort() {
                taskAbortController.abort();
              },
              join: () => taskPromise
            };
            tasks.add(task);
            taskPromise.catch(AbortError_1.catchAbortError).catch((error) => {
              failure = { error };
              spawnAbortController.abort();
            }).finally(() => {
              tasks.delete(task);
              if (tasks.size === 0) {
                if (failure != null) {
                  reject(failure.error);
                } else {
                  resolve(result.value);
                }
              }
            });
            return task;
          }
        });
        promise = promise.finally(() => {
          removeAbortListener();
          removeSpawnAbortListener();
          let deferPromise = Promise.resolve();
          for (let i4 = deferredFunctions.length - 1; i4 >= 0; i4--) {
            deferPromise = deferPromise.finally(deferredFunctions[i4]);
          }
          return deferPromise;
        });
        return promise;
      }
      exports2.spawn = spawn;
    }
  });

  // node_modules/abort-controller-x/lib/run.js
  var require_run = __commonJS({
    "node_modules/abort-controller-x/lib/run.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.run = void 0;
      var AbortError_1 = require_AbortError();
      function run3(fn) {
        const abortController = new AbortController();
        const promise = fn(abortController.signal).catch(AbortError_1.catchAbortError);
        return () => {
          abortController.abort();
          return promise;
        };
      }
      exports2.run = run3;
    }
  });

  // node_modules/abort-controller-x/lib/index.js
  var require_lib30 = __commonJS({
    "node_modules/abort-controller-x/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m5, exports3) {
        for (var p2 in m5)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m5, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_abortable(), exports2);
      __exportStar(require_AbortError(), exports2);
      __exportStar(require_delay(), exports2);
      __exportStar(require_execute(), exports2);
      __exportStar(require_forever(), exports2);
      __exportStar(require_waitForEvent(), exports2);
      __exportStar(require_all(), exports2);
      __exportStar(require_race(), exports2);
      __exportStar(require_retry(), exports2);
      __exportStar(require_spawn(), exports2);
      __exportStar(require_run(), exports2);
    }
  });

  // node_modules/nice-grpc-web/lib/utils/AsyncSink.js
  var require_AsyncSink = __commonJS({
    "node_modules/nice-grpc-web/lib/utils/AsyncSink.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AsyncSink = void 0;
      var ARRAY_VALUE = "value";
      var ARRAY_ERROR = "error";
      var AsyncSink = class {
        constructor() {
          this._ended = false;
          this._values = [];
          this._resolvers = [];
        }
        [Symbol.asyncIterator]() {
          return this;
        }
        write(value) {
          this._push({ type: ARRAY_VALUE, value });
        }
        error(error) {
          this._push({ type: ARRAY_ERROR, error });
        }
        _push(item) {
          if (this._ended) {
            throw new Error("AsyncSink already ended");
          }
          if (this._resolvers.length > 0) {
            const { resolve, reject } = this._resolvers.shift();
            if (item.type === ARRAY_ERROR) {
              reject(item.error);
            } else {
              resolve({ done: false, value: item.value });
            }
          } else {
            this._values.push(item);
          }
        }
        next() {
          if (this._values.length > 0) {
            const { type, value, error } = this._values.shift();
            if (type === ARRAY_ERROR) {
              return Promise.reject(error);
            } else {
              return Promise.resolve({ done: false, value });
            }
          }
          if (this._ended) {
            return Promise.resolve({ done: true });
          }
          return new Promise((resolve, reject) => {
            this._resolvers.push({ resolve, reject });
          });
        }
        end() {
          while (this._resolvers.length > 0) {
            this._resolvers.shift().resolve({ done: true });
          }
          this._ended = true;
        }
      };
      exports2.AsyncSink = AsyncSink;
    }
  });

  // node_modules/nice-grpc-web/lib/utils/isAsyncIterable.js
  var require_isAsyncIterable = __commonJS({
    "node_modules/nice-grpc-web/lib/utils/isAsyncIterable.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isAsyncIterable = void 0;
      function isAsyncIterable2(value) {
        return value != null && Symbol.asyncIterator in value;
      }
      exports2.isAsyncIterable = isAsyncIterable2;
    }
  });

  // node_modules/js-base64/base64.js
  var require_base642 = __commonJS({
    "node_modules/js-base64/base64.js"(exports2, module2) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (
          // cf. https://github.com/dankogai/js-base64/issues/119
          function() {
            var _Base64 = global2.Base64;
            var gBase64 = factory();
            gBase64.noConflict = function() {
              global2.Base64 = _Base64;
              return gBase64;
            };
            if (global2.Meteor) {
              Base64 = gBase64;
            }
            global2.Base64 = gBase64;
          }()
        );
      })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports2, function() {
        "use strict";
        var version7 = "3.7.5";
        var VERSION = version7;
        var _hasatob = typeof atob === "function";
        var _hasbtoa = typeof btoa === "function";
        var _hasBuffer = typeof Buffer === "function";
        var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
        var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
        var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var b64chs = Array.prototype.slice.call(b64ch);
        var b64tab = function(a2) {
          var tab = {};
          a2.forEach(function(c3, i4) {
            return tab[c3] = i4;
          });
          return tab;
        }(b64chs);
        var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
        var _fromCC = String.fromCharCode.bind(String);
        var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it) {
          return new Uint8Array(Array.prototype.slice.call(it, 0));
        };
        var _mkUriSafe = function(src) {
          return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
            return m0 == "+" ? "-" : "_";
          });
        };
        var _tidyB64 = function(s4) {
          return s4.replace(/[^A-Za-z0-9\+\/]/g, "");
        };
        var btoaPolyfill = function(bin) {
          var u322, c0, c1, c22, asc = "";
          var pad2 = bin.length % 3;
          for (var i4 = 0; i4 < bin.length; ) {
            if ((c0 = bin.charCodeAt(i4++)) > 255 || (c1 = bin.charCodeAt(i4++)) > 255 || (c22 = bin.charCodeAt(i4++)) > 255)
              throw new TypeError("invalid character found");
            u322 = c0 << 16 | c1 << 8 | c22;
            asc += b64chs[u322 >> 18 & 63] + b64chs[u322 >> 12 & 63] + b64chs[u322 >> 6 & 63] + b64chs[u322 & 63];
          }
          return pad2 ? asc.slice(0, pad2 - 3) + "===".substring(pad2) : asc;
        };
        var _btoa = _hasbtoa ? function(bin) {
          return btoa(bin);
        } : _hasBuffer ? function(bin) {
          return Buffer.from(bin, "binary").toString("base64");
        } : btoaPolyfill;
        var _fromUint8Array = _hasBuffer ? function(u8a2) {
          return Buffer.from(u8a2).toString("base64");
        } : function(u8a2) {
          var maxargs = 4096;
          var strs = [];
          for (var i4 = 0, l4 = u8a2.length; i4 < l4; i4 += maxargs) {
            strs.push(_fromCC.apply(null, u8a2.subarray(i4, i4 + maxargs)));
          }
          return _btoa(strs.join(""));
        };
        var fromUint8Array = function(u8a2, urlsafe) {
          if (urlsafe === void 0) {
            urlsafe = false;
          }
          return urlsafe ? _mkUriSafe(_fromUint8Array(u8a2)) : _fromUint8Array(u8a2);
        };
        var cb_utob = function(c3) {
          if (c3.length < 2) {
            var cc = c3.charCodeAt(0);
            return cc < 128 ? c3 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
          } else {
            var cc = 65536 + (c3.charCodeAt(0) - 55296) * 1024 + (c3.charCodeAt(1) - 56320);
            return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
          }
        };
        var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
        var utob = function(u3) {
          return u3.replace(re_utob, cb_utob);
        };
        var _encode = _hasBuffer ? function(s4) {
          return Buffer.from(s4, "utf8").toString("base64");
        } : _TE ? function(s4) {
          return _fromUint8Array(_TE.encode(s4));
        } : function(s4) {
          return _btoa(utob(s4));
        };
        var encode = function(src, urlsafe) {
          if (urlsafe === void 0) {
            urlsafe = false;
          }
          return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
        };
        var encodeURI2 = function(src) {
          return encode(src, true);
        };
        var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
        var cb_btou = function(cccc) {
          switch (cccc.length) {
            case 4:
              var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
              return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
            case 3:
              return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
            default:
              return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
          }
        };
        var btou = function(b4) {
          return b4.replace(re_btou, cb_btou);
        };
        var atobPolyfill = function(asc) {
          asc = asc.replace(/\s+/g, "");
          if (!b64re.test(asc))
            throw new TypeError("malformed base64.");
          asc += "==".slice(2 - (asc.length & 3));
          var u24, bin = "", r1, r2;
          for (var i4 = 0; i4 < asc.length; ) {
            u24 = b64tab[asc.charAt(i4++)] << 18 | b64tab[asc.charAt(i4++)] << 12 | (r1 = b64tab[asc.charAt(i4++)]) << 6 | (r2 = b64tab[asc.charAt(i4++)]);
            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
          }
          return bin;
        };
        var _atob = _hasatob ? function(asc) {
          return atob(_tidyB64(asc));
        } : _hasBuffer ? function(asc) {
          return Buffer.from(asc, "base64").toString("binary");
        } : atobPolyfill;
        var _toUint8Array = _hasBuffer ? function(a2) {
          return _U8Afrom(Buffer.from(a2, "base64"));
        } : function(a2) {
          return _U8Afrom(_atob(a2).split("").map(function(c3) {
            return c3.charCodeAt(0);
          }));
        };
        var toUint8Array = function(a2) {
          return _toUint8Array(_unURI(a2));
        };
        var _decode = _hasBuffer ? function(a2) {
          return Buffer.from(a2, "base64").toString("utf8");
        } : _TD ? function(a2) {
          return _TD.decode(_toUint8Array(a2));
        } : function(a2) {
          return btou(_atob(a2));
        };
        var _unURI = function(a2) {
          return _tidyB64(a2.replace(/[-_]/g, function(m0) {
            return m0 == "-" ? "+" : "/";
          }));
        };
        var decode = function(src) {
          return _decode(_unURI(src));
        };
        var isValid2 = function(src) {
          if (typeof src !== "string")
            return false;
          var s4 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
          return !/[^\s0-9a-zA-Z\+/]/.test(s4) || !/[^\s0-9a-zA-Z\-_]/.test(s4);
        };
        var _noEnum = function(v7) {
          return {
            value: v7,
            enumerable: false,
            writable: true,
            configurable: true
          };
        };
        var extendString = function() {
          var _add = function(name, body) {
            return Object.defineProperty(String.prototype, name, _noEnum(body));
          };
          _add("fromBase64", function() {
            return decode(this);
          });
          _add("toBase64", function(urlsafe) {
            return encode(this, urlsafe);
          });
          _add("toBase64URI", function() {
            return encode(this, true);
          });
          _add("toBase64URL", function() {
            return encode(this, true);
          });
          _add("toUint8Array", function() {
            return toUint8Array(this);
          });
        };
        var extendUint8Array = function() {
          var _add = function(name, body) {
            return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
          };
          _add("toBase64", function(urlsafe) {
            return fromUint8Array(this, urlsafe);
          });
          _add("toBase64URI", function() {
            return fromUint8Array(this, true);
          });
          _add("toBase64URL", function() {
            return fromUint8Array(this, true);
          });
        };
        var extendBuiltins = function() {
          extendString();
          extendUint8Array();
        };
        var gBase64 = {
          version: version7,
          VERSION,
          atob: _atob,
          atobPolyfill,
          btoa: _btoa,
          btoaPolyfill,
          fromBase64: decode,
          toBase64: encode,
          encode,
          encodeURI: encodeURI2,
          encodeURL: encodeURI2,
          utob,
          btou,
          decode,
          isValid: isValid2,
          fromUint8Array,
          toUint8Array,
          extendString,
          extendUint8Array,
          extendBuiltins
        };
        gBase64.Base64 = {};
        Object.keys(gBase64).forEach(function(k3) {
          return gBase64.Base64[k3] = gBase64[k3];
        });
        return gBase64;
      });
    }
  });

  // node_modules/nice-grpc-web/lib/utils/convertMetadata.js
  var require_convertMetadata = __commonJS({
    "node_modules/nice-grpc-web/lib/utils/convertMetadata.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.convertMetadataFromGrpcWeb = exports2.convertMetadataToGrpcWeb = void 0;
      var grpc_web_1 = require_grpc_web_client_umd();
      var nice_grpc_common_1 = require_lib29();
      var js_base64_1 = require_base642();
      function convertMetadataToGrpcWeb(metadata) {
        const grpcMetadata = new grpc_web_1.grpc.Metadata();
        for (const [key, values] of metadata) {
          for (const value of values) {
            grpcMetadata.append(key, typeof value === "string" ? value : js_base64_1.Base64.fromUint8Array(value));
          }
        }
        return grpcMetadata;
      }
      exports2.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
      function convertMetadataFromGrpcWeb(grpcMetadata) {
        const metadata = (0, nice_grpc_common_1.Metadata)();
        for (const [key, values] of Object.entries(grpcMetadata.headersMap)) {
          if (key.endsWith("-bin")) {
            for (const value of values) {
              for (const item of value.split(/,\s?/)) {
                metadata.append(key, js_base64_1.Base64.toUint8Array(item));
              }
            }
          } else {
            metadata.set(key, values);
          }
        }
        return metadata;
      }
      exports2.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
    }
  });

  // node_modules/nice-grpc-web/lib/client/createBidiStreamingMethod.js
  var require_createBidiStreamingMethod = __commonJS({
    "node_modules/nice-grpc-web/lib/client/createBidiStreamingMethod.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createBidiStreamingMethod = void 0;
      var nice_grpc_common_1 = require_lib29();
      var grpc_web_1 = require_grpc_web_client_umd();
      var abort_controller_x_1 = require_lib30();
      var AsyncSink_1 = require_AsyncSink();
      var service_definitions_1 = require_service_definitions();
      var isAsyncIterable_1 = require_isAsyncIterable();
      var convertMetadata_1 = require_convertMetadata();
      function createBidiStreamingMethod(definition, channel, middleware, defaultOptions) {
        const grpcMethodDefinition = (0, service_definitions_1.toGrpcWebMethodDefinition)(definition);
        const methodDescriptor = {
          path: definition.path,
          requestStream: definition.requestStream,
          responseStream: definition.responseStream,
          options: definition.options
        };
        async function* bidiStreamingMethod(request, options) {
          if (!(0, isAsyncIterable_1.isAsyncIterable)(request)) {
            throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
          }
          const { metadata = (0, nice_grpc_common_1.Metadata)(), signal = new AbortController().signal, onHeader, onTrailer } = options;
          const pipeAbortController = new AbortController();
          const sink = new AsyncSink_1.AsyncSink();
          const client = grpc_web_1.grpc.client(grpcMethodDefinition, {
            host: channel.address,
            transport: channel.transport
          });
          client.onHeaders((headers) => {
            onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1.convertMetadataFromGrpcWeb)(headers));
          });
          client.onMessage((message) => {
            sink.write(message);
          });
          client.onEnd((code, message, trailers) => {
            onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1.convertMetadataFromGrpcWeb)(trailers));
            if (code === grpc_web_1.grpc.Code.OK) {
              sink.end();
            } else {
              sink.error(new nice_grpc_common_1.ClientError(definition.path, +code, message));
            }
          });
          client.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(metadata));
          let pipeError;
          pipeRequest(pipeAbortController.signal, request, client, definition).then(() => {
            client.finishSend();
          }, (err) => {
            if (!(0, abort_controller_x_1.isAbortError)(err)) {
              pipeError = err;
              client.close();
              sink.end();
            }
          });
          const abortListener = () => {
            sink.error(new abort_controller_x_1.AbortError());
            pipeAbortController.abort();
            client.close();
          };
          signal.addEventListener("abort", abortListener);
          try {
            yield* sink;
          } finally {
            pipeAbortController.abort();
            signal.removeEventListener("abort", abortListener);
            (0, abort_controller_x_1.throwIfAborted)(signal);
            if (pipeError) {
              throw pipeError;
            }
          }
        }
        const method = middleware == null ? bidiStreamingMethod : (request, options) => middleware({
          method: methodDescriptor,
          requestStream: true,
          request,
          responseStream: true,
          next: bidiStreamingMethod
        }, options);
        return (request, options) => {
          const iterable = method(request, {
            ...defaultOptions,
            ...options
          });
          const iterator2 = iterable[Symbol.asyncIterator]();
          return {
            [Symbol.asyncIterator]() {
              return {
                async next() {
                  const result = await iterator2.next();
                  if (result.done && result.value != null) {
                    return await iterator2.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method"));
                  }
                  return result;
                },
                return() {
                  return iterator2.return();
                },
                throw(err) {
                  return iterator2.throw(err);
                }
              };
            }
          };
        };
      }
      exports2.createBidiStreamingMethod = createBidiStreamingMethod;
      async function pipeRequest(signal, request, client, definition) {
        for await (const item of request) {
          (0, abort_controller_x_1.throwIfAborted)(signal);
          client.send({
            serializeBinary: () => definition.requestSerialize(item)
          });
        }
      }
    }
  });

  // node_modules/nice-grpc-web/lib/client/createClientStreamingMethod.js
  var require_createClientStreamingMethod = __commonJS({
    "node_modules/nice-grpc-web/lib/client/createClientStreamingMethod.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createClientStreamingMethod = void 0;
      var nice_grpc_common_1 = require_lib29();
      var grpc_web_1 = require_grpc_web_client_umd();
      var abort_controller_x_1 = require_lib30();
      var service_definitions_1 = require_service_definitions();
      var isAsyncIterable_1 = require_isAsyncIterable();
      var convertMetadata_1 = require_convertMetadata();
      function createClientStreamingMethod(definition, channel, middleware, defaultOptions) {
        const grpcMethodDefinition = (0, service_definitions_1.toGrpcWebMethodDefinition)(definition);
        const methodDescriptor = {
          path: definition.path,
          requestStream: definition.requestStream,
          responseStream: definition.responseStream,
          options: definition.options
        };
        async function* clientStreamingMethod(request, options) {
          if (!(0, isAsyncIterable_1.isAsyncIterable)(request)) {
            throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
          }
          const { metadata = (0, nice_grpc_common_1.Metadata)(), signal = new AbortController().signal, onHeader, onTrailer } = options;
          return await (0, abort_controller_x_1.execute)(signal, (resolve, reject) => {
            const pipeAbortController = new AbortController();
            let response;
            const client = grpc_web_1.grpc.client(grpcMethodDefinition, {
              host: channel.address,
              transport: channel.transport
            });
            client.onHeaders((headers) => {
              onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1.convertMetadataFromGrpcWeb)(headers));
            });
            client.onMessage((message) => {
              response = message;
            });
            client.onEnd((code, message, trailers) => {
              onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1.convertMetadataFromGrpcWeb)(trailers));
              pipeAbortController.abort();
              if (code === grpc_web_1.grpc.Code.OK) {
                resolve(response);
              } else {
                reject(new nice_grpc_common_1.ClientError(definition.path, +code, message));
              }
            });
            client.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(metadata));
            pipeRequest(pipeAbortController.signal, request, client, definition).then(() => {
              client.finishSend();
            }, (err) => {
              if (!(0, abort_controller_x_1.isAbortError)(err)) {
                reject(err);
                client.close();
              }
            });
            return () => {
              pipeAbortController.abort();
              client.close();
            };
          });
        }
        const method = middleware == null ? clientStreamingMethod : (request, options) => middleware({
          method: methodDescriptor,
          requestStream: true,
          request,
          responseStream: false,
          next: clientStreamingMethod
        }, options);
        return async (request, options) => {
          const iterable = method(request, {
            ...defaultOptions,
            ...options
          });
          const iterator2 = iterable[Symbol.asyncIterator]();
          let result = await iterator2.next();
          while (true) {
            if (!result.done) {
              result = await iterator2.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
              continue;
            }
            if (result.value == null) {
              result = await iterator2.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
              continue;
            }
            return result.value;
          }
        };
      }
      exports2.createClientStreamingMethod = createClientStreamingMethod;
      async function pipeRequest(signal, request, client, definition) {
        for await (const item of request) {
          (0, abort_controller_x_1.throwIfAborted)(signal);
          client.send({
            serializeBinary: () => definition.requestSerialize(item)
          });
        }
      }
    }
  });

  // node_modules/nice-grpc-web/lib/client/createServerStreamingMethod.js
  var require_createServerStreamingMethod = __commonJS({
    "node_modules/nice-grpc-web/lib/client/createServerStreamingMethod.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createServerStreamingMethod = void 0;
      var grpc_web_1 = require_grpc_web_client_umd();
      var abort_controller_x_1 = require_lib30();
      var AsyncSink_1 = require_AsyncSink();
      var nice_grpc_common_1 = require_lib29();
      var service_definitions_1 = require_service_definitions();
      var convertMetadata_1 = require_convertMetadata();
      var isAsyncIterable_1 = require_isAsyncIterable();
      function createServerStreamingMethod(definition, channel, middleware, defaultOptions) {
        const grpcMethodDefinition = (0, service_definitions_1.toGrpcWebMethodDefinition)(definition);
        const methodDescriptor = {
          path: definition.path,
          requestStream: definition.requestStream,
          responseStream: definition.responseStream,
          options: definition.options
        };
        async function* serverStreamingMethod(request, options) {
          if ((0, isAsyncIterable_1.isAsyncIterable)(request)) {
            throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
          }
          const { metadata = (0, nice_grpc_common_1.Metadata)(), signal = new AbortController().signal, onHeader, onTrailer } = options;
          const sink = new AsyncSink_1.AsyncSink();
          const client = grpc_web_1.grpc.client(grpcMethodDefinition, {
            host: channel.address,
            transport: channel.transport
          });
          client.onHeaders((headers) => {
            onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1.convertMetadataFromGrpcWeb)(headers));
          });
          client.onMessage((message) => {
            sink.write(message);
          });
          client.onEnd((code, message, trailers) => {
            onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1.convertMetadataFromGrpcWeb)(trailers));
            if (code === grpc_web_1.grpc.Code.OK) {
              sink.end();
            } else {
              sink.error(new nice_grpc_common_1.ClientError(definition.path, +code, message));
            }
          });
          client.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(metadata));
          client.send({
            serializeBinary: () => definition.requestSerialize(request)
          });
          client.finishSend();
          const abortListener = () => {
            sink.error(new abort_controller_x_1.AbortError());
            client.close();
          };
          signal.addEventListener("abort", abortListener);
          try {
            yield* sink;
          } finally {
            signal.removeEventListener("abort", abortListener);
            (0, abort_controller_x_1.throwIfAborted)(signal);
          }
        }
        const method = middleware == null ? serverStreamingMethod : (request, options) => middleware({
          method: methodDescriptor,
          requestStream: false,
          request,
          responseStream: true,
          next: serverStreamingMethod
        }, options);
        return (request, options) => {
          const iterable = method(request, {
            ...defaultOptions,
            ...options
          });
          const iterator2 = iterable[Symbol.asyncIterator]();
          return {
            [Symbol.asyncIterator]() {
              return {
                async next() {
                  const result = await iterator2.next();
                  if (result.done && result.value != null) {
                    return await iterator2.throw(new Error("A middleware returned a message, but expected to return void for server streaming method"));
                  }
                  return result;
                },
                return() {
                  return iterator2.return();
                },
                throw(err) {
                  return iterator2.throw(err);
                }
              };
            }
          };
        };
      }
      exports2.createServerStreamingMethod = createServerStreamingMethod;
    }
  });

  // node_modules/nice-grpc-web/lib/client/createUnaryMethod.js
  var require_createUnaryMethod = __commonJS({
    "node_modules/nice-grpc-web/lib/client/createUnaryMethod.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createUnaryMethod = void 0;
      var nice_grpc_common_1 = require_lib29();
      var grpc_web_1 = require_grpc_web_client_umd();
      var abort_controller_x_1 = require_lib30();
      var service_definitions_1 = require_service_definitions();
      var isAsyncIterable_1 = require_isAsyncIterable();
      var convertMetadata_1 = require_convertMetadata();
      function createUnaryMethod(definition, channel, middleware, defaultOptions) {
        const grpcMethodDefinition = (0, service_definitions_1.toGrpcWebMethodDefinition)(definition);
        const methodDescriptor = {
          path: definition.path,
          requestStream: definition.requestStream,
          responseStream: definition.responseStream,
          options: definition.options
        };
        async function* unaryMethod(request, options) {
          if ((0, isAsyncIterable_1.isAsyncIterable)(request)) {
            throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
          }
          const { metadata = (0, nice_grpc_common_1.Metadata)(), signal = new AbortController().signal, onHeader, onTrailer } = options;
          return await (0, abort_controller_x_1.execute)(signal, (resolve, reject) => {
            let response;
            const client = grpc_web_1.grpc.client(grpcMethodDefinition, {
              host: channel.address,
              transport: channel.transport
            });
            client.onHeaders((headers) => {
              onHeader === null || onHeader === void 0 ? void 0 : onHeader((0, convertMetadata_1.convertMetadataFromGrpcWeb)(headers));
            });
            client.onMessage((message) => {
              response = message;
            });
            client.onEnd((code, message, trailers) => {
              onTrailer === null || onTrailer === void 0 ? void 0 : onTrailer((0, convertMetadata_1.convertMetadataFromGrpcWeb)(trailers));
              if (code === grpc_web_1.grpc.Code.OK) {
                resolve(response);
              } else {
                reject(new nice_grpc_common_1.ClientError(definition.path, +code, message));
              }
            });
            client.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(metadata));
            client.send({
              serializeBinary: () => definition.requestSerialize(request)
            });
            client.finishSend();
            return () => {
              client.close();
            };
          });
        }
        const method = middleware == null ? unaryMethod : (request, options) => middleware({
          method: methodDescriptor,
          requestStream: false,
          request,
          responseStream: false,
          next: unaryMethod
        }, options);
        return async (request, options) => {
          const iterable = method(request, {
            ...defaultOptions,
            ...options
          });
          const iterator2 = iterable[Symbol.asyncIterator]();
          let result = await iterator2.next();
          while (true) {
            if (!result.done) {
              result = await iterator2.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
              continue;
            }
            if (result.value == null) {
              result = await iterator2.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
              continue;
            }
            return result.value;
          }
        };
      }
      exports2.createUnaryMethod = createUnaryMethod;
    }
  });

  // node_modules/nice-grpc-web/lib/client/ClientFactory.js
  var require_ClientFactory = __commonJS({
    "node_modules/nice-grpc-web/lib/client/ClientFactory.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createClient = exports2.createClientFactory = void 0;
      var nice_grpc_common_1 = require_lib29();
      var service_definitions_1 = require_service_definitions();
      var createBidiStreamingMethod_1 = require_createBidiStreamingMethod();
      var createClientStreamingMethod_1 = require_createClientStreamingMethod();
      var createServerStreamingMethod_1 = require_createServerStreamingMethod();
      var createUnaryMethod_1 = require_createUnaryMethod();
      function createClientFactory() {
        return createClientFactoryWithMiddleware();
      }
      exports2.createClientFactory = createClientFactory;
      function createClient2(definition, channel, defaultCallOptions) {
        return createClientFactory().create(definition, channel, defaultCallOptions);
      }
      exports2.createClient = createClient2;
      function createClientFactoryWithMiddleware(middleware) {
        return {
          use(newMiddleware) {
            return createClientFactoryWithMiddleware(middleware == null ? newMiddleware : (0, nice_grpc_common_1.composeClientMiddleware)(middleware, newMiddleware));
          },
          create(definition, channel, defaultCallOptions = {}) {
            const client = {};
            const methodEntries = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(definition));
            for (const [methodName, methodDefinition] of methodEntries) {
              const defaultOptions = {
                ...defaultCallOptions["*"],
                ...defaultCallOptions[methodName]
              };
              if (!methodDefinition.requestStream) {
                if (!methodDefinition.responseStream) {
                  client[methodName] = (0, createUnaryMethod_1.createUnaryMethod)(methodDefinition, channel, middleware, defaultOptions);
                } else {
                  client[methodName] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(methodDefinition, channel, middleware, defaultOptions);
                }
              } else {
                if (!methodDefinition.responseStream) {
                  client[methodName] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(methodDefinition, channel, middleware, defaultOptions);
                } else {
                  client[methodName] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(methodDefinition, channel, middleware, defaultOptions);
                }
              }
            }
            return client;
          }
        };
      }
    }
  });

  // node_modules/nice-grpc-web/lib/client/Client.js
  var require_Client = __commonJS({
    "node_modules/nice-grpc-web/lib/client/Client.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/nice-grpc-web/lib/index.js
  var require_lib31 = __commonJS({
    "node_modules/nice-grpc-web/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m5, exports3) {
        for (var p2 in m5)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m5, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Status = exports2.Metadata = exports2.composeClientMiddleware = exports2.ClientError = void 0;
      var nice_grpc_common_1 = require_lib29();
      Object.defineProperty(exports2, "ClientError", { enumerable: true, get: function() {
        return nice_grpc_common_1.ClientError;
      } });
      Object.defineProperty(exports2, "composeClientMiddleware", { enumerable: true, get: function() {
        return nice_grpc_common_1.composeClientMiddleware;
      } });
      Object.defineProperty(exports2, "Metadata", { enumerable: true, get: function() {
        return nice_grpc_common_1.Metadata;
      } });
      Object.defineProperty(exports2, "Status", { enumerable: true, get: function() {
        return nice_grpc_common_1.Status;
      } });
      __exportStar(require_service_definitions(), exports2);
      __exportStar(require_channel(), exports2);
      __exportStar(require_ClientFactory(), exports2);
      __exportStar(require_Client(), exports2);
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports2, module2) {
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array2, setter, iteratee, accumulator) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            var value = array2[index2];
            setter(accumulator, value, iteratee(value), array2);
          }
          return accumulator;
        }
        function arrayEach(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (iteratee(array2[index2], index2, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEachRight(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          while (length--) {
            if (iteratee(array2[length], length, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function arrayEvery(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (!predicate(array2[index2], index2, array2)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array2[index2];
            if (predicate(value, index2, array2)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          return !!length && baseIndexOf(array2, value, 0) > -1;
        }
        function arrayIncludesWith(array2, value, comparator) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (comparator(value, array2[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array2[index2], index2, array2);
          }
          return result;
        }
        function arrayPush(array2, values) {
          var index2 = -1, length = values.length, offset = array2.length;
          while (++index2 < length) {
            array2[offset + index2] = values[index2];
          }
          return array2;
        }
        function arrayReduce(array2, iteratee, accumulator, initAccum) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[++index2];
          }
          while (++index2 < length) {
            accumulator = iteratee(accumulator, array2[index2], index2, array2);
          }
          return accumulator;
        }
        function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
          var length = array2 == null ? 0 : array2.length;
          if (initAccum && length) {
            accumulator = array2[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array2[length], length, array2);
          }
          return accumulator;
        }
        function arraySome(array2, predicate) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array2, value, fromIndex, comparator) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (comparator(array2[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array2, iteratee) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSum(array2, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object2) {
            return object2 == null ? undefined2 : object2[key];
          };
        }
        function basePropertyOf(object2) {
          return function(key) {
            return object2 == null ? undefined2 : object2[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array2, comparer2) {
          var length = array2.length;
          array2.sort(comparer2);
          while (length--) {
            array2[length] = array2[length].value;
          }
          return array2;
        }
        function baseSum(array2, iteratee) {
          var result, index2 = -1, length = array2.length;
          while (++index2 < length) {
            var current = iteratee(array2[index2]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n4, iteratee) {
          var index2 = -1, result = Array(n4);
          while (++index2 < n4) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object2, props) {
          return arrayMap(props, function(key) {
            return [key, object2[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object2, props) {
          return arrayMap(props, function(key) {
            return object2[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array2, placeholder) {
          var length = array2.length, result = 0;
          while (length--) {
            if (array2[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object2, key) {
          return object2 == null ? undefined2 : object2[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator2) {
          var data, result = [];
          while (!(data = iterator2.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map3) {
          var index2 = -1, result = Array(map3.size);
          map3.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array2, placeholder) {
          var index2 = -1, length = array2.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array2[index2];
            if (value === placeholder || value === PLACEHOLDER) {
              array2[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray(set4) {
          var index2 = -1, result = Array(set4.size);
          set4.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        function setToPairs(set4) {
          var index2 = -1, result = Array(set4.size);
          set4.forEach(function(value) {
            result[++index2] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index2 = string.length;
          while (index2-- && reWhitespace.test(string.charAt(index2))) {
          }
          return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context2) {
          context2 = context2 == null ? root : _18.defaults(root.Object(), context2, _18.pick(root, contextProps));
          var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto2 = Object2.prototype;
          var coreJsData = context2["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto2.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid2 ? "Symbol(src)_1." + uid2 : "";
          }();
          var nativeObjectToString = objectProto2.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context2.Buffer : undefined2, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty3 = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray3(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object2() {
            }
            return function(proto2) {
              if (!isObject2(proto2)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto2);
              }
              object2.prototype = proto2;
              var result2 = new object2();
              object2.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray3(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array2, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value = array2[index2];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed3 = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed3;
                  } else if (!computed3) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash2(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash2.prototype.clear = hashClear;
          Hash2.prototype["delete"] = hashDelete;
          Hash2.prototype.get = hashGet;
          Hash2.prototype.has = hashHas;
          Hash2.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index2 == lastIndex) {
              data.pop();
            } else {
              splice2.call(data, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? undefined2 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash2(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash2()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size4 = data.size;
            data.set(key, value);
            this.size += data.size == size4 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index2 = -1, length = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index2 < length) {
              this.add(values2[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray3(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array2) {
            var length = array2.length;
            return length ? array2[baseRandom(0, length - 1)] : undefined2;
          }
          function arraySampleSize(array2, n4) {
            return shuffleSelf(copyArray(array2), baseClamp(n4, 0, array2.length));
          }
          function arrayShuffle(array2) {
            return shuffleSelf(copyArray(array2));
          }
          function assignMergeValue(object2, key, value) {
            if (value !== undefined2 && !eq2(object2[key], value) || value === undefined2 && !(key in object2)) {
              baseAssignValue(object2, key, value);
            }
          }
          function assignValue(object2, key, value) {
            var objValue = object2[key];
            if (!(hasOwnProperty.call(object2, key) && eq2(objValue, value)) || value === undefined2 && !(key in object2)) {
              baseAssignValue(object2, key, value);
            }
          }
          function assocIndexOf(array2, key) {
            var length = array2.length;
            while (length--) {
              if (eq2(array2[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object2, source) {
            return object2 && copyObject(source, keys(source), object2);
          }
          function baseAssignIn(object2, source) {
            return object2 && copyObject(source, keysIn(source), object2);
          }
          function baseAssignValue(object2, key, value) {
            if (key == "__proto__" && defineProperty3) {
              defineProperty3(object2, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object2[key] = value;
            }
          }
          function baseAt(object2, paths) {
            var index2 = -1, length = paths.length, result2 = Array2(length), skip = object2 == null;
            while (++index2 < length) {
              result2[index2] = skip ? undefined2 : get3(object2, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number2, lower, upper) {
            if (number2 === number2) {
              if (upper !== undefined2) {
                number2 = number2 <= upper ? number2 : upper;
              }
              if (lower !== undefined2) {
                number2 = number2 >= lower ? number2 : lower;
              }
            }
            return number2;
          }
          function baseClone(value, bitmask, customizer, key, object2, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray3(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object2) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object2 ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object2) {
              return baseConformsTo(object2, source, props);
            };
          }
          function baseConformsTo(object2, source, props) {
            var length = props.length;
            if (object2 == null) {
              return !length;
            }
            object2 = Object2(object2);
            while (length--) {
              var key = props[length], predicate = source[key], value = object2[key];
              if (value === undefined2 && !(key in object2) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait2, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait2);
          }
          function baseDifference(array2, values2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
            if (!length) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index2 < length) {
                var value = array2[index2], computed3 = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed3 === computed3) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed3) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values2, computed3, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index2, collection2) {
              result2 = !!predicate(value, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array2, iteratee2, comparator) {
            var index2 = -1, length = array2.length;
            while (++index2 < length) {
              var value = array2[index2], current = iteratee2(value);
              if (current != null && (computed3 === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed3))) {
                var computed3 = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array2, value, start, end) {
            var length = array2.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined2 || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array2[start++] = value;
            }
            return array2;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index2, collection2) {
              if (predicate(value, index2, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array2, depth, predicate, isStrict, result2) {
            var index2 = -1, length = array2.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index2 < length) {
              var value = array2[index2];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object2, iteratee2) {
            return object2 && baseFor(object2, iteratee2, keys);
          }
          function baseForOwnRight(object2, iteratee2) {
            return object2 && baseForRight(object2, iteratee2, keys);
          }
          function baseFunctions(object2, props) {
            return arrayFilter(props, function(key) {
              return isFunction3(object2[key]);
            });
          }
          function baseGet(object2, path) {
            path = castPath(path, object2);
            var index2 = 0, length = path.length;
            while (object2 != null && index2 < length) {
              object2 = object2[toKey(path[index2++])];
            }
            return index2 && index2 == length ? object2 : undefined2;
          }
          function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object2);
            return isArray3(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object2, key) {
            return object2 != null && hasOwnProperty.call(object2, key);
          }
          function baseHasIn(object2, key) {
            return object2 != null && key in Object2(object2);
          }
          function baseInRange(number2, start, end) {
            return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array2 = arrays[othIndex];
              if (othIndex && iteratee2) {
                array2 = arrayMap(array2, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array2.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
            }
            array2 = arrays[0];
            var index2 = -1, seen = caches[0];
            outer:
              while (++index2 < length && result2.length < maxLength) {
                var value = array2[index2], computed3 = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed3) : includes2(result2, computed3, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed3) : includes2(arrays[othIndex], computed3, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object2, setter, iteratee2, accumulator) {
            baseForOwn(object2, function(value, key, object3) {
              setter(accumulator, iteratee2(value), key, object3);
            });
            return accumulator;
          }
          function baseInvoke(object2, path, args) {
            path = castPath(path, object2);
            object2 = parent(object2, path);
            var func = object2 == null ? object2 : object2[toKey(last2(path))];
            return func == null ? undefined2 : apply(func, object2, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray3(object2), othIsArr = isArray3(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object2)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object2, source, matchData, customizer) {
            var index2 = matchData.length, length = index2, noCustomizer = !customizer;
            if (object2 == null) {
              return !length;
            }
            object2 = Object2(object2);
            while (index2--) {
              var data = matchData[index2];
              if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
                return false;
              }
            }
            while (++index2 < length) {
              data = matchData[index2];
              var key = data[0], objValue = object2[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object2)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object2, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject2(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity2;
            }
            if (typeof value == "object") {
              return isArray3(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property7(value);
          }
          function baseKeys(object2) {
            if (!isPrototype(object2)) {
              return nativeKeys(object2);
            }
            var result2 = [];
            for (var key in Object2(object2)) {
              if (hasOwnProperty.call(object2, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object2) {
            if (!isObject2(object2)) {
              return nativeKeysIn(object2);
            }
            var isProto = isPrototype(object2), result2 = [];
            for (var key in object2) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index2] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object2) {
              return object2 === source || baseIsMatch(object2, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object2) {
              var objValue = get3(object2, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object2, source, srcIndex, customizer, stack) {
            if (object2 === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject2(srcValue)) {
                baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object2, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object2, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray3(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray3(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction3(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object2, key, newValue);
          }
          function baseNth(array2, n4) {
            var length = array2.length;
            if (!length) {
              return;
            }
            n4 += n4 < 0 ? length : 0;
            return isIndex(n4, length) ? array2[n4] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray3(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity2];
            }
            var index2 = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index2, "value": value };
            });
            return baseSortBy(result2, function(object2, other) {
              return compareMultiple(object2, other, orders);
            });
          }
          function basePick(object2, paths) {
            return basePickBy(object2, paths, function(value, path) {
              return hasIn(object2, path);
            });
          }
          function basePickBy(object2, paths, predicate) {
            var index2 = -1, length = paths.length, result2 = {};
            while (++index2 < length) {
              var path = paths[index2], value = baseGet(object2, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object2), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object2) {
              return baseGet(object2, path);
            };
          }
          function basePullAll(array2, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array2;
            if (array2 === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array2, baseUnary(iteratee2));
            }
            while (++index2 < length) {
              var fromIndex = 0, value = values2[index2], computed3 = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed3, fromIndex, comparator)) > -1) {
                if (seen !== array2) {
                  splice2.call(seen, fromIndex, 1);
                }
                splice2.call(array2, fromIndex, 1);
              }
            }
            return array2;
          }
          function basePullAt(array2, indexes) {
            var length = array2 ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index2 = indexes[length];
              if (length == lastIndex || index2 !== previous) {
                var previous = index2;
                if (isIndex(index2)) {
                  splice2.call(array2, index2, 1);
                } else {
                  baseUnset(array2, index2);
                }
              }
            }
            return array2;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
            while (length--) {
              result2[fromRight ? length : ++index2] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n4) {
            var result2 = "";
            if (!string || n4 < 1 || n4 > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n4 % 2) {
                result2 += string;
              }
              n4 = nativeFloor(n4 / 2);
              if (n4) {
                string += string;
              }
            } while (n4);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity2), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n4) {
            var array2 = values(collection);
            return shuffleSelf(array2, baseClamp(n4, 0, array2.length));
          }
          function baseSet(object2, path, value, customizer) {
            if (!isObject2(object2)) {
              return object2;
            }
            path = castPath(path, object2);
            var index2 = -1, length = path.length, lastIndex = length - 1, nested = object2;
            while (nested != null && ++index2 < length) {
              var key = toKey(path[index2]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object2;
              }
              if (index2 != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object2;
          }
          var baseSetData = !metaMap ? identity2 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty3 ? identity2 : function(func, string) {
            return defineProperty3(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array2, start, end) {
            var index2 = -1, length = array2.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length);
            while (++index2 < length) {
              result2[index2] = array2[index2 + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index2, collection2) {
              result2 = predicate(value, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array2, value, retHighest) {
            var low = 0, high = array2 == null ? low : array2.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed3 = array2[mid];
                if (computed3 !== null && !isSymbol(computed3) && (retHighest ? computed3 <= value : computed3 < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array2, value, identity2, retHighest);
          }
          function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
            var low = 0, high = array2 == null ? 0 : array2.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed3 = iteratee2(array2[mid]), othIsDefined = computed3 !== undefined2, othIsNull = computed3 === null, othIsReflexive = computed3 === computed3, othIsSymbol = isSymbol(computed3);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed3 <= value : computed3 < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array2, iteratee2) {
            var index2 = -1, length = array2.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array2[index2], computed3 = iteratee2 ? iteratee2(value) : value;
              if (!index2 || !eq2(computed3, seen)) {
                var seen = computed3;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray3(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set5 = iteratee2 ? null : createSet(array2);
              if (set5) {
                return setToArray(set5);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length) {
                var value = array2[index2], computed3 = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed3 === computed3) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed3) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed3, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed3);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object2, path) {
            path = castPath(path, object2);
            object2 = parent(object2, path);
            return object2 == null || delete object2[toKey(last2(path))];
          }
          function baseUpdate(object2, path, updater, customizer) {
            return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
          }
          function baseWhile(array2, predicate, isDrop, fromRight) {
            var length = array2.length, index2 = fromRight ? length : -1;
            while ((fromRight ? index2-- : ++index2 < length) && predicate(array2[index2], index2, array2)) {
            }
            return isDrop ? baseSlice(array2, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array2, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action2) {
              return action2.func.apply(action2.thisArg, arrayPush([result3], action2.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length);
            while (++index2 < length) {
              var array2 = arrays[index2], othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array2, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
            while (++index2 < length) {
              var value = index2 < valsLength ? values2[index2] : undefined2;
              assignFunc(result2, props[index2], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity2;
          }
          function castPath(value, object2) {
            if (isArray3(value)) {
              return value;
            }
            return isKey(value, object2) ? [value] : stringToPath(toString3(value));
          }
          var castRest = baseRest;
          function castSlice(array2, start, end) {
            var length = array2.length;
            end = end === undefined2 ? length : end;
            return !start && end >= length ? array2 : baseSlice(array2, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id3) {
            return root.clearTimeout(id3);
          };
          function cloneBuffer(buffer2, isDeep) {
            if (isDeep) {
              return buffer2.slice();
            }
            var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
            buffer2.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object2, other, orders) {
            var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order = orders[index2];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object2.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array2) {
            var index2 = -1, length = source.length;
            array2 || (array2 = Array2(length));
            while (++index2 < length) {
              array2[index2] = source[index2];
            }
            return array2;
          }
          function copyObject(source, props, object2, customizer) {
            var isNew = !object2;
            object2 || (object2 = {});
            var index2 = -1, length = props.length;
            while (++index2 < length) {
              var key = props[index2];
              var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object2, key, newValue);
              } else {
                assignValue(object2, key, newValue);
              }
            }
            return object2;
          }
          function copySymbols(source, object2) {
            return copyObject(source, getSymbols(source), object2);
          }
          function copySymbolsIn(source, object2) {
            return copyObject(source, getSymbolsIn(source), object2);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray3(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object2, sources) {
              var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined2 : customizer;
                length = 1;
              }
              object2 = Object2(object2);
              while (++index2 < length) {
                var source = sources[index2];
                if (source) {
                  assigner(object2, source, index2, customizer);
                }
              }
              return object2;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike2(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object2, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index2];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object2;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString3(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length
                );
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike2(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index2 = wrapper ? index2 : length;
              while (++index2 < length) {
                func = funcs[index2];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray3(value)) {
                  return wrapper.plant(value).value();
                }
                var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
                while (++index3 < length) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array2(length), index2 = length;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length) {
                args.length = ary2;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object2, iteratee2) {
              return baseInverter(object2, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined2;
              }
              start = toFinite(start);
              if (end === undefined2) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber2(value);
                other = toNumber2(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number2, precision) {
              number2 = toNumber2(number2);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number2)) {
                var pair = (toString3(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString3(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number2);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop4 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object2) {
              var tag = getTag(object2);
              if (tag == mapTag) {
                return mapToArray(object2);
              }
              if (tag == setTag) {
                return setToPairs(object2);
              }
              return baseToPairs(object2, keysFunc(object2));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object2) {
            if (objValue === undefined2 || eq2(objValue, objectProto2[key]) && !hasOwnProperty.call(object2, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject2(value) ? undefined2 : value;
          }
          function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array2);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array2;
            }
            var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array2, other);
            stack.set(other, array2);
            while (++index2 < arrLength) {
              var arrValue = array2[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array2);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                  return false;
                }
                object2 = object2.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq2(+object2, +other);
              case errorTag:
                return object2.name == other.name && object2.message == other.message;
              case regexpTag:
              case stringTag:
                return object2 == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object2.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object2);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object2, other);
                var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object2);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object2) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object2);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object2;
            }
            var result2 = true;
            stack.set(object2, other);
            stack.set(other, object2);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object2[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object2.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object2);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object2) {
            return baseGetAllKeys(object2, keys, getSymbols);
          }
          function getAllKeysIn(object2) {
            return baseGetAllKeys(object2, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop4 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
            while (length--) {
              var data = array2[length], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object2 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object2.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map4, key) {
            var data = map4.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object2) {
            var result2 = keys(object2), length = result2.length;
            while (length--) {
              var key = result2[length], value = object2[key];
              result2[length] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object2, key) {
            var value = getValue(object2, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
            if (object2 == null) {
              return [];
            }
            object2 = Object2(object2);
            return arrayFilter(nativeGetSymbols(object2), function(symbol) {
              return propertyIsEnumerable.call(object2, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
            var result2 = [];
            while (object2) {
              arrayPush(result2, getSymbols(object2));
              object2 = getPrototype(object2);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index2 = -1, length = transforms.length;
            while (++index2 < length) {
              var data = transforms[index2], size4 = data.size;
              switch (data.type) {
                case "drop":
                  start += size4;
                  break;
                case "dropRight":
                  end -= size4;
                  break;
                case "take":
                  end = nativeMin(end, start + size4);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size4);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object2, path, hasFunc) {
            path = castPath(path, object2);
            var index2 = -1, length = path.length, result2 = false;
            while (++index2 < length) {
              var key = toKey(path[index2]);
              if (!(result2 = object2 != null && hasFunc(object2, key))) {
                break;
              }
              object2 = object2[key];
            }
            if (result2 || ++index2 != length) {
              return result2;
            }
            length = object2 == null ? 0 : object2.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray3(object2) || isArguments(object2));
          }
          function initCloneArray(array2) {
            var length = array2.length, result2 = new array2.constructor(length);
            if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
              result2.index = array2.index;
              result2.input = array2.input;
            }
            return result2;
          }
          function initCloneObject(object2) {
            return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
          }
          function initCloneByTag(object2, tag, isDeep) {
            var Ctor = object2.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object2);
              case boolTag:
              case dateTag:
                return new Ctor(+object2);
              case dataViewTag:
                return cloneDataView(object2, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object2, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object2);
              case regexpTag:
                return cloneRegExp(object2);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object2);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray3(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function isIterateeCall(value, index2, object2) {
            if (!isObject2(object2)) {
              return false;
            }
            var type = typeof index2;
            if (type == "number" ? isArrayLike2(object2) && isIndex(index2, object2.length) : type == "string" && index2 in object2) {
              return eq2(object2[index2], value);
            }
            return false;
          }
          function isKey(value, object2) {
            if (isArray3(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction3 : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
            return value === proto2;
          }
          function isStrictComparable(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object2) {
              if (object2 == null) {
                return false;
              }
              return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object2) {
            var result2 = [];
            if (object2 != null) {
              for (var key in Object2(object2)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform2) {
            start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length);
              while (++index2 < length) {
                array2[index2] = args[start + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start + 1);
              while (++index2 < start) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start] = transform2(array2);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object2, path) {
            return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
          }
          function reorder(array2, indexes) {
            var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
            while (length--) {
              var index2 = indexes[length];
              array2[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
            }
            return array2;
          }
          function safeGet(object2, key) {
            if (key === "constructor" && typeof object2[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object2[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait2) {
            return root.setTimeout(func, wait2);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array2, size4) {
            var index2 = -1, length = array2.length, lastIndex = length - 1;
            size4 = size4 === undefined2 ? length : size4;
            while (++index2 < size4) {
              var rand = baseRandom(index2, lastIndex), value = array2[rand];
              array2[rand] = array2[index2];
              array2[index2] = value;
            }
            array2.length = size4;
            return array2;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match, number2, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array2, size4, guard) {
            if (guard ? isIterateeCall(array2, size4, guard) : size4 === undefined2) {
              size4 = 1;
            } else {
              size4 = nativeMax(toInteger(size4), 0);
            }
            var length = array2 == null ? 0 : array2.length;
            if (!length || size4 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size4));
            while (index2 < length) {
              result2[resIndex++] = baseSlice(array2, index2, index2 += size4);
            }
            return result2;
          }
          function compact(array2) {
            var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
            while (++index2 < length) {
              var value = array2[index2];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat6() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array2(length - 1), array2 = arguments[0], index2 = length;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush(isArray3(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array2, values2) {
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array2, values2) {
            var iteratee2 = last2(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array2, values2) {
            var comparator = last2(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array2, n4, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n4 = guard || n4 === undefined2 ? 1 : toInteger(n4);
            return baseSlice(array2, n4 < 0 ? 0 : n4, length);
          }
          function dropRight(array2, n4, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n4 = guard || n4 === undefined2 ? 1 : toInteger(n4);
            n4 = length - n4;
            return baseSlice(array2, 0, n4 < 0 ? 0 : n4);
          }
          function dropRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
          }
          function fill(array2, value, start, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array2, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array2, value, start, end);
          }
          function findIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array2, predicate, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = length - 1;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return baseFindIndex(array2, getIteratee(predicate, 3), index2, true);
          }
          function flatten(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten(array2, 1) : [];
          }
          function flattenDeep(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseFlatten(array2, INFINITY) : [];
          }
          function flattenDepth(array2, depth) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array2, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length) {
              var pair = pairs[index2];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array2) {
            return array2 && array2.length ? array2[0] : undefined2;
          }
          function indexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length + index2, 0);
            }
            return baseIndexOf(array2, value, index2);
          }
          function initial(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last2(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last2(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join2(array2, separator) {
            return array2 == null ? "" : nativeJoin.call(array2, separator);
          }
          function last2(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? array2[length - 1] : undefined2;
          }
          function lastIndexOf(array2, value, fromIndex) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return -1;
            }
            var index2 = length;
            if (fromIndex !== undefined2) {
              index2 = toInteger(fromIndex);
              index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
            }
            return value === value ? strictLastIndexOf(array2, value, index2) : baseFindIndex(array2, baseIsNaN, index2, true);
          }
          function nth(array2, n4) {
            return array2 && array2.length ? baseNth(array2, toInteger(n4)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array2, values2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
          }
          function pullAllBy(array2, values2, iteratee2) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
          }
          function pullAllWith(array2, values2, comparator) {
            return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
          }
          var pullAt = flatRest(function(array2, indexes) {
            var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
            basePullAt(array2, arrayMap(indexes, function(index2) {
              return isIndex(index2, length) ? +index2 : index2;
            }).sort(compareAscending));
            return result2;
          });
          function remove2(array2, predicate) {
            var result2 = [];
            if (!(array2 && array2.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length = array2.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length) {
              var value = array2[index2];
              if (predicate(value, index2, array2)) {
                result2.push(value);
                indexes.push(index2);
              }
            }
            basePullAt(array2, indexes);
            return result2;
          }
          function reverse2(array2) {
            return array2 == null ? array2 : nativeReverse.call(array2);
          }
          function slice2(array2, start, end) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined2 ? length : toInteger(end);
            }
            return baseSlice(array2, start, end);
          }
          function sortedIndex(array2, value) {
            return baseSortedIndex(array2, value);
          }
          function sortedIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index2 = baseSortedIndex(array2, value);
              if (index2 < length && eq2(array2[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array2, value) {
            return baseSortedIndex(array2, value, true);
          }
          function sortedLastIndexBy(array2, value, iteratee2) {
            return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array2, value) {
            var length = array2 == null ? 0 : array2.length;
            if (length) {
              var index2 = baseSortedIndex(array2, value, true) - 1;
              if (eq2(array2[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array2) {
            return array2 && array2.length ? baseSortedUniq(array2) : [];
          }
          function sortedUniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array2) {
            var length = array2 == null ? 0 : array2.length;
            return length ? baseSlice(array2, 1, length) : [];
          }
          function take2(array2, n4, guard) {
            if (!(array2 && array2.length)) {
              return [];
            }
            n4 = guard || n4 === undefined2 ? 1 : toInteger(n4);
            return baseSlice(array2, 0, n4 < 0 ? 0 : n4);
          }
          function takeRight(array2, n4, guard) {
            var length = array2 == null ? 0 : array2.length;
            if (!length) {
              return [];
            }
            n4 = guard || n4 === undefined2 ? 1 : toInteger(n4);
            n4 = length - n4;
            return baseSlice(array2, n4 < 0 ? 0 : n4, length);
          }
          function takeRightWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array2, predicate) {
            return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last2(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array2) {
            return array2 && array2.length ? baseUniq(array2) : [];
          }
          function uniqBy(array2, iteratee2) {
            return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array2, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
          }
          function unzip(array2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var length = 0;
            array2 = arrayFilter(array2, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index2) {
              return arrayMap(array2, baseProperty(index2));
            });
          }
          function unzipWith(array2, iteratee2) {
            if (!(array2 && array2.length)) {
              return [];
            }
            var result2 = unzip(array2);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array2, values2) {
            return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
          });
          var xor2 = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last2(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last2(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain2(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
              return baseAt(object2, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array2) {
              if (length && !array2.length) {
                array2.push(undefined2);
              }
              return array2;
            });
          });
          function wrapperChain() {
            return chain2(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse2],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse2);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray3(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter2(collection, predicate) {
            var func = isArray3(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map3(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map3(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map3(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray3(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray3(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike2(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map3(collection, iteratee2) {
            var func = isArray3(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray3(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray3(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray3(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray3(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray3(collection) ? arrayFilter : baseFilter;
            return func(collection, negate2(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray3(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n4, guard) {
            if (guard ? isIterateeCall(collection, n4, guard) : n4 === undefined2) {
              n4 = 1;
            } else {
              n4 = toInteger(n4);
            }
            var func = isArray3(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n4);
          }
          function shuffle(collection) {
            var func = isArray3(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size3(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike2(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray3(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now2 = ctxNow || function() {
            return root.Date.now();
          };
          function after(n4, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n4 = toInteger(n4);
            return function() {
              if (--n4 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n4, guard) {
            n4 = guard ? undefined2 : n4;
            n4 = func && n4 == null ? func.length : n4;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n4);
          }
          function before(n4, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n4 = toInteger(n4);
            return function() {
              if (--n4 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n4 <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind2 = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind2));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object2, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object2, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait2, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait2 = toNumber2(wait2) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait2) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait2);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now2();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush() {
              return timerId === undefined2 ? result2 : trailingEdge(now2());
            }
            function debounced() {
              var time = now2(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait2);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait2);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay2 = baseRest(function(func, wait2, args) {
            return baseDelay(func, toNumber2(wait2) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate2(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once2(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray3(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index2 = -1, length = nativeMin(args.length, funcsLength);
              while (++index2 < length) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined2 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array2 = args[start], otherArgs = castSlice(args, 0, start);
              if (array2) {
                arrayPush(otherArgs, array2);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle2(func, wait2, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait2, {
              "leading": leading,
              "maxWait": wait2,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray3(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object2, source) {
            return source == null || baseConformsTo(object2, source, keys(source));
          }
          function eq2(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt2 = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray3 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike2(value) {
            return value != null && isLength(value.length) && !isFunction3(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike2(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike2(value) && (isArray3(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction3(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject2(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object2, source) {
            return object2 === source || baseIsMatch(object2, source, getMatchData(source));
          }
          function isMatchWith(object2, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object2, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject2(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto2 = getPrototype(value);
            if (proto2 === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike2(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber2(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign2 = value < 0 ? -1 : 1;
              return sign2 * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber2(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject2(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString3(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign2 = createAssigner(function(object2, source) {
            if (isPrototype(source) || isArrayLike2(source)) {
              copyObject(source, keys(source), object2);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object2, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object2, source) {
            copyObject(source, keysIn(source), object2);
          });
          var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object2, customizer);
          });
          var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
            copyObject(source, keys(source), object2, customizer);
          });
          var at2 = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults = baseRest(function(object2, sources) {
            object2 = Object2(object2);
            var index2 = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index2 < length) {
              var source = sources[index2];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object2[key];
                if (value === undefined2 || eq2(value, objectProto2[key]) && !hasOwnProperty.call(object2, key)) {
                  object2[key] = source[key];
                }
              }
            }
            return object2;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object2, predicate) {
            return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object2, predicate) {
            return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object2, iteratee2) {
            return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object2, iteratee2) {
            return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object2, iteratee2) {
            return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object2, iteratee2) {
            return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
          }
          function functions(object2) {
            return object2 == null ? [] : baseFunctions(object2, keys(object2));
          }
          function functionsIn(object2) {
            return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
          }
          function get3(object2, path, defaultValue) {
            var result2 = object2 == null ? undefined2 : baseGet(object2, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has2(object2, path) {
            return object2 != null && hasPath(object2, path, baseHas);
          }
          function hasIn(object2, path) {
            return object2 != null && hasPath(object2, path, baseHasIn);
          }
          var invert2 = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity2));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object2) {
            return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
          }
          function keysIn(object2) {
            return isArrayLike2(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
          }
          function mapKeys(object2, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object2, function(value, key, object3) {
              baseAssignValue(result2, iteratee2(value, key, object3), value);
            });
            return result2;
          }
          function mapValues(object2, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object2, function(value, key, object3) {
              baseAssignValue(result2, key, iteratee2(value, key, object3));
            });
            return result2;
          }
          var merge = createAssigner(function(object2, source, srcIndex) {
            baseMerge(object2, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
            baseMerge(object2, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object2, paths) {
            var result2 = {};
            if (object2 == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object2);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object2, getAllKeysIn(object2), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result2, paths[length]);
            }
            return result2;
          });
          function omitBy(object2, predicate) {
            return pickBy(object2, negate2(getIteratee(predicate)));
          }
          var pick = flatRest(function(object2, paths) {
            return object2 == null ? {} : basePick(object2, paths);
          });
          function pickBy(object2, predicate) {
            if (object2 == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object2), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object2, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object2, path, defaultValue) {
            path = castPath(path, object2);
            var index2 = -1, length = path.length;
            if (!length) {
              length = 1;
              object2 = undefined2;
            }
            while (++index2 < length) {
              var value = object2 == null ? undefined2 : object2[toKey(path[index2])];
              if (value === undefined2) {
                index2 = length;
                value = defaultValue;
              }
              object2 = isFunction3(value) ? value.call(object2) : value;
            }
            return object2;
          }
          function set4(object2, path, value) {
            return object2 == null ? object2 : baseSet(object2, path, value);
          }
          function setWith(object2, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object2 == null ? object2 : baseSet(object2, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object2, iteratee2, accumulator) {
            var isArr = isArray3(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object2 && object2.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object2)) {
                accumulator = isFunction3(Ctor) ? baseCreate(getPrototype(object2)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index2, object3) {
              return iteratee2(accumulator, value, index2, object3);
            });
            return accumulator;
          }
          function unset(object2, path) {
            return object2 == null ? true : baseUnset(object2, path);
          }
          function update(object2, path, updater) {
            return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
          }
          function updateWith(object2, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
          }
          function values(object2) {
            return object2 == null ? [] : baseValues(object2, keys(object2));
          }
          function valuesIn(object2) {
            return object2 == null ? [] : baseValues(object2, keysIn(object2));
          }
          function clamp(number2, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber2(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber2(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber2(number2), lower, upper);
          }
          function inRange(number2, start, end) {
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number2 = toNumber2(number2);
            return baseInRange(number2, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString3(string).toLowerCase());
          }
          function deburr(string) {
            string = toString3(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString3(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape2(string) {
            string = toString3(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString3(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad2(string, length, chars) {
            string = toString3(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString3(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString3(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt2(string, radix3, guard) {
            if (guard || radix3 == null) {
              radix3 = 0;
            } else if (radix3) {
              radix3 = +radix3;
            }
            return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix3 || 0);
          }
          function repeat(string, n4, guard) {
            if (guard ? isIterateeCall(string, n4, guard) : n4 === undefined2) {
              n4 = 1;
            } else {
              n4 = toInteger(n4);
            }
            return baseRepeat(toString3(string), n4);
          }
          function replace2() {
            var args = arguments, string = toString3(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split2(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString3(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString3(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString3(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString3(value).toLowerCase();
          }
          function toUpper(value) {
            return toString3(value).toUpperCase();
          }
          function trim2(string, chars, guard) {
            string = toString3(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString3(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString3(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString3(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index2 = result2.lastIndexOf(separator);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString3(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString3(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object2, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object2, key, bind2(object2[key], object2));
            });
            return object2;
          });
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index2 = -1;
              while (++index2 < length) {
                var pair = pairs[index2];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow3 = createFlow();
          var flowRight = createFlow(true);
          function identity2(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object2) {
              return baseInvoke(object2, path, args);
            };
          });
          var methodOf = baseRest(function(object2, args) {
            return function(path) {
              return baseInvoke(object2, path, args);
            };
          });
          function mixin(object2, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object2;
              object2 = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain3 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction3(object2);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object2[methodName] = func;
              if (isFunc) {
                object2.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain3 || chainAll) {
                    var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object2, arrayPush([this.value()], arguments));
                };
              }
            });
            return object2;
          }
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }
          function noop4() {
          }
          function nthArg(n4) {
            n4 = toInteger(n4);
            return baseRest(function(args) {
              return baseNth(args, n4);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property7(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object2) {
            return function(path) {
              return object2 == null ? undefined2 : baseGet(object2, path);
            };
          }
          var range2 = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n4, iteratee2) {
            n4 = toInteger(n4);
            if (n4 < 1 || n4 > MAX_SAFE_INTEGER) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n4, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n4 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length, iteratee2);
            while (++index2 < n4) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray3(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
          }
          function uniqueId(prefix) {
            var id3 = ++idCounter;
            return toString3(prefix) + id3;
          }
          var add3 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide2 = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : undefined2;
          }
          function maxBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array2) {
            return baseMean(array2, identity2);
          }
          function meanBy(array2, iteratee2) {
            return baseMean(array2, getIteratee(iteratee2, 2));
          }
          function min(array2) {
            return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : undefined2;
          }
          function minBy(array2, iteratee2) {
            return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply2 = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract2 = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array2) {
            return array2 && array2.length ? baseSum(array2, identity2) : 0;
          }
          function sumBy(array2, iteratee2) {
            return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign2;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at2;
          lodash.before = before;
          lodash.bind = bind2;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain2;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat6;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay2;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter2;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow3;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert2;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map3;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate2;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once2;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property7;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range2;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove2;
          lodash.rest = rest;
          lodash.reverse = reverse2;
          lodash.sampleSize = sampleSize;
          lodash.set = set4;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice2;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split2;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take2;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle2;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor2;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add3;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide2;
          lodash.endsWith = endsWith;
          lodash.eq = eq2;
          lodash.escape = escape2;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get3;
          lodash.gt = gt2;
          lodash.gte = gte;
          lodash.has = has2;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity2;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray3;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike2;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction3;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject2;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject2;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join2;
          lodash.kebabCase = kebabCase;
          lodash.last = last2;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply2;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop4;
          lodash.now = now2;
          lodash.pad = pad2;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace2;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size3;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract2;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber2;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString3;
          lodash.toUpper = toUpper;
          lodash.trim = trim2;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape2;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n4) {
              n4 = n4 === undefined2 ? 1 : nativeMax(toInteger(n4), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n4, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n4, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n4) {
              return this.reverse()[methodName](n4).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity2);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate2(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined2) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray3(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray3(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray3(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _18 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root._ = _18;
          define(function() {
            return _18;
          });
        } else if (freeModule) {
          (freeModule.exports = _18)._ = _18;
          freeExports._ = _18;
        } else {
          root._ = _18;
        }
      }).call(exports2);
    }
  });

  // node_modules/@noble/hashes/esm/hmac.js
  var HMAC, hmac;
  var init_hmac = __esm({
    "node_modules/@noble/hashes/esm/hmac.js"() {
      init_assert();
      init_utils2();
      HMAC = class extends Hash {
        constructor(hash3, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          assert_default.hash(hash3);
          const key = toBytes2(_key);
          this.iHash = hash3.create();
          if (typeof this.iHash.update !== "function")
            throw new TypeError("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad2 = new Uint8Array(blockLen);
          pad2.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
          for (let i4 = 0; i4 < pad2.length; i4++)
            pad2[i4] ^= 54;
          this.iHash.update(pad2);
          this.oHash = hash3.create();
          for (let i4 = 0; i4 < pad2.length; i4++)
            pad2[i4] ^= 54 ^ 92;
          this.oHash.update(pad2);
          pad2.fill(0);
        }
        update(buf) {
          assert_default.exists(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          assert_default.exists(this);
          assert_default.bytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
      hmac.create = (hash3, key) => new HMAC(hash3, key);
    }
  });

  // node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h6 = isLE2 ? 4 : 0;
    const l4 = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h6, wh, isLE2);
    view.setUint32(byteOffset + l4, wl, isLE2);
  }
  var SHA2;
  var init_sha2 = __esm({
    "node_modules/@noble/hashes/esm/_sha2.js"() {
      init_assert();
      init_utils2();
      SHA2 = class extends Hash {
        constructor(blockLen, outputLen, padOffset, isLE2) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE2;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = createView(this.buffer);
        }
        update(data) {
          assert_default.exists(this);
          const { view, buffer: buffer2, blockLen } = this;
          data = toBytes2(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take2 = Math.min(blockLen - this.pos, len - pos);
            if (take2 === blockLen) {
              const dataView = createView(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer2.set(data.subarray(pos, pos + take2), this.pos);
            this.pos += take2;
            pos += take2;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          assert_default.exists(this);
          assert_default.output(out, this);
          this.finished = true;
          const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
          let { pos } = this;
          buffer2[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i4 = pos; i4 < blockLen; i4++)
            buffer2[i4] = 0;
          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
          this.process(view, 0);
          const oview = createView(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i4 = 0; i4 < outLen; i4++)
            oview.setUint32(4 * i4, state[i4], isLE2);
        }
        digest() {
          const { buffer: buffer2, outputLen } = this;
          this.digestInto(buffer2);
          const res = buffer2.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer2);
          return to;
        }
      };
    }
  });

  // node_modules/@noble/hashes/esm/sha256.js
  var Chi, Maj, SHA256_K, IV, SHA256_W, SHA256, SHA224, sha2563, sha224;
  var init_sha256 = __esm({
    "node_modules/@noble/hashes/esm/sha256.js"() {
      init_sha2();
      init_utils2();
      Chi = (a2, b4, c3) => a2 & b4 ^ ~a2 & c3;
      Maj = (a2, b4, c3) => a2 & b4 ^ a2 & c3 ^ b4 & c3;
      SHA256_K = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      IV = new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      SHA256_W = new Uint32Array(64);
      SHA256 = class extends SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV[0] | 0;
          this.B = IV[1] | 0;
          this.C = IV[2] | 0;
          this.D = IV[3] | 0;
          this.E = IV[4] | 0;
          this.F = IV[5] | 0;
          this.G = IV[6] | 0;
          this.H = IV[7] | 0;
        }
        get() {
          const { A: A3, B: B5, C: C4, D: D4, E: E4, F: F5, G: G5, H: H3 } = this;
          return [A3, B5, C4, D4, E4, F5, G5, H3];
        }
        // prettier-ignore
        set(A3, B5, C4, D4, E4, F5, G5, H3) {
          this.A = A3 | 0;
          this.B = B5 | 0;
          this.C = C4 | 0;
          this.D = D4 | 0;
          this.E = E4 | 0;
          this.F = F5 | 0;
          this.G = G5 | 0;
          this.H = H3 | 0;
        }
        process(view, offset) {
          for (let i4 = 0; i4 < 16; i4++, offset += 4)
            SHA256_W[i4] = view.getUint32(offset, false);
          for (let i4 = 16; i4 < 64; i4++) {
            const W15 = SHA256_W[i4 - 15];
            const W22 = SHA256_W[i4 - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
            const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
            SHA256_W[i4] = s1 + SHA256_W[i4 - 7] + s0 + SHA256_W[i4 - 16] | 0;
          }
          let { A: A3, B: B5, C: C4, D: D4, E: E4, F: F5, G: G5, H: H3 } = this;
          for (let i4 = 0; i4 < 64; i4++) {
            const sigma1 = rotr(E4, 6) ^ rotr(E4, 11) ^ rotr(E4, 25);
            const T1 = H3 + sigma1 + Chi(E4, F5, G5) + SHA256_K[i4] + SHA256_W[i4] | 0;
            const sigma0 = rotr(A3, 2) ^ rotr(A3, 13) ^ rotr(A3, 22);
            const T22 = sigma0 + Maj(A3, B5, C4) | 0;
            H3 = G5;
            G5 = F5;
            F5 = E4;
            E4 = D4 + T1 | 0;
            D4 = C4;
            C4 = B5;
            B5 = A3;
            A3 = T1 + T22 | 0;
          }
          A3 = A3 + this.A | 0;
          B5 = B5 + this.B | 0;
          C4 = C4 + this.C | 0;
          D4 = D4 + this.D | 0;
          E4 = E4 + this.E | 0;
          F5 = F5 + this.F | 0;
          G5 = G5 + this.G | 0;
          H3 = H3 + this.H | 0;
          this.set(A3, B5, C4, D4, E4, F5, G5, H3);
        }
        roundClean() {
          SHA256_W.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      SHA224 = class extends SHA256 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      sha2563 = wrapConstructor(() => new SHA256());
      sha224 = wrapConstructor(() => new SHA224());
    }
  });

  // node_modules/@noble/curves/esm/abstract/modular.js
  function mod2(a2, b4) {
    const result = a2 % b4;
    return result >= _0n3 ? result : b4 + result;
  }
  function pow(num, power, modulo2) {
    if (modulo2 <= _0n3 || power < _0n3)
      throw new Error("Expected power/modulo > 0");
    if (modulo2 === _1n3)
      return _0n3;
    let res = _1n3;
    while (power > _0n3) {
      if (power & _1n3)
        res = res * num % modulo2;
      num = num * num % modulo2;
      power >>= _1n3;
    }
    return res;
  }
  function pow2(x8, power, modulo2) {
    let res = x8;
    while (power-- > _0n3) {
      res *= res;
      res %= modulo2;
    }
    return res;
  }
  function invert(number2, modulo2) {
    if (number2 === _0n3 || modulo2 <= _0n3) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo2}`);
    }
    let a2 = mod2(number2, modulo2);
    let b4 = modulo2;
    let x8 = _0n3, y4 = _1n3, u3 = _1n3, v7 = _0n3;
    while (a2 !== _0n3) {
      const q4 = b4 / a2;
      const r2 = b4 % a2;
      const m5 = x8 - u3 * q4;
      const n4 = y4 - v7 * q4;
      b4 = a2, a2 = r2, x8 = u3, y4 = v7, u3 = m5, v7 = n4;
    }
    const gcd2 = b4;
    if (gcd2 !== _1n3)
      throw new Error("invert: does not exist");
    return mod2(x8, modulo2);
  }
  function tonelliShanks(P4) {
    const legendreC = (P4 - _1n3) / _2n3;
    let Q2, S3, Z4;
    for (Q2 = P4 - _1n3, S3 = 0; Q2 % _2n3 === _0n3; Q2 /= _2n3, S3++)
      ;
    for (Z4 = _2n3; Z4 < P4 && pow(Z4, legendreC, P4) !== P4 - _1n3; Z4++)
      ;
    if (S3 === 1) {
      const p1div4 = (P4 + _1n3) / _4n;
      return function tonelliFast(Fp2, n4) {
        const root = Fp2.pow(n4, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q2 + _1n3) / _2n3;
    return function tonelliSlow(Fp2, n4) {
      if (Fp2.pow(n4, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r2 = S3;
      let g5 = Fp2.pow(Fp2.mul(Fp2.ONE, Z4), Q2);
      let x8 = Fp2.pow(n4, Q1div2);
      let b4 = Fp2.pow(n4, Q2);
      while (!Fp2.eql(b4, Fp2.ONE)) {
        if (Fp2.eql(b4, Fp2.ZERO))
          return Fp2.ZERO;
        let m5 = 1;
        for (let t22 = Fp2.sqr(b4); m5 < r2; m5++) {
          if (Fp2.eql(t22, Fp2.ONE))
            break;
          t22 = Fp2.sqr(t22);
        }
        const ge4 = Fp2.pow(g5, _1n3 << BigInt(r2 - m5 - 1));
        g5 = Fp2.sqr(ge4);
        x8 = Fp2.mul(x8, ge4);
        b4 = Fp2.mul(b4, g5);
        r2 = m5;
      }
      return x8;
    };
  }
  function FpSqrt(P4) {
    if (P4 % _4n === _3n) {
      const p1div4 = (P4 + _1n3) / _4n;
      return function sqrt3mod4(Fp2, n4) {
        const root = Fp2.pow(n4, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P4 % _8n === _5n) {
      const c1 = (P4 - _5n) / _8n;
      return function sqrt5mod8(Fp2, n4) {
        const n22 = Fp2.mul(n4, _2n3);
        const v7 = Fp2.pow(n22, c1);
        const nv = Fp2.mul(n4, v7);
        const i4 = Fp2.mul(Fp2.mul(nv, _2n3), v7);
        const root = Fp2.mul(nv, Fp2.sub(i4, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P4 % _16n === _9n) {
    }
    return tonelliShanks(P4);
  }
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map3, val) => {
      map3[val] = "function";
      return map3;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f5, num, power) {
    if (power < _0n3)
      throw new Error("Expected power > 0");
    if (power === _0n3)
      return f5.ONE;
    if (power === _1n3)
      return num;
    let p2 = f5.ONE;
    let d6 = num;
    while (power > _0n3) {
      if (power & _1n3)
        p2 = f5.mul(p2, d6);
      d6 = f5.sqr(d6);
      power >>= _1n3;
    }
    return p2;
  }
  function FpInvertBatch(f5, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i4) => {
      if (f5.is0(num))
        return acc;
      tmp[i4] = acc;
      return f5.mul(acc, num);
    }, f5.ONE);
    const inverted = f5.inv(lastMultiplied);
    nums.reduceRight((acc, num, i4) => {
      if (f5.is0(num))
        return acc;
      tmp[i4] = f5.mul(acc, tmp[i4]);
      return f5.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n4, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n4.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field2(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n3)
      throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f5 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n3,
      ONE: _1n3,
      create: (num) => mod2(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n3 <= num && num < ORDER;
      },
      is0: (num) => num === _0n3,
      isOdd: (num) => (num & _1n3) === _1n3,
      neg: (num) => mod2(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod2(num * num, ORDER),
      add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f5, num, power),
      div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n4) => sqrtP(f5, n4)),
      invertBatch: (lst) => FpInvertBatch(f5, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a2, b4, c3) => c3 ? b4 : a2,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f5);
  }
  function hashToPrivateScalar(hash3, groupOrder, isLE2 = false) {
    hash3 = ensureBytes("privateHash", hash3);
    const hashLen = hash3.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
      throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE2 ? bytesToNumberLE(hash3) : bytesToNumberBE(hash3);
    return mod2(num, groupOrder - _1n3) + _1n3;
  }
  var _0n3, _1n3, _2n3, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;
  var init_modular = __esm({
    "node_modules/@noble/curves/esm/abstract/modular.js"() {
      init_utils3();
      _0n3 = BigInt(0);
      _1n3 = BigInt(1);
      _2n3 = BigInt(2);
      _3n = BigInt(3);
      _4n = BigInt(4);
      _5n = BigInt(5);
      _8n = BigInt(8);
      _9n = BigInt(9);
      _16n = BigInt(16);
      FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
    }
  });

  // node_modules/@noble/curves/esm/abstract/curve.js
  function wNAF(c3, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W4) => {
      const windows = Math.ceil(bits / W4) + 1;
      const windowSize = 2 ** (W4 - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      // non-const time multiplication ladder
      unsafeLadder(elm, n4) {
        let p2 = c3.ZERO;
        let d6 = elm;
        while (n4 > _0n4) {
          if (n4 & _1n4)
            p2 = p2.add(d6);
          d6 = d6.double();
          n4 >>= _1n4;
        }
        return p2;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W4) {
        const { windows, windowSize } = opts(W4);
        const points = [];
        let p2 = elm;
        let base = p2;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p2;
          points.push(base);
          for (let i4 = 1; i4 < windowSize; i4++) {
            base = base.add(p2);
            points.push(base);
          }
          p2 = base.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W4, precomputes, n4) {
        const { windows, windowSize } = opts(W4);
        let p2 = c3.ZERO;
        let f5 = c3.BASE;
        const mask = BigInt(2 ** W4 - 1);
        const maxNumber = 2 ** W4;
        const shiftBy = BigInt(W4);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n4 & mask);
          n4 >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n4 += _1n4;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f5 = f5.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p: p2, f: f5 };
      },
      wNAFCached(P4, precomputesMap, n4, transform) {
        const W4 = P4._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P4);
        if (!comp) {
          comp = this.precomputeWindow(P4, W4);
          if (W4 !== 1) {
            precomputesMap.set(P4, transform(comp));
          }
        }
        return this.wNAF(W4, comp, n4);
      }
    };
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }
  var _0n4, _1n4;
  var init_curve = __esm({
    "node_modules/@noble/curves/esm/abstract/curve.js"() {
      init_modular();
      init_utils3();
      _0n4 = BigInt(0);
      _1n4 = BigInt(1);
    }
  });

  // node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a: a2 } = opts;
    if (endo) {
      if (!Fp2.eql(a2, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const toBytes4 = CURVE.toBytes || ((c3, point, isCompressed) => {
      const a2 = point.toAffine();
      return concatBytes3(Uint8Array.from([4]), Fp2.toBytes(a2.x), Fp2.toBytes(a2.y));
    });
    const fromBytes3 = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x8 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y4 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x: x8, y: y4 };
    });
    function weierstrassEquation(x8) {
      const { a: a2, b: b4 } = CURVE;
      const x22 = Fp2.sqr(x8);
      const x32 = Fp2.mul(x22, x8);
      return Fp2.add(Fp2.add(x32, Fp2.mul(x8, a2)), b4);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n4 } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (key instanceof Uint8Array)
          key = bytesToHex2(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod2(num, n4);
      assertGE(num);
      return num;
    }
    const pointPrecomputes = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point3))
        throw new Error("ProjectivePoint expected");
    }
    class Point3 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p2) {
        const { x: x8, y: y4 } = p2 || {};
        if (!p2 || !Fp2.isValid(x8) || !Fp2.isValid(y4))
          throw new Error("invalid affine point");
        if (p2 instanceof Point3)
          throw new Error("projective point not allowed");
        const is0 = (i4) => Fp2.eql(i4, Fp2.ZERO);
        if (is0(x8) && is0(y4))
          return Point3.ZERO;
        return new Point3(x8, y4, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p2) => p2.pz));
        return points.map((p2, i4) => p2.toAffine(toInv[i4])).map(Point3.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex2) {
        const P4 = Point3.fromAffine(fromBytes3(ensureBytes("pointHex", hex2)));
        P4.assertValidity();
        return P4;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint)
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: x8, y: y4 } = this.toAffine();
        if (!Fp2.isValid(x8) || !Fp2.isValid(y4))
          throw new Error("bad point: x or y not FE");
        const left = Fp2.sqr(y4);
        const right = weierstrassEquation(x8);
        if (!Fp2.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: y4 } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y4);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X22, py: Y22, pz: Z22 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X22, Z1));
        const U22 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y22, Z1));
        return U1 && U22;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point3(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: a2, b: b4 } = CURVE;
        const b32 = Fp2.mul(b4, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y32 = Fp2.ZERO, Z32 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t22 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z32 = Fp2.mul(X1, Z1);
        Z32 = Fp2.add(Z32, Z32);
        X3 = Fp2.mul(a2, Z32);
        Y32 = Fp2.mul(b32, t22);
        Y32 = Fp2.add(X3, Y32);
        X3 = Fp2.sub(t1, Y32);
        Y32 = Fp2.add(t1, Y32);
        Y32 = Fp2.mul(X3, Y32);
        X3 = Fp2.mul(t3, X3);
        Z32 = Fp2.mul(b32, Z32);
        t22 = Fp2.mul(a2, t22);
        t3 = Fp2.sub(t0, t22);
        t3 = Fp2.mul(a2, t3);
        t3 = Fp2.add(t3, Z32);
        Z32 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z32, t0);
        t0 = Fp2.add(t0, t22);
        t0 = Fp2.mul(t0, t3);
        Y32 = Fp2.add(Y32, t0);
        t22 = Fp2.mul(Y1, Z1);
        t22 = Fp2.add(t22, t22);
        t0 = Fp2.mul(t22, t3);
        X3 = Fp2.sub(X3, t0);
        Z32 = Fp2.mul(t22, t1);
        Z32 = Fp2.add(Z32, Z32);
        Z32 = Fp2.add(Z32, Z32);
        return new Point3(X3, Y32, Z32);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X22, py: Y22, pz: Z22 } = other;
        let X3 = Fp2.ZERO, Y32 = Fp2.ZERO, Z32 = Fp2.ZERO;
        const a2 = CURVE.a;
        const b32 = Fp2.mul(CURVE.b, _3n2);
        let t0 = Fp2.mul(X1, X22);
        let t1 = Fp2.mul(Y1, Y22);
        let t22 = Fp2.mul(Z1, Z22);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X22, Y22);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X22, Z22);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t22);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y22, Z22);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t22);
        t5 = Fp2.sub(t5, X3);
        Z32 = Fp2.mul(a2, t4);
        X3 = Fp2.mul(b32, t22);
        Z32 = Fp2.add(X3, Z32);
        X3 = Fp2.sub(t1, Z32);
        Z32 = Fp2.add(t1, Z32);
        Y32 = Fp2.mul(X3, Z32);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t22 = Fp2.mul(a2, t22);
        t4 = Fp2.mul(b32, t4);
        t1 = Fp2.add(t1, t22);
        t22 = Fp2.sub(t0, t22);
        t22 = Fp2.mul(a2, t22);
        t4 = Fp2.add(t4, t22);
        t0 = Fp2.mul(t1, t4);
        Y32 = Fp2.add(Y32, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z32 = Fp2.mul(t5, Z32);
        Z32 = Fp2.add(Z32, t0);
        return new Point3(X3, Y32, Z32);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point3.ZERO);
      }
      wNAF(n4) {
        return wnaf.wNAFCached(this, pointPrecomputes, n4, (comp) => {
          const toInv = Fp2.invertBatch(comp.map((p2) => p2.pz));
          return comp.map((p2, i4) => p2.toAffine(toInv[i4])).map(Point3.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(n4) {
        const I4 = Point3.ZERO;
        if (n4 === _0n5)
          return I4;
        assertGE(n4);
        if (n4 === _1n5)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n4);
        let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n4);
        let k1p = I4;
        let k2p = I4;
        let d6 = this;
        while (k1 > _0n5 || k22 > _0n5) {
          if (k1 & _1n5)
            k1p = k1p.add(d6);
          if (k22 & _1n5)
            k2p = k2p.add(d6);
          d6 = d6.double();
          k1 >>= _1n5;
          k22 >>= _1n5;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        assertGE(scalar);
        let n4 = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n4);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k22);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p: p2, f: f5 } = this.wNAF(n4);
          point = p2;
          fake = f5;
        }
        return Point3.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q2, a2, b4) {
        const G5 = Point3.BASE;
        const mul = (P4, a3) => a3 === _0n5 || a3 === _1n5 || !P4.equals(G5) ? P4.multiplyUnsafe(a3) : P4.multiply(a3);
        const sum = mul(this, a2).add(mul(Q2, b4));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z) ∋ (x=x/z, y=y/z)
      toAffine(iz) {
        const { px: x8, py: y4, pz: z5 } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp2.ONE : Fp2.inv(z5);
        const ax = Fp2.mul(x8, iz);
        const ay = Fp2.mul(y4, iz);
        const zz = Fp2.mul(z5, iz);
        if (is0)
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        if (!Fp2.eql(zz, Fp2.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n5)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point3, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n5)
          return this;
        if (clearCofactor)
          return clearCofactor(Point3, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes4(Point3, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex2(this.toRawBytes(isCompressed));
      }
    }
    Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point3,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n5 < num && num < Fp2.ORDER;
    }
    function modN2(a2) {
      return mod2(a2, CURVE_ORDER);
    }
    function invN(a2) {
      return invert(a2, CURVE_ORDER);
    }
    const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(c3, point, isCompressed) {
        const a2 = point.toAffine();
        const x8 = Fp2.toBytes(a2.x);
        const cat = concatBytes3;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x8);
        } else {
          return cat(Uint8Array.from([4]), x8, Fp2.toBytes(a2.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x8 = bytesToNumberBE(tail);
          if (!isValidFieldElement(x8))
            throw new Error("Point is not on curve");
          const y22 = weierstrassEquation(x8);
          let y4 = Fp2.sqrt(y22);
          const isYOdd = (y4 & _1n5) === _1n5;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y4 = Fp2.neg(y4);
          return { x: x8, y: y4 };
        } else if (len === uncompressedLen && head === 4) {
          const x8 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y4 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x: x8, y: y4 };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n5;
      return number2 > HALF;
    }
    function normalizeS(s4) {
      return isBiggerThanHalfOrder(s4) ? modN2(-s4) : s4;
    }
    const slcNum = (b4, from2, to) => bytesToNumberBE(b4.slice(from2, to));
    class Signature {
      constructor(r2, s4, recovery) {
        this.r = r2;
        this.s = s4;
        this.recovery = recovery;
        this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex2) {
        const l4 = CURVE.nByteLength;
        hex2 = ensureBytes("compactSignature", hex2, l4 * 2);
        return new Signature(slcNum(hex2, 0, l4), slcNum(hex2, l4, 2 * l4));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex2) {
        const { r: r2, s: s4 } = DER.toSig(ensureBytes("DER", hex2));
        return new Signature(r2, s4);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r: r2, s: s4, recovery: rec } = this;
        const h6 = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R4 = Point3.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN2(-h6 * ir);
        const u22 = modN2(s4 * ir);
        const Q2 = Point3.BASE.multiplyAndAddUnsafe(R4, u1, u22);
        if (!Q2)
          throw new Error("point at infinify");
        Q2.assertValidity();
        return Q2;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes2(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes2(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size (nBitLength+64)
       * as per FIPS 186 B.4.1 with modulo bias being neglible.
       */
      randomPrivateKey: () => {
        const rand = CURVE.randomBytes(Fp2.BYTES + 8);
        const num = hashToPrivateScalar(rand, CURVE_ORDER);
        return numberToBytesBE(num, CURVE.nByteLength);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point = Point3.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point3)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b4 = Point3.fromHex(publicB);
      return b4.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN2(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n5 <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k3) => k3 in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash3, randomBytes: randomBytes3 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d6 = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d6), int2octets(h1int)];
      if (ent != null) {
        const e = ent === true ? randomBytes3(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e, Fp2.BYTES));
      }
      const seed = concatBytes3(...seedArgs);
      const m5 = h1int;
      function k2sig(kBytes) {
        const k3 = bits2int(kBytes);
        if (!isWithinCurveOrder(k3))
          return;
        const ik = invN(k3);
        const q4 = Point3.BASE.multiply(k3).toAffine();
        const r2 = modN2(q4.x);
        if (r2 === _0n5)
          return;
        const s4 = modN2(ik * modN2(m5 + r2 * d6));
        if (s4 === _0n5)
          return;
        let recovery = (q4.x === r2 ? 0 : 2) | Number(q4.y & _1n5);
        let normS = s4;
        if (lowS && isBiggerThanHalfOrder(s4)) {
          normS = normalizeS(s4);
          recovery ^= 1;
        }
        return new Signature(r2, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign2(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const drbg = createHmacDrbg(CURVE.hash.outputLen, CURVE.nByteLength, CURVE.hmac);
      return drbg(seed, k2sig);
    }
    Point3.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P4;
      try {
        if (typeof sg === "string" || sg instanceof Uint8Array) {
          try {
            _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r3, s: s5 } = sg;
          _sig = new Signature(r3, s5);
        } else {
          throw new Error("PARSE");
        }
        P4 = Point3.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r: r2, s: s4 } = _sig;
      const h6 = bits2int_modN(msgHash);
      const is = invN(s4);
      const u1 = modN2(h6 * is);
      const u22 = modN2(r2 * is);
      const R4 = Point3.BASE.multiplyAndAddUnsafe(P4, u1, u22)?.toAffine();
      if (!R4)
        return false;
      const v7 = modN2(R4.x);
      return v7 === r2;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign: sign2,
      verify,
      ProjectivePoint: Point3,
      Signature,
      utils
    };
  }
  function SWUFpSqrtRatio(Fp2, Z4) {
    const q4 = Fp2.ORDER;
    let l4 = _0n5;
    for (let o3 = q4 - _1n5; o3 % _2n4 === _0n5; o3 /= _2n4)
      l4 += _1n5;
    const c1 = l4;
    const c22 = (q4 - _1n5) / _2n4 ** c1;
    const c3 = (c22 - _1n5) / _2n4;
    const c4 = _2n4 ** c1 - _1n5;
    const c5 = _2n4 ** (c1 - _1n5);
    const c6 = Fp2.pow(Z4, c22);
    const c7 = Fp2.pow(Z4, (c22 + _1n5) / _2n4);
    let sqrtRatio = (u3, v7) => {
      let tv1 = c6;
      let tv2 = Fp2.pow(v7, c4);
      let tv3 = Fp2.sqr(tv2);
      tv3 = Fp2.mul(tv3, v7);
      let tv5 = Fp2.mul(u3, tv3);
      tv5 = Fp2.pow(tv5, c3);
      tv5 = Fp2.mul(tv5, tv2);
      tv2 = Fp2.mul(tv5, v7);
      tv3 = Fp2.mul(tv5, u3);
      let tv4 = Fp2.mul(tv3, tv2);
      tv5 = Fp2.pow(tv4, c5);
      let isQR = Fp2.eql(tv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, c7);
      tv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, isQR);
      tv4 = Fp2.cmov(tv5, tv4, isQR);
      for (let i4 = c1; i4 > _1n5; i4--) {
        let tv52 = _2n4 ** (i4 - _2n4);
        let tvv5 = Fp2.pow(tv4, tv52);
        const e1 = Fp2.eql(tvv5, Fp2.ONE);
        tv2 = Fp2.mul(tv3, tv1);
        tv1 = Fp2.mul(tv1, tv1);
        tvv5 = Fp2.mul(tv4, tv1);
        tv3 = Fp2.cmov(tv2, tv3, e1);
        tv4 = Fp2.cmov(tvv5, tv4, e1);
      }
      return { isValid: isQR, value: tv3 };
    };
    if (Fp2.ORDER % _4n2 === _3n2) {
      const c12 = (Fp2.ORDER - _3n2) / _4n2;
      const c23 = Fp2.sqrt(Fp2.neg(Z4));
      sqrtRatio = (u3, v7) => {
        let tv1 = Fp2.sqr(v7);
        const tv2 = Fp2.mul(u3, v7);
        tv1 = Fp2.mul(tv1, tv2);
        let y1 = Fp2.pow(tv1, c12);
        y1 = Fp2.mul(y1, tv2);
        const y22 = Fp2.mul(y1, c23);
        const tv3 = Fp2.mul(Fp2.sqr(y1), v7);
        const isQR = Fp2.eql(tv3, u3);
        let y4 = Fp2.cmov(y22, y1, isQR);
        return { isValid: isQR, value: y4 };
      };
    }
    return sqrtRatio;
  }
  function mapToCurveSimpleSWU(Fp2, opts) {
    validateField(Fp2);
    if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
    if (!Fp2.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (u3) => {
      let tv1, tv2, tv3, tv4, tv5, tv6, x8, y4;
      tv1 = Fp2.sqr(u3);
      tv1 = Fp2.mul(tv1, opts.Z);
      tv2 = Fp2.sqr(tv1);
      tv2 = Fp2.add(tv2, tv1);
      tv3 = Fp2.add(tv2, Fp2.ONE);
      tv3 = Fp2.mul(tv3, opts.B);
      tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
      tv4 = Fp2.mul(tv4, opts.A);
      tv2 = Fp2.sqr(tv3);
      tv6 = Fp2.sqr(tv4);
      tv5 = Fp2.mul(tv6, opts.A);
      tv2 = Fp2.add(tv2, tv5);
      tv2 = Fp2.mul(tv2, tv3);
      tv6 = Fp2.mul(tv6, tv4);
      tv5 = Fp2.mul(tv6, opts.B);
      tv2 = Fp2.add(tv2, tv5);
      x8 = Fp2.mul(tv1, tv3);
      const { isValid: isValid2, value } = sqrtRatio(tv2, tv6);
      y4 = Fp2.mul(tv1, u3);
      y4 = Fp2.mul(y4, value);
      x8 = Fp2.cmov(x8, tv3, isValid2);
      y4 = Fp2.cmov(y4, value, isValid2);
      const e1 = Fp2.isOdd(u3) === Fp2.isOdd(y4);
      y4 = Fp2.cmov(Fp2.neg(y4), y4, e1);
      x8 = Fp2.div(x8, tv4);
      return { x: x8, y: y4 };
    };
  }
  var b2n, h2b, DER, _0n5, _1n5, _2n4, _3n2, _4n2;
  var init_weierstrass = __esm({
    "node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
      init_modular();
      init_utils3();
      init_utils3();
      init_curve();
      ({ bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports2);
      DER = {
        // asn.1 DER encoding utils
        Err: class DERErr extends Error {
          constructor(m5 = "") {
            super(m5);
          }
        },
        _parseInt(data) {
          const { Err: E4 } = DER;
          if (data.length < 2 || data[0] !== 2)
            throw new E4("Invalid signature integer tag");
          const len = data[1];
          const res = data.subarray(2, len + 2);
          if (!len || res.length !== len)
            throw new E4("Invalid signature integer: wrong length");
          if (res[0] & 128)
            throw new E4("Invalid signature integer: negative");
          if (res[0] === 0 && !(res[1] & 128))
            throw new E4("Invalid signature integer: unnecessary leading zero");
          return { d: b2n(res), l: data.subarray(len + 2) };
        },
        toSig(hex2) {
          const { Err: E4 } = DER;
          const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
          if (!(data instanceof Uint8Array))
            throw new Error("ui8a expected");
          let l4 = data.length;
          if (l4 < 2 || data[0] != 48)
            throw new E4("Invalid signature tag");
          if (data[1] !== l4 - 2)
            throw new E4("Invalid signature: incorrect length");
          const { d: r2, l: sBytes } = DER._parseInt(data.subarray(2));
          const { d: s4, l: rBytesLeft } = DER._parseInt(sBytes);
          if (rBytesLeft.length)
            throw new E4("Invalid signature: left bytes after parsing");
          return { r: r2, s: s4 };
        },
        hexFromSig(sig) {
          const slice2 = (s5) => Number.parseInt(s5[0], 16) & 8 ? "00" + s5 : s5;
          const h6 = (num) => {
            const hex2 = num.toString(16);
            return hex2.length & 1 ? `0${hex2}` : hex2;
          };
          const s4 = slice2(h6(sig.s));
          const r2 = slice2(h6(sig.r));
          const shl = s4.length / 2;
          const rhl = r2.length / 2;
          const sl = h6(shl);
          const rl = h6(rhl);
          return `30${h6(rhl + shl + 4)}02${rl}${r2}02${sl}${s4}`;
        }
      };
      _0n5 = BigInt(0);
      _1n5 = BigInt(1);
      _2n4 = BigInt(2);
      _3n2 = BigInt(3);
      _4n2 = BigInt(4);
    }
  });

  // node_modules/@noble/curves/esm/abstract/hash-to-curve.js
  function validateDST(dst) {
    if (dst instanceof Uint8Array)
      return dst;
    if (typeof dst === "string")
      return utf8ToBytes2(dst);
    throw new Error("DST must be Uint8Array or string");
  }
  function i2osp(value, length) {
    if (value < 0 || value >= 1 << 8 * length) {
      throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i4 = length - 1; i4 >= 0; i4--) {
      res[i4] = value & 255;
      value >>>= 8;
    }
    return new Uint8Array(res);
  }
  function strxor(a2, b4) {
    const arr = new Uint8Array(a2.length);
    for (let i4 = 0; i4 < a2.length; i4++) {
      arr[i4] = a2[i4] ^ b4[i4];
    }
    return arr;
  }
  function isBytes4(item) {
    if (!(item instanceof Uint8Array))
      throw new Error("Uint8Array expected");
  }
  function isNum(item) {
    if (!Number.isSafeInteger(item))
      throw new Error("number expected");
  }
  function expand_message_xmd(msg, DST, lenInBytes, H3) {
    isBytes4(msg);
    isBytes4(DST);
    isNum(lenInBytes);
    if (DST.length > 255)
      DST = H3(concatBytes3(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H3;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
      throw new Error("Invalid xmd length");
    const DST_prime = concatBytes3(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b4 = new Array(ell);
    const b_0 = H3(concatBytes3(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b4[0] = H3(concatBytes3(b_0, i2osp(1, 1), DST_prime));
    for (let i4 = 1; i4 <= ell; i4++) {
      const args = [strxor(b_0, b4[i4 - 1]), i2osp(i4 + 1, 1), DST_prime];
      b4[i4] = H3(concatBytes3(...args));
    }
    const pseudo_random_bytes = concatBytes3(...b4);
    return pseudo_random_bytes.slice(0, lenInBytes);
  }
  function expand_message_xof(msg, DST, lenInBytes, k3, H3) {
    isBytes4(msg);
    isBytes4(DST);
    isNum(lenInBytes);
    if (DST.length > 255) {
      const dkLen = Math.ceil(2 * k3 / 8);
      DST = H3.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
      throw new Error("expand_message_xof: invalid lenInBytes");
    return H3.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
  }
  function hash_to_field(msg, count, options) {
    validateObject(options, {
      DST: "string",
      p: "bigint",
      m: "isSafeInteger",
      k: "isSafeInteger",
      hash: "hash"
    });
    const { p: p2, k: k3, m: m5, hash: hash3, expand, DST: _DST } = options;
    isBytes4(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p2.toString(2).length;
    const L3 = Math.ceil((log2p + k3) / 8);
    const len_in_bytes = count * m5 * L3;
    let prb;
    if (expand === "xmd") {
      prb = expand_message_xmd(msg, DST, len_in_bytes, hash3);
    } else if (expand === "xof") {
      prb = expand_message_xof(msg, DST, len_in_bytes, k3, hash3);
    } else if (expand === "_internal_pass") {
      prb = msg;
    } else {
      throw new Error('expand must be "xmd" or "xof"');
    }
    const u3 = new Array(count);
    for (let i4 = 0; i4 < count; i4++) {
      const e = new Array(m5);
      for (let j3 = 0; j3 < m5; j3++) {
        const elm_offset = L3 * (j3 + i4 * m5);
        const tv = prb.subarray(elm_offset, elm_offset + L3);
        e[j3] = mod2(os2ip(tv), p2);
      }
      u3[i4] = e;
    }
    return u3;
  }
  function isogenyMap(field, map3) {
    const COEFF = map3.map((i4) => Array.from(i4).reverse());
    return (x8, y4) => {
      const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i4) => field.add(field.mul(acc, x8), i4)));
      x8 = field.div(xNum, xDen);
      y4 = field.mul(y4, field.div(yNum, yDen));
      return { x: x8, y: y4 };
    };
  }
  function createHasher(Point3, mapToCurve, def) {
    if (typeof mapToCurve !== "function")
      throw new Error("mapToCurve() must be defined");
    return {
      // Encodes byte string to elliptic curve
      // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
      hashToCurve(msg, options) {
        const u3 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
        const u0 = Point3.fromAffine(mapToCurve(u3[0]));
        const u1 = Point3.fromAffine(mapToCurve(u3[1]));
        const P4 = u0.add(u1).clearCofactor();
        P4.assertValidity();
        return P4;
      },
      // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
      encodeToCurve(msg, options) {
        const u3 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
        const P4 = Point3.fromAffine(mapToCurve(u3[0])).clearCofactor();
        P4.assertValidity();
        return P4;
      }
    };
  }
  var os2ip;
  var init_hash_to_curve = __esm({
    "node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
      init_modular();
      init_utils3();
      os2ip = bytesToNumberBE;
    }
  });

  // node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash3) {
    return {
      hash: hash3,
      hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
      randomBytes: randomBytes2
    };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
    return Object.freeze({ ...create(defHash), create });
  }
  var init_shortw_utils = __esm({
    "node_modules/@noble/curves/esm/_shortw_utils.js"() {
      init_hmac();
      init_utils2();
      init_weierstrass();
    }
  });

  // node_modules/@noble/curves/esm/secp256k1.js
  function sqrtMod(y4) {
    const P4 = secp256k1P;
    const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b22 = y4 * y4 * y4 % P4;
    const b32 = b22 * b22 * y4 % P4;
    const b6 = pow2(b32, _3n3, P4) * b32 % P4;
    const b9 = pow2(b6, _3n3, P4) * b32 % P4;
    const b11 = pow2(b9, _2n5, P4) * b22 % P4;
    const b222 = pow2(b11, _11n, P4) * b11 % P4;
    const b44 = pow2(b222, _22n, P4) * b222 % P4;
    const b88 = pow2(b44, _44n, P4) * b44 % P4;
    const b176 = pow2(b88, _88n, P4) * b88 % P4;
    const b220 = pow2(b176, _44n, P4) * b44 % P4;
    const b223 = pow2(b220, _3n3, P4) * b32 % P4;
    const t1 = pow2(b223, _23n, P4) * b222 % P4;
    const t22 = pow2(t1, _6n, P4) * b22 % P4;
    const root = pow2(t22, _2n5, P4);
    if (!Fp.eql(Fp.sqr(root), y4))
      throw new Error("Cannot find square root");
    return root;
  }
  function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = sha2563(Uint8Array.from(tag, (c3) => c3.charCodeAt(0)));
      tagP = concatBytes3(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return sha2563(concatBytes3(tagP, ...messages));
  }
  function schnorrGetExtPubKey(priv) {
    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
    let p2 = Point.fromPrivateKey(d_);
    const scalar = p2.hasEvenY() ? d_ : modN(-d_);
    return { scalar, bytes: pointToBytes(p2) };
  }
  function lift_x(x8) {
    if (!fe2(x8))
      throw new Error("bad x: need 0 < x < p");
    const xx = modP(x8 * x8);
    const c3 = modP(xx * x8 + BigInt(7));
    let y4 = sqrtMod(c3);
    if (y4 % _2n5 !== _0n6)
      y4 = modP(-y4);
    const p2 = new Point(x8, y4, _1n6);
    p2.assertValidity();
    return p2;
  }
  function challenge(...args) {
    return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message, privateKey, auxRand = randomBytes2(32)) {
    const m5 = ensureBytes("message", message);
    const { bytes: px, scalar: d6 } = schnorrGetExtPubKey(privateKey);
    const a2 = ensureBytes("auxRand", auxRand, 32);
    const t3 = numTo32b(d6 ^ bytesToNumberBE(taggedHash("BIP0340/aux", a2)));
    const rand = taggedHash("BIP0340/nonce", t3, px, m5);
    const k_ = modN(bytesToNumberBE(rand));
    if (k_ === _0n6)
      throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k3 } = schnorrGetExtPubKey(k_);
    const e = challenge(rx, px, m5);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k3 + e * d6)), 32);
    if (!schnorrVerify(sig, m5, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature, message, publicKey) {
    const sig = ensureBytes("signature", signature, 64);
    const m5 = ensureBytes("message", message);
    const pub = ensureBytes("publicKey", publicKey, 32);
    try {
      const P4 = lift_x(bytesToNumberBE(pub));
      const r2 = bytesToNumberBE(sig.subarray(0, 32));
      if (!fe2(r2))
        return false;
      const s4 = bytesToNumberBE(sig.subarray(32, 64));
      if (!ge2(s4))
        return false;
      const e = challenge(numTo32b(r2), pointToBytes(P4), m5);
      const R4 = GmulAdd(P4, s4, modN(-e));
      if (!R4 || !R4.hasEvenY() || R4.toAffine().x !== r2)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  var secp256k1P, secp256k1N, _1n6, _2n5, divNearest, Fp, secp256k1, _0n6, fe2, ge2, TAGGED_HASH_PREFIXES, pointToBytes, numTo32b, modP, modN, Point, GmulAdd, schnorr, isoMap, mapSWU, hashToCurve, encodeToCurve;
  var init_secp256k1 = __esm({
    "node_modules/@noble/curves/esm/secp256k1.js"() {
      init_sha256();
      init_utils2();
      init_modular();
      init_weierstrass();
      init_utils3();
      init_hash_to_curve();
      init_shortw_utils();
      secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
      secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
      _1n6 = BigInt(1);
      _2n5 = BigInt(2);
      divNearest = (a2, b4) => (a2 + b4 / _2n5) / b4;
      Fp = Field2(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
      secp256k1 = createCurve({
        a: BigInt(0),
        b: BigInt(7),
        Fp,
        n: secp256k1N,
        // Base point (x, y) aka generator point
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: true,
        /**
         * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
         * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
         * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
         * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
         */
        endo: {
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: (k3) => {
            const n4 = secp256k1N;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b22 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000");
            const c1 = divNearest(b22 * k3, n4);
            const c22 = divNearest(-b1 * k3, n4);
            let k1 = mod2(k3 - c1 * a1 - c22 * a2, n4);
            let k22 = mod2(-c1 * b1 - c22 * b22, n4);
            const k1neg = k1 > POW_2_128;
            const k2neg = k22 > POW_2_128;
            if (k1neg)
              k1 = n4 - k1;
            if (k2neg)
              k22 = n4 - k22;
            if (k1 > POW_2_128 || k22 > POW_2_128) {
              throw new Error("splitScalar: Endomorphism failed, k=" + k3);
            }
            return { k1neg, k1, k2neg, k2: k22 };
          }
        }
      }, sha2563);
      _0n6 = BigInt(0);
      fe2 = (x8) => typeof x8 === "bigint" && _0n6 < x8 && x8 < secp256k1P;
      ge2 = (x8) => typeof x8 === "bigint" && _0n6 < x8 && x8 < secp256k1N;
      TAGGED_HASH_PREFIXES = {};
      pointToBytes = (point) => point.toRawBytes(true).slice(1);
      numTo32b = (n4) => numberToBytesBE(n4, 32);
      modP = (x8) => mod2(x8, secp256k1P);
      modN = (x8) => mod2(x8, secp256k1N);
      Point = secp256k1.ProjectivePoint;
      GmulAdd = (Q2, a2, b4) => Point.BASE.multiplyAndAddUnsafe(Q2, a2, b4);
      schnorr = {
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
          randomPrivateKey: secp256k1.utils.randomPrivateKey,
          lift_x,
          pointToBytes,
          numberToBytesBE,
          bytesToNumberBE,
          taggedHash,
          mod: mod2
        }
      };
      isoMap = isogenyMap(Fp, [
        // xNum
        [
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
          "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
          "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
          "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
          "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ],
        // yNum
        [
          "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
          "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
          "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
          "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
          "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
          "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ]
      ].map((i4) => i4.map((j3) => BigInt(j3))));
      mapSWU = mapToCurveSimpleSWU(Fp, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fp.create(BigInt("-11"))
      });
      ({ hashToCurve, encodeToCurve } = createHasher(secp256k1.ProjectivePoint, (scalars) => {
        const { x: x8, y: y4 } = mapSWU(Fp.create(scalars[0]));
        return isoMap(x8, y4);
      }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha2563
      }));
    }
  });

  // node_modules/@noble/hashes/_assert.js
  var require_assert = __commonJS({
    "node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number2(n4) {
        if (!Number.isSafeInteger(n4) || n4 < 0)
          throw new Error(`Wrong positive integer: ${n4}`);
      }
      exports2.number = number2;
      function bool2(b4) {
        if (typeof b4 !== "boolean")
          throw new Error(`Expected boolean, not ${b4}`);
      }
      exports2.bool = bool2;
      function bytes2(b4, ...lengths) {
        if (!(b4 instanceof Uint8Array))
          throw new TypeError("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b4.length))
          throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b4.length}`);
      }
      exports2.bytes = bytes2;
      function hash3(hash4) {
        if (typeof hash4 !== "function" || typeof hash4.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number2(hash4.outputLen);
        number2(hash4.blockLen);
      }
      exports2.hash = hash3;
      function exists2(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists2;
      function output2(out, instance) {
        bytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports2.output = output2;
      var assert2 = {
        number: number2,
        bool: bool2,
        bytes: bytes2,
        hash: hash3,
        exists: exists2,
        output: output2
      };
      exports2.default = assert2;
    }
  });

  // node_modules/@noble/hashes/crypto.js
  var require_crypto = __commonJS({
    "node_modules/@noble/hashes/crypto.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      exports2.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/utils.js
  var require_utils6 = __commonJS({
    "node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_crypto();
      var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u8;
      var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u322;
      var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView2;
      var rotr2 = (word, shift2) => word << 32 - shift2 | word >>> shift2;
      exports2.rotr = rotr2;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes4 = Array.from({ length: 256 }, (v7, i4) => i4.toString(16).padStart(2, "0"));
      function bytesToHex4(uint8a) {
        if (!(uint8a instanceof Uint8Array))
          throw new Error("Uint8Array expected");
        let hex2 = "";
        for (let i4 = 0; i4 < uint8a.length; i4++) {
          hex2 += hexes4[uint8a[i4]];
        }
        return hex2;
      }
      exports2.bytesToHex = bytesToHex4;
      function hexToBytes4(hex2) {
        if (typeof hex2 !== "string") {
          throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
        }
        if (hex2.length % 2)
          throw new Error("hexToBytes: received invalid unpadded hex");
        const array2 = new Uint8Array(hex2.length / 2);
        for (let i4 = 0; i4 < array2.length; i4++) {
          const j3 = i4 * 2;
          const hexByte = hex2.slice(j3, j3 + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array2[i4] = byte;
        }
        return array2;
      }
      exports2.hexToBytes = hexToBytes4;
      var nextTick = async () => {
      };
      exports2.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i4 = 0; i4 < iters; i4++) {
          cb(i4);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes3(str) {
        if (typeof str !== "string") {
          throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
        }
        return new TextEncoder().encode(str);
      }
      exports2.utf8ToBytes = utf8ToBytes3;
      function toBytes4(data) {
        if (typeof data === "string")
          data = utf8ToBytes3(data);
        if (!(data instanceof Uint8Array))
          throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
        return data;
      }
      exports2.toBytes = toBytes4;
      function concatBytes4(...arrays) {
        if (!arrays.every((a2) => a2 instanceof Uint8Array))
          throw new Error("Uint8Array list expected");
        if (arrays.length === 1)
          return arrays[0];
        const length = arrays.reduce((a2, arr) => a2 + arr.length, 0);
        const result = new Uint8Array(length);
        for (let i4 = 0, pad2 = 0; i4 < arrays.length; i4++) {
          const arr = arrays[i4];
          result.set(arr, pad2);
          pad2 += arr.length;
        }
        return result;
      }
      exports2.concatBytes = concatBytes4;
      var Hash2 = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash2;
      var isPlainObject2 = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject2(opts)))
          throw new TypeError("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor2(hashConstructor) {
        const hashC = (message) => hashConstructor().update(toBytes4(message)).digest();
        const tmp = hashConstructor();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashConstructor();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor2;
      function wrapConstructorWithOpts2(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts2;
      function randomBytes3(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes3;
    }
  });

  // node_modules/@noble/hashes/hmac.js
  var require_hmac2 = __commonJS({
    "node_modules/@noble/hashes/hmac.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hmac = void 0;
      var _assert_js_1 = require_assert();
      var utils_js_1 = require_utils6();
      var HMAC2 = class extends utils_js_1.Hash {
        constructor(hash3, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          _assert_js_1.default.hash(hash3);
          const key = (0, utils_js_1.toBytes)(_key);
          this.iHash = hash3.create();
          if (typeof this.iHash.update !== "function")
            throw new TypeError("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad2 = new Uint8Array(blockLen);
          pad2.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
          for (let i4 = 0; i4 < pad2.length; i4++)
            pad2[i4] ^= 54;
          this.iHash.update(pad2);
          this.oHash = hash3.create();
          for (let i4 = 0; i4 < pad2.length; i4++)
            pad2[i4] ^= 54 ^ 92;
          this.oHash.update(pad2);
          pad2.fill(0);
        }
        update(buf) {
          _assert_js_1.default.exists(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          _assert_js_1.default.exists(this);
          _assert_js_1.default.bytes(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
      exports2.hmac = hmac2;
      exports2.hmac.create = (hash3, key) => new HMAC2(hash3, key);
    }
  });

  // node_modules/@noble/hashes/pbkdf2.js
  var require_pbkdf2 = __commonJS({
    "node_modules/@noble/hashes/pbkdf2.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.pbkdf2Async = exports2.pbkdf2 = void 0;
      var _assert_js_1 = require_assert();
      var hmac_js_1 = require_hmac2();
      var utils_js_1 = require_utils6();
      function pbkdf2Init(hash3, _password, _salt, _opts) {
        _assert_js_1.default.hash(hash3);
        const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
        const { c: c3, dkLen, asyncTick } = opts;
        _assert_js_1.default.number(c3);
        _assert_js_1.default.number(dkLen);
        _assert_js_1.default.number(asyncTick);
        if (c3 < 1)
          throw new Error("PBKDF2: iterations (c) should be >= 1");
        const password = (0, utils_js_1.toBytes)(_password);
        const salt = (0, utils_js_1.toBytes)(_salt);
        const DK = new Uint8Array(dkLen);
        const PRF = hmac_js_1.hmac.create(hash3, password);
        const PRFSalt = PRF._cloneInto().update(salt);
        return { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt };
      }
      function pbkdf2Output(PRF, PRFSalt, DK, prfW, u3) {
        PRF.destroy();
        PRFSalt.destroy();
        if (prfW)
          prfW.destroy();
        u3.fill(0);
        return DK;
      }
      function pbkdf2(hash3, password, salt, opts) {
        const { c: c3, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
        let prfW;
        const arr = new Uint8Array(4);
        const view = (0, utils_js_1.createView)(arr);
        const u3 = new Uint8Array(PRF.outputLen);
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
          const Ti = DK.subarray(pos, pos + PRF.outputLen);
          view.setInt32(0, ti, false);
          (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u3);
          Ti.set(u3.subarray(0, Ti.length));
          for (let ui = 1; ui < c3; ui++) {
            PRF._cloneInto(prfW).update(u3).digestInto(u3);
            for (let i4 = 0; i4 < Ti.length; i4++)
              Ti[i4] ^= u3[i4];
          }
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u3);
      }
      exports2.pbkdf2 = pbkdf2;
      async function pbkdf2Async(hash3, password, salt, opts) {
        const { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
        let prfW;
        const arr = new Uint8Array(4);
        const view = (0, utils_js_1.createView)(arr);
        const u3 = new Uint8Array(PRF.outputLen);
        for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
          const Ti = DK.subarray(pos, pos + PRF.outputLen);
          view.setInt32(0, ti, false);
          (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u3);
          Ti.set(u3.subarray(0, Ti.length));
          await (0, utils_js_1.asyncLoop)(c3 - 1, asyncTick, (i4) => {
            PRF._cloneInto(prfW).update(u3).digestInto(u3);
            for (let i5 = 0; i5 < Ti.length; i5++)
              Ti[i5] ^= u3[i5];
          });
        }
        return pbkdf2Output(PRF, PRFSalt, DK, prfW, u3);
      }
      exports2.pbkdf2Async = pbkdf2Async;
    }
  });

  // node_modules/@noble/hashes/_sha2.js
  var require_sha2 = __commonJS({
    "node_modules/@noble/hashes/_sha2.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SHA2 = void 0;
      var _assert_js_1 = require_assert();
      var utils_js_1 = require_utils6();
      function setBigUint642(view, byteOffset, value, isLE2) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE2);
        const _32n2 = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n2 & _u32_max);
        const wl = Number(value & _u32_max);
        const h6 = isLE2 ? 4 : 0;
        const l4 = isLE2 ? 0 : 4;
        view.setUint32(byteOffset + h6, wh, isLE2);
        view.setUint32(byteOffset + l4, wl, isLE2);
      }
      var SHA22 = class extends utils_js_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE2) {
          super();
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE2;
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_js_1.createView)(this.buffer);
        }
        update(data) {
          _assert_js_1.default.exists(this);
          const { view, buffer: buffer2, blockLen } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take2 = Math.min(blockLen - this.pos, len - pos);
            if (take2 === blockLen) {
              const dataView = (0, utils_js_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer2.set(data.subarray(pos, pos + take2), this.pos);
            this.pos += take2;
            pos += take2;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          _assert_js_1.default.exists(this);
          _assert_js_1.default.output(out, this);
          this.finished = true;
          const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
          let { pos } = this;
          buffer2[pos++] = 128;
          this.buffer.subarray(pos).fill(0);
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i4 = pos; i4 < blockLen; i4++)
            buffer2[i4] = 0;
          setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE2);
          this.process(view, 0);
          const oview = (0, utils_js_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i4 = 0; i4 < outLen; i4++)
            oview.setUint32(4 * i4, state[i4], isLE2);
        }
        digest() {
          const { buffer: buffer2, outputLen } = this;
          this.digestInto(buffer2);
          const res = buffer2.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
          to.length = length;
          to.pos = pos;
          to.finished = finished;
          to.destroyed = destroyed;
          if (length % blockLen)
            to.buffer.set(buffer2);
          return to;
        }
      };
      exports2.SHA2 = SHA22;
    }
  });

  // node_modules/@noble/hashes/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/@noble/hashes/sha256.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha224 = exports2.sha256 = void 0;
      var _sha2_js_1 = require_sha2();
      var utils_js_1 = require_utils6();
      var Chi2 = (a2, b4, c3) => a2 & b4 ^ ~a2 & c3;
      var Maj2 = (a2, b4, c3) => a2 & b4 ^ a2 & c3 ^ b4 & c3;
      var SHA256_K2 = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var IV2 = new Uint32Array([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      var SHA256_W2 = new Uint32Array(64);
      var SHA2562 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(64, 32, 8, false);
          this.A = IV2[0] | 0;
          this.B = IV2[1] | 0;
          this.C = IV2[2] | 0;
          this.D = IV2[3] | 0;
          this.E = IV2[4] | 0;
          this.F = IV2[5] | 0;
          this.G = IV2[6] | 0;
          this.H = IV2[7] | 0;
        }
        get() {
          const { A: A3, B: B5, C: C4, D: D4, E: E4, F: F5, G: G5, H: H3 } = this;
          return [A3, B5, C4, D4, E4, F5, G5, H3];
        }
        // prettier-ignore
        set(A3, B5, C4, D4, E4, F5, G5, H3) {
          this.A = A3 | 0;
          this.B = B5 | 0;
          this.C = C4 | 0;
          this.D = D4 | 0;
          this.E = E4 | 0;
          this.F = F5 | 0;
          this.G = G5 | 0;
          this.H = H3 | 0;
        }
        process(view, offset) {
          for (let i4 = 0; i4 < 16; i4++, offset += 4)
            SHA256_W2[i4] = view.getUint32(offset, false);
          for (let i4 = 16; i4 < 64; i4++) {
            const W15 = SHA256_W2[i4 - 15];
            const W22 = SHA256_W2[i4 - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_js_1.rotr)(W22, 17) ^ (0, utils_js_1.rotr)(W22, 19) ^ W22 >>> 10;
            SHA256_W2[i4] = s1 + SHA256_W2[i4 - 7] + s0 + SHA256_W2[i4 - 16] | 0;
          }
          let { A: A3, B: B5, C: C4, D: D4, E: E4, F: F5, G: G5, H: H3 } = this;
          for (let i4 = 0; i4 < 64; i4++) {
            const sigma1 = (0, utils_js_1.rotr)(E4, 6) ^ (0, utils_js_1.rotr)(E4, 11) ^ (0, utils_js_1.rotr)(E4, 25);
            const T1 = H3 + sigma1 + Chi2(E4, F5, G5) + SHA256_K2[i4] + SHA256_W2[i4] | 0;
            const sigma0 = (0, utils_js_1.rotr)(A3, 2) ^ (0, utils_js_1.rotr)(A3, 13) ^ (0, utils_js_1.rotr)(A3, 22);
            const T22 = sigma0 + Maj2(A3, B5, C4) | 0;
            H3 = G5;
            G5 = F5;
            F5 = E4;
            E4 = D4 + T1 | 0;
            D4 = C4;
            C4 = B5;
            B5 = A3;
            A3 = T1 + T22 | 0;
          }
          A3 = A3 + this.A | 0;
          B5 = B5 + this.B | 0;
          C4 = C4 + this.C | 0;
          D4 = D4 + this.D | 0;
          E4 = E4 + this.E | 0;
          F5 = F5 + this.F | 0;
          G5 = G5 + this.G | 0;
          H3 = H3 + this.H | 0;
          this.set(A3, B5, C4, D4, E4, F5, G5, H3);
        }
        roundClean() {
          SHA256_W2.fill(0);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          this.buffer.fill(0);
        }
      };
      var SHA2242 = class extends SHA2562 {
        constructor() {
          super();
          this.A = 3238371032 | 0;
          this.B = 914150663 | 0;
          this.C = 812702999 | 0;
          this.D = 4144912697 | 0;
          this.E = 4290775857 | 0;
          this.F = 1750603025 | 0;
          this.G = 1694076839 | 0;
          this.H = 3204075428 | 0;
          this.outputLen = 28;
        }
      };
      exports2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2562());
      exports2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA2242());
    }
  });

  // node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add = exports2.toBig = exports2.split = exports2.fromBig = void 0;
      var U32_MASK642 = BigInt(2 ** 32 - 1);
      var _32n2 = BigInt(32);
      function fromBig2(n4, le2 = false) {
        if (le2)
          return { h: Number(n4 & U32_MASK642), l: Number(n4 >> _32n2 & U32_MASK642) };
        return { h: Number(n4 >> _32n2 & U32_MASK642) | 0, l: Number(n4 & U32_MASK642) | 0 };
      }
      exports2.fromBig = fromBig2;
      function split2(lst, le2 = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i4 = 0; i4 < lst.length; i4++) {
          const { h: h6, l: l4 } = fromBig2(lst[i4], le2);
          [Ah[i4], Al[i4]] = [h6, l4];
        }
        return [Ah, Al];
      }
      exports2.split = split2;
      var toBig2 = (h6, l4) => BigInt(h6 >>> 0) << _32n2 | BigInt(l4 >>> 0);
      exports2.toBig = toBig2;
      var shrSH2 = (h6, l4, s4) => h6 >>> s4;
      var shrSL2 = (h6, l4, s4) => h6 << 32 - s4 | l4 >>> s4;
      var rotrSH2 = (h6, l4, s4) => h6 >>> s4 | l4 << 32 - s4;
      var rotrSL2 = (h6, l4, s4) => h6 << 32 - s4 | l4 >>> s4;
      var rotrBH2 = (h6, l4, s4) => h6 << 64 - s4 | l4 >>> s4 - 32;
      var rotrBL2 = (h6, l4, s4) => h6 >>> s4 - 32 | l4 << 64 - s4;
      var rotr32H2 = (h6, l4) => l4;
      var rotr32L2 = (h6, l4) => h6;
      var rotlSH2 = (h6, l4, s4) => h6 << s4 | l4 >>> 32 - s4;
      var rotlSL2 = (h6, l4, s4) => l4 << s4 | h6 >>> 32 - s4;
      var rotlBH2 = (h6, l4, s4) => l4 << s4 - 32 | h6 >>> 64 - s4;
      var rotlBL2 = (h6, l4, s4) => h6 << s4 - 32 | l4 >>> 64 - s4;
      function add3(Ah, Al, Bh, Bl) {
        const l4 = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l4 / 2 ** 32 | 0) | 0, l: l4 | 0 };
      }
      exports2.add = add3;
      var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      var u642 = {
        fromBig: fromBig2,
        split: split2,
        toBig: exports2.toBig,
        shrSH: shrSH2,
        shrSL: shrSL2,
        rotrSH: rotrSH2,
        rotrSL: rotrSL2,
        rotrBH: rotrBH2,
        rotrBL: rotrBL2,
        rotr32H: rotr32H2,
        rotr32L: rotr32L2,
        rotlSH: rotlSH2,
        rotlSL: rotlSL2,
        rotlBH: rotlBH2,
        rotlBL: rotlBL2,
        add: add3,
        add3L: add3L2,
        add3H: add3H2,
        add4L: add4L2,
        add4H: add4H2,
        add5H: add5H2,
        add5L: add5L2
      };
      exports2.default = u642;
    }
  });

  // node_modules/@noble/hashes/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/@noble/hashes/sha512.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sha384 = exports2.sha512_256 = exports2.sha512_224 = exports2.sha512 = exports2.SHA512 = void 0;
      var _sha2_js_1 = require_sha2();
      var _u64_js_1 = require_u64();
      var utils_js_1 = require_utils6();
      var [SHA512_Kh2, SHA512_Kl2] = _u64_js_1.default.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n4) => BigInt(n4)));
      var SHA512_W_H2 = new Uint32Array(80);
      var SHA512_W_L2 = new Uint32Array(80);
      var SHA5122 = class extends _sha2_js_1.SHA2 {
        constructor() {
          super(128, 64, 16, false);
          this.Ah = 1779033703 | 0;
          this.Al = 4089235720 | 0;
          this.Bh = 3144134277 | 0;
          this.Bl = 2227873595 | 0;
          this.Ch = 1013904242 | 0;
          this.Cl = 4271175723 | 0;
          this.Dh = 2773480762 | 0;
          this.Dl = 1595750129 | 0;
          this.Eh = 1359893119 | 0;
          this.El = 2917565137 | 0;
          this.Fh = 2600822924 | 0;
          this.Fl = 725511199 | 0;
          this.Gh = 528734635 | 0;
          this.Gl = 4215389547 | 0;
          this.Hh = 1541459225 | 0;
          this.Hl = 327033209 | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset) {
          for (let i4 = 0; i4 < 16; i4++, offset += 4) {
            SHA512_W_H2[i4] = view.getUint32(offset);
            SHA512_W_L2[i4] = view.getUint32(offset += 4);
          }
          for (let i4 = 16; i4 < 80; i4++) {
            const W15h = SHA512_W_H2[i4 - 15] | 0;
            const W15l = SHA512_W_L2[i4 - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H2[i4 - 2] | 0;
            const W2l = SHA512_W_L2[i4 - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L2[i4 - 7], SHA512_W_L2[i4 - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H2[i4 - 7], SHA512_W_H2[i4 - 16]);
            SHA512_W_H2[i4] = SUMh | 0;
            SHA512_W_L2[i4] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i4 = 0; i4 < 80; i4++) {
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i4], SHA512_W_L2[i4]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i4], SHA512_W_H2[i4]);
            const T1l = T1ll | 0;
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          SHA512_W_H2.fill(0);
          SHA512_W_L2.fill(0);
        }
        destroy() {
          this.buffer.fill(0);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports2.SHA512 = SHA5122;
      var SHA512_2242 = class extends SHA5122 {
        constructor() {
          super();
          this.Ah = 2352822216 | 0;
          this.Al = 424955298 | 0;
          this.Bh = 1944164710 | 0;
          this.Bl = 2312950998 | 0;
          this.Ch = 502970286 | 0;
          this.Cl = 855612546 | 0;
          this.Dh = 1738396948 | 0;
          this.Dl = 1479516111 | 0;
          this.Eh = 258812777 | 0;
          this.El = 2077511080 | 0;
          this.Fh = 2011393907 | 0;
          this.Fl = 79989058 | 0;
          this.Gh = 1067287976 | 0;
          this.Gl = 1780299464 | 0;
          this.Hh = 286451373 | 0;
          this.Hl = 2446758561 | 0;
          this.outputLen = 28;
        }
      };
      var SHA512_2562 = class extends SHA5122 {
        constructor() {
          super();
          this.Ah = 573645204 | 0;
          this.Al = 4230739756 | 0;
          this.Bh = 2673172387 | 0;
          this.Bl = 3360449730 | 0;
          this.Ch = 596883563 | 0;
          this.Cl = 1867755857 | 0;
          this.Dh = 2520282905 | 0;
          this.Dl = 1497426621 | 0;
          this.Eh = 2519219938 | 0;
          this.El = 2827943907 | 0;
          this.Fh = 3193839141 | 0;
          this.Fl = 1401305490 | 0;
          this.Gh = 721525244 | 0;
          this.Gl = 746961066 | 0;
          this.Hh = 246885852 | 0;
          this.Hl = 2177182882 | 0;
          this.outputLen = 32;
        }
      };
      var SHA3842 = class extends SHA5122 {
        constructor() {
          super();
          this.Ah = 3418070365 | 0;
          this.Al = 3238371032 | 0;
          this.Bh = 1654270250 | 0;
          this.Bl = 914150663 | 0;
          this.Ch = 2438529370 | 0;
          this.Cl = 812702999 | 0;
          this.Dh = 355462360 | 0;
          this.Dl = 4144912697 | 0;
          this.Eh = 1731405415 | 0;
          this.El = 4290775857 | 0;
          this.Fh = 2394180231 | 0;
          this.Fl = 1750603025 | 0;
          this.Gh = 3675008525 | 0;
          this.Gl = 1694076839 | 0;
          this.Hh = 1203062813 | 0;
          this.Hl = 3204075428 | 0;
          this.outputLen = 48;
        }
      };
      exports2.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA5122());
      exports2.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2242());
      exports2.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2562());
      exports2.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA3842());
    }
  });

  // node_modules/@scure/base/lib/index.js
  var require_lib32 = __commonJS({
    "node_modules/@scure/base/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.bytes = exports2.stringToBytes = exports2.str = exports2.bytesToString = exports2.hex = exports2.utf8 = exports2.bech32m = exports2.bech32 = exports2.base58check = exports2.base58xmr = exports2.base58xrp = exports2.base58flickr = exports2.base58 = exports2.base64url = exports2.base64 = exports2.base32crockford = exports2.base32hex = exports2.base32 = exports2.base16 = exports2.utils = exports2.assertNumber = void 0;
      function assertNumber2(n4) {
        if (!Number.isSafeInteger(n4))
          throw new Error(`Wrong integer: ${n4}`);
      }
      exports2.assertNumber = assertNumber2;
      function chain2(...args) {
        const wrap = (a2, b4) => (c3) => a2(b4(c3));
        const encode = Array.from(args).reverse().reduce((acc, i4) => acc ? wrap(acc, i4.encode) : i4.encode, void 0);
        const decode = args.reduce((acc, i4) => acc ? wrap(acc, i4.decode) : i4.decode, void 0);
        return { encode, decode };
      }
      function alphabet2(alphabet3) {
        return {
          encode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("alphabet.encode input should be an array of numbers");
            return digits.map((i4) => {
              assertNumber2(i4);
              if (i4 < 0 || i4 >= alphabet3.length)
                throw new Error(`Digit index outside alphabet: ${i4} (alphabet: ${alphabet3.length})`);
              return alphabet3[i4];
            });
          },
          decode: (input) => {
            if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
              throw new Error("alphabet.decode input should be array of strings");
            return input.map((letter) => {
              if (typeof letter !== "string")
                throw new Error(`alphabet.decode: not string element=${letter}`);
              const index2 = alphabet3.indexOf(letter);
              if (index2 === -1)
                throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet3}`);
              return index2;
            });
          }
        };
      }
      function join2(separator = "") {
        if (typeof separator !== "string")
          throw new Error("join separator should be string");
        return {
          encode: (from2) => {
            if (!Array.isArray(from2) || from2.length && typeof from2[0] !== "string")
              throw new Error("join.encode input should be array of strings");
            for (let i4 of from2)
              if (typeof i4 !== "string")
                throw new Error(`join.encode: non-string input=${i4}`);
            return from2.join(separator);
          },
          decode: (to) => {
            if (typeof to !== "string")
              throw new Error("join.decode input should be string");
            return to.split(separator);
          }
        };
      }
      function padding2(bits, chr = "=") {
        assertNumber2(bits);
        if (typeof chr !== "string")
          throw new Error("padding chr should be string");
        return {
          encode(data) {
            if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
              throw new Error("padding.encode input should be array of strings");
            for (let i4 of data)
              if (typeof i4 !== "string")
                throw new Error(`padding.encode: non-string input=${i4}`);
            while (data.length * bits % 8)
              data.push(chr);
            return data;
          },
          decode(input) {
            if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
              throw new Error("padding.encode input should be array of strings");
            for (let i4 of input)
              if (typeof i4 !== "string")
                throw new Error(`padding.decode: non-string input=${i4}`);
            let end = input.length;
            if (end * bits % 8)
              throw new Error("Invalid padding: string should have whole number of bytes");
            for (; end > 0 && input[end - 1] === chr; end--) {
              if (!((end - 1) * bits % 8))
                throw new Error("Invalid padding: string has too much padding");
            }
            return input.slice(0, end);
          }
        };
      }
      function normalize2(fn) {
        if (typeof fn !== "function")
          throw new Error("normalize fn should be function");
        return { encode: (from2) => from2, decode: (to) => fn(to) };
      }
      function convertRadix3(data, from2, to) {
        if (from2 < 2)
          throw new Error(`convertRadix: wrong from=${from2}, base cannot be less than 2`);
        if (to < 2)
          throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
        if (!Array.isArray(data))
          throw new Error("convertRadix: data should be array");
        if (!data.length)
          return [];
        let pos = 0;
        const res = [];
        const digits = Array.from(data);
        digits.forEach((d6) => {
          assertNumber2(d6);
          if (d6 < 0 || d6 >= from2)
            throw new Error(`Wrong integer: ${d6}`);
        });
        while (true) {
          let carry = 0;
          let done = true;
          for (let i4 = pos; i4 < digits.length; i4++) {
            const digit = digits[i4];
            const digitBase = from2 * carry + digit;
            if (!Number.isSafeInteger(digitBase) || from2 * carry / from2 !== carry || digitBase - digit !== from2 * carry) {
              throw new Error("convertRadix: carry overflow");
            }
            carry = digitBase % to;
            digits[i4] = Math.floor(digitBase / to);
            if (!Number.isSafeInteger(digits[i4]) || digits[i4] * to + carry !== digitBase)
              throw new Error("convertRadix: carry overflow");
            if (!done)
              continue;
            else if (!digits[i4])
              pos = i4;
            else
              done = false;
          }
          res.push(carry);
          if (done)
            break;
        }
        for (let i4 = 0; i4 < data.length - 1 && data[i4] === 0; i4++)
          res.push(0);
        return res.reverse();
      }
      var gcd2 = (a2, b4) => !b4 ? a2 : gcd2(b4, a2 % b4);
      var radix2carry2 = (from2, to) => from2 + (to - gcd2(from2, to));
      function convertRadix22(data, from2, to, padding3) {
        if (!Array.isArray(data))
          throw new Error("convertRadix2: data should be array");
        if (from2 <= 0 || from2 > 32)
          throw new Error(`convertRadix2: wrong from=${from2}`);
        if (to <= 0 || to > 32)
          throw new Error(`convertRadix2: wrong to=${to}`);
        if (radix2carry2(from2, to) > 32) {
          throw new Error(`convertRadix2: carry overflow from=${from2} to=${to} carryBits=${radix2carry2(from2, to)}`);
        }
        let carry = 0;
        let pos = 0;
        const mask = 2 ** to - 1;
        const res = [];
        for (const n4 of data) {
          assertNumber2(n4);
          if (n4 >= 2 ** from2)
            throw new Error(`convertRadix2: invalid data word=${n4} from=${from2}`);
          carry = carry << from2 | n4;
          if (pos + from2 > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
          pos += from2;
          for (; pos >= to; pos -= to)
            res.push((carry >> pos - to & mask) >>> 0);
          carry &= 2 ** pos - 1;
        }
        carry = carry << to - pos & mask;
        if (!padding3 && pos >= from2)
          throw new Error("Excess padding");
        if (!padding3 && carry)
          throw new Error(`Non-zero padding: ${carry}`);
        if (padding3 && pos > 0)
          res.push(carry >>> 0);
        return res;
      }
      function radix3(num) {
        assertNumber2(num);
        return {
          encode: (bytes2) => {
            if (!(bytes2 instanceof Uint8Array))
              throw new Error("radix.encode input should be Uint8Array");
            return convertRadix3(Array.from(bytes2), 2 ** 8, num);
          },
          decode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("radix.decode input should be array of strings");
            return Uint8Array.from(convertRadix3(digits, num, 2 ** 8));
          }
        };
      }
      function radix22(bits, revPadding = false) {
        assertNumber2(bits);
        if (bits <= 0 || bits > 32)
          throw new Error("radix2: bits should be in (0..32]");
        if (radix2carry2(8, bits) > 32 || radix2carry2(bits, 8) > 32)
          throw new Error("radix2: carry overflow");
        return {
          encode: (bytes2) => {
            if (!(bytes2 instanceof Uint8Array))
              throw new Error("radix2.encode input should be Uint8Array");
            return convertRadix22(Array.from(bytes2), 8, bits, !revPadding);
          },
          decode: (digits) => {
            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
              throw new Error("radix2.decode input should be array of strings");
            return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
          }
        };
      }
      function unsafeWrapper2(fn) {
        if (typeof fn !== "function")
          throw new Error("unsafeWrapper fn should be function");
        return function(...args) {
          try {
            return fn.apply(null, args);
          } catch (e) {
          }
        };
      }
      function checksum2(len, fn) {
        assertNumber2(len);
        if (typeof fn !== "function")
          throw new Error("checksum fn should be function");
        return {
          encode(data) {
            if (!(data instanceof Uint8Array))
              throw new Error("checksum.encode: input should be Uint8Array");
            const checksum3 = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(checksum3, data.length);
            return res;
          },
          decode(data) {
            if (!(data instanceof Uint8Array))
              throw new Error("checksum.decode: input should be Uint8Array");
            const payload = data.slice(0, -len);
            const newChecksum = fn(payload).slice(0, len);
            const oldChecksum = data.slice(-len);
            for (let i4 = 0; i4 < len; i4++)
              if (newChecksum[i4] !== oldChecksum[i4])
                throw new Error("Invalid checksum");
            return payload;
          }
        };
      }
      exports2.utils = { alphabet: alphabet2, chain: chain2, checksum: checksum2, radix: radix3, radix2: radix22, join: join2, padding: padding2 };
      exports2.base16 = chain2(radix22(4), alphabet2("0123456789ABCDEF"), join2(""));
      exports2.base32 = chain2(radix22(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding2(5), join2(""));
      exports2.base32hex = chain2(radix22(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding2(5), join2(""));
      exports2.base32crockford = chain2(radix22(5), alphabet2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize2((s4) => s4.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
      exports2.base64 = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding2(6), join2(""));
      exports2.base64url = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding2(6), join2(""));
      var genBase582 = (abc) => chain2(radix3(58), alphabet2(abc), join2(""));
      exports2.base58 = genBase582("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
      exports2.base58flickr = genBase582("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
      exports2.base58xrp = genBase582("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
      var XMR_BLOCK_LEN2 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
      exports2.base58xmr = {
        encode(data) {
          let res = "";
          for (let i4 = 0; i4 < data.length; i4 += 8) {
            const block = data.subarray(i4, i4 + 8);
            res += exports2.base58.encode(block).padStart(XMR_BLOCK_LEN2[block.length], "1");
          }
          return res;
        },
        decode(str) {
          let res = [];
          for (let i4 = 0; i4 < str.length; i4 += 11) {
            const slice2 = str.slice(i4, i4 + 11);
            const blockLen = XMR_BLOCK_LEN2.indexOf(slice2.length);
            const block = exports2.base58.decode(slice2);
            for (let j3 = 0; j3 < block.length - blockLen; j3++) {
              if (block[j3] !== 0)
                throw new Error("base58xmr: wrong padding");
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
          }
          return Uint8Array.from(res);
        }
      };
      var base58check3 = (sha2564) => chain2(checksum2(4, (data) => sha2564(sha2564(data))), exports2.base58);
      exports2.base58check = base58check3;
      var BECH_ALPHABET2 = chain2(alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
      var POLYMOD_GENERATORS2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
      function bech32Polymod2(pre) {
        const b4 = pre >> 25;
        let chk = (pre & 33554431) << 5;
        for (let i4 = 0; i4 < POLYMOD_GENERATORS2.length; i4++) {
          if ((b4 >> i4 & 1) === 1)
            chk ^= POLYMOD_GENERATORS2[i4];
        }
        return chk;
      }
      function bechChecksum2(prefix, words, encodingConst = 1) {
        const len = prefix.length;
        let chk = 1;
        for (let i4 = 0; i4 < len; i4++) {
          const c3 = prefix.charCodeAt(i4);
          if (c3 < 33 || c3 > 126)
            throw new Error(`Invalid prefix (${prefix})`);
          chk = bech32Polymod2(chk) ^ c3 >> 5;
        }
        chk = bech32Polymod2(chk);
        for (let i4 = 0; i4 < len; i4++)
          chk = bech32Polymod2(chk) ^ prefix.charCodeAt(i4) & 31;
        for (let v7 of words)
          chk = bech32Polymod2(chk) ^ v7;
        for (let i4 = 0; i4 < 6; i4++)
          chk = bech32Polymod2(chk);
        chk ^= encodingConst;
        return BECH_ALPHABET2.encode(convertRadix22([chk % 2 ** 30], 30, 5, false));
      }
      function genBech322(encoding) {
        const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
        const _words = radix22(5);
        const fromWords = _words.decode;
        const toWords = _words.encode;
        const fromWordsUnsafe = unsafeWrapper2(fromWords);
        function encode(prefix, words, limit = 90) {
          if (typeof prefix !== "string")
            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
          if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
          const actualLength = prefix.length + 7 + words.length;
          if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
          prefix = prefix.toLowerCase();
          return `${prefix}1${BECH_ALPHABET2.encode(words)}${bechChecksum2(prefix, words, ENCODING_CONST)}`;
        }
        function decode(str, limit = 90) {
          if (typeof str !== "string")
            throw new Error(`bech32.decode input should be string, not ${typeof str}`);
          if (str.length < 8 || limit !== false && str.length > limit)
            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
          const lowered = str.toLowerCase();
          if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
          str = lowered;
          const sepIndex = str.lastIndexOf("1");
          if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
          const prefix = str.slice(0, sepIndex);
          const _words2 = str.slice(sepIndex + 1);
          if (_words2.length < 6)
            throw new Error("Data must be at least 6 characters long");
          const words = BECH_ALPHABET2.decode(_words2).slice(0, -6);
          const sum = bechChecksum2(prefix, words, ENCODING_CONST);
          if (!_words2.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
          return { prefix, words };
        }
        const decodeUnsafe = unsafeWrapper2(decode);
        function decodeToBytes(str) {
          const { prefix, words } = decode(str, false);
          return { prefix, words, bytes: fromWords(words) };
        }
        return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
      }
      exports2.bech32 = genBech322("bech32");
      exports2.bech32m = genBech322("bech32m");
      exports2.utf8 = {
        encode: (data) => new TextDecoder().decode(data),
        decode: (str) => new TextEncoder().encode(str)
      };
      exports2.hex = chain2(radix22(4), alphabet2("0123456789abcdef"), join2(""), normalize2((s4) => {
        if (typeof s4 !== "string" || s4.length % 2)
          throw new TypeError(`hex.decode: expected string, got ${typeof s4} with length ${s4.length}`);
        return s4.toLowerCase();
      }));
      var CODERS2 = {
        utf8: exports2.utf8,
        hex: exports2.hex,
        base16: exports2.base16,
        base32: exports2.base32,
        base64: exports2.base64,
        base64url: exports2.base64url,
        base58: exports2.base58,
        base58xmr: exports2.base58xmr
      };
      var coderTypeError2 = `Invalid encoding type. Available types: ${Object.keys(CODERS2).join(", ")}`;
      var bytesToString2 = (type, bytes2) => {
        if (typeof type !== "string" || !CODERS2.hasOwnProperty(type))
          throw new TypeError(coderTypeError2);
        if (!(bytes2 instanceof Uint8Array))
          throw new TypeError("bytesToString() expects Uint8Array");
        return CODERS2[type].encode(bytes2);
      };
      exports2.bytesToString = bytesToString2;
      exports2.str = exports2.bytesToString;
      var stringToBytes2 = (type, str) => {
        if (!CODERS2.hasOwnProperty(type))
          throw new TypeError(coderTypeError2);
        if (typeof str !== "string")
          throw new TypeError("stringToBytes() expects string");
        return CODERS2[type].decode(str);
      };
      exports2.stringToBytes = stringToBytes2;
      exports2.bytes = exports2.stringToBytes;
    }
  });

  // node_modules/@scure/bip39/index.js
  var require_bip39 = __commonJS({
    "node_modules/@scure/bip39/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mnemonicToSeedSync = exports2.mnemonicToSeed = exports2.validateMnemonic = exports2.entropyToMnemonic = exports2.mnemonicToEntropy = exports2.generateMnemonic = void 0;
      var _assert_1 = require_assert();
      var pbkdf2_1 = require_pbkdf2();
      var sha256_1 = require_sha256();
      var sha512_1 = require_sha512();
      var utils_1 = require_utils6();
      var base_1 = require_lib32();
      var isJapanese = (wordlist10) => wordlist10[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
      function nfkd(str) {
        if (typeof str !== "string")
          throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
        return str.normalize("NFKD");
      }
      function normalize2(str) {
        const norm = nfkd(str);
        const words = norm.split(" ");
        if (![12, 15, 18, 21, 24].includes(words.length))
          throw new Error("Invalid mnemonic");
        return { nfkd: norm, words };
      }
      function assertEntropy(entropy) {
        _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
      }
      function generateMnemonic2(wordlist10, strength = 128) {
        _assert_1.default.number(strength);
        if (strength % 32 !== 0 || strength > 256)
          throw new TypeError("Invalid entropy");
        return entropyToMnemonic2((0, utils_1.randomBytes)(strength / 8), wordlist10);
      }
      exports2.generateMnemonic = generateMnemonic2;
      var calcChecksum = (entropy) => {
        const bitsLeft = 8 - entropy.length / 4;
        return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
      };
      function getCoder(wordlist10) {
        if (!Array.isArray(wordlist10) || wordlist10.length !== 2048 || typeof wordlist10[0] !== "string")
          throw new Error("Worlist: expected array of 2048 strings");
        wordlist10.forEach((i4) => {
          if (typeof i4 !== "string")
            throw new Error(`Wordlist: non-string element: ${i4}`);
        });
        return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist10));
      }
      function mnemonicToEntropy2(mnemonic, wordlist10) {
        const { words } = normalize2(mnemonic);
        const entropy = getCoder(wordlist10).decode(words);
        assertEntropy(entropy);
        return entropy;
      }
      exports2.mnemonicToEntropy = mnemonicToEntropy2;
      function entropyToMnemonic2(entropy, wordlist10) {
        assertEntropy(entropy);
        const words = getCoder(wordlist10).encode(entropy);
        return words.join(isJapanese(wordlist10) ? "\u3000" : " ");
      }
      exports2.entropyToMnemonic = entropyToMnemonic2;
      function validateMnemonic(mnemonic, wordlist10) {
        try {
          mnemonicToEntropy2(mnemonic, wordlist10);
        } catch (e) {
          return false;
        }
        return true;
      }
      exports2.validateMnemonic = validateMnemonic;
      var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
      function mnemonicToSeed2(mnemonic, passphrase = "") {
        return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
      }
      exports2.mnemonicToSeed = mnemonicToSeed2;
      function mnemonicToSeedSync2(mnemonic, passphrase = "") {
        return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
      }
      exports2.mnemonicToSeedSync = mnemonicToSeedSync2;
    }
  });

  // node_modules/@scure/bip39/wordlists/czech.js
  var require_czech = __commonJS({
    "node_modules/@scure/bip39/wordlists/czech.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `abdikace
abeceda
adresa
agrese
akce
aktovka
alej
alkohol
amputace
ananas
andulka
anekdota
anketa
antika
anulovat
archa
arogance
asfalt
asistent
aspirace
astma
astronom
atlas
atletika
atol
autobus
azyl
babka
bachor
bacil
baculka
badatel
bageta
bagr
bahno
bakterie
balada
baletka
balkon
balonek
balvan
balza
bambus
bankomat
barbar
baret
barman
baroko
barva
baterka
batoh
bavlna
bazalka
bazilika
bazuka
bedna
beran
beseda
bestie
beton
bezinka
bezmoc
beztak
bicykl
bidlo
biftek
bikiny
bilance
biograf
biolog
bitva
bizon
blahobyt
blatouch
blecha
bledule
blesk
blikat
blizna
blokovat
bloudit
blud
bobek
bobr
bodlina
bodnout
bohatost
bojkot
bojovat
bokorys
bolest
borec
borovice
bota
boubel
bouchat
bouda
boule
bourat
boxer
bradavka
brambora
branka
bratr
brepta
briketa
brko
brloh
bronz
broskev
brunetka
brusinka
brzda
brzy
bublina
bubnovat
buchta
buditel
budka
budova
bufet
bujarost
bukvice
buldok
bulva
bunda
bunkr
burza
butik
buvol
buzola
bydlet
bylina
bytovka
bzukot
capart
carevna
cedr
cedule
cejch
cejn
cela
celer
celkem
celnice
cenina
cennost
cenovka
centrum
cenzor
cestopis
cetka
chalupa
chapadlo
charita
chata
chechtat
chemie
chichot
chirurg
chlad
chleba
chlubit
chmel
chmura
chobot
chochol
chodba
cholera
chomout
chopit
choroba
chov
chrapot
chrlit
chrt
chrup
chtivost
chudina
chutnat
chvat
chvilka
chvost
chyba
chystat
chytit
cibule
cigareta
cihelna
cihla
cinkot
cirkus
cisterna
citace
citrus
cizinec
cizost
clona
cokoliv
couvat
ctitel
ctnost
cudnost
cuketa
cukr
cupot
cvaknout
cval
cvik
cvrkot
cyklista
daleko
dareba
datel
datum
dcera
debata
dechovka
decibel
deficit
deflace
dekl
dekret
demokrat
deprese
derby
deska
detektiv
dikobraz
diktovat
dioda
diplom
disk
displej
divadlo
divoch
dlaha
dlouho
dluhopis
dnes
dobro
dobytek
docent
dochutit
dodnes
dohled
dohoda
dohra
dojem
dojnice
doklad
dokola
doktor
dokument
dolar
doleva
dolina
doma
dominant
domluvit
domov
donutit
dopad
dopis
doplnit
doposud
doprovod
dopustit
dorazit
dorost
dort
dosah
doslov
dostatek
dosud
dosyta
dotaz
dotek
dotknout
doufat
doutnat
dovozce
dozadu
doznat
dozorce
drahota
drak
dramatik
dravec
draze
drdol
drobnost
drogerie
drozd
drsnost
drtit
drzost
duben
duchovno
dudek
duha
duhovka
dusit
dusno
dutost
dvojice
dvorec
dynamit
ekolog
ekonomie
elektron
elipsa
email
emise
emoce
empatie
epizoda
epocha
epopej
epos
esej
esence
eskorta
eskymo
etiketa
euforie
evoluce
exekuce
exkurze
expedice
exploze
export
extrakt
facka
fajfka
fakulta
fanatik
fantazie
farmacie
favorit
fazole
federace
fejeton
fenka
fialka
figurant
filozof
filtr
finance
finta
fixace
fjord
flanel
flirt
flotila
fond
fosfor
fotbal
fotka
foton
frakce
freska
fronta
fukar
funkce
fyzika
galeje
garant
genetika
geolog
gilotina
glazura
glejt
golem
golfista
gotika
graf
gramofon
granule
grep
gril
grog
groteska
guma
hadice
hadr
hala
halenka
hanba
hanopis
harfa
harpuna
havran
hebkost
hejkal
hejno
hejtman
hektar
helma
hematom
herec
herna
heslo
hezky
historik
hladovka
hlasivky
hlava
hledat
hlen
hlodavec
hloh
hloupost
hltat
hlubina
hluchota
hmat
hmota
hmyz
hnis
hnojivo
hnout
hoblina
hoboj
hoch
hodiny
hodlat
hodnota
hodovat
hojnost
hokej
holinka
holka
holub
homole
honitba
honorace
horal
horda
horizont
horko
horlivec
hormon
hornina
horoskop
horstvo
hospoda
hostina
hotovost
houba
houf
houpat
houska
hovor
hradba
hranice
hravost
hrazda
hrbolek
hrdina
hrdlo
hrdost
hrnek
hrobka
hromada
hrot
hrouda
hrozen
hrstka
hrubost
hryzat
hubenost
hubnout
hudba
hukot
humr
husita
hustota
hvozd
hybnost
hydrant
hygiena
hymna
hysterik
idylka
ihned
ikona
iluze
imunita
infekce
inflace
inkaso
inovace
inspekce
internet
invalida
investor
inzerce
ironie
jablko
jachta
jahoda
jakmile
jakost
jalovec
jantar
jarmark
jaro
jasan
jasno
jatka
javor
jazyk
jedinec
jedle
jednatel
jehlan
jekot
jelen
jelito
jemnost
jenom
jepice
jeseter
jevit
jezdec
jezero
jinak
jindy
jinoch
jiskra
jistota
jitrnice
jizva
jmenovat
jogurt
jurta
kabaret
kabel
kabinet
kachna
kadet
kadidlo
kahan
kajak
kajuta
kakao
kaktus
kalamita
kalhoty
kalibr
kalnost
kamera
kamkoliv
kamna
kanibal
kanoe
kantor
kapalina
kapela
kapitola
kapka
kaple
kapota
kapr
kapusta
kapybara
karamel
karotka
karton
kasa
katalog
katedra
kauce
kauza
kavalec
kazajka
kazeta
kazivost
kdekoliv
kdesi
kedluben
kemp
keramika
kino
klacek
kladivo
klam
klapot
klasika
klaun
klec
klenba
klepat
klesnout
klid
klima
klisna
klobouk
klokan
klopa
kloub
klubovna
klusat
kluzkost
kmen
kmitat
kmotr
kniha
knot
koalice
koberec
kobka
kobliha
kobyla
kocour
kohout
kojenec
kokos
koktejl
kolaps
koleda
kolize
kolo
komando
kometa
komik
komnata
komora
kompas
komunita
konat
koncept
kondice
konec
konfese
kongres
konina
konkurs
kontakt
konzerva
kopanec
kopie
kopnout
koprovka
korbel
korektor
kormidlo
koroptev
korpus
koruna
koryto
korzet
kosatec
kostka
kotel
kotleta
kotoul
koukat
koupelna
kousek
kouzlo
kovboj
koza
kozoroh
krabice
krach
krajina
kralovat
krasopis
kravata
kredit
krejcar
kresba
kreveta
kriket
kritik
krize
krkavec
krmelec
krmivo
krocan
krok
kronika
kropit
kroupa
krovka
krtek
kruhadlo
krupice
krutost
krvinka
krychle
krypta
krystal
kryt
kudlanka
kufr
kujnost
kukla
kulajda
kulich
kulka
kulomet
kultura
kuna
kupodivu
kurt
kurzor
kutil
kvalita
kvasinka
kvestor
kynolog
kyselina
kytara
kytice
kytka
kytovec
kyvadlo
labrador
lachtan
ladnost
laik
lakomec
lamela
lampa
lanovka
lasice
laso
lastura
latinka
lavina
lebka
leckdy
leden
lednice
ledovka
ledvina
legenda
legie
legrace
lehce
lehkost
lehnout
lektvar
lenochod
lentilka
lepenka
lepidlo
letadlo
letec
letmo
letokruh
levhart
levitace
levobok
libra
lichotka
lidojed
lidskost
lihovina
lijavec
lilek
limetka
linie
linka
linoleum
listopad
litina
litovat
lobista
lodivod
logika
logoped
lokalita
loket
lomcovat
lopata
lopuch
lord
losos
lotr
loudal
louh
louka
louskat
lovec
lstivost
lucerna
lucifer
lump
lusk
lustrace
lvice
lyra
lyrika
lysina
madam
madlo
magistr
mahagon
majetek
majitel
majorita
makak
makovice
makrela
malba
malina
malovat
malvice
maminka
mandle
manko
marnost
masakr
maskot
masopust
matice
matrika
maturita
mazanec
mazivo
mazlit
mazurka
mdloba
mechanik
meditace
medovina
melasa
meloun
mentolka
metla
metoda
metr
mezera
migrace
mihnout
mihule
mikina
mikrofon
milenec
milimetr
milost
mimika
mincovna
minibar
minomet
minulost
miska
mistr
mixovat
mladost
mlha
mlhovina
mlok
mlsat
mluvit
mnich
mnohem
mobil
mocnost
modelka
modlitba
mohyla
mokro
molekula
momentka
monarcha
monokl
monstrum
montovat
monzun
mosaz
moskyt
most
motivace
motorka
motyka
moucha
moudrost
mozaika
mozek
mozol
mramor
mravenec
mrkev
mrtvola
mrzet
mrzutost
mstitel
mudrc
muflon
mulat
mumie
munice
muset
mutace
muzeum
muzikant
myslivec
mzda
nabourat
nachytat
nadace
nadbytek
nadhoz
nadobro
nadpis
nahlas
nahnat
nahodile
nahradit
naivita
najednou
najisto
najmout
naklonit
nakonec
nakrmit
nalevo
namazat
namluvit
nanometr
naoko
naopak
naostro
napadat
napevno
naplnit
napnout
naposled
naprosto
narodit
naruby
narychlo
nasadit
nasekat
naslepo
nastat
natolik
navenek
navrch
navzdory
nazvat
nebe
nechat
necky
nedaleko
nedbat
neduh
negace
nehet
nehoda
nejen
nejprve
neklid
nelibost
nemilost
nemoc
neochota
neonka
nepokoj
nerost
nerv
nesmysl
nesoulad
netvor
neuron
nevina
nezvykle
nicota
nijak
nikam
nikdy
nikl
nikterak
nitro
nocleh
nohavice
nominace
nora
norek
nositel
nosnost
nouze
noviny
novota
nozdra
nuda
nudle
nuget
nutit
nutnost
nutrie
nymfa
obal
obarvit
obava
obdiv
obec
obehnat
obejmout
obezita
obhajoba
obilnice
objasnit
objekt
obklopit
oblast
oblek
obliba
obloha
obluda
obnos
obohatit
obojek
obout
obrazec
obrna
obruba
obrys
obsah
obsluha
obstarat
obuv
obvaz
obvinit
obvod
obvykle
obyvatel
obzor
ocas
ocel
ocenit
ochladit
ochota
ochrana
ocitnout
odboj
odbyt
odchod
odcizit
odebrat
odeslat
odevzdat
odezva
odhadce
odhodit
odjet
odjinud
odkaz
odkoupit
odliv
odluka
odmlka
odolnost
odpad
odpis
odplout
odpor
odpustit
odpykat
odrazka
odsoudit
odstup
odsun
odtok
odtud
odvaha
odveta
odvolat
odvracet
odznak
ofina
ofsajd
ohlas
ohnisko
ohrada
ohrozit
ohryzek
okap
okenice
oklika
okno
okouzlit
okovy
okrasa
okres
okrsek
okruh
okupant
okurka
okusit
olejnina
olizovat
omak
omeleta
omezit
omladina
omlouvat
omluva
omyl
onehdy
opakovat
opasek
operace
opice
opilost
opisovat
opora
opozice
opravdu
oproti
orbital
orchestr
orgie
orlice
orloj
ortel
osada
oschnout
osika
osivo
oslava
oslepit
oslnit
oslovit
osnova
osoba
osolit
ospalec
osten
ostraha
ostuda
ostych
osvojit
oteplit
otisk
otop
otrhat
otrlost
otrok
otruby
otvor
ovanout
ovar
oves
ovlivnit
ovoce
oxid
ozdoba
pachatel
pacient
padouch
pahorek
pakt
palanda
palec
palivo
paluba
pamflet
pamlsek
panenka
panika
panna
panovat
panstvo
pantofle
paprika
parketa
parodie
parta
paruka
paryba
paseka
pasivita
pastelka
patent
patrona
pavouk
pazneht
pazourek
pecka
pedagog
pejsek
peklo
peloton
penalta
pendrek
penze
periskop
pero
pestrost
petarda
petice
petrolej
pevnina
pexeso
pianista
piha
pijavice
pikle
piknik
pilina
pilnost
pilulka
pinzeta
pipeta
pisatel
pistole
pitevna
pivnice
pivovar
placenta
plakat
plamen
planeta
plastika
platit
plavidlo
plaz
plech
plemeno
plenta
ples
pletivo
plevel
plivat
plnit
plno
plocha
plodina
plomba
plout
pluk
plyn
pobavit
pobyt
pochod
pocit
poctivec
podat
podcenit
podepsat
podhled
podivit
podklad
podmanit
podnik
podoba
podpora
podraz
podstata
podvod
podzim
poezie
pohanka
pohnutka
pohovor
pohroma
pohyb
pointa
pojistka
pojmout
pokazit
pokles
pokoj
pokrok
pokuta
pokyn
poledne
polibek
polknout
poloha
polynom
pomalu
pominout
pomlka
pomoc
pomsta
pomyslet
ponechat
ponorka
ponurost
popadat
popel
popisek
poplach
poprosit
popsat
popud
poradce
porce
porod
porucha
poryv
posadit
posed
posila
poskok
poslanec
posoudit
pospolu
postava
posudek
posyp
potah
potkan
potlesk
potomek
potrava
potupa
potvora
poukaz
pouto
pouzdro
povaha
povidla
povlak
povoz
povrch
povstat
povyk
povzdech
pozdrav
pozemek
poznatek
pozor
pozvat
pracovat
prahory
praktika
prales
praotec
praporek
prase
pravda
princip
prkno
probudit
procento
prodej
profese
prohra
projekt
prolomit
promile
pronikat
propad
prorok
prosba
proton
proutek
provaz
prskavka
prsten
prudkost
prut
prvek
prvohory
psanec
psovod
pstruh
ptactvo
puberta
puch
pudl
pukavec
puklina
pukrle
pult
pumpa
punc
pupen
pusa
pusinka
pustina
putovat
putyka
pyramida
pysk
pytel
racek
rachot
radiace
radnice
radon
raft
ragby
raketa
rakovina
rameno
rampouch
rande
rarach
rarita
rasovna
rastr
ratolest
razance
razidlo
reagovat
reakce
recept
redaktor
referent
reflex
rejnok
reklama
rekord
rekrut
rektor
reputace
revize
revma
revolver
rezerva
riskovat
riziko
robotika
rodokmen
rohovka
rokle
rokoko
romaneto
ropovod
ropucha
rorejs
rosol
rostlina
rotmistr
rotoped
rotunda
roubenka
roucho
roup
roura
rovina
rovnice
rozbor
rozchod
rozdat
rozeznat
rozhodce
rozinka
rozjezd
rozkaz
rozloha
rozmar
rozpad
rozruch
rozsah
roztok
rozum
rozvod
rubrika
ruchadlo
rukavice
rukopis
ryba
rybolov
rychlost
rydlo
rypadlo
rytina
ryzost
sadista
sahat
sako
samec
samizdat
samota
sanitka
sardinka
sasanka
satelit
sazba
sazenice
sbor
schovat
sebranka
secese
sedadlo
sediment
sedlo
sehnat
sejmout
sekera
sekta
sekunda
sekvoje
semeno
seno
servis
sesadit
seshora
seskok
seslat
sestra
sesuv
sesypat
setba
setina
setkat
setnout
setrvat
sever
seznam
shoda
shrnout
sifon
silnice
sirka
sirotek
sirup
situace
skafandr
skalisko
skanzen
skaut
skeptik
skica
skladba
sklenice
sklo
skluz
skoba
skokan
skoro
skripta
skrz
skupina
skvost
skvrna
slabika
sladidlo
slanina
slast
slavnost
sledovat
slepec
sleva
slezina
slib
slina
sliznice
slon
sloupek
slovo
sluch
sluha
slunce
slupka
slza
smaragd
smetana
smilstvo
smlouva
smog
smrad
smrk
smrtka
smutek
smysl
snad
snaha
snob
sobota
socha
sodovka
sokol
sopka
sotva
souboj
soucit
soudce
souhlas
soulad
soumrak
souprava
soused
soutok
souviset
spalovna
spasitel
spis
splav
spodek
spojenec
spolu
sponzor
spornost
spousta
sprcha
spustit
sranda
sraz
srdce
srna
srnec
srovnat
srpen
srst
srub
stanice
starosta
statika
stavba
stehno
stezka
stodola
stolek
stopa
storno
stoupat
strach
stres
strhnout
strom
struna
studna
stupnice
stvol
styk
subjekt
subtropy
suchar
sudost
sukno
sundat
sunout
surikata
surovina
svah
svalstvo
svetr
svatba
svazek
svisle
svitek
svoboda
svodidlo
svorka
svrab
sykavka
sykot
synek
synovec
sypat
sypkost
syrovost
sysel
sytost
tabletka
tabule
tahoun
tajemno
tajfun
tajga
tajit
tajnost
taktika
tamhle
tampon
tancovat
tanec
tanker
tapeta
tavenina
tazatel
technika
tehdy
tekutina
telefon
temnota
tendence
tenista
tenor
teplota
tepna
teprve
terapie
termoska
textil
ticho
tiskopis
titulek
tkadlec
tkanina
tlapka
tleskat
tlukot
tlupa
tmel
toaleta
topinka
topol
torzo
touha
toulec
tradice
traktor
tramp
trasa
traverza
trefit
trest
trezor
trhavina
trhlina
trochu
trojice
troska
trouba
trpce
trpitel
trpkost
trubec
truchlit
truhlice
trus
trvat
tudy
tuhnout
tuhost
tundra
turista
turnaj
tuzemsko
tvaroh
tvorba
tvrdost
tvrz
tygr
tykev
ubohost
uboze
ubrat
ubrousek
ubrus
ubytovna
ucho
uctivost
udivit
uhradit
ujednat
ujistit
ujmout
ukazatel
uklidnit
uklonit
ukotvit
ukrojit
ulice
ulita
ulovit
umyvadlo
unavit
uniforma
uniknout
upadnout
uplatnit
uplynout
upoutat
upravit
uran
urazit
usednout
usilovat
usmrtit
usnadnit
usnout
usoudit
ustlat
ustrnout
utahovat
utkat
utlumit
utonout
utopenec
utrousit
uvalit
uvolnit
uvozovka
uzdravit
uzel
uzenina
uzlina
uznat
vagon
valcha
valoun
vana
vandal
vanilka
varan
varhany
varovat
vcelku
vchod
vdova
vedro
vegetace
vejce
velbloud
veletrh
velitel
velmoc
velryba
venkov
veranda
verze
veselka
veskrze
vesnice
vespodu
vesta
veterina
veverka
vibrace
vichr
videohra
vidina
vidle
vila
vinice
viset
vitalita
vize
vizitka
vjezd
vklad
vkus
vlajka
vlak
vlasec
vlevo
vlhkost
vliv
vlnovka
vloupat
vnucovat
vnuk
voda
vodivost
vodoznak
vodstvo
vojensky
vojna
vojsko
volant
volba
volit
volno
voskovka
vozidlo
vozovna
vpravo
vrabec
vracet
vrah
vrata
vrba
vrcholek
vrhat
vrstva
vrtule
vsadit
vstoupit
vstup
vtip
vybavit
vybrat
vychovat
vydat
vydra
vyfotit
vyhledat
vyhnout
vyhodit
vyhradit
vyhubit
vyjasnit
vyjet
vyjmout
vyklopit
vykonat
vylekat
vymazat
vymezit
vymizet
vymyslet
vynechat
vynikat
vynutit
vypadat
vyplatit
vypravit
vypustit
vyrazit
vyrovnat
vyrvat
vyslovit
vysoko
vystavit
vysunout
vysypat
vytasit
vytesat
vytratit
vyvinout
vyvolat
vyvrhel
vyzdobit
vyznat
vzadu
vzbudit
vzchopit
vzdor
vzduch
vzdychat
vzestup
vzhledem
vzkaz
vzlykat
vznik
vzorek
vzpoura
vztah
vztek
xylofon
zabrat
zabydlet
zachovat
zadarmo
zadusit
zafoukat
zahltit
zahodit
zahrada
zahynout
zajatec
zajet
zajistit
zaklepat
zakoupit
zalepit
zamezit
zamotat
zamyslet
zanechat
zanikat
zaplatit
zapojit
zapsat
zarazit
zastavit
zasunout
zatajit
zatemnit
zatknout
zaujmout
zavalit
zavelet
zavinit
zavolat
zavrtat
zazvonit
zbavit
zbrusu
zbudovat
zbytek
zdaleka
zdarma
zdatnost
zdivo
zdobit
zdroj
zdvih
zdymadlo
zelenina
zeman
zemina
zeptat
zezadu
zezdola
zhatit
zhltnout
zhluboka
zhotovit
zhruba
zima
zimnice
zjemnit
zklamat
zkoumat
zkratka
zkumavka
zlato
zlehka
zloba
zlom
zlost
zlozvyk
zmapovat
zmar
zmatek
zmije
zmizet
zmocnit
zmodrat
zmrzlina
zmutovat
znak
znalost
znamenat
znovu
zobrazit
zotavit
zoubek
zoufale
zplodit
zpomalit
zprava
zprostit
zprudka
zprvu
zrada
zranit
zrcadlo
zrnitost
zrno
zrovna
zrychlit
zrzavost
zticha
ztratit
zubovina
zubr
zvednout
zvenku
zvesela
zvon
zvrat
zvukovod
zvyk`.split("\n");
    }
  });

  // node_modules/@scure/bip39/wordlists/english.js
  var require_english = __commonJS({
    "node_modules/@scure/bip39/wordlists/english.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
    }
  });

  // node_modules/@scure/bip39/wordlists/french.js
  var require_french = __commonJS({
    "node_modules/@scure/bip39/wordlists/french.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `abaisser
abandon
abdiquer
abeille
abolir
aborder
aboutir
aboyer
abrasif
abreuver
abriter
abroger
abrupt
absence
absolu
absurde
abusif
abyssal
acade\u0301mie
acajou
acarien
accabler
accepter
acclamer
accolade
accroche
accuser
acerbe
achat
acheter
aciduler
acier
acompte
acque\u0301rir
acronyme
acteur
actif
actuel
adepte
ade\u0301quat
adhe\u0301sif
adjectif
adjuger
admettre
admirer
adopter
adorer
adoucir
adresse
adroit
adulte
adverbe
ae\u0301rer
ae\u0301ronef
affaire
affecter
affiche
affreux
affubler
agacer
agencer
agile
agiter
agrafer
agre\u0301able
agrume
aider
aiguille
ailier
aimable
aisance
ajouter
ajuster
alarmer
alchimie
alerte
alge\u0300bre
algue
alie\u0301ner
aliment
alle\u0301ger
alliage
allouer
allumer
alourdir
alpaga
altesse
alve\u0301ole
amateur
ambigu
ambre
ame\u0301nager
amertume
amidon
amiral
amorcer
amour
amovible
amphibie
ampleur
amusant
analyse
anaphore
anarchie
anatomie
ancien
ane\u0301antir
angle
angoisse
anguleux
animal
annexer
annonce
annuel
anodin
anomalie
anonyme
anormal
antenne
antidote
anxieux
apaiser
ape\u0301ritif
aplanir
apologie
appareil
appeler
apporter
appuyer
aquarium
aqueduc
arbitre
arbuste
ardeur
ardoise
argent
arlequin
armature
armement
armoire
armure
arpenter
arracher
arriver
arroser
arsenic
arte\u0301riel
article
aspect
asphalte
aspirer
assaut
asservir
assiette
associer
assurer
asticot
astre
astuce
atelier
atome
atrium
atroce
attaque
attentif
attirer
attraper
aubaine
auberge
audace
audible
augurer
aurore
automne
autruche
avaler
avancer
avarice
avenir
averse
aveugle
aviateur
avide
avion
aviser
avoine
avouer
avril
axial
axiome
badge
bafouer
bagage
baguette
baignade
balancer
balcon
baleine
balisage
bambin
bancaire
bandage
banlieue
bannie\u0300re
banquier
barbier
baril
baron
barque
barrage
bassin
bastion
bataille
bateau
batterie
baudrier
bavarder
belette
be\u0301lier
belote
be\u0301ne\u0301fice
berceau
berger
berline
bermuda
besace
besogne
be\u0301tail
beurre
biberon
bicycle
bidule
bijou
bilan
bilingue
billard
binaire
biologie
biopsie
biotype
biscuit
bison
bistouri
bitume
bizarre
blafard
blague
blanchir
blessant
blinder
blond
bloquer
blouson
bobard
bobine
boire
boiser
bolide
bonbon
bondir
bonheur
bonifier
bonus
bordure
borne
botte
boucle
boueux
bougie
boulon
bouquin
bourse
boussole
boutique
boxeur
branche
brasier
brave
brebis
bre\u0300che
breuvage
bricoler
brigade
brillant
brioche
brique
brochure
broder
bronzer
brousse
broyeur
brume
brusque
brutal
bruyant
buffle
buisson
bulletin
bureau
burin
bustier
butiner
butoir
buvable
buvette
cabanon
cabine
cachette
cadeau
cadre
cafe\u0301ine
caillou
caisson
calculer
calepin
calibre
calmer
calomnie
calvaire
camarade
came\u0301ra
camion
campagne
canal
caneton
canon
cantine
canular
capable
caporal
caprice
capsule
capter
capuche
carabine
carbone
caresser
caribou
carnage
carotte
carreau
carton
cascade
casier
casque
cassure
causer
caution
cavalier
caverne
caviar
ce\u0301dille
ceinture
ce\u0301leste
cellule
cendrier
censurer
central
cercle
ce\u0301re\u0301bral
cerise
cerner
cerveau
cesser
chagrin
chaise
chaleur
chambre
chance
chapitre
charbon
chasseur
chaton
chausson
chavirer
chemise
chenille
che\u0301quier
chercher
cheval
chien
chiffre
chignon
chime\u0300re
chiot
chlorure
chocolat
choisir
chose
chouette
chrome
chute
cigare
cigogne
cimenter
cine\u0301ma
cintrer
circuler
cirer
cirque
citerne
citoyen
citron
civil
clairon
clameur
claquer
classe
clavier
client
cligner
climat
clivage
cloche
clonage
cloporte
cobalt
cobra
cocasse
cocotier
coder
codifier
coffre
cogner
cohe\u0301sion
coiffer
coincer
cole\u0300re
colibri
colline
colmater
colonel
combat
come\u0301die
commande
compact
concert
conduire
confier
congeler
connoter
consonne
contact
convexe
copain
copie
corail
corbeau
cordage
corniche
corpus
correct
corte\u0300ge
cosmique
costume
coton
coude
coupure
courage
couteau
couvrir
coyote
crabe
crainte
cravate
crayon
cre\u0301ature
cre\u0301diter
cre\u0301meux
creuser
crevette
cribler
crier
cristal
crite\u0300re
croire
croquer
crotale
crucial
cruel
crypter
cubique
cueillir
cuille\u0300re
cuisine
cuivre
culminer
cultiver
cumuler
cupide
curatif
curseur
cyanure
cycle
cylindre
cynique
daigner
damier
danger
danseur
dauphin
de\u0301battre
de\u0301biter
de\u0301border
de\u0301brider
de\u0301butant
de\u0301caler
de\u0301cembre
de\u0301chirer
de\u0301cider
de\u0301clarer
de\u0301corer
de\u0301crire
de\u0301cupler
de\u0301dale
de\u0301ductif
de\u0301esse
de\u0301fensif
de\u0301filer
de\u0301frayer
de\u0301gager
de\u0301givrer
de\u0301glutir
de\u0301grafer
de\u0301jeuner
de\u0301lice
de\u0301loger
demander
demeurer
de\u0301molir
de\u0301nicher
de\u0301nouer
dentelle
de\u0301nuder
de\u0301part
de\u0301penser
de\u0301phaser
de\u0301placer
de\u0301poser
de\u0301ranger
de\u0301rober
de\u0301sastre
descente
de\u0301sert
de\u0301signer
de\u0301sobe\u0301ir
dessiner
destrier
de\u0301tacher
de\u0301tester
de\u0301tourer
de\u0301tresse
devancer
devenir
deviner
devoir
diable
dialogue
diamant
dicter
diffe\u0301rer
dige\u0301rer
digital
digne
diluer
dimanche
diminuer
dioxyde
directif
diriger
discuter
disposer
dissiper
distance
divertir
diviser
docile
docteur
dogme
doigt
domaine
domicile
dompter
donateur
donjon
donner
dopamine
dortoir
dorure
dosage
doseur
dossier
dotation
douanier
double
douceur
douter
doyen
dragon
draper
dresser
dribbler
droiture
duperie
duplexe
durable
durcir
dynastie
e\u0301blouir
e\u0301carter
e\u0301charpe
e\u0301chelle
e\u0301clairer
e\u0301clipse
e\u0301clore
e\u0301cluse
e\u0301cole
e\u0301conomie
e\u0301corce
e\u0301couter
e\u0301craser
e\u0301cre\u0301mer
e\u0301crivain
e\u0301crou
e\u0301cume
e\u0301cureuil
e\u0301difier
e\u0301duquer
effacer
effectif
effigie
effort
effrayer
effusion
e\u0301galiser
e\u0301garer
e\u0301jecter
e\u0301laborer
e\u0301largir
e\u0301lectron
e\u0301le\u0301gant
e\u0301le\u0301phant
e\u0301le\u0300ve
e\u0301ligible
e\u0301litisme
e\u0301loge
e\u0301lucider
e\u0301luder
emballer
embellir
embryon
e\u0301meraude
e\u0301mission
emmener
e\u0301motion
e\u0301mouvoir
empereur
employer
emporter
emprise
e\u0301mulsion
encadrer
enche\u0300re
enclave
encoche
endiguer
endosser
endroit
enduire
e\u0301nergie
enfance
enfermer
enfouir
engager
engin
englober
e\u0301nigme
enjamber
enjeu
enlever
ennemi
ennuyeux
enrichir
enrobage
enseigne
entasser
entendre
entier
entourer
entraver
e\u0301nume\u0301rer
envahir
enviable
envoyer
enzyme
e\u0301olien
e\u0301paissir
e\u0301pargne
e\u0301patant
e\u0301paule
e\u0301picerie
e\u0301pide\u0301mie
e\u0301pier
e\u0301pilogue
e\u0301pine
e\u0301pisode
e\u0301pitaphe
e\u0301poque
e\u0301preuve
e\u0301prouver
e\u0301puisant
e\u0301querre
e\u0301quipe
e\u0301riger
e\u0301rosion
erreur
e\u0301ruption
escalier
espadon
espe\u0300ce
espie\u0300gle
espoir
esprit
esquiver
essayer
essence
essieu
essorer
estime
estomac
estrade
e\u0301tage\u0300re
e\u0301taler
e\u0301tanche
e\u0301tatique
e\u0301teindre
e\u0301tendoir
e\u0301ternel
e\u0301thanol
e\u0301thique
ethnie
e\u0301tirer
e\u0301toffer
e\u0301toile
e\u0301tonnant
e\u0301tourdir
e\u0301trange
e\u0301troit
e\u0301tude
euphorie
e\u0301valuer
e\u0301vasion
e\u0301ventail
e\u0301vidence
e\u0301viter
e\u0301volutif
e\u0301voquer
exact
exage\u0301rer
exaucer
exceller
excitant
exclusif
excuse
exe\u0301cuter
exemple
exercer
exhaler
exhorter
exigence
exiler
exister
exotique
expe\u0301dier
explorer
exposer
exprimer
exquis
extensif
extraire
exulter
fable
fabuleux
facette
facile
facture
faiblir
falaise
fameux
famille
farceur
farfelu
farine
farouche
fasciner
fatal
fatigue
faucon
fautif
faveur
favori
fe\u0301brile
fe\u0301conder
fe\u0301de\u0301rer
fe\u0301lin
femme
fe\u0301mur
fendoir
fe\u0301odal
fermer
fe\u0301roce
ferveur
festival
feuille
feutre
fe\u0301vrier
fiasco
ficeler
fictif
fide\u0300le
figure
filature
filetage
filie\u0300re
filleul
filmer
filou
filtrer
financer
finir
fiole
firme
fissure
fixer
flairer
flamme
flasque
flatteur
fle\u0301au
fle\u0300che
fleur
flexion
flocon
flore
fluctuer
fluide
fluvial
folie
fonderie
fongible
fontaine
forcer
forgeron
formuler
fortune
fossile
foudre
fouge\u0300re
fouiller
foulure
fourmi
fragile
fraise
franchir
frapper
frayeur
fre\u0301gate
freiner
frelon
fre\u0301mir
fre\u0301ne\u0301sie
fre\u0300re
friable
friction
frisson
frivole
froid
fromage
frontal
frotter
fruit
fugitif
fuite
fureur
furieux
furtif
fusion
futur
gagner
galaxie
galerie
gambader
garantir
gardien
garnir
garrigue
gazelle
gazon
ge\u0301ant
ge\u0301latine
ge\u0301lule
gendarme
ge\u0301ne\u0301ral
ge\u0301nie
genou
gentil
ge\u0301ologie
ge\u0301ome\u0300tre
ge\u0301ranium
germe
gestuel
geyser
gibier
gicler
girafe
givre
glace
glaive
glisser
globe
gloire
glorieux
golfeur
gomme
gonfler
gorge
gorille
goudron
gouffre
goulot
goupille
gourmand
goutte
graduel
graffiti
graine
grand
grappin
gratuit
gravir
grenat
griffure
griller
grimper
grogner
gronder
grotte
groupe
gruger
grutier
gruye\u0300re
gue\u0301pard
guerrier
guide
guimauve
guitare
gustatif
gymnaste
gyrostat
habitude
hachoir
halte
hameau
hangar
hanneton
haricot
harmonie
harpon
hasard
he\u0301lium
he\u0301matome
herbe
he\u0301risson
hermine
he\u0301ron
he\u0301siter
heureux
hiberner
hibou
hilarant
histoire
hiver
homard
hommage
homoge\u0300ne
honneur
honorer
honteux
horde
horizon
horloge
hormone
horrible
houleux
housse
hublot
huileux
humain
humble
humide
humour
hurler
hydromel
hygie\u0300ne
hymne
hypnose
idylle
ignorer
iguane
illicite
illusion
image
imbiber
imiter
immense
immobile
immuable
impact
impe\u0301rial
implorer
imposer
imprimer
imputer
incarner
incendie
incident
incliner
incolore
indexer
indice
inductif
ine\u0301dit
ineptie
inexact
infini
infliger
informer
infusion
inge\u0301rer
inhaler
inhiber
injecter
injure
innocent
inoculer
inonder
inscrire
insecte
insigne
insolite
inspirer
instinct
insulter
intact
intense
intime
intrigue
intuitif
inutile
invasion
inventer
inviter
invoquer
ironique
irradier
irre\u0301el
irriter
isoler
ivoire
ivresse
jaguar
jaillir
jambe
janvier
jardin
jauger
jaune
javelot
jetable
jeton
jeudi
jeunesse
joindre
joncher
jongler
joueur
jouissif
journal
jovial
joyau
joyeux
jubiler
jugement
junior
jupon
juriste
justice
juteux
juve\u0301nile
kayak
kimono
kiosque
label
labial
labourer
lace\u0301rer
lactose
lagune
laine
laisser
laitier
lambeau
lamelle
lampe
lanceur
langage
lanterne
lapin
largeur
larme
laurier
lavabo
lavoir
lecture
le\u0301gal
le\u0301ger
le\u0301gume
lessive
lettre
levier
lexique
le\u0301zard
liasse
libe\u0301rer
libre
licence
licorne
lie\u0300ge
lie\u0300vre
ligature
ligoter
ligue
limer
limite
limonade
limpide
line\u0301aire
lingot
lionceau
liquide
lisie\u0300re
lister
lithium
litige
littoral
livreur
logique
lointain
loisir
lombric
loterie
louer
lourd
loutre
louve
loyal
lubie
lucide
lucratif
lueur
lugubre
luisant
lumie\u0300re
lunaire
lundi
luron
lutter
luxueux
machine
magasin
magenta
magique
maigre
maillon
maintien
mairie
maison
majorer
malaxer
male\u0301fice
malheur
malice
mallette
mammouth
mandater
maniable
manquant
manteau
manuel
marathon
marbre
marchand
mardi
maritime
marqueur
marron
marteler
mascotte
massif
mate\u0301riel
matie\u0300re
matraque
maudire
maussade
mauve
maximal
me\u0301chant
me\u0301connu
me\u0301daille
me\u0301decin
me\u0301diter
me\u0301duse
meilleur
me\u0301lange
me\u0301lodie
membre
me\u0301moire
menacer
mener
menhir
mensonge
mentor
mercredi
me\u0301rite
merle
messager
mesure
me\u0301tal
me\u0301te\u0301ore
me\u0301thode
me\u0301tier
meuble
miauler
microbe
miette
mignon
migrer
milieu
million
mimique
mince
mine\u0301ral
minimal
minorer
minute
miracle
miroiter
missile
mixte
mobile
moderne
moelleux
mondial
moniteur
monnaie
monotone
monstre
montagne
monument
moqueur
morceau
morsure
mortier
moteur
motif
mouche
moufle
moulin
mousson
mouton
mouvant
multiple
munition
muraille
mure\u0300ne
murmure
muscle
muse\u0301um
musicien
mutation
muter
mutuel
myriade
myrtille
myste\u0300re
mythique
nageur
nappe
narquois
narrer
natation
nation
nature
naufrage
nautique
navire
ne\u0301buleux
nectar
ne\u0301faste
ne\u0301gation
ne\u0301gliger
ne\u0301gocier
neige
nerveux
nettoyer
neurone
neutron
neveu
niche
nickel
nitrate
niveau
noble
nocif
nocturne
noirceur
noisette
nomade
nombreux
nommer
normatif
notable
notifier
notoire
nourrir
nouveau
novateur
novembre
novice
nuage
nuancer
nuire
nuisible
nume\u0301ro
nuptial
nuque
nutritif
obe\u0301ir
objectif
obliger
obscur
observer
obstacle
obtenir
obturer
occasion
occuper
oce\u0301an
octobre
octroyer
octupler
oculaire
odeur
odorant
offenser
officier
offrir
ogive
oiseau
oisillon
olfactif
olivier
ombrage
omettre
onctueux
onduler
one\u0301reux
onirique
opale
opaque
ope\u0301rer
opinion
opportun
opprimer
opter
optique
orageux
orange
orbite
ordonner
oreille
organe
orgueil
orifice
ornement
orque
ortie
osciller
osmose
ossature
otarie
ouragan
ourson
outil
outrager
ouvrage
ovation
oxyde
oxyge\u0300ne
ozone
paisible
palace
palmare\u0300s
palourde
palper
panache
panda
pangolin
paniquer
panneau
panorama
pantalon
papaye
papier
papoter
papyrus
paradoxe
parcelle
paresse
parfumer
parler
parole
parrain
parsemer
partager
parure
parvenir
passion
paste\u0300que
paternel
patience
patron
pavillon
pavoiser
payer
paysage
peigne
peintre
pelage
pe\u0301lican
pelle
pelouse
peluche
pendule
pe\u0301ne\u0301trer
pe\u0301nible
pensif
pe\u0301nurie
pe\u0301pite
pe\u0301plum
perdrix
perforer
pe\u0301riode
permuter
perplexe
persil
perte
peser
pe\u0301tale
petit
pe\u0301trir
peuple
pharaon
phobie
phoque
photon
phrase
physique
piano
pictural
pie\u0300ce
pierre
pieuvre
pilote
pinceau
pipette
piquer
pirogue
piscine
piston
pivoter
pixel
pizza
placard
plafond
plaisir
planer
plaque
plastron
plateau
pleurer
plexus
pliage
plomb
plonger
pluie
plumage
pochette
poe\u0301sie
poe\u0300te
pointe
poirier
poisson
poivre
polaire
policier
pollen
polygone
pommade
pompier
ponctuel
ponde\u0301rer
poney
portique
position
posse\u0301der
posture
potager
poteau
potion
pouce
poulain
poumon
pourpre
poussin
pouvoir
prairie
pratique
pre\u0301cieux
pre\u0301dire
pre\u0301fixe
pre\u0301lude
pre\u0301nom
pre\u0301sence
pre\u0301texte
pre\u0301voir
primitif
prince
prison
priver
proble\u0300me
proce\u0301der
prodige
profond
progre\u0300s
proie
projeter
prologue
promener
propre
prospe\u0300re
prote\u0301ger
prouesse
proverbe
prudence
pruneau
psychose
public
puceron
puiser
pulpe
pulsar
punaise
punitif
pupitre
purifier
puzzle
pyramide
quasar
querelle
question
quie\u0301tude
quitter
quotient
racine
raconter
radieux
ragondin
raideur
raisin
ralentir
rallonge
ramasser
rapide
rasage
ratisser
ravager
ravin
rayonner
re\u0301actif
re\u0301agir
re\u0301aliser
re\u0301animer
recevoir
re\u0301citer
re\u0301clamer
re\u0301colter
recruter
reculer
recycler
re\u0301diger
redouter
refaire
re\u0301flexe
re\u0301former
refrain
refuge
re\u0301galien
re\u0301gion
re\u0301glage
re\u0301gulier
re\u0301ite\u0301rer
rejeter
rejouer
relatif
relever
relief
remarque
reme\u0300de
remise
remonter
remplir
remuer
renard
renfort
renifler
renoncer
rentrer
renvoi
replier
reporter
reprise
reptile
requin
re\u0301serve
re\u0301sineux
re\u0301soudre
respect
rester
re\u0301sultat
re\u0301tablir
retenir
re\u0301ticule
retomber
retracer
re\u0301union
re\u0301ussir
revanche
revivre
re\u0301volte
re\u0301vulsif
richesse
rideau
rieur
rigide
rigoler
rincer
riposter
risible
risque
rituel
rival
rivie\u0300re
rocheux
romance
rompre
ronce
rondin
roseau
rosier
rotatif
rotor
rotule
rouge
rouille
rouleau
routine
royaume
ruban
rubis
ruche
ruelle
rugueux
ruiner
ruisseau
ruser
rustique
rythme
sabler
saboter
sabre
sacoche
safari
sagesse
saisir
salade
salive
salon
saluer
samedi
sanction
sanglier
sarcasme
sardine
saturer
saugrenu
saumon
sauter
sauvage
savant
savonner
scalpel
scandale
sce\u0301le\u0301rat
sce\u0301nario
sceptre
sche\u0301ma
science
scinder
score
scrutin
sculpter
se\u0301ance
se\u0301cable
se\u0301cher
secouer
se\u0301cre\u0301ter
se\u0301datif
se\u0301duire
seigneur
se\u0301jour
se\u0301lectif
semaine
sembler
semence
se\u0301minal
se\u0301nateur
sensible
sentence
se\u0301parer
se\u0301quence
serein
sergent
se\u0301rieux
serrure
se\u0301rum
service
se\u0301same
se\u0301vir
sevrage
sextuple
side\u0301ral
sie\u0300cle
sie\u0301ger
siffler
sigle
signal
silence
silicium
simple
since\u0300re
sinistre
siphon
sirop
sismique
situer
skier
social
socle
sodium
soigneux
soldat
soleil
solitude
soluble
sombre
sommeil
somnoler
sonde
songeur
sonnette
sonore
sorcier
sortir
sosie
sottise
soucieux
soudure
souffle
soulever
soupape
source
soutirer
souvenir
spacieux
spatial
spe\u0301cial
sphe\u0300re
spiral
stable
station
sternum
stimulus
stipuler
strict
studieux
stupeur
styliste
sublime
substrat
subtil
subvenir
succe\u0300s
sucre
suffixe
sugge\u0301rer
suiveur
sulfate
superbe
supplier
surface
suricate
surmener
surprise
sursaut
survie
suspect
syllabe
symbole
syme\u0301trie
synapse
syntaxe
syste\u0300me
tabac
tablier
tactile
tailler
talent
talisman
talonner
tambour
tamiser
tangible
tapis
taquiner
tarder
tarif
tartine
tasse
tatami
tatouage
taupe
taureau
taxer
te\u0301moin
temporel
tenaille
tendre
teneur
tenir
tension
terminer
terne
terrible
te\u0301tine
texte
the\u0300me
the\u0301orie
the\u0301rapie
thorax
tibia
tie\u0300de
timide
tirelire
tiroir
tissu
titane
titre
tituber
toboggan
tole\u0301rant
tomate
tonique
tonneau
toponyme
torche
tordre
tornade
torpille
torrent
torse
tortue
totem
toucher
tournage
tousser
toxine
traction
trafic
tragique
trahir
train
trancher
travail
tre\u0300fle
tremper
tre\u0301sor
treuil
triage
tribunal
tricoter
trilogie
triomphe
tripler
triturer
trivial
trombone
tronc
tropical
troupeau
tuile
tulipe
tumulte
tunnel
turbine
tuteur
tutoyer
tuyau
tympan
typhon
typique
tyran
ubuesque
ultime
ultrason
unanime
unifier
union
unique
unitaire
univers
uranium
urbain
urticant
usage
usine
usuel
usure
utile
utopie
vacarme
vaccin
vagabond
vague
vaillant
vaincre
vaisseau
valable
valise
vallon
valve
vampire
vanille
vapeur
varier
vaseux
vassal
vaste
vecteur
vedette
ve\u0301ge\u0301tal
ve\u0301hicule
veinard
ve\u0301loce
vendredi
ve\u0301ne\u0301rer
venger
venimeux
ventouse
verdure
ve\u0301rin
vernir
verrou
verser
vertu
veston
ve\u0301te\u0301ran
ve\u0301tuste
vexant
vexer
viaduc
viande
victoire
vidange
vide\u0301o
vignette
vigueur
vilain
village
vinaigre
violon
vipe\u0300re
virement
virtuose
virus
visage
viseur
vision
visqueux
visuel
vital
vitesse
viticole
vitrine
vivace
vivipare
vocation
voguer
voile
voisin
voiture
volaille
volcan
voltiger
volume
vorace
vortex
voter
vouloir
voyage
voyelle
wagon
xe\u0301non
yacht
ze\u0300bre
ze\u0301nith
zeste
zoologie`.split("\n");
    }
  });

  // node_modules/@scure/bip39/wordlists/italian.js
  var require_italian = __commonJS({
    "node_modules/@scure/bip39/wordlists/italian.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `abaco
abbaglio
abbinato
abete
abisso
abolire
abrasivo
abrogato
accadere
accenno
accusato
acetone
achille
acido
acqua
acre
acrilico
acrobata
acuto
adagio
addebito
addome
adeguato
aderire
adipe
adottare
adulare
affabile
affetto
affisso
affranto
aforisma
afoso
africano
agave
agente
agevole
aggancio
agire
agitare
agonismo
agricolo
agrumeto
aguzzo
alabarda
alato
albatro
alberato
albo
albume
alce
alcolico
alettone
alfa
algebra
aliante
alibi
alimento
allagato
allegro
allievo
allodola
allusivo
almeno
alogeno
alpaca
alpestre
altalena
alterno
alticcio
altrove
alunno
alveolo
alzare
amalgama
amanita
amarena
ambito
ambrato
ameba
america
ametista
amico
ammasso
ammenda
ammirare
ammonito
amore
ampio
ampliare
amuleto
anacardo
anagrafe
analista
anarchia
anatra
anca
ancella
ancora
andare
andrea
anello
angelo
angolare
angusto
anima
annegare
annidato
anno
annuncio
anonimo
anticipo
anzi
apatico
apertura
apode
apparire
appetito
appoggio
approdo
appunto
aprile
arabica
arachide
aragosta
araldica
arancio
aratura
arazzo
arbitro
archivio
ardito
arenile
argento
argine
arguto
aria
armonia
arnese
arredato
arringa
arrosto
arsenico
arso
artefice
arzillo
asciutto
ascolto
asepsi
asettico
asfalto
asino
asola
aspirato
aspro
assaggio
asse
assoluto
assurdo
asta
astenuto
astice
astratto
atavico
ateismo
atomico
atono
attesa
attivare
attorno
attrito
attuale
ausilio
austria
autista
autonomo
autunno
avanzato
avere
avvenire
avviso
avvolgere
azione
azoto
azzimo
azzurro
babele
baccano
bacino
baco
badessa
badilata
bagnato
baita
balcone
baldo
balena
ballata
balzano
bambino
bandire
baraonda
barbaro
barca
baritono
barlume
barocco
basilico
basso
batosta
battuto
baule
bava
bavosa
becco
beffa
belgio
belva
benda
benevole
benigno
benzina
bere
berlina
beta
bibita
bici
bidone
bifido
biga
bilancia
bimbo
binocolo
biologo
bipede
bipolare
birbante
birra
biscotto
bisesto
bisnonno
bisonte
bisturi
bizzarro
blando
blatta
bollito
bonifico
bordo
bosco
botanico
bottino
bozzolo
braccio
bradipo
brama
branca
bravura
bretella
brevetto
brezza
briglia
brillante
brindare
broccolo
brodo
bronzina
brullo
bruno
bubbone
buca
budino
buffone
buio
bulbo
buono
burlone
burrasca
bussola
busta
cadetto
caduco
calamaro
calcolo
calesse
calibro
calmo
caloria
cambusa
camerata
camicia
cammino
camola
campale
canapa
candela
cane
canino
canotto
cantina
capace
capello
capitolo
capogiro
cappero
capra
capsula
carapace
carcassa
cardo
carisma
carovana
carretto
cartolina
casaccio
cascata
caserma
caso
cassone
castello
casuale
catasta
catena
catrame
cauto
cavillo
cedibile
cedrata
cefalo
celebre
cellulare
cena
cenone
centesimo
ceramica
cercare
certo
cerume
cervello
cesoia
cespo
ceto
chela
chiaro
chicca
chiedere
chimera
china
chirurgo
chitarra
ciao
ciclismo
cifrare
cigno
cilindro
ciottolo
circa
cirrosi
citrico
cittadino
ciuffo
civetta
civile
classico
clinica
cloro
cocco
codardo
codice
coerente
cognome
collare
colmato
colore
colposo
coltivato
colza
coma
cometa
commando
comodo
computer
comune
conciso
condurre
conferma
congelare
coniuge
connesso
conoscere
consumo
continuo
convegno
coperto
copione
coppia
copricapo
corazza
cordata
coricato
cornice
corolla
corpo
corredo
corsia
cortese
cosmico
costante
cottura
covato
cratere
cravatta
creato
credere
cremoso
crescita
creta
criceto
crinale
crisi
critico
croce
cronaca
crostata
cruciale
crusca
cucire
cuculo
cugino
cullato
cupola
curatore
cursore
curvo
cuscino
custode
dado
daino
dalmata
damerino
daniela
dannoso
danzare
datato
davanti
davvero
debutto
decennio
deciso
declino
decollo
decreto
dedicato
definito
deforme
degno
delegare
delfino
delirio
delta
demenza
denotato
dentro
deposito
derapata
derivare
deroga
descritto
deserto
desiderio
desumere
detersivo
devoto
diametro
dicembre
diedro
difeso
diffuso
digerire
digitale
diluvio
dinamico
dinnanzi
dipinto
diploma
dipolo
diradare
dire
dirotto
dirupo
disagio
discreto
disfare
disgelo
disposto
distanza
disumano
dito
divano
divelto
dividere
divorato
doblone
docente
doganale
dogma
dolce
domato
domenica
dominare
dondolo
dono
dormire
dote
dottore
dovuto
dozzina
drago
druido
dubbio
dubitare
ducale
duna
duomo
duplice
duraturo
ebano
eccesso
ecco
eclissi
economia
edera
edicola
edile
editoria
educare
egemonia
egli
egoismo
egregio
elaborato
elargire
elegante
elencato
eletto
elevare
elfico
elica
elmo
elsa
eluso
emanato
emblema
emesso
emiro
emotivo
emozione
empirico
emulo
endemico
enduro
energia
enfasi
enoteca
entrare
enzima
epatite
epilogo
episodio
epocale
eppure
equatore
erario
erba
erboso
erede
eremita
erigere
ermetico
eroe
erosivo
errante
esagono
esame
esanime
esaudire
esca
esempio
esercito
esibito
esigente
esistere
esito
esofago
esortato
esoso
espanso
espresso
essenza
esso
esteso
estimare
estonia
estroso
esultare
etilico
etnico
etrusco
etto
euclideo
europa
evaso
evidenza
evitato
evoluto
evviva
fabbrica
faccenda
fachiro
falco
famiglia
fanale
fanfara
fango
fantasma
fare
farfalla
farinoso
farmaco
fascia
fastoso
fasullo
faticare
fato
favoloso
febbre
fecola
fede
fegato
felpa
feltro
femmina
fendere
fenomeno
fermento
ferro
fertile
fessura
festivo
fetta
feudo
fiaba
fiducia
fifa
figurato
filo
finanza
finestra
finire
fiore
fiscale
fisico
fiume
flacone
flamenco
flebo
flemma
florido
fluente
fluoro
fobico
focaccia
focoso
foderato
foglio
folata
folclore
folgore
fondente
fonetico
fonia
fontana
forbito
forchetta
foresta
formica
fornaio
foro
fortezza
forzare
fosfato
fosso
fracasso
frana
frassino
fratello
freccetta
frenata
fresco
frigo
frollino
fronde
frugale
frutta
fucilata
fucsia
fuggente
fulmine
fulvo
fumante
fumetto
fumoso
fune
funzione
fuoco
furbo
furgone
furore
fuso
futile
gabbiano
gaffe
galateo
gallina
galoppo
gambero
gamma
garanzia
garbo
garofano
garzone
gasdotto
gasolio
gastrico
gatto
gaudio
gazebo
gazzella
geco
gelatina
gelso
gemello
gemmato
gene
genitore
gennaio
genotipo
gergo
ghepardo
ghiaccio
ghisa
giallo
gilda
ginepro
giocare
gioiello
giorno
giove
girato
girone
gittata
giudizio
giurato
giusto
globulo
glutine
gnomo
gobba
golf
gomito
gommone
gonfio
gonna
governo
gracile
grado
grafico
grammo
grande
grattare
gravoso
grazia
greca
gregge
grifone
grigio
grinza
grotta
gruppo
guadagno
guaio
guanto
guardare
gufo
guidare
ibernato
icona
identico
idillio
idolo
idra
idrico
idrogeno
igiene
ignaro
ignorato
ilare
illeso
illogico
illudere
imballo
imbevuto
imbocco
imbuto
immane
immerso
immolato
impacco
impeto
impiego
importo
impronta
inalare
inarcare
inattivo
incanto
incendio
inchino
incisivo
incluso
incontro
incrocio
incubo
indagine
india
indole
inedito
infatti
infilare
inflitto
ingaggio
ingegno
inglese
ingordo
ingrosso
innesco
inodore
inoltrare
inondato
insano
insetto
insieme
insonnia
insulina
intasato
intero
intonaco
intuito
inumidire
invalido
invece
invito
iperbole
ipnotico
ipotesi
ippica
iride
irlanda
ironico
irrigato
irrorare
isolato
isotopo
isterico
istituto
istrice
italia
iterare
labbro
labirinto
lacca
lacerato
lacrima
lacuna
laddove
lago
lampo
lancetta
lanterna
lardoso
larga
laringe
lastra
latenza
latino
lattuga
lavagna
lavoro
legale
leggero
lembo
lentezza
lenza
leone
lepre
lesivo
lessato
lesto
letterale
leva
levigato
libero
lido
lievito
lilla
limatura
limitare
limpido
lineare
lingua
liquido
lira
lirica
lisca
lite
litigio
livrea
locanda
lode
logica
lombare
londra
longevo
loquace
lorenzo
loto
lotteria
luce
lucidato
lumaca
luminoso
lungo
lupo
luppolo
lusinga
lusso
lutto
macabro
macchina
macero
macinato
madama
magico
maglia
magnete
magro
maiolica
malafede
malgrado
malinteso
malsano
malto
malumore
mana
mancia
mandorla
mangiare
manifesto
mannaro
manovra
mansarda
mantide
manubrio
mappa
maratona
marcire
maretta
marmo
marsupio
maschera
massaia
mastino
materasso
matricola
mattone
maturo
mazurca
meandro
meccanico
mecenate
medesimo
meditare
mega
melassa
melis
melodia
meninge
meno
mensola
mercurio
merenda
merlo
meschino
mese
messere
mestolo
metallo
metodo
mettere
miagolare
mica
micelio
michele
microbo
midollo
miele
migliore
milano
milite
mimosa
minerale
mini
minore
mirino
mirtillo
miscela
missiva
misto
misurare
mitezza
mitigare
mitra
mittente
mnemonico
modello
modifica
modulo
mogano
mogio
mole
molosso
monastero
monco
mondina
monetario
monile
monotono
monsone
montato
monviso
mora
mordere
morsicato
mostro
motivato
motosega
motto
movenza
movimento
mozzo
mucca
mucosa
muffa
mughetto
mugnaio
mulatto
mulinello
multiplo
mummia
munto
muovere
murale
musa
muscolo
musica
mutevole
muto
nababbo
nafta
nanometro
narciso
narice
narrato
nascere
nastrare
naturale
nautica
naviglio
nebulosa
necrosi
negativo
negozio
nemmeno
neofita
neretto
nervo
nessuno
nettuno
neutrale
neve
nevrotico
nicchia
ninfa
nitido
nobile
nocivo
nodo
nome
nomina
nordico
normale
norvegese
nostrano
notare
notizia
notturno
novella
nucleo
nulla
numero
nuovo
nutrire
nuvola
nuziale
oasi
obbedire
obbligo
obelisco
oblio
obolo
obsoleto
occasione
occhio
occidente
occorrere
occultare
ocra
oculato
odierno
odorare
offerta
offrire
offuscato
oggetto
oggi
ognuno
olandese
olfatto
oliato
oliva
ologramma
oltre
omaggio
ombelico
ombra
omega
omissione
ondoso
onere
onice
onnivoro
onorevole
onta
operato
opinione
opposto
oracolo
orafo
ordine
orecchino
orefice
orfano
organico
origine
orizzonte
orma
ormeggio
ornativo
orologio
orrendo
orribile
ortensia
ortica
orzata
orzo
osare
oscurare
osmosi
ospedale
ospite
ossa
ossidare
ostacolo
oste
otite
otre
ottagono
ottimo
ottobre
ovale
ovest
ovino
oviparo
ovocito
ovunque
ovviare
ozio
pacchetto
pace
pacifico
padella
padrone
paese
paga
pagina
palazzina
palesare
pallido
palo
palude
pandoro
pannello
paolo
paonazzo
paprica
parabola
parcella
parere
pargolo
pari
parlato
parola
partire
parvenza
parziale
passivo
pasticca
patacca
patologia
pattume
pavone
peccato
pedalare
pedonale
peggio
peloso
penare
pendice
penisola
pennuto
penombra
pensare
pentola
pepe
pepita
perbene
percorso
perdonato
perforare
pergamena
periodo
permesso
perno
perplesso
persuaso
pertugio
pervaso
pesatore
pesista
peso
pestifero
petalo
pettine
petulante
pezzo
piacere
pianta
piattino
piccino
picozza
piega
pietra
piffero
pigiama
pigolio
pigro
pila
pilifero
pillola
pilota
pimpante
pineta
pinna
pinolo
pioggia
piombo
piramide
piretico
pirite
pirolisi
pitone
pizzico
placebo
planare
plasma
platano
plenario
pochezza
poderoso
podismo
poesia
poggiare
polenta
poligono
pollice
polmonite
polpetta
polso
poltrona
polvere
pomice
pomodoro
ponte
popoloso
porfido
poroso
porpora
porre
portata
posa
positivo
possesso
postulato
potassio
potere
pranzo
prassi
pratica
precluso
predica
prefisso
pregiato
prelievo
premere
prenotare
preparato
presenza
pretesto
prevalso
prima
principe
privato
problema
procura
produrre
profumo
progetto
prolunga
promessa
pronome
proposta
proroga
proteso
prova
prudente
prugna
prurito
psiche
pubblico
pudica
pugilato
pugno
pulce
pulito
pulsante
puntare
pupazzo
pupilla
puro
quadro
qualcosa
quasi
querela
quota
raccolto
raddoppio
radicale
radunato
raffica
ragazzo
ragione
ragno
ramarro
ramingo
ramo
randagio
rantolare
rapato
rapina
rappreso
rasatura
raschiato
rasente
rassegna
rastrello
rata
ravveduto
reale
recepire
recinto
recluta
recondito
recupero
reddito
redimere
regalato
registro
regola
regresso
relazione
remare
remoto
renna
replica
reprimere
reputare
resa
residente
responso
restauro
rete
retina
retorica
rettifica
revocato
riassunto
ribadire
ribelle
ribrezzo
ricarica
ricco
ricevere
riciclato
ricordo
ricreduto
ridicolo
ridurre
rifasare
riflesso
riforma
rifugio
rigare
rigettato
righello
rilassato
rilevato
rimanere
rimbalzo
rimedio
rimorchio
rinascita
rincaro
rinforzo
rinnovo
rinomato
rinsavito
rintocco
rinuncia
rinvenire
riparato
ripetuto
ripieno
riportare
ripresa
ripulire
risata
rischio
riserva
risibile
riso
rispetto
ristoro
risultato
risvolto
ritardo
ritegno
ritmico
ritrovo
riunione
riva
riverso
rivincita
rivolto
rizoma
roba
robotico
robusto
roccia
roco
rodaggio
rodere
roditore
rogito
rollio
romantico
rompere
ronzio
rosolare
rospo
rotante
rotondo
rotula
rovescio
rubizzo
rubrica
ruga
rullino
rumine
rumoroso
ruolo
rupe
russare
rustico
sabato
sabbiare
sabotato
sagoma
salasso
saldatura
salgemma
salivare
salmone
salone
saltare
saluto
salvo
sapere
sapido
saporito
saraceno
sarcasmo
sarto
sassoso
satellite
satira
satollo
saturno
savana
savio
saziato
sbadiglio
sbalzo
sbancato
sbarra
sbattere
sbavare
sbendare
sbirciare
sbloccato
sbocciato
sbrinare
sbruffone
sbuffare
scabroso
scadenza
scala
scambiare
scandalo
scapola
scarso
scatenare
scavato
scelto
scenico
scettro
scheda
schiena
sciarpa
scienza
scindere
scippo
sciroppo
scivolo
sclerare
scodella
scolpito
scomparto
sconforto
scoprire
scorta
scossone
scozzese
scriba
scrollare
scrutinio
scuderia
scultore
scuola
scuro
scusare
sdebitare
sdoganare
seccatura
secondo
sedano
seggiola
segnalato
segregato
seguito
selciato
selettivo
sella
selvaggio
semaforo
sembrare
seme
seminato
sempre
senso
sentire
sepolto
sequenza
serata
serbato
sereno
serio
serpente
serraglio
servire
sestina
setola
settimana
sfacelo
sfaldare
sfamato
sfarzoso
sfaticato
sfera
sfida
sfilato
sfinge
sfocato
sfoderare
sfogo
sfoltire
sforzato
sfratto
sfruttato
sfuggito
sfumare
sfuso
sgabello
sgarbato
sgonfiare
sgorbio
sgrassato
sguardo
sibilo
siccome
sierra
sigla
signore
silenzio
sillaba
simbolo
simpatico
simulato
sinfonia
singolo
sinistro
sino
sintesi
sinusoide
sipario
sisma
sistole
situato
slitta
slogatura
sloveno
smarrito
smemorato
smentito
smeraldo
smilzo
smontare
smottato
smussato
snellire
snervato
snodo
sobbalzo
sobrio
soccorso
sociale
sodale
soffitto
sogno
soldato
solenne
solido
sollazzo
solo
solubile
solvente
somatico
somma
sonda
sonetto
sonnifero
sopire
soppeso
sopra
sorgere
sorpasso
sorriso
sorso
sorteggio
sorvolato
sospiro
sosta
sottile
spada
spalla
spargere
spatola
spavento
spazzola
specie
spedire
spegnere
spelatura
speranza
spessore
spettrale
spezzato
spia
spigoloso
spillato
spinoso
spirale
splendido
sportivo
sposo
spranga
sprecare
spronato
spruzzo
spuntino
squillo
sradicare
srotolato
stabile
stacco
staffa
stagnare
stampato
stantio
starnuto
stasera
statuto
stelo
steppa
sterzo
stiletto
stima
stirpe
stivale
stizzoso
stonato
storico
strappo
stregato
stridulo
strozzare
strutto
stuccare
stufo
stupendo
subentro
succoso
sudore
suggerito
sugo
sultano
suonare
superbo
supporto
surgelato
surrogato
sussurro
sutura
svagare
svedese
sveglio
svelare
svenuto
svezia
sviluppo
svista
svizzera
svolta
svuotare
tabacco
tabulato
tacciare
taciturno
tale
talismano
tampone
tannino
tara
tardivo
targato
tariffa
tarpare
tartaruga
tasto
tattico
taverna
tavolata
tazza
teca
tecnico
telefono
temerario
tempo
temuto
tendone
tenero
tensione
tentacolo
teorema
terme
terrazzo
terzetto
tesi
tesserato
testato
tetro
tettoia
tifare
tigella
timbro
tinto
tipico
tipografo
tiraggio
tiro
titanio
titolo
titubante
tizio
tizzone
toccare
tollerare
tolto
tombola
tomo
tonfo
tonsilla
topazio
topologia
toppa
torba
tornare
torrone
tortora
toscano
tossire
tostatura
totano
trabocco
trachea
trafila
tragedia
tralcio
tramonto
transito
trapano
trarre
trasloco
trattato
trave
treccia
tremolio
trespolo
tributo
tricheco
trifoglio
trillo
trincea
trio
tristezza
triturato
trivella
tromba
trono
troppo
trottola
trovare
truccato
tubatura
tuffato
tulipano
tumulto
tunisia
turbare
turchino
tuta
tutela
ubicato
uccello
uccisore
udire
uditivo
uffa
ufficio
uguale
ulisse
ultimato
umano
umile
umorismo
uncinetto
ungere
ungherese
unicorno
unificato
unisono
unitario
unte
uovo
upupa
uragano
urgenza
urlo
usanza
usato
uscito
usignolo
usuraio
utensile
utilizzo
utopia
vacante
vaccinato
vagabondo
vagliato
valanga
valgo
valico
valletta
valoroso
valutare
valvola
vampata
vangare
vanitoso
vano
vantaggio
vanvera
vapore
varano
varcato
variante
vasca
vedetta
vedova
veduto
vegetale
veicolo
velcro
velina
velluto
veloce
venato
vendemmia
vento
verace
verbale
vergogna
verifica
vero
verruca
verticale
vescica
vessillo
vestale
veterano
vetrina
vetusto
viandante
vibrante
vicenda
vichingo
vicinanza
vidimare
vigilia
vigneto
vigore
vile
villano
vimini
vincitore
viola
vipera
virgola
virologo
virulento
viscoso
visione
vispo
vissuto
visura
vita
vitello
vittima
vivanda
vivido
viziare
voce
voga
volatile
volere
volpe
voragine
vulcano
zampogna
zanna
zappato
zattera
zavorra
zefiro
zelante
zelo
zenzero
zerbino
zibetto
zinco
zircone
zitto
zolla
zotico
zucchero
zufolo
zulu
zuppa`.split("\n");
    }
  });

  // node_modules/@scure/bip39/wordlists/japanese.js
  var require_japanese = __commonJS({
    "node_modules/@scure/bip39/wordlists/japanese.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `\u3042\u3044\u3053\u304F\u3057\u3093
\u3042\u3044\u3055\u3064
\u3042\u3044\u305F\u3099
\u3042\u304A\u305D\u3099\u3089
\u3042\u304B\u3061\u3083\u3093
\u3042\u304D\u308B
\u3042\u3051\u304B\u3099\u305F
\u3042\u3051\u308B
\u3042\u3053\u304B\u3099\u308C\u308B
\u3042\u3055\u3044
\u3042\u3055\u3072
\u3042\u3057\u3042\u3068
\u3042\u3057\u3099\u308F\u3046
\u3042\u3059\u3099\u304B\u308B
\u3042\u3059\u3099\u304D
\u3042\u305D\u3075\u3099
\u3042\u305F\u3048\u308B
\u3042\u305F\u305F\u3081\u308B
\u3042\u305F\u308A\u307E\u3048
\u3042\u305F\u308B
\u3042\u3064\u3044
\u3042\u3064\u304B\u3046
\u3042\u3063\u3057\u3085\u304F
\u3042\u3064\u307E\u308A
\u3042\u3064\u3081\u308B
\u3042\u3066\u306A
\u3042\u3066\u306F\u307E\u308B
\u3042\u3072\u308B
\u3042\u3075\u3099\u3089
\u3042\u3075\u3099\u308B
\u3042\u3075\u308C\u308B
\u3042\u307E\u3044
\u3042\u307E\u3068\u3099
\u3042\u307E\u3084\u304B\u3059
\u3042\u307E\u308A
\u3042\u307F\u3082\u306E
\u3042\u3081\u308A\u304B
\u3042\u3084\u307E\u308B
\u3042\u3086\u3080
\u3042\u3089\u3044\u304F\u3099\u307E
\u3042\u3089\u3057
\u3042\u3089\u3059\u3057\u3099
\u3042\u3089\u305F\u3081\u308B
\u3042\u3089\u3086\u308B
\u3042\u3089\u308F\u3059
\u3042\u308A\u304B\u3099\u3068\u3046
\u3042\u308F\u305B\u308B
\u3042\u308F\u3066\u308B
\u3042\u3093\u3044
\u3042\u3093\u304B\u3099\u3044
\u3042\u3093\u3053
\u3042\u3093\u305B\u3099\u3093
\u3042\u3093\u3066\u3044
\u3042\u3093\u306A\u3044
\u3042\u3093\u307E\u308A
\u3044\u3044\u305F\u3099\u3059
\u3044\u304A\u3093
\u3044\u304B\u3099\u3044
\u3044\u304B\u3099\u304F
\u3044\u304D\u304A\u3044
\u3044\u304D\u306A\u308A
\u3044\u304D\u3082\u306E
\u3044\u304D\u308B
\u3044\u304F\u3057\u3099
\u3044\u304F\u3075\u3099\u3093
\u3044\u3051\u306F\u3099\u306A
\u3044\u3051\u3093
\u3044\u3053\u3046
\u3044\u3053\u304F
\u3044\u3053\u3064
\u3044\u3055\u307E\u3057\u3044
\u3044\u3055\u3093
\u3044\u3057\u304D
\u3044\u3057\u3099\u3085\u3046
\u3044\u3057\u3099\u3087\u3046
\u3044\u3057\u3099\u308F\u308B
\u3044\u3059\u3099\u307F
\u3044\u3059\u3099\u308C
\u3044\u305B\u3044
\u3044\u305B\u3048\u3072\u3099
\u3044\u305B\u304B\u3044
\u3044\u305B\u304D
\u3044\u305B\u3099\u3093
\u3044\u305D\u3046\u308D\u3046
\u3044\u305D\u304B\u3099\u3057\u3044
\u3044\u305F\u3099\u3044
\u3044\u305F\u3099\u304F
\u3044\u305F\u3059\u3099\u3089
\u3044\u305F\u307F
\u3044\u305F\u308A\u3042
\u3044\u3061\u304A\u3046
\u3044\u3061\u3057\u3099
\u3044\u3061\u3068\u3099
\u3044\u3061\u306F\u3099
\u3044\u3061\u3075\u3099
\u3044\u3061\u308A\u3085\u3046
\u3044\u3064\u304B
\u3044\u3063\u3057\u3085\u3093
\u3044\u3063\u305B\u3044
\u3044\u3063\u305D\u3046
\u3044\u3063\u305F\u3093
\u3044\u3063\u3061
\u3044\u3063\u3066\u3044
\u3044\u3063\u307B\u309A\u3046
\u3044\u3066\u3055\u3099
\u3044\u3066\u3093
\u3044\u3068\u3099\u3046
\u3044\u3068\u3053
\u3044\u306A\u3044
\u3044\u306A\u304B
\u3044\u306D\u3080\u308A
\u3044\u306E\u3061
\u3044\u306E\u308B
\u3044\u306F\u3064
\u3044\u306F\u3099\u308B
\u3044\u306F\u3093
\u3044\u3072\u3099\u304D
\u3044\u3072\u3093
\u3044\u3075\u304F
\u3044\u3078\u3093
\u3044\u307B\u3046
\u3044\u307F\u3093
\u3044\u3082\u3046\u3068
\u3044\u3082\u305F\u308C
\u3044\u3082\u308A
\u3044\u3084\u304B\u3099\u308B
\u3044\u3084\u3059
\u3044\u3088\u304B\u3093
\u3044\u3088\u304F
\u3044\u3089\u3044
\u3044\u3089\u3059\u3068
\u3044\u308A\u304F\u3099\u3061
\u3044\u308A\u3087\u3046
\u3044\u308C\u3044
\u3044\u308C\u3082\u306E
\u3044\u308C\u308B
\u3044\u308D\u3048\u3093\u3072\u309A\u3064
\u3044\u308F\u3044
\u3044\u308F\u3046
\u3044\u308F\u304B\u3093
\u3044\u308F\u306F\u3099
\u3044\u308F\u3086\u308B
\u3044\u3093\u3051\u3099\u3093\u307E\u3081
\u3044\u3093\u3055\u3064
\u3044\u3093\u3057\u3087\u3046
\u3044\u3093\u3088\u3046
\u3046\u3048\u304D
\u3046\u3048\u308B
\u3046\u304A\u3055\u3099
\u3046\u304B\u3099\u3044
\u3046\u304B\u3075\u3099
\u3046\u304B\u3078\u3099\u308B
\u3046\u304D\u308F
\u3046\u304F\u3089\u3044\u306A
\u3046\u304F\u308C\u308C
\u3046\u3051\u305F\u307E\u308F\u308B
\u3046\u3051\u3064\u3051
\u3046\u3051\u3068\u308B
\u3046\u3051\u3082\u3064
\u3046\u3051\u308B
\u3046\u3053\u3099\u304B\u3059
\u3046\u3053\u3099\u304F
\u3046\u3053\u3093
\u3046\u3055\u304D\u3099
\u3046\u3057\u306A\u3046
\u3046\u3057\u308D\u304B\u3099\u307F
\u3046\u3059\u3044
\u3046\u3059\u304D\u3099
\u3046\u3059\u304F\u3099\u3089\u3044
\u3046\u3059\u3081\u308B
\u3046\u305B\u3064
\u3046\u3061\u3042\u308F\u305B
\u3046\u3061\u304B\u3099\u308F
\u3046\u3061\u304D
\u3046\u3061\u3085\u3046
\u3046\u3063\u304B\u308A
\u3046\u3064\u304F\u3057\u3044
\u3046\u3063\u305F\u3048\u308B
\u3046\u3064\u308B
\u3046\u3068\u3099\u3093
\u3046\u306A\u304D\u3099
\u3046\u306A\u3057\u3099
\u3046\u306A\u3059\u3099\u304F
\u3046\u306A\u308B
\u3046\u306D\u308B
\u3046\u306E\u3046
\u3046\u3075\u3099\u3051\u3099
\u3046\u3075\u3099\u3053\u3099\u3048
\u3046\u307E\u308C\u308B
\u3046\u3081\u308B
\u3046\u3082\u3046
\u3046\u3084\u307E\u3046
\u3046\u3088\u304F
\u3046\u3089\u304B\u3099\u3048\u3059
\u3046\u3089\u304F\u3099\u3061
\u3046\u3089\u306A\u3044
\u3046\u308A\u3042\u3051\u3099
\u3046\u308A\u304D\u308C
\u3046\u308B\u3055\u3044
\u3046\u308C\u3057\u3044
\u3046\u308C\u3086\u304D
\u3046\u308C\u308B
\u3046\u308D\u3053
\u3046\u308F\u304D
\u3046\u308F\u3055
\u3046\u3093\u3053\u3046
\u3046\u3093\u3061\u3093
\u3046\u3093\u3066\u3093
\u3046\u3093\u3068\u3099\u3046
\u3048\u3044\u3048\u3093
\u3048\u3044\u304B\u3099
\u3048\u3044\u304D\u3087\u3046
\u3048\u3044\u3053\u3099
\u3048\u3044\u305B\u3044
\u3048\u3044\u3075\u3099\u3093
\u3048\u3044\u3088\u3046
\u3048\u3044\u308F
\u3048\u304A\u308A
\u3048\u304B\u3099\u304A
\u3048\u304B\u3099\u304F
\u3048\u304D\u305F\u3044
\u3048\u304F\u305B\u308B
\u3048\u3057\u3083\u304F
\u3048\u3059\u3066
\u3048\u3064\u3089\u3093
\u3048\u306E\u304F\u3099
\u3048\u307B\u3046\u307E\u304D
\u3048\u307B\u3093
\u3048\u307E\u304D
\u3048\u3082\u3057\u3099
\u3048\u3082\u306E
\u3048\u3089\u3044
\u3048\u3089\u3075\u3099
\u3048\u308A\u3042
\u3048\u3093\u3048\u3093
\u3048\u3093\u304B\u3044
\u3048\u3093\u304D\u3099
\u3048\u3093\u3051\u3099\u304D
\u3048\u3093\u3057\u3085\u3046
\u3048\u3093\u305B\u3099\u3064
\u3048\u3093\u305D\u304F
\u3048\u3093\u3061\u3087\u3046
\u3048\u3093\u3068\u3064
\u304A\u3044\u304B\u3051\u308B
\u304A\u3044\u3053\u3059
\u304A\u3044\u3057\u3044
\u304A\u3044\u3064\u304F
\u304A\u3046\u3048\u3093
\u304A\u3046\u3055\u307E
\u304A\u3046\u3057\u3099
\u304A\u3046\u305B\u3064
\u304A\u3046\u305F\u3044
\u304A\u3046\u3075\u304F
\u304A\u3046\u3078\u3099\u3044
\u304A\u3046\u3088\u3046
\u304A\u3048\u308B
\u304A\u304A\u3044
\u304A\u304A\u3046
\u304A\u304A\u3068\u3099\u304A\u308A
\u304A\u304A\u3084
\u304A\u304A\u3088\u305D
\u304A\u304B\u3048\u308A
\u304A\u304B\u3059\u3099
\u304A\u304B\u3099\u3080
\u304A\u304B\u308F\u308A
\u304A\u304D\u3099\u306A\u3046
\u304A\u304D\u308B
\u304A\u304F\u3055\u307E
\u304A\u304F\u3057\u3099\u3087\u3046
\u304A\u304F\u308A\u304B\u3099\u306A
\u304A\u304F\u308B
\u304A\u304F\u308C\u308B
\u304A\u3053\u3059
\u304A\u3053\u306A\u3046
\u304A\u3053\u308B
\u304A\u3055\u3048\u308B
\u304A\u3055\u306A\u3044
\u304A\u3055\u3081\u308B
\u304A\u3057\u3044\u308C
\u304A\u3057\u3048\u308B
\u304A\u3057\u3099\u304D\u3099
\u304A\u3057\u3099\u3055\u3093
\u304A\u3057\u3083\u308C
\u304A\u305D\u3089\u304F
\u304A\u305D\u308F\u308B
\u304A\u305F\u304B\u3099\u3044
\u304A\u305F\u304F
\u304A\u305F\u3099\u3084\u304B
\u304A\u3061\u3064\u304F
\u304A\u3063\u3068
\u304A\u3064\u308A
\u304A\u3066\u3099\u304B\u3051
\u304A\u3068\u3057\u3082\u306E
\u304A\u3068\u306A\u3057\u3044
\u304A\u3068\u3099\u308A
\u304A\u3068\u3099\u308D\u304B\u3059
\u304A\u306F\u3099\u3055\u3093
\u304A\u307E\u3044\u308A
\u304A\u3081\u3066\u3099\u3068\u3046
\u304A\u3082\u3044\u3066\u3099
\u304A\u3082\u3046
\u304A\u3082\u305F\u3044
\u304A\u3082\u3061\u3083
\u304A\u3084\u3064
\u304A\u3084\u3086\u3072\u3099
\u304A\u3088\u307B\u3099\u3059
\u304A\u3089\u3093\u305F\u3099
\u304A\u308D\u3059
\u304A\u3093\u304B\u3099\u304F
\u304A\u3093\u3051\u3044
\u304A\u3093\u3057\u3083
\u304A\u3093\u305B\u3093
\u304A\u3093\u305F\u3099\u3093
\u304A\u3093\u3061\u3085\u3046
\u304A\u3093\u3068\u3099\u3051\u3044
\u304B\u3042\u3064
\u304B\u3044\u304B\u3099
\u304B\u3099\u3044\u304D
\u304B\u3099\u3044\u3051\u3093
\u304B\u3099\u3044\u3053\u3046
\u304B\u3044\u3055\u3064
\u304B\u3044\u3057\u3083
\u304B\u3044\u3059\u3044\u3088\u304F
\u304B\u3044\u305B\u3099\u3093
\u304B\u3044\u305D\u3099\u3046\u3068\u3099
\u304B\u3044\u3064\u3046
\u304B\u3044\u3066\u3093
\u304B\u3044\u3068\u3046
\u304B\u3044\u3075\u304F
\u304B\u3099\u3044\u3078\u304D
\u304B\u3044\u307B\u3046
\u304B\u3044\u3088\u3046
\u304B\u3099\u3044\u3089\u3044
\u304B\u3044\u308F
\u304B\u3048\u308B
\u304B\u304A\u308A
\u304B\u304B\u3048\u308B
\u304B\u304B\u3099\u304F
\u304B\u304B\u3099\u3057
\u304B\u304B\u3099\u307F
\u304B\u304F\u3053\u3099
\u304B\u304F\u3068\u304F
\u304B\u3055\u3099\u308B
\u304B\u3099\u305D\u3099\u3046
\u304B\u305F\u3044
\u304B\u305F\u3061
\u304B\u3099\u3061\u3087\u3046
\u304B\u3099\u3063\u304D\u3085\u3046
\u304B\u3099\u3063\u3053\u3046
\u304B\u3099\u3063\u3055\u3093
\u304B\u3099\u3063\u3057\u3087\u3046
\u304B\u306A\u3055\u3099\u308F\u3057
\u304B\u306E\u3046
\u304B\u3099\u306F\u304F
\u304B\u3075\u3099\u304B
\u304B\u307B\u3046
\u304B\u307B\u3053\u3099
\u304B\u307E\u3046
\u304B\u307E\u307B\u3099\u3053
\u304B\u3081\u308C\u304A\u3093
\u304B\u3086\u3044
\u304B\u3088\u3046\u3072\u3099
\u304B\u3089\u3044
\u304B\u308B\u3044
\u304B\u308D\u3046
\u304B\u308F\u304F
\u304B\u308F\u3089
\u304B\u3099\u3093\u304B
\u304B\u3093\u3051\u3044
\u304B\u3093\u3053\u3046
\u304B\u3093\u3057\u3083
\u304B\u3093\u305D\u3046
\u304B\u3093\u305F\u3093
\u304B\u3093\u3061
\u304B\u3099\u3093\u306F\u3099\u308B
\u304D\u3042\u3044
\u304D\u3042\u3064
\u304D\u3044\u308D
\u304D\u3099\u3044\u3093
\u304D\u3046\u3044
\u304D\u3046\u3093
\u304D\u3048\u308B
\u304D\u304A\u3046
\u304D\u304A\u304F
\u304D\u304A\u3061
\u304D\u304A\u3093
\u304D\u304B\u3044
\u304D\u304B\u304F
\u304D\u304B\u3093\u3057\u3083
\u304D\u304D\u3066
\u304D\u304F\u306F\u3099\u308A
\u304D\u304F\u3089\u3051\u3099
\u304D\u3051\u3093\u305B\u3044
\u304D\u3053\u3046
\u304D\u3053\u3048\u308B
\u304D\u3053\u304F
\u304D\u3055\u3044
\u304D\u3055\u304F
\u304D\u3055\u307E
\u304D\u3055\u3089\u304D\u3099
\u304D\u3099\u3057\u3099\u304B\u304B\u3099\u304F
\u304D\u3099\u3057\u304D
\u304D\u3099\u3057\u3099\u305F\u3044\u3051\u3093
\u304D\u3099\u3057\u3099\u306B\u3063\u3066\u3044
\u304D\u3099\u3057\u3099\u3085\u3064\u3057\u3083
\u304D\u3059\u3046
\u304D\u305B\u3044
\u304D\u305B\u304D
\u304D\u305B\u3064
\u304D\u305D\u3046
\u304D\u305D\u3099\u304F
\u304D\u305D\u3099\u3093
\u304D\u305F\u3048\u308B
\u304D\u3061\u3087\u3046
\u304D\u3064\u3048\u3093
\u304D\u3099\u3063\u3061\u308A
\u304D\u3064\u3064\u304D
\u304D\u3064\u306D
\u304D\u3066\u3044
\u304D\u3068\u3099\u3046
\u304D\u3068\u3099\u304F
\u304D\u306A\u3044
\u304D\u306A\u304B\u3099
\u304D\u306A\u3053
\u304D\u306C\u3053\u3099\u3057
\u304D\u306D\u3093
\u304D\u306E\u3046
\u304D\u306E\u3057\u305F
\u304D\u306F\u304F
\u304D\u3072\u3099\u3057\u3044
\u304D\u3072\u3093
\u304D\u3075\u304F
\u304D\u3075\u3099\u3093
\u304D\u307B\u3099\u3046
\u304D\u307B\u3093
\u304D\u307E\u308B
\u304D\u307F\u3064
\u304D\u3080\u3059\u3099\u304B\u3057\u3044
\u304D\u3081\u308B
\u304D\u3082\u305F\u3099\u3081\u3057
\u304D\u3082\u3061
\u304D\u3082\u306E
\u304D\u3083\u304F
\u304D\u3084\u304F
\u304D\u3099\u3085\u3046\u306B\u304F
\u304D\u3088\u3046
\u304D\u3087\u3046\u308A\u3085\u3046
\u304D\u3089\u3044
\u304D\u3089\u304F
\u304D\u308A\u3093
\u304D\u308C\u3044
\u304D\u308C\u3064
\u304D\u308D\u304F
\u304D\u3099\u308D\u3093
\u304D\u308F\u3081\u308B
\u304D\u3099\u3093\u3044\u308D
\u304D\u3093\u304B\u304F\u3057\u3099
\u304D\u3093\u3057\u3099\u3087
\u304D\u3093\u3088\u3046\u3072\u3099
\u304F\u3099\u3042\u3044
\u304F\u3044\u3059\u3099
\u304F\u3046\u304B\u3093
\u304F\u3046\u304D
\u304F\u3046\u304F\u3099\u3093
\u304F\u3046\u3053\u3046
\u304F\u3099\u3046\u305B\u3044
\u304F\u3046\u305D\u3046
\u304F\u3099\u3046\u305F\u3089
\u304F\u3046\u3075\u304F
\u304F\u3046\u307B\u3099
\u304F\u304B\u3093
\u304F\u304D\u3087\u3046
\u304F\u3051\u3099\u3093
\u304F\u3099\u3053\u3046
\u304F\u3055\u3044
\u304F\u3055\u304D
\u304F\u3055\u306F\u3099\u306A
\u304F\u3055\u308B
\u304F\u3057\u3083\u307F
\u304F\u3057\u3087\u3046
\u304F\u3059\u306E\u304D
\u304F\u3059\u308A\u3086\u3072\u3099
\u304F\u305B\u3051\u3099
\u304F\u305B\u3093
\u304F\u3099\u305F\u3044\u3066\u304D
\u304F\u305F\u3099\u3055\u308B
\u304F\u305F\u3072\u3099\u308C\u308B
\u304F\u3061\u3053\u307F
\u304F\u3061\u3055\u304D
\u304F\u3064\u3057\u305F
\u304F\u3099\u3063\u3059\u308A
\u304F\u3064\u308D\u304F\u3099
\u304F\u3068\u3046\u3066\u3093
\u304F\u3068\u3099\u304F
\u304F\u306A\u3093
\u304F\u306D\u304F\u306D
\u304F\u306E\u3046
\u304F\u3075\u3046
\u304F\u307F\u3042\u308F\u305B
\u304F\u307F\u305F\u3066\u308B
\u304F\u3081\u308B
\u304F\u3084\u304F\u3057\u3087
\u304F\u3089\u3059
\u304F\u3089\u3078\u3099\u308B
\u304F\u308B\u307E
\u304F\u308C\u308B
\u304F\u308D\u3046
\u304F\u308F\u3057\u3044
\u304F\u3099\u3093\u304B\u3093
\u304F\u3099\u3093\u3057\u3087\u304F
\u304F\u3099\u3093\u305F\u3044
\u304F\u3099\u3093\u3066
\u3051\u3042\u306A
\u3051\u3044\u304B\u304F
\u3051\u3044\u3051\u3093
\u3051\u3044\u3053
\u3051\u3044\u3055\u3064
\u3051\u3099\u3044\u3057\u3099\u3085\u3064
\u3051\u3044\u305F\u3044
\u3051\u3099\u3044\u306E\u3046\u3057\u3099\u3093
\u3051\u3044\u308C\u304D
\u3051\u3044\u308D
\u3051\u304A\u3068\u3059
\u3051\u304A\u308A\u3082\u306E
\u3051\u3099\u304D\u304B
\u3051\u3099\u304D\u3051\u3099\u3093
\u3051\u3099\u304D\u305F\u3099\u3093
\u3051\u3099\u304D\u3061\u3093
\u3051\u3099\u304D\u3068\u3064
\u3051\u3099\u304D\u306F
\u3051\u3099\u304D\u3084\u304F
\u3051\u3099\u3053\u3046
\u3051\u3099\u3053\u304F\u3057\u3099\u3087\u3046
\u3051\u3099\u3055\u3099\u3044
\u3051\u3055\u304D
\u3051\u3099\u3055\u3099\u3093
\u3051\u3057\u304D
\u3051\u3057\u3053\u3099\u3080
\u3051\u3057\u3087\u3046
\u3051\u3099\u3059\u3068
\u3051\u305F\u306F\u3099
\u3051\u3061\u3083\u3063\u3075\u309A
\u3051\u3061\u3089\u3059
\u3051\u3064\u3042\u3064
\u3051\u3064\u3044
\u3051\u3064\u3048\u304D
\u3051\u3063\u3053\u3093
\u3051\u3064\u3057\u3099\u3087
\u3051\u3063\u305B\u304D
\u3051\u3063\u3066\u3044
\u3051\u3064\u307E\u3064
\u3051\u3099\u3064\u3088\u3046\u3072\u3099
\u3051\u3099\u3064\u308C\u3044
\u3051\u3064\u308D\u3093
\u3051\u3099\u3068\u3099\u304F
\u3051\u3068\u306F\u3099\u3059
\u3051\u3068\u308B
\u3051\u306A\u3051\u3099
\u3051\u306A\u3059
\u3051\u306A\u307F
\u3051\u306C\u304D
\u3051\u3099\u306D\u3064
\u3051\u306D\u3093
\u3051\u306F\u3044
\u3051\u3099\u3072\u3093
\u3051\u3075\u3099\u304B\u3044
\u3051\u3099\u307B\u3099\u304F
\u3051\u307E\u308A
\u3051\u307F\u304B\u308B
\u3051\u3080\u3057
\u3051\u3080\u308A
\u3051\u3082\u306E
\u3051\u3089\u3044
\u3051\u308D\u3051\u308D
\u3051\u308F\u3057\u3044
\u3051\u3093\u3044
\u3051\u3093\u3048\u3064
\u3051\u3093\u304A
\u3051\u3093\u304B
\u3051\u3099\u3093\u304D
\u3051\u3093\u3051\u3099\u3093
\u3051\u3093\u3053\u3046
\u3051\u3093\u3055\u304F
\u3051\u3093\u3057\u3085\u3046
\u3051\u3093\u3059\u3046
\u3051\u3099\u3093\u305D\u3046
\u3051\u3093\u3061\u304F
\u3051\u3093\u3066\u3044
\u3051\u3093\u3068\u3046
\u3051\u3093\u306A\u3044
\u3051\u3093\u306B\u3093
\u3051\u3099\u3093\u3075\u3099\u3064
\u3051\u3093\u307E
\u3051\u3093\u307F\u3093
\u3051\u3093\u3081\u3044
\u3051\u3093\u3089\u3093
\u3051\u3093\u308A
\u3053\u3042\u304F\u307E
\u3053\u3044\u306C
\u3053\u3044\u3072\u3099\u3068
\u3053\u3099\u3046\u3044
\u3053\u3046\u3048\u3093
\u3053\u3046\u304A\u3093
\u3053\u3046\u304B\u3093
\u3053\u3099\u3046\u304D\u3085\u3046
\u3053\u3099\u3046\u3051\u3044
\u3053\u3046\u3053\u3046
\u3053\u3046\u3055\u3044
\u3053\u3046\u3057\u3099
\u3053\u3046\u3059\u3044
\u3053\u3099\u3046\u305B\u3044
\u3053\u3046\u305D\u304F
\u3053\u3046\u305F\u3044
\u3053\u3046\u3061\u3083
\u3053\u3046\u3064\u3046
\u3053\u3046\u3066\u3044
\u3053\u3046\u3068\u3099\u3046
\u3053\u3046\u306A\u3044
\u3053\u3046\u306F\u3044
\u3053\u3099\u3046\u307B\u3046
\u3053\u3099\u3046\u307E\u3093
\u3053\u3046\u3082\u304F
\u3053\u3046\u308A\u3064
\u3053\u3048\u308B
\u3053\u304A\u308A
\u3053\u3099\u304B\u3044
\u3053\u3099\u304B\u3099\u3064
\u3053\u3099\u304B\u3093
\u3053\u304F\u3053\u3099
\u3053\u304F\u3055\u3044
\u3053\u304F\u3068\u3046
\u3053\u304F\u306A\u3044
\u3053\u304F\u306F\u304F
\u3053\u304F\u3099\u307E
\u3053\u3051\u3044
\u3053\u3051\u308B
\u3053\u3053\u306E\u304B
\u3053\u3053\u308D
\u3053\u3055\u3081
\u3053\u3057\u3064
\u3053\u3059\u3046
\u3053\u305B\u3044
\u3053\u305B\u304D
\u3053\u305B\u3099\u3093
\u3053\u305D\u305F\u3099\u3066
\u3053\u305F\u3044
\u3053\u305F\u3048\u308B
\u3053\u305F\u3064
\u3053\u3061\u3087\u3046
\u3053\u3063\u304B
\u3053\u3064\u3053\u3064
\u3053\u3064\u306F\u3099\u3093
\u3053\u3064\u3075\u3099
\u3053\u3066\u3044
\u3053\u3066\u3093
\u3053\u3068\u304B\u3099\u3089
\u3053\u3068\u3057
\u3053\u3068\u306F\u3099
\u3053\u3068\u308A
\u3053\u306A\u3053\u3099\u306A
\u3053\u306D\u3053\u306D
\u3053\u306E\u307E\u307E
\u3053\u306E\u307F
\u3053\u306E\u3088
\u3053\u3099\u306F\u3093
\u3053\u3072\u3064\u3057\u3099
\u3053\u3075\u3046
\u3053\u3075\u3093
\u3053\u307B\u3099\u308C\u308B
\u3053\u3099\u307E\u3042\u3075\u3099\u3089
\u3053\u307E\u304B\u3044
\u3053\u3099\u307E\u3059\u308A
\u3053\u307E\u3064\u306A
\u3053\u307E\u308B
\u3053\u3080\u304D\u3099\u3053
\u3053\u3082\u3057\u3099
\u3053\u3082\u3061
\u3053\u3082\u306E
\u3053\u3082\u3093
\u3053\u3084\u304F
\u3053\u3084\u307E
\u3053\u3086\u3046
\u3053\u3086\u3072\u3099
\u3053\u3088\u3044
\u3053\u3088\u3046
\u3053\u308A\u308B
\u3053\u308C\u304F\u3057\u3087\u3093
\u3053\u308D\u3063\u3051
\u3053\u308F\u3082\u3066
\u3053\u308F\u308C\u308B
\u3053\u3093\u3044\u3093
\u3053\u3093\u304B\u3044
\u3053\u3093\u304D
\u3053\u3093\u3057\u3085\u3046
\u3053\u3093\u3059\u3044
\u3053\u3093\u305F\u3099\u3066
\u3053\u3093\u3068\u3093
\u3053\u3093\u306A\u3093
\u3053\u3093\u3072\u3099\u306B
\u3053\u3093\u307B\u309A\u3093
\u3053\u3093\u307E\u3051
\u3053\u3093\u3084
\u3053\u3093\u308C\u3044
\u3053\u3093\u308F\u304F
\u3055\u3099\u3044\u3048\u304D
\u3055\u3044\u304B\u3044
\u3055\u3044\u304D\u3093
\u3055\u3099\u3044\u3051\u3099\u3093
\u3055\u3099\u3044\u3053
\u3055\u3044\u3057\u3087
\u3055\u3044\u305B\u3044
\u3055\u3099\u3044\u305F\u304F
\u3055\u3099\u3044\u3061\u3085\u3046
\u3055\u3044\u3066\u304D
\u3055\u3099\u3044\u308A\u3087\u3046
\u3055\u3046\u306A
\u3055\u304B\u3044\u3057
\u3055\u304B\u3099\u3059
\u3055\u304B\u306A
\u3055\u304B\u307F\u3061
\u3055\u304B\u3099\u308B
\u3055\u304D\u3099\u3087\u3046
\u3055\u304F\u3057
\u3055\u304F\u3072\u3093
\u3055\u304F\u3089
\u3055\u3053\u304F
\u3055\u3053\u3064
\u3055\u3059\u3099\u304B\u308B
\u3055\u3099\u305B\u304D
\u3055\u305F\u3093
\u3055\u3064\u3048\u3044
\u3055\u3099\u3064\u304A\u3093
\u3055\u3099\u3063\u304B
\u3055\u3099\u3064\u304B\u3099\u304F
\u3055\u3063\u304D\u3087\u304F
\u3055\u3099\u3063\u3057
\u3055\u3064\u3057\u3099\u3093
\u3055\u3099\u3063\u305D\u3046
\u3055\u3064\u305F\u306F\u3099
\u3055\u3064\u307E\u3044\u3082
\u3055\u3066\u3044
\u3055\u3068\u3044\u3082
\u3055\u3068\u3046
\u3055\u3068\u304A\u3084
\u3055\u3068\u3057
\u3055\u3068\u308B
\u3055\u306E\u3046
\u3055\u306F\u3099\u304F
\u3055\u3072\u3099\u3057\u3044
\u3055\u3078\u3099\u3064
\u3055\u307B\u3046
\u3055\u307B\u3068\u3099
\u3055\u307E\u3059
\u3055\u307F\u3057\u3044
\u3055\u307F\u305F\u3099\u308C
\u3055\u3080\u3051
\u3055\u3081\u308B
\u3055\u3084\u3048\u3093\u3068\u3099\u3046
\u3055\u3086\u3046
\u3055\u3088\u3046
\u3055\u3088\u304F
\u3055\u3089\u305F\u3099
\u3055\u3099\u308B\u305D\u306F\u3099
\u3055\u308F\u3084\u304B
\u3055\u308F\u308B
\u3055\u3093\u3044\u3093
\u3055\u3093\u304B
\u3055\u3093\u304D\u3083\u304F
\u3055\u3093\u3053\u3046
\u3055\u3093\u3055\u3044
\u3055\u3099\u3093\u3057\u3087
\u3055\u3093\u3059\u3046
\u3055\u3093\u305B\u3044
\u3055\u3093\u305D
\u3055\u3093\u3061
\u3055\u3093\u307E
\u3055\u3093\u307F
\u3055\u3093\u3089\u3093
\u3057\u3042\u3044
\u3057\u3042\u3051\u3099
\u3057\u3042\u3055\u3063\u3066
\u3057\u3042\u308F\u305B
\u3057\u3044\u304F
\u3057\u3044\u3093
\u3057\u3046\u3061
\u3057\u3048\u3044
\u3057\u304A\u3051
\u3057\u304B\u3044
\u3057\u304B\u304F
\u3057\u3099\u304B\u3093
\u3057\u3053\u3099\u3068
\u3057\u3059\u3046
\u3057\u3099\u305F\u3099\u3044
\u3057\u305F\u3046\u3051
\u3057\u305F\u304D\u3099
\u3057\u305F\u3066
\u3057\u305F\u307F
\u3057\u3061\u3087\u3046
\u3057\u3061\u308A\u3093
\u3057\u3063\u304B\u308A
\u3057\u3064\u3057\u3099
\u3057\u3064\u3082\u3093
\u3057\u3066\u3044
\u3057\u3066\u304D
\u3057\u3066\u3064
\u3057\u3099\u3066\u3093
\u3057\u3099\u3068\u3099\u3046
\u3057\u306A\u304D\u3099\u308C
\u3057\u306A\u3082\u306E
\u3057\u306A\u3093
\u3057\u306D\u307E
\u3057\u306D\u3093
\u3057\u306E\u304F\u3099
\u3057\u306E\u3075\u3099
\u3057\u306F\u3044
\u3057\u306F\u3099\u304B\u308A
\u3057\u306F\u3064
\u3057\u306F\u3089\u3044
\u3057\u306F\u3093
\u3057\u3072\u3087\u3046
\u3057\u3075\u304F
\u3057\u3099\u3075\u3099\u3093
\u3057\u3078\u3044
\u3057\u307B\u3046
\u3057\u307B\u3093
\u3057\u307E\u3046
\u3057\u307E\u308B
\u3057\u307F\u3093
\u3057\u3080\u3051\u308B
\u3057\u3099\u3080\u3057\u3087
\u3057\u3081\u3044
\u3057\u3081\u308B
\u3057\u3082\u3093
\u3057\u3083\u3044\u3093
\u3057\u3083\u3046\u3093
\u3057\u3083\u304A\u3093
\u3057\u3099\u3083\u304B\u3099\u3044\u3082
\u3057\u3084\u304F\u3057\u3087
\u3057\u3083\u304F\u307B\u3046
\u3057\u3083\u3051\u3093
\u3057\u3083\u3053
\u3057\u3083\u3055\u3099\u3044
\u3057\u3083\u3057\u3093
\u3057\u3083\u305B\u3093
\u3057\u3083\u305D\u3046
\u3057\u3083\u305F\u3044
\u3057\u3083\u3061\u3087\u3046
\u3057\u3083\u3063\u304D\u3093
\u3057\u3099\u3083\u307E
\u3057\u3083\u308A\u3093
\u3057\u3083\u308C\u3044
\u3057\u3099\u3086\u3046
\u3057\u3099\u3085\u3046\u3057\u3087
\u3057\u3085\u304F\u306F\u304F
\u3057\u3099\u3085\u3057\u3093
\u3057\u3085\u3063\u305B\u304D
\u3057\u3085\u307F
\u3057\u3085\u3089\u306F\u3099
\u3057\u3099\u3085\u3093\u306F\u3099\u3093
\u3057\u3087\u3046\u304B\u3044
\u3057\u3087\u304F\u305F\u304F
\u3057\u3087\u3063\u3051\u3093
\u3057\u3087\u3068\u3099\u3046
\u3057\u3087\u3082\u3064
\u3057\u3089\u305B\u308B
\u3057\u3089\u3078\u3099\u308B
\u3057\u3093\u304B
\u3057\u3093\u3053\u3046
\u3057\u3099\u3093\u3057\u3099\u3083
\u3057\u3093\u305B\u3044\u3057\u3099
\u3057\u3093\u3061\u304F
\u3057\u3093\u308A\u3093
\u3059\u3042\u3051\u3099
\u3059\u3042\u3057
\u3059\u3042\u306A
\u3059\u3099\u3042\u3093
\u3059\u3044\u3048\u3044
\u3059\u3044\u304B
\u3059\u3044\u3068\u3046
\u3059\u3099\u3044\u3075\u3099\u3093
\u3059\u3044\u3088\u3046\u3072\u3099
\u3059\u3046\u304B\u3099\u304F
\u3059\u3046\u3057\u3099\u3064
\u3059\u3046\u305B\u3093
\u3059\u304A\u3068\u3099\u308A
\u3059\u304D\u307E
\u3059\u304F\u3046
\u3059\u304F\u306A\u3044
\u3059\u3051\u308B
\u3059\u3053\u3099\u3044
\u3059\u3053\u3057
\u3059\u3099\u3055\u3093
\u3059\u3059\u3099\u3057\u3044
\u3059\u3059\u3080
\u3059\u3059\u3081\u308B
\u3059\u3063\u304B\u308A
\u3059\u3099\u3063\u3057\u308A
\u3059\u3099\u3063\u3068
\u3059\u3066\u304D
\u3059\u3066\u308B
\u3059\u306D\u308B
\u3059\u306E\u3053
\u3059\u306F\u305F\u3099
\u3059\u306F\u3099\u3089\u3057\u3044
\u3059\u3099\u3072\u3087\u3046
\u3059\u3099\u3075\u3099\u306C\u308C
\u3059\u3075\u3099\u308A
\u3059\u3075\u308C
\u3059\u3078\u3099\u3066
\u3059\u3078\u3099\u308B
\u3059\u3099\u307B\u3046
\u3059\u307B\u3099\u3093
\u3059\u307E\u3044
\u3059\u3081\u3057
\u3059\u3082\u3046
\u3059\u3084\u304D
\u3059\u3089\u3059\u3089
\u3059\u308B\u3081
\u3059\u308C\u3061\u304B\u3099\u3046
\u3059\u308D\u3063\u3068
\u3059\u308F\u308B
\u3059\u3093\u305B\u3099\u3093
\u3059\u3093\u307B\u309A\u3046
\u305B\u3042\u3075\u3099\u3089
\u305B\u3044\u304B\u3064
\u305B\u3044\u3051\u3099\u3093
\u305B\u3044\u3057\u3099
\u305B\u3044\u3088\u3046
\u305B\u304A\u3046
\u305B\u304B\u3044\u304B\u3093
\u305B\u304D\u306B\u3093
\u305B\u304D\u3080
\u305B\u304D\u3086
\u305B\u304D\u3089\u3093\u3046\u3093
\u305B\u3051\u3093
\u305B\u3053\u3046
\u305B\u3059\u3057\u3099
\u305B\u305F\u3044
\u305B\u305F\u3051
\u305B\u3063\u304B\u304F
\u305B\u3063\u304D\u3083\u304F
\u305B\u3099\u3063\u304F
\u305B\u3063\u3051\u3093
\u305B\u3063\u3053\u3064
\u305B\u3063\u3055\u305F\u304F\u307E
\u305B\u3064\u305D\u3099\u304F
\u305B\u3064\u305F\u3099\u3093
\u305B\u3064\u3066\u3099\u3093
\u305B\u3063\u306F\u309A\u3093
\u305B\u3064\u3072\u3099
\u305B\u3064\u3075\u3099\u3093
\u305B\u3064\u3081\u3044
\u305B\u3064\u308A\u3064
\u305B\u306A\u304B
\u305B\u306E\u3072\u3099
\u305B\u306F\u306F\u3099
\u305B\u3072\u3099\u308D
\u305B\u307B\u3099\u306D
\u305B\u307E\u3044
\u305B\u307E\u308B
\u305B\u3081\u308B
\u305B\u3082\u305F\u308C
\u305B\u308A\u3075
\u305B\u3099\u3093\u3042\u304F
\u305B\u3093\u3044
\u305B\u3093\u3048\u3044
\u305B\u3093\u304B
\u305B\u3093\u304D\u3087
\u305B\u3093\u304F
\u305B\u3093\u3051\u3099\u3093
\u305B\u3099\u3093\u3053\u3099
\u305B\u3093\u3055\u3044
\u305B\u3093\u3057\u3085
\u305B\u3093\u3059\u3044
\u305B\u3093\u305B\u3044
\u305B\u3093\u305D\u3099
\u305B\u3093\u305F\u304F
\u305B\u3093\u3061\u3087\u3046
\u305B\u3093\u3066\u3044
\u305B\u3093\u3068\u3046
\u305B\u3093\u306C\u304D
\u305B\u3093\u306D\u3093
\u305B\u3093\u306F\u309A\u3044
\u305B\u3099\u3093\u3075\u3099
\u305B\u3099\u3093\u307B\u309A\u3046
\u305B\u3093\u3080
\u305B\u3093\u3081\u3093\u3057\u3099\u3087
\u305B\u3093\u3082\u3093
\u305B\u3093\u3084\u304F
\u305B\u3093\u3086\u3046
\u305B\u3093\u3088\u3046
\u305B\u3099\u3093\u3089
\u305B\u3099\u3093\u308A\u3083\u304F
\u305B\u3093\u308C\u3044
\u305B\u3093\u308D
\u305D\u3042\u304F
\u305D\u3044\u3068\u3051\u3099\u308B
\u305D\u3044\u306D
\u305D\u3046\u304B\u3099\u3093\u304D\u3087\u3046
\u305D\u3046\u304D
\u305D\u3046\u3053\u3099
\u305D\u3046\u3057\u3093
\u305D\u3046\u305F\u3099\u3093
\u305D\u3046\u306A\u3093
\u305D\u3046\u3072\u3099
\u305D\u3046\u3081\u3093
\u305D\u3046\u308A
\u305D\u3048\u3082\u306E
\u305D\u3048\u3093
\u305D\u304B\u3099\u3044
\u305D\u3051\u3099\u304D
\u305D\u3053\u3046
\u305D\u3053\u305D\u3053
\u305D\u3055\u3099\u3044
\u305D\u3057\u306A
\u305D\u305B\u3044
\u305D\u305B\u3093
\u305D\u305D\u304F\u3099
\u305D\u305F\u3099\u3066\u308B
\u305D\u3064\u3046
\u305D\u3064\u3048\u3093
\u305D\u3063\u304B\u3093
\u305D\u3064\u304D\u3099\u3087\u3046
\u305D\u3063\u3051\u3064
\u305D\u3063\u3053\u3046
\u305D\u3063\u305B\u3093
\u305D\u3063\u3068
\u305D\u3068\u304B\u3099\u308F
\u305D\u3068\u3064\u3099\u3089
\u305D\u306A\u3048\u308B
\u305D\u306A\u305F
\u305D\u3075\u307B\u3099
\u305D\u307B\u3099\u304F
\u305D\u307B\u3099\u308D
\u305D\u307E\u3064
\u305D\u307E\u308B
\u305D\u3080\u304F
\u305D\u3080\u308A\u3048
\u305D\u3081\u308B
\u305D\u3082\u305D\u3082
\u305D\u3088\u304B\u305B\u3099
\u305D\u3089\u307E\u3081
\u305D\u308D\u3046
\u305D\u3093\u304B\u3044
\u305D\u3093\u3051\u3044
\u305D\u3093\u3055\u3099\u3044
\u305D\u3093\u3057\u3064
\u305D\u3093\u305D\u3099\u304F
\u305D\u3093\u3061\u3087\u3046
\u305D\u3099\u3093\u3072\u3099
\u305D\u3099\u3093\u3075\u3099\u3093
\u305D\u3093\u307F\u3093
\u305F\u3042\u3044
\u305F\u3044\u3044\u3093
\u305F\u3044\u3046\u3093
\u305F\u3044\u3048\u304D
\u305F\u3044\u304A\u3046
\u305F\u3099\u3044\u304B\u3099\u304F
\u305F\u3044\u304D
\u305F\u3044\u304F\u3099\u3046
\u305F\u3044\u3051\u3093
\u305F\u3044\u3053
\u305F\u3044\u3055\u3099\u3044
\u305F\u3099\u3044\u3057\u3099\u3087\u3046\u3075\u3099
\u305F\u3099\u3044\u3059\u304D
\u305F\u3044\u305B\u3064
\u305F\u3044\u305D\u3046
\u305F\u3099\u3044\u305F\u3044
\u305F\u3044\u3061\u3087\u3046
\u305F\u3044\u3066\u3044
\u305F\u3099\u3044\u3068\u3099\u3053\u308D
\u305F\u3044\u306A\u3044
\u305F\u3044\u306D\u3064
\u305F\u3044\u306E\u3046
\u305F\u3044\u306F\u3093
\u305F\u3099\u3044\u3072\u3087\u3046
\u305F\u3044\u3075\u3046
\u305F\u3044\u3078\u3093
\u305F\u3044\u307B
\u305F\u3044\u307E\u3064\u306F\u3099\u306A
\u305F\u3044\u307F\u3093\u304F\u3099
\u305F\u3044\u3080
\u305F\u3044\u3081\u3093
\u305F\u3044\u3084\u304D
\u305F\u3044\u3088\u3046
\u305F\u3044\u3089
\u305F\u3044\u308A\u3087\u304F
\u305F\u3044\u308B
\u305F\u3044\u308F\u3093
\u305F\u3046\u3048
\u305F\u3048\u308B
\u305F\u304A\u3059
\u305F\u304A\u308B
\u305F\u304A\u308C\u308B
\u305F\u304B\u3044
\u305F\u304B\u306D
\u305F\u304D\u3072\u3099
\u305F\u304F\u3055\u3093
\u305F\u3053\u304F
\u305F\u3053\u3084\u304D
\u305F\u3055\u3044
\u305F\u3057\u3055\u3099\u3093
\u305F\u3099\u3057\u3099\u3083\u308C
\u305F\u3059\u3051\u308B
\u305F\u3059\u3099\u3055\u308F\u308B
\u305F\u305D\u304B\u3099\u308C
\u305F\u305F\u304B\u3046
\u305F\u305F\u304F
\u305F\u305F\u3099\u3057\u3044
\u305F\u305F\u307F
\u305F\u3061\u306F\u3099\u306A
\u305F\u3099\u3063\u304B\u3044
\u305F\u3099\u3063\u304D\u3083\u304F
\u305F\u3099\u3063\u3053
\u305F\u3099\u3063\u3057\u3085\u3064
\u305F\u3099\u3063\u305F\u3044
\u305F\u3066\u308B
\u305F\u3068\u3048\u308B
\u305F\u306A\u306F\u3099\u305F
\u305F\u306B\u3093
\u305F\u306C\u304D
\u305F\u306E\u3057\u307F
\u305F\u306F\u3064
\u305F\u3075\u3099\u3093
\u305F\u3078\u3099\u308B
\u305F\u307B\u3099\u3046
\u305F\u307E\u3053\u3099
\u305F\u307E\u308B
\u305F\u3099\u3080\u308B
\u305F\u3081\u3044\u304D
\u305F\u3081\u3059
\u305F\u3081\u308B
\u305F\u3082\u3064
\u305F\u3084\u3059\u3044
\u305F\u3088\u308B
\u305F\u3089\u3059
\u305F\u308A\u304D\u307B\u3093\u304B\u3099\u3093
\u305F\u308A\u3087\u3046
\u305F\u308A\u308B
\u305F\u308B\u3068
\u305F\u308C\u308B
\u305F\u308C\u3093\u3068
\u305F\u308D\u3063\u3068
\u305F\u308F\u3080\u308C\u308B
\u305F\u3099\u3093\u3042\u3064
\u305F\u3093\u3044
\u305F\u3093\u304A\u3093
\u305F\u3093\u304B
\u305F\u3093\u304D
\u305F\u3093\u3051\u3093
\u305F\u3093\u3053\u3099
\u305F\u3093\u3055\u3093
\u305F\u3093\u3057\u3099\u3087\u3046\u3072\u3099
\u305F\u3099\u3093\u305B\u3044
\u305F\u3093\u305D\u304F
\u305F\u3093\u305F\u3044
\u305F\u3099\u3093\u3061
\u305F\u3093\u3066\u3044
\u305F\u3093\u3068\u3046
\u305F\u3099\u3093\u306A
\u305F\u3093\u306B\u3093
\u305F\u3099\u3093\u306D\u3064
\u305F\u3093\u306E\u3046
\u305F\u3093\u3072\u309A\u3093
\u305F\u3099\u3093\u307B\u3099\u3046
\u305F\u3093\u307E\u3064
\u305F\u3093\u3081\u3044
\u305F\u3099\u3093\u308C\u3064
\u305F\u3099\u3093\u308D
\u305F\u3099\u3093\u308F
\u3061\u3042\u3044
\u3061\u3042\u3093
\u3061\u3044\u304D
\u3061\u3044\u3055\u3044
\u3061\u3048\u3093
\u3061\u304B\u3044
\u3061\u304B\u3089
\u3061\u304D\u3085\u3046
\u3061\u304D\u3093
\u3061\u3051\u3044\u3059\u3099
\u3061\u3051\u3093
\u3061\u3053\u304F
\u3061\u3055\u3044
\u3061\u3057\u304D
\u3061\u3057\u308A\u3087\u3046
\u3061\u305B\u3044
\u3061\u305D\u3046
\u3061\u305F\u3044
\u3061\u305F\u3093
\u3061\u3061\u304A\u3084
\u3061\u3064\u3057\u3099\u3087
\u3061\u3066\u304D
\u3061\u3066\u3093
\u3061\u306C\u304D
\u3061\u306C\u308A
\u3061\u306E\u3046
\u3061\u3072\u3087\u3046
\u3061\u3078\u3044\u305B\u3093
\u3061\u307B\u3046
\u3061\u307E\u305F
\u3061\u307F\u3064
\u3061\u307F\u3068\u3099\u308D
\u3061\u3081\u3044\u3068\u3099
\u3061\u3083\u3093\u3053\u306A\u3078\u3099
\u3061\u3085\u3046\u3044
\u3061\u3086\u308A\u3087\u304F
\u3061\u3087\u3046\u3057
\u3061\u3087\u3055\u304F\u3051\u3093
\u3061\u3089\u3057
\u3061\u3089\u307F
\u3061\u308A\u304B\u3099\u307F
\u3061\u308A\u3087\u3046
\u3061\u308B\u3068\u3099
\u3061\u308F\u308F
\u3061\u3093\u305F\u3044
\u3061\u3093\u3082\u304F
\u3064\u3044\u304B
\u3064\u3044\u305F\u3061
\u3064\u3046\u304B
\u3064\u3046\u3057\u3099\u3087\u3046
\u3064\u3046\u306F\u3093
\u3064\u3046\u308F
\u3064\u304B\u3046
\u3064\u304B\u308C\u308B
\u3064\u304F\u306D
\u3064\u304F\u308B
\u3064\u3051\u306D
\u3064\u3051\u308B
\u3064\u3053\u3099\u3046
\u3064\u305F\u3048\u308B
\u3064\u3064\u3099\u304F
\u3064\u3064\u3057\u3099
\u3064\u3064\u3080
\u3064\u3068\u3081\u308B
\u3064\u306A\u304B\u3099\u308B
\u3064\u306A\u307F
\u3064\u306D\u3064\u3099\u306D
\u3064\u306E\u308B
\u3064\u3075\u3099\u3059
\u3064\u307E\u3089\u306A\u3044
\u3064\u307E\u308B
\u3064\u307F\u304D
\u3064\u3081\u305F\u3044
\u3064\u3082\u308A
\u3064\u3082\u308B
\u3064\u3088\u3044
\u3064\u308B\u307B\u3099
\u3064\u308B\u307F\u304F
\u3064\u308F\u3082\u306E
\u3064\u308F\u308A
\u3066\u3042\u3057
\u3066\u3042\u3066
\u3066\u3042\u307F
\u3066\u3044\u304A\u3093
\u3066\u3044\u304B
\u3066\u3044\u304D
\u3066\u3044\u3051\u3044
\u3066\u3044\u3053\u304F
\u3066\u3044\u3055\u3064
\u3066\u3044\u3057
\u3066\u3044\u305B\u3044
\u3066\u3044\u305F\u3044
\u3066\u3044\u3068\u3099
\u3066\u3044\u306D\u3044
\u3066\u3044\u3072\u3087\u3046
\u3066\u3044\u3078\u3093
\u3066\u3044\u307B\u3099\u3046
\u3066\u3046\u3061
\u3066\u304A\u304F\u308C
\u3066\u304D\u3068\u3046
\u3066\u304F\u3072\u3099
\u3066\u3099\u3053\u307B\u3099\u3053
\u3066\u3055\u304D\u3099\u3087\u3046
\u3066\u3055\u3051\u3099
\u3066\u3059\u308A
\u3066\u305D\u3046
\u3066\u3061\u304B\u3099\u3044
\u3066\u3061\u3087\u3046
\u3066\u3064\u304B\u3099\u304F
\u3066\u3064\u3064\u3099\u304D
\u3066\u3099\u3063\u306F\u309A
\u3066\u3064\u307B\u3099\u3046
\u3066\u3064\u3084
\u3066\u3099\u306C\u304B\u3048
\u3066\u306C\u304D
\u3066\u306C\u304F\u3099\u3044
\u3066\u306E\u3072\u3089
\u3066\u306F\u3044
\u3066\u3075\u3099\u304F\u308D
\u3066\u3075\u305F\u3099
\u3066\u307B\u3068\u3099\u304D
\u3066\u307B\u3093
\u3066\u307E\u3048
\u3066\u307E\u304D\u3059\u3099\u3057
\u3066\u307F\u3057\u3099\u304B
\u3066\u307F\u3084\u3051\u3099
\u3066\u3089\u3059
\u3066\u308C\u3072\u3099
\u3066\u308F\u3051
\u3066\u308F\u305F\u3057
\u3066\u3099\u3093\u3042\u3064
\u3066\u3093\u3044\u3093
\u3066\u3093\u304B\u3044
\u3066\u3093\u304D
\u3066\u3093\u304F\u3099
\u3066\u3093\u3051\u3093
\u3066\u3093\u3053\u3099\u304F
\u3066\u3093\u3055\u3044
\u3066\u3093\u3057
\u3066\u3093\u3059\u3046
\u3066\u3099\u3093\u3061
\u3066\u3093\u3066\u304D
\u3066\u3093\u3068\u3046
\u3066\u3093\u306A\u3044
\u3066\u3093\u3075\u309A\u3089
\u3066\u3093\u307B\u3099\u3046\u305F\u3099\u3044
\u3066\u3093\u3081\u3064
\u3066\u3093\u3089\u3093\u304B\u3044
\u3066\u3099\u3093\u308A\u3087\u304F
\u3066\u3099\u3093\u308F
\u3068\u3099\u3042\u3044
\u3068\u3044\u308C
\u3068\u3099\u3046\u304B\u3093
\u3068\u3046\u304D\u3085\u3046
\u3068\u3099\u3046\u304F\u3099
\u3068\u3046\u3057
\u3068\u3046\u3080\u304D\u3099
\u3068\u304A\u3044
\u3068\u304A\u304B
\u3068\u304A\u304F
\u3068\u304A\u3059
\u3068\u304A\u308B
\u3068\u304B\u3044
\u3068\u304B\u3059
\u3068\u304D\u304A\u308A
\u3068\u304D\u3068\u3099\u304D
\u3068\u304F\u3044
\u3068\u304F\u3057\u3085\u3046
\u3068\u304F\u3066\u3093
\u3068\u304F\u306B
\u3068\u304F\u3078\u3099\u3064
\u3068\u3051\u3044
\u3068\u3051\u308B
\u3068\u3053\u3084
\u3068\u3055\u304B
\u3068\u3057\u3087\u304B\u3093
\u3068\u305D\u3046
\u3068\u305F\u3093
\u3068\u3061\u3085\u3046
\u3068\u3063\u304D\u3085\u3046
\u3068\u3063\u304F\u3093
\u3068\u3064\u305B\u3099\u3093
\u3068\u3064\u306B\u3085\u3046
\u3068\u3068\u3099\u3051\u308B
\u3068\u3068\u306E\u3048\u308B
\u3068\u306A\u3044
\u3068\u306A\u3048\u308B
\u3068\u306A\u308A
\u3068\u306E\u3055\u307E
\u3068\u306F\u3099\u3059
\u3068\u3099\u3075\u3099\u304B\u3099\u308F
\u3068\u307B\u3046
\u3068\u307E\u308B
\u3068\u3081\u308B
\u3068\u3082\u305F\u3099\u3061
\u3068\u3082\u308B
\u3068\u3099\u3088\u3046\u3072\u3099
\u3068\u3089\u3048\u308B
\u3068\u3093\u304B\u3064
\u3068\u3099\u3093\u3075\u3099\u308A
\u306A\u3044\u304B\u304F
\u306A\u3044\u3053\u3046
\u306A\u3044\u3057\u3087
\u306A\u3044\u3059
\u306A\u3044\u305B\u3093
\u306A\u3044\u305D\u3046
\u306A\u304A\u3059
\u306A\u304B\u3099\u3044
\u306A\u304F\u3059
\u306A\u3051\u3099\u308B
\u306A\u3053\u3046\u3068\u3099
\u306A\u3055\u3051
\u306A\u305F\u3066\u3099\u3053\u3053
\u306A\u3063\u3068\u3046
\u306A\u3064\u3084\u3059\u307F
\u306A\u306A\u304A\u3057
\u306A\u306B\u3053\u3099\u3068
\u306A\u306B\u3082\u306E
\u306A\u306B\u308F
\u306A\u306E\u304B
\u306A\u3075\u305F\u3099
\u306A\u307E\u3044\u304D
\u306A\u307E\u3048
\u306A\u307E\u307F
\u306A\u307F\u305F\u3099
\u306A\u3081\u3089\u304B
\u306A\u3081\u308B
\u306A\u3084\u3080
\u306A\u3089\u3046
\u306A\u3089\u3072\u3099
\u306A\u3089\u3075\u3099
\u306A\u308C\u308B
\u306A\u308F\u3068\u3072\u3099
\u306A\u308F\u306F\u3099\u308A
\u306B\u3042\u3046
\u306B\u3044\u304B\u3099\u305F
\u306B\u3046\u3051
\u306B\u304A\u3044
\u306B\u304B\u3044
\u306B\u304B\u3099\u3066
\u306B\u304D\u3072\u3099
\u306B\u304F\u3057\u307F
\u306B\u304F\u307E\u3093
\u306B\u3051\u3099\u308B
\u306B\u3055\u3093\u304B\u305F\u3093\u305D
\u306B\u3057\u304D
\u306B\u305B\u3082\u306E
\u306B\u3061\u3057\u3099\u3087\u3046
\u306B\u3061\u3088\u3046\u3072\u3099
\u306B\u3063\u304B
\u306B\u3063\u304D
\u306B\u3063\u3051\u3044
\u306B\u3063\u3053\u3046
\u306B\u3063\u3055\u3093
\u306B\u3063\u3057\u3087\u304F
\u306B\u3063\u3059\u3046
\u306B\u3063\u305B\u304D
\u306B\u3063\u3066\u3044
\u306B\u306A\u3046
\u306B\u307B\u3093
\u306B\u307E\u3081
\u306B\u3082\u3064
\u306B\u3084\u308A
\u306B\u3085\u3046\u3044\u3093
\u306B\u308A\u3093\u3057\u3083
\u306B\u308F\u3068\u308A
\u306B\u3093\u3044
\u306B\u3093\u304B
\u306B\u3093\u304D
\u306B\u3093\u3051\u3099\u3093
\u306B\u3093\u3057\u304D
\u306B\u3093\u3059\u3099\u3046
\u306B\u3093\u305D\u3046
\u306B\u3093\u305F\u3044
\u306B\u3093\u3061
\u306B\u3093\u3066\u3044
\u306B\u3093\u306B\u304F
\u306B\u3093\u3075\u309A
\u306B\u3093\u307E\u308A
\u306B\u3093\u3080
\u306B\u3093\u3081\u3044
\u306B\u3093\u3088\u3046
\u306C\u3044\u304F\u304D\u3099
\u306C\u304B\u3059
\u306C\u304F\u3099\u3044\u3068\u308B
\u306C\u304F\u3099\u3046
\u306C\u304F\u3082\u308A
\u306C\u3059\u3080
\u306C\u307E\u3048\u3072\u3099
\u306C\u3081\u308A
\u306C\u3089\u3059
\u306C\u3093\u3061\u3083\u304F
\u306D\u3042\u3051\u3099
\u306D\u3044\u304D
\u306D\u3044\u308B
\u306D\u3044\u308D
\u306D\u304F\u3099\u305B
\u306D\u304F\u305F\u3044
\u306D\u304F\u3089
\u306D\u3053\u305B\u3099
\u306D\u3053\u3080
\u306D\u3055\u3051\u3099
\u306D\u3059\u3053\u3099\u3059
\u306D\u305D\u3078\u3099\u308B
\u306D\u305F\u3099\u3093
\u306D\u3064\u3044
\u306D\u3063\u3057\u3093
\u306D\u3064\u305D\u3099\u3046
\u306D\u3063\u305F\u3044\u304D\u3099\u3087
\u306D\u3075\u3099\u305D\u304F
\u306D\u3075\u305F\u3099
\u306D\u307B\u3099\u3046
\u306D\u307B\u308A\u306F\u307B\u308A
\u306D\u307E\u304D
\u306D\u307E\u308F\u3057
\u306D\u307F\u307F
\u306D\u3080\u3044
\u306D\u3080\u305F\u3044
\u306D\u3082\u3068
\u306D\u3089\u3046
\u306D\u308F\u3055\u3099
\u306D\u3093\u3044\u308A
\u306D\u3093\u304A\u3057
\u306D\u3093\u304B\u3093
\u306D\u3093\u304D\u3093
\u306D\u3093\u304F\u3099
\u306D\u3093\u3055\u3099
\u306D\u3093\u3057
\u306D\u3093\u3061\u3083\u304F
\u306D\u3093\u3068\u3099
\u306D\u3093\u3072\u309A
\u306D\u3093\u3075\u3099\u3064
\u306D\u3093\u307E\u3064
\u306D\u3093\u308A\u3087\u3046
\u306D\u3093\u308C\u3044
\u306E\u3044\u3059\u3099
\u306E\u304A\u3064\u3099\u307E
\u306E\u304B\u3099\u3059
\u306E\u304D\u306A\u307F
\u306E\u3053\u304D\u3099\u308A
\u306E\u3053\u3059
\u306E\u3053\u308B
\u306E\u305B\u308B
\u306E\u305D\u3099\u304F
\u306E\u305D\u3099\u3080
\u306E\u305F\u307E\u3046
\u306E\u3061\u307B\u3068\u3099
\u306E\u3063\u304F
\u306E\u306F\u3099\u3059
\u306E\u306F\u3089
\u306E\u3078\u3099\u308B
\u306E\u307B\u3099\u308B
\u306E\u307F\u3082\u306E
\u306E\u3084\u307E
\u306E\u3089\u3044\u306C
\u306E\u3089\u306D\u3053
\u306E\u308A\u3082\u306E
\u306E\u308A\u3086\u304D
\u306E\u308C\u3093
\u306E\u3093\u304D
\u306F\u3099\u3042\u3044
\u306F\u3042\u304F
\u306F\u3099\u3042\u3055\u3093
\u306F\u3099\u3044\u304B
\u306F\u3099\u3044\u304F
\u306F\u3044\u3051\u3093
\u306F\u3044\u3053\u3099
\u306F\u3044\u3057\u3093
\u306F\u3044\u3059\u3044
\u306F\u3044\u305B\u3093
\u306F\u3044\u305D\u3046
\u306F\u3044\u3061
\u306F\u3099\u3044\u306F\u3099\u3044
\u306F\u3044\u308C\u3064
\u306F\u3048\u308B
\u306F\u304A\u308B
\u306F\u304B\u3044
\u306F\u3099\u304B\u308A
\u306F\u304B\u308B
\u306F\u304F\u3057\u3085
\u306F\u3051\u3093
\u306F\u3053\u3075\u3099
\u306F\u3055\u307F
\u306F\u3055\u3093
\u306F\u3057\u3053\u3099
\u306F\u3099\u3057\u3087
\u306F\u3057\u308B
\u306F\u305B\u308B
\u306F\u309A\u305D\u3053\u3093
\u306F\u305D\u3093
\u306F\u305F\u3093
\u306F\u3061\u307F\u3064
\u306F\u3064\u304A\u3093
\u306F\u3063\u304B\u304F
\u306F\u3064\u3099\u304D
\u306F\u3063\u304D\u308A
\u306F\u3063\u304F\u3064
\u306F\u3063\u3051\u3093
\u306F\u3063\u3053\u3046
\u306F\u3063\u3055\u3093
\u306F\u3063\u3057\u3093
\u306F\u3063\u305F\u3064
\u306F\u3063\u3061\u3085\u3046
\u306F\u3063\u3066\u3093
\u306F\u3063\u3072\u309A\u3087\u3046
\u306F\u3063\u307B\u309A\u3046
\u306F\u306A\u3059
\u306F\u306A\u3072\u3099
\u306F\u306B\u304B\u3080
\u306F\u3075\u3099\u3089\u3057
\u306F\u307F\u304B\u3099\u304D
\u306F\u3080\u304B\u3046
\u306F\u3081\u3064
\u306F\u3084\u3044
\u306F\u3084\u3057
\u306F\u3089\u3046
\u306F\u308D\u3046\u3043\u3093
\u306F\u308F\u3044
\u306F\u3093\u3044
\u306F\u3093\u3048\u3044
\u306F\u3093\u304A\u3093
\u306F\u3093\u304B\u304F
\u306F\u3093\u304D\u3087\u3046
\u306F\u3099\u3093\u304F\u3099\u307F
\u306F\u3093\u3053
\u306F\u3093\u3057\u3083
\u306F\u3093\u3059\u3046
\u306F\u3093\u305F\u3099\u3093
\u306F\u309A\u3093\u3061
\u306F\u309A\u3093\u3064
\u306F\u3093\u3066\u3044
\u306F\u3093\u3068\u3057
\u306F\u3093\u306E\u3046
\u306F\u3093\u306F\u309A
\u306F\u3093\u3075\u3099\u3093
\u306F\u3093\u3078\u309A\u3093
\u306F\u3093\u307B\u3099\u3046\u304D
\u306F\u3093\u3081\u3044
\u306F\u3093\u3089\u3093
\u306F\u3093\u308D\u3093
\u3072\u3044\u304D
\u3072\u3046\u3093
\u3072\u3048\u308B
\u3072\u304B\u304F
\u3072\u304B\u308A
\u3072\u304B\u308B
\u3072\u304B\u3093
\u3072\u304F\u3044
\u3072\u3051\u3064
\u3072\u3053\u3046\u304D
\u3072\u3053\u304F
\u3072\u3055\u3044
\u3072\u3055\u3057\u3075\u3099\u308A
\u3072\u3055\u3093
\u3072\u3099\u3057\u3099\u3085\u3064\u304B\u3093
\u3072\u3057\u3087
\u3072\u305D\u304B
\u3072\u305D\u3080
\u3072\u305F\u3080\u304D
\u3072\u305F\u3099\u308A
\u3072\u305F\u308B
\u3072\u3064\u304D\u3099
\u3072\u3063\u3053\u3057
\u3072\u3063\u3057
\u3072\u3064\u3057\u3099\u3085\u3072\u3093
\u3072\u3063\u3059
\u3072\u3064\u305B\u3099\u3093
\u3072\u309A\u3063\u305F\u308A
\u3072\u309A\u3063\u3061\u308A
\u3072\u3064\u3088\u3046
\u3072\u3066\u3044
\u3072\u3068\u3053\u3099\u307F
\u3072\u306A\u307E\u3064\u308A
\u3072\u306A\u3093
\u3072\u306D\u308B
\u3072\u306F\u3093
\u3072\u3072\u3099\u304F
\u3072\u3072\u3087\u3046
\u3072\u307B\u3046
\u3072\u307E\u308F\u308A
\u3072\u307E\u3093
\u3072\u307F\u3064
\u3072\u3081\u3044
\u3072\u3081\u3057\u3099\u3057
\u3072\u3084\u3051
\u3072\u3084\u3059
\u3072\u3088\u3046
\u3072\u3099\u3087\u3046\u304D
\u3072\u3089\u304B\u3099\u306A
\u3072\u3089\u304F
\u3072\u308A\u3064
\u3072\u308A\u3087\u3046
\u3072\u308B\u307E
\u3072\u308B\u3084\u3059\u307F
\u3072\u308C\u3044
\u3072\u308D\u3044
\u3072\u308D\u3046
\u3072\u308D\u304D
\u3072\u308D\u3086\u304D
\u3072\u3093\u304B\u304F
\u3072\u3093\u3051\u3064
\u3072\u3093\u3053\u3093
\u3072\u3093\u3057\u3085
\u3072\u3093\u305D\u3046
\u3072\u309A\u3093\u3061
\u3072\u3093\u306F\u309A\u3093
\u3072\u3099\u3093\u307B\u3099\u3046
\u3075\u3042\u3093
\u3075\u3044\u3046\u3061
\u3075\u3046\u3051\u3044
\u3075\u3046\u305B\u3093
\u3075\u309A\u3046\u305F\u308D\u3046
\u3075\u3046\u3068\u3046
\u3075\u3046\u3075
\u3075\u3048\u308B
\u3075\u304A\u3093
\u3075\u304B\u3044
\u3075\u304D\u3093
\u3075\u304F\u3055\u3099\u3064
\u3075\u304F\u3075\u3099\u304F\u308D
\u3075\u3053\u3046
\u3075\u3055\u3044
\u3075\u3057\u304D\u3099
\u3075\u3057\u3099\u307F
\u3075\u3059\u307E
\u3075\u305B\u3044
\u3075\u305B\u304F\u3099
\u3075\u305D\u304F
\u3075\u3099\u305F\u306B\u304F
\u3075\u305F\u3093
\u3075\u3061\u3087\u3046
\u3075\u3064\u3046
\u3075\u3064\u304B
\u3075\u3063\u304B\u3064
\u3075\u3063\u304D
\u3075\u3063\u3053\u304F
\u3075\u3099\u3068\u3099\u3046
\u3075\u3068\u308B
\u3075\u3068\u3093
\u3075\u306E\u3046
\u3075\u306F\u3044
\u3075\u3072\u3087\u3046
\u3075\u3078\u3093
\u3075\u307E\u3093
\u3075\u307F\u3093
\u3075\u3081\u3064
\u3075\u3081\u3093
\u3075\u3088\u3046
\u3075\u308A\u3053
\u3075\u308A\u308B
\u3075\u308B\u3044
\u3075\u3093\u3044\u304D
\u3075\u3099\u3093\u304B\u3099\u304F
\u3075\u3099\u3093\u304F\u3099
\u3075\u3093\u3057\u3064
\u3075\u3099\u3093\u305B\u304D
\u3075\u3093\u305D\u3046
\u3075\u3099\u3093\u307B\u309A\u3046
\u3078\u3044\u3042\u3093
\u3078\u3044\u304A\u3093
\u3078\u3044\u304B\u3099\u3044
\u3078\u3044\u304D
\u3078\u3044\u3051\u3099\u3093
\u3078\u3044\u3053\u3046
\u3078\u3044\u3055
\u3078\u3044\u3057\u3083
\u3078\u3044\u305B\u3064
\u3078\u3044\u305D
\u3078\u3044\u305F\u304F
\u3078\u3044\u3066\u3093
\u3078\u3044\u306D\u3064
\u3078\u3044\u308F
\u3078\u304D\u304B\u3099
\u3078\u3053\u3080
\u3078\u3099\u306B\u3044\u308D
\u3078\u3099\u306B\u3057\u3087\u3046\u304B\u3099
\u3078\u3089\u3059
\u3078\u3093\u304B\u3093
\u3078\u3099\u3093\u304D\u3087\u3046
\u3078\u3099\u3093\u3053\u3099\u3057
\u3078\u3093\u3055\u3044
\u3078\u3093\u305F\u3044
\u3078\u3099\u3093\u308A
\u307B\u3042\u3093
\u307B\u3044\u304F
\u307B\u3099\u3046\u304D\u3099\u3087
\u307B\u3046\u3053\u304F
\u307B\u3046\u305D\u3046
\u307B\u3046\u307B\u3046
\u307B\u3046\u3082\u3093
\u307B\u3046\u308A\u3064
\u307B\u3048\u308B
\u307B\u304A\u3093
\u307B\u304B\u3093
\u307B\u304D\u3087\u3046
\u307B\u3099\u304D\u3093
\u307B\u304F\u308D
\u307B\u3051\u3064
\u307B\u3051\u3093
\u307B\u3053\u3046
\u307B\u3053\u308B
\u307B\u3057\u3044
\u307B\u3057\u3064
\u307B\u3057\u3085
\u307B\u3057\u3087\u3046
\u307B\u305B\u3044
\u307B\u305D\u3044
\u307B\u305D\u304F
\u307B\u305F\u3066
\u307B\u305F\u308B
\u307B\u309A\u3061\u3075\u3099\u304F\u308D
\u307B\u3063\u304D\u3087\u304F
\u307B\u3063\u3055
\u307B\u3063\u305F\u3093
\u307B\u3068\u3093\u3068\u3099
\u307B\u3081\u308B
\u307B\u3093\u3044
\u307B\u3093\u304D
\u307B\u3093\u3051
\u307B\u3093\u3057\u3064
\u307B\u3093\u3084\u304F
\u307E\u3044\u306B\u3061
\u307E\u304B\u3044
\u307E\u304B\u305B\u308B
\u307E\u304B\u3099\u308B
\u307E\u3051\u308B
\u307E\u3053\u3068
\u307E\u3055\u3064
\u307E\u3057\u3099\u3081
\u307E\u3059\u304F
\u307E\u305B\u3099\u308B
\u307E\u3064\u308A
\u307E\u3068\u3081
\u307E\u306A\u3075\u3099
\u307E\u306C\u3051
\u307E\u306D\u304F
\u307E\u307B\u3046
\u307E\u3082\u308B
\u307E\u3086\u3051\u3099
\u307E\u3088\u3046
\u307E\u308D\u3084\u304B
\u307E\u308F\u3059
\u307E\u308F\u308A
\u307E\u308F\u308B
\u307E\u3093\u304B\u3099
\u307E\u3093\u304D\u3064
\u307E\u3093\u305D\u3099\u304F
\u307E\u3093\u306A\u304B
\u307F\u3044\u3089
\u307F\u3046\u3061
\u307F\u3048\u308B
\u307F\u304B\u3099\u304F
\u307F\u304B\u305F
\u307F\u304B\u3093
\u307F\u3051\u3093
\u307F\u3053\u3093
\u307F\u3057\u3099\u304B\u3044
\u307F\u3059\u3044
\u307F\u3059\u3048\u308B
\u307F\u305B\u308B
\u307F\u3063\u304B
\u307F\u3064\u304B\u308B
\u307F\u3064\u3051\u308B
\u307F\u3066\u3044
\u307F\u3068\u3081\u308B
\u307F\u306A\u3068
\u307F\u306A\u307F\u304B\u3055\u3044
\u307F\u306D\u3089\u308B
\u307F\u306E\u3046
\u307F\u306E\u304B\u3099\u3059
\u307F\u307B\u3093
\u307F\u3082\u3068
\u307F\u3084\u3051\u3099
\u307F\u3089\u3044
\u307F\u308A\u3087\u304F
\u307F\u308F\u304F
\u307F\u3093\u304B
\u307F\u3093\u305D\u3099\u304F
\u3080\u3044\u304B
\u3080\u3048\u304D
\u3080\u3048\u3093
\u3080\u304B\u3044
\u3080\u304B\u3046
\u3080\u304B\u3048
\u3080\u304B\u3057
\u3080\u304D\u3099\u3061\u3083
\u3080\u3051\u308B
\u3080\u3051\u3099\u3093
\u3080\u3055\u307B\u3099\u308B
\u3080\u3057\u3042\u3064\u3044
\u3080\u3057\u306F\u3099
\u3080\u3057\u3099\u3085\u3093
\u3080\u3057\u308D
\u3080\u3059\u3046
\u3080\u3059\u3053
\u3080\u3059\u3075\u3099
\u3080\u3059\u3081
\u3080\u305B\u308B
\u3080\u305B\u3093
\u3080\u3061\u3085\u3046
\u3080\u306A\u3057\u3044
\u3080\u306E\u3046
\u3080\u3084\u307F
\u3080\u3088\u3046
\u3080\u3089\u3055\u304D
\u3080\u308A\u3087\u3046
\u3080\u308D\u3093
\u3081\u3044\u3042\u3093
\u3081\u3044\u3046\u3093
\u3081\u3044\u3048\u3093
\u3081\u3044\u304B\u304F
\u3081\u3044\u304D\u3087\u304F
\u3081\u3044\u3055\u3044
\u3081\u3044\u3057
\u3081\u3044\u305D\u3046
\u3081\u3044\u3075\u3099\u3064
\u3081\u3044\u308C\u3044
\u3081\u3044\u308F\u304F
\u3081\u304F\u3099\u307E\u308C\u308B
\u3081\u3055\u3099\u3059
\u3081\u3057\u305F
\u3081\u3059\u3099\u3089\u3057\u3044
\u3081\u305F\u3099\u3064
\u3081\u307E\u3044
\u3081\u3084\u3059
\u3081\u3093\u304D\u3087
\u3081\u3093\u305B\u304D
\u3081\u3093\u3068\u3099\u3046
\u3082\u3046\u3057\u3042\u3051\u3099\u308B
\u3082\u3046\u3068\u3099\u3046\u3051\u3093
\u3082\u3048\u308B
\u3082\u304F\u3057
\u3082\u304F\u3066\u304D
\u3082\u304F\u3088\u3046\u3072\u3099
\u3082\u3061\u308D\u3093
\u3082\u3068\u3099\u308B
\u3082\u3089\u3046
\u3082\u3093\u304F
\u3082\u3093\u305F\u3099\u3044
\u3084\u304A\u3084
\u3084\u3051\u308B
\u3084\u3055\u3044
\u3084\u3055\u3057\u3044
\u3084\u3059\u3044
\u3084\u3059\u305F\u308D\u3046
\u3084\u3059\u307F
\u3084\u305B\u308B
\u3084\u305D\u3046
\u3084\u305F\u3044
\u3084\u3061\u3093
\u3084\u3063\u3068
\u3084\u3063\u306F\u309A\u308A
\u3084\u3075\u3099\u308B
\u3084\u3081\u308B
\u3084\u3084\u3053\u3057\u3044
\u3084\u3088\u3044
\u3084\u308F\u3089\u304B\u3044
\u3086\u3046\u304D
\u3086\u3046\u3072\u3099\u3093\u304D\u3087\u304F
\u3086\u3046\u3078\u3099
\u3086\u3046\u3081\u3044
\u3086\u3051\u3064
\u3086\u3057\u3085\u3064
\u3086\u305B\u3093
\u3086\u305D\u3046
\u3086\u305F\u304B
\u3086\u3061\u3083\u304F
\u3086\u3066\u3099\u308B
\u3086\u306B\u3085\u3046
\u3086\u3072\u3099\u308F
\u3086\u3089\u3044
\u3086\u308C\u308B
\u3088\u3046\u3044
\u3088\u3046\u304B
\u3088\u3046\u304D\u3085\u3046
\u3088\u3046\u3057\u3099
\u3088\u3046\u3059
\u3088\u3046\u3061\u3048\u3093
\u3088\u304B\u305B\u3099
\u3088\u304B\u3093
\u3088\u304D\u3093
\u3088\u304F\u305B\u3044
\u3088\u304F\u307B\u3099\u3046
\u3088\u3051\u3044
\u3088\u3053\u3099\u308C\u308B
\u3088\u3055\u3093
\u3088\u3057\u3085\u3046
\u3088\u305D\u3046
\u3088\u305D\u304F
\u3088\u3063\u304B
\u3088\u3066\u3044
\u3088\u3068\u3099\u304B\u3099\u308F\u304F
\u3088\u306D\u3064
\u3088\u3084\u304F
\u3088\u3086\u3046
\u3088\u308D\u3053\u3075\u3099
\u3088\u308D\u3057\u3044
\u3089\u3044\u3046
\u3089\u304F\u304B\u3099\u304D
\u3089\u304F\u3053\u3099
\u3089\u304F\u3055\u3064
\u3089\u304F\u305F\u3099
\u3089\u3057\u3093\u306F\u3099\u3093
\u3089\u305B\u3093
\u3089\u305D\u3099\u304F
\u3089\u305F\u3044
\u3089\u3063\u304B
\u3089\u308C\u3064
\u308A\u3048\u304D
\u308A\u304B\u3044
\u308A\u304D\u3055\u304F
\u308A\u304D\u305B\u3064
\u308A\u304F\u304F\u3099\u3093
\u308A\u304F\u3064
\u308A\u3051\u3093
\u308A\u3053\u3046
\u308A\u305B\u3044
\u308A\u305D\u3046
\u308A\u305D\u304F
\u308A\u3066\u3093
\u308A\u306D\u3093
\u308A\u3086\u3046
\u308A\u3085\u3046\u304B\u3099\u304F
\u308A\u3088\u3046
\u308A\u3087\u3046\u308A
\u308A\u3087\u304B\u3093
\u308A\u3087\u304F\u3061\u3083
\u308A\u3087\u3053\u3046
\u308A\u308A\u304F
\u308A\u308C\u304D
\u308A\u308D\u3093
\u308A\u3093\u3053\u3099
\u308B\u3044\u3051\u3044
\u308B\u3044\u3055\u3044
\u308B\u3044\u3057\u3099
\u308B\u3044\u305B\u304D
\u308B\u3059\u306F\u3099\u3093
\u308B\u308A\u304B\u3099\u308F\u3089
\u308C\u3044\u304B\u3093
\u308C\u3044\u304D\u3099
\u308C\u3044\u305B\u3044
\u308C\u3044\u305D\u3099\u3046\u3053
\u308C\u3044\u3068\u3046
\u308C\u3044\u307B\u3099\u3046
\u308C\u304D\u3057
\u308C\u304D\u305F\u3099\u3044
\u308C\u3093\u3042\u3044
\u308C\u3093\u3051\u3044
\u308C\u3093\u3053\u3093
\u308C\u3093\u3055\u3044
\u308C\u3093\u3057\u3085\u3046
\u308C\u3093\u305D\u3099\u304F
\u308C\u3093\u3089\u304F
\u308D\u3046\u304B
\u308D\u3046\u3053\u3099
\u308D\u3046\u3057\u3099\u3093
\u308D\u3046\u305D\u304F
\u308D\u304F\u304B\u3099
\u308D\u3053\u3064
\u308D\u3057\u3099\u3046\u3089
\u308D\u3057\u3085\u3064
\u308D\u305B\u3093
\u308D\u3066\u3093
\u308D\u3081\u3093
\u308D\u308C\u3064
\u308D\u3093\u304D\u3099
\u308D\u3093\u306F\u309A
\u308D\u3093\u3075\u3099\u3093
\u308D\u3093\u308A
\u308F\u304B\u3059
\u308F\u304B\u3081
\u308F\u304B\u3084\u307E
\u308F\u304B\u308C\u308B
\u308F\u3057\u3064
\u308F\u3057\u3099\u307E\u3057
\u308F\u3059\u308C\u3082\u306E
\u308F\u3089\u3046
\u308F\u308C\u308B`.split("\n");
    }
  });

  // node_modules/@scure/bip39/wordlists/korean.js
  var require_korean = __commonJS({
    "node_modules/@scure/bip39/wordlists/korean.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `\u1100\u1161\u1100\u1167\u11A8
\u1100\u1161\u1101\u1173\u11B7
\u1100\u1161\u1102\u1161\u11AB
\u1100\u1161\u1102\u1173\u11BC
\u1100\u1161\u1103\u1173\u11A8
\u1100\u1161\u1105\u1173\u110E\u1175\u11B7
\u1100\u1161\u1106\u116E\u11B7
\u1100\u1161\u1107\u1161\u11BC
\u1100\u1161\u1109\u1161\u11BC
\u1100\u1161\u1109\u1173\u11B7
\u1100\u1161\u110B\u116E\u11AB\u1103\u1166
\u1100\u1161\u110B\u1173\u11AF
\u1100\u1161\u110B\u1175\u1103\u1173
\u1100\u1161\u110B\u1175\u11B8
\u1100\u1161\u110C\u1161\u11BC
\u1100\u1161\u110C\u1165\u11BC
\u1100\u1161\u110C\u1169\u11A8
\u1100\u1161\u110C\u116E\u11A8
\u1100\u1161\u11A8\u110B\u1169
\u1100\u1161\u11A8\u110C\u1161
\u1100\u1161\u11AB\u1100\u1167\u11A8
\u1100\u1161\u11AB\u1107\u116E
\u1100\u1161\u11AB\u1109\u1165\u11B8
\u1100\u1161\u11AB\u110C\u1161\u11BC
\u1100\u1161\u11AB\u110C\u1165\u11B8
\u1100\u1161\u11AB\u1111\u1161\u11AB
\u1100\u1161\u11AF\u1103\u1173\u11BC
\u1100\u1161\u11AF\u1107\u1175
\u1100\u1161\u11AF\u1109\u1162\u11A8
\u1100\u1161\u11AF\u110C\u1173\u11BC
\u1100\u1161\u11B7\u1100\u1161\u11A8
\u1100\u1161\u11B7\u1100\u1175
\u1100\u1161\u11B7\u1109\u1169
\u1100\u1161\u11B7\u1109\u116E\u1109\u1165\u11BC
\u1100\u1161\u11B7\u110C\u1161
\u1100\u1161\u11B7\u110C\u1165\u11BC
\u1100\u1161\u11B8\u110C\u1161\u1100\u1175
\u1100\u1161\u11BC\u1102\u1161\u11B7
\u1100\u1161\u11BC\u1103\u1161\u11BC
\u1100\u1161\u11BC\u1103\u1169
\u1100\u1161\u11BC\u1105\u1167\u11A8\u1112\u1175
\u1100\u1161\u11BC\u1107\u1167\u11AB
\u1100\u1161\u11BC\u1107\u116E\u11A8
\u1100\u1161\u11BC\u1109\u1161
\u1100\u1161\u11BC\u1109\u116E\u1105\u1163\u11BC
\u1100\u1161\u11BC\u110B\u1161\u110C\u1175
\u1100\u1161\u11BC\u110B\u116F\u11AB\u1103\u1169
\u1100\u1161\u11BC\u110B\u1174
\u1100\u1161\u11BC\u110C\u1166
\u1100\u1161\u11BC\u110C\u1169
\u1100\u1161\u11C0\u110B\u1175
\u1100\u1162\u1100\u116E\u1105\u1175
\u1100\u1162\u1102\u1161\u1105\u1175
\u1100\u1162\u1107\u1161\u11BC
\u1100\u1162\u1107\u1167\u11AF
\u1100\u1162\u1109\u1165\u11AB
\u1100\u1162\u1109\u1165\u11BC
\u1100\u1162\u110B\u1175\u11AB
\u1100\u1162\u11A8\u1100\u116A\u11AB\u110C\u1165\u11A8
\u1100\u1165\u1109\u1175\u11AF
\u1100\u1165\u110B\u1162\u11A8
\u1100\u1165\u110B\u116E\u11AF
\u1100\u1165\u110C\u1175\u11BA
\u1100\u1165\u1111\u116E\u11B7
\u1100\u1165\u11A8\u110C\u1165\u11BC
\u1100\u1165\u11AB\u1100\u1161\u11BC
\u1100\u1165\u11AB\u1106\u116E\u11AF
\u1100\u1165\u11AB\u1109\u1165\u11AF
\u1100\u1165\u11AB\u110C\u1169
\u1100\u1165\u11AB\u110E\u116E\u11A8
\u1100\u1165\u11AF\u110B\u1173\u11B7
\u1100\u1165\u11B7\u1109\u1161
\u1100\u1165\u11B7\u1110\u1169
\u1100\u1166\u1109\u1175\u1111\u1161\u11AB
\u1100\u1166\u110B\u1175\u11B7
\u1100\u1167\u110B\u116E\u11AF
\u1100\u1167\u11AB\u1112\u1162
\u1100\u1167\u11AF\u1100\u116A
\u1100\u1167\u11AF\u1100\u116E\u11A8
\u1100\u1167\u11AF\u1105\u1169\u11AB
\u1100\u1167\u11AF\u1109\u1165\u11A8
\u1100\u1167\u11AF\u1109\u1173\u11BC
\u1100\u1167\u11AF\u1109\u1175\u11B7
\u1100\u1167\u11AF\u110C\u1165\u11BC
\u1100\u1167\u11AF\u1112\u1169\u11AB
\u1100\u1167\u11BC\u1100\u1168
\u1100\u1167\u11BC\u1100\u1169
\u1100\u1167\u11BC\u1100\u1175
\u1100\u1167\u11BC\u1105\u1167\u11A8
\u1100\u1167\u11BC\u1107\u1169\u11A8\u1100\u116E\u11BC
\u1100\u1167\u11BC\u1107\u1175
\u1100\u1167\u11BC\u1109\u1161\u11BC\u1103\u1169
\u1100\u1167\u11BC\u110B\u1167\u11BC
\u1100\u1167\u11BC\u110B\u116E
\u1100\u1167\u11BC\u110C\u1162\u11BC
\u1100\u1167\u11BC\u110C\u1166
\u1100\u1167\u11BC\u110C\u116E
\u1100\u1167\u11BC\u110E\u1161\u11AF
\u1100\u1167\u11BC\u110E\u1175
\u1100\u1167\u11BC\u1112\u1163\u11BC
\u1100\u1167\u11BC\u1112\u1165\u11B7
\u1100\u1168\u1100\u1169\u11A8
\u1100\u1168\u1103\u1161\u11AB
\u1100\u1168\u1105\u1161\u11AB
\u1100\u1168\u1109\u1161\u11AB
\u1100\u1168\u1109\u1169\u11A8
\u1100\u1168\u110B\u1163\u11A8
\u1100\u1168\u110C\u1165\u11AF
\u1100\u1168\u110E\u1173\u11BC
\u1100\u1168\u1112\u116C\u11A8
\u1100\u1169\u1100\u1162\u11A8
\u1100\u1169\u1100\u116E\u1105\u1167
\u1100\u1169\u1100\u116E\u11BC
\u1100\u1169\u1100\u1173\u11B8
\u1100\u1169\u1103\u1173\u11BC\u1112\u1161\u11A8\u1109\u1162\u11BC
\u1100\u1169\u1106\u116E\u1109\u1175\u11AB
\u1100\u1169\u1106\u1175\u11AB
\u1100\u1169\u110B\u1163\u11BC\u110B\u1175
\u1100\u1169\u110C\u1161\u11BC
\u1100\u1169\u110C\u1165\u11AB
\u1100\u1169\u110C\u1175\u11B8
\u1100\u1169\u110E\u116E\u11BA\u1100\u1161\u1105\u116E
\u1100\u1169\u1110\u1169\u11BC
\u1100\u1169\u1112\u1163\u11BC
\u1100\u1169\u11A8\u1109\u1175\u11A8
\u1100\u1169\u11AF\u1106\u1169\u11A8
\u1100\u1169\u11AF\u110D\u1161\u1100\u1175
\u1100\u1169\u11AF\u1111\u1173
\u1100\u1169\u11BC\u1100\u1161\u11AB
\u1100\u1169\u11BC\u1100\u1162
\u1100\u1169\u11BC\u1100\u1167\u11A8
\u1100\u1169\u11BC\u1100\u116E\u11AB
\u1100\u1169\u11BC\u1100\u1173\u11B8
\u1100\u1169\u11BC\u1100\u1175
\u1100\u1169\u11BC\u1103\u1169\u11BC
\u1100\u1169\u11BC\u1106\u116E\u110B\u116F\u11AB
\u1100\u1169\u11BC\u1107\u116E
\u1100\u1169\u11BC\u1109\u1161
\u1100\u1169\u11BC\u1109\u1175\u11A8
\u1100\u1169\u11BC\u110B\u1165\u11B8
\u1100\u1169\u11BC\u110B\u1167\u11AB
\u1100\u1169\u11BC\u110B\u116F\u11AB
\u1100\u1169\u11BC\u110C\u1161\u11BC
\u1100\u1169\u11BC\u110D\u1161
\u1100\u1169\u11BC\u110E\u1162\u11A8
\u1100\u1169\u11BC\u1110\u1169\u11BC
\u1100\u1169\u11BC\u1111\u1169
\u1100\u1169\u11BC\u1112\u1161\u11BC
\u1100\u1169\u11BC\u1112\u1172\u110B\u1175\u11AF
\u1100\u116A\u1106\u1169\u11A8
\u1100\u116A\u110B\u1175\u11AF
\u1100\u116A\u110C\u1161\u11BC
\u1100\u116A\u110C\u1165\u11BC
\u1100\u116A\u1112\u1161\u11A8
\u1100\u116A\u11AB\u1100\u1162\u11A8
\u1100\u116A\u11AB\u1100\u1168
\u1100\u116A\u11AB\u1100\u116A\u11BC
\u1100\u116A\u11AB\u1102\u1167\u11B7
\u1100\u116A\u11AB\u1105\u1161\u11B7
\u1100\u116A\u11AB\u1105\u1167\u11AB
\u1100\u116A\u11AB\u1105\u1175
\u1100\u116A\u11AB\u1109\u1173\u11B8
\u1100\u116A\u11AB\u1109\u1175\u11B7
\u1100\u116A\u11AB\u110C\u1165\u11B7
\u1100\u116A\u11AB\u110E\u1161\u11AF
\u1100\u116A\u11BC\u1100\u1167\u11BC
\u1100\u116A\u11BC\u1100\u1169
\u1100\u116A\u11BC\u110C\u1161\u11BC
\u1100\u116A\u11BC\u110C\u116E
\u1100\u116C\u1105\u1169\u110B\u116E\u11B7
\u1100\u116C\u11BC\u110C\u1161\u11BC\u1112\u1175
\u1100\u116D\u1100\u116A\u1109\u1165
\u1100\u116D\u1106\u116E\u11AB
\u1100\u116D\u1107\u1169\u11A8
\u1100\u116D\u1109\u1175\u11AF
\u1100\u116D\u110B\u1163\u11BC
\u1100\u116D\u110B\u1172\u11A8
\u1100\u116D\u110C\u1161\u11BC
\u1100\u116D\u110C\u1175\u11A8
\u1100\u116D\u1110\u1169\u11BC
\u1100\u116D\u1112\u116A\u11AB
\u1100\u116D\u1112\u116E\u11AB
\u1100\u116E\u1100\u1167\u11BC
\u1100\u116E\u1105\u1173\u11B7
\u1100\u116E\u1106\u1165\u11BC
\u1100\u116E\u1107\u1167\u11AF
\u1100\u116E\u1107\u116E\u11AB
\u1100\u116E\u1109\u1165\u11A8
\u1100\u116E\u1109\u1165\u11BC
\u1100\u116E\u1109\u1169\u11A8
\u1100\u116E\u110B\u1167\u11A8
\u1100\u116E\u110B\u1175\u11B8
\u1100\u116E\u110E\u1165\u11BC
\u1100\u116E\u110E\u1166\u110C\u1165\u11A8
\u1100\u116E\u11A8\u1100\u1161
\u1100\u116E\u11A8\u1100\u1175
\u1100\u116E\u11A8\u1102\u1162
\u1100\u116E\u11A8\u1105\u1175\u11B8
\u1100\u116E\u11A8\u1106\u116E\u11AF
\u1100\u116E\u11A8\u1106\u1175\u11AB
\u1100\u116E\u11A8\u1109\u116E
\u1100\u116E\u11A8\u110B\u1165
\u1100\u116E\u11A8\u110B\u116A\u11BC
\u1100\u116E\u11A8\u110C\u1165\u11A8
\u1100\u116E\u11A8\u110C\u1166
\u1100\u116E\u11A8\u1112\u116C
\u1100\u116E\u11AB\u1103\u1162
\u1100\u116E\u11AB\u1109\u1161
\u1100\u116E\u11AB\u110B\u1175\u11AB
\u1100\u116E\u11BC\u1100\u1173\u11A8\u110C\u1165\u11A8
\u1100\u116F\u11AB\u1105\u1175
\u1100\u116F\u11AB\u110B\u1171
\u1100\u116F\u11AB\u1110\u116E
\u1100\u1171\u1100\u116E\u11A8
\u1100\u1171\u1109\u1175\u11AB
\u1100\u1172\u110C\u1165\u11BC
\u1100\u1172\u110E\u1175\u11A8
\u1100\u1172\u11AB\u1112\u1167\u11BC
\u1100\u1173\u1102\u1161\u11AF
\u1100\u1173\u1102\u1163\u11BC
\u1100\u1173\u1102\u1173\u11AF
\u1100\u1173\u1105\u1165\u1102\u1161
\u1100\u1173\u1105\u116E\u11B8
\u1100\u1173\u1105\u1173\u11BA
\u1100\u1173\u1105\u1175\u11B7
\u1100\u1173\u110C\u1166\u1109\u1165\u110B\u1163
\u1100\u1173\u1110\u1169\u1105\u1169\u11A8
\u1100\u1173\u11A8\u1107\u1169\u11A8
\u1100\u1173\u11A8\u1112\u1175
\u1100\u1173\u11AB\u1100\u1165
\u1100\u1173\u11AB\u1100\u116D
\u1100\u1173\u11AB\u1105\u1162
\u1100\u1173\u11AB\u1105\u1169
\u1100\u1173\u11AB\u1106\u116E
\u1100\u1173\u11AB\u1107\u1169\u11AB
\u1100\u1173\u11AB\u110B\u116F\u11AB
\u1100\u1173\u11AB\u110B\u1172\u11A8
\u1100\u1173\u11AB\u110E\u1165
\u1100\u1173\u11AF\u110A\u1175
\u1100\u1173\u11AF\u110C\u1161
\u1100\u1173\u11B7\u1100\u1161\u11BC\u1109\u1161\u11AB
\u1100\u1173\u11B7\u1100\u1169
\u1100\u1173\u11B7\u1102\u1167\u11AB
\u1100\u1173\u11B7\u1106\u1166\u1103\u1161\u11AF
\u1100\u1173\u11B7\u110B\u1162\u11A8
\u1100\u1173\u11B7\u110B\u1167\u11AB
\u1100\u1173\u11B7\u110B\u116D\u110B\u1175\u11AF
\u1100\u1173\u11B7\u110C\u1175
\u1100\u1173\u11BC\u110C\u1165\u11BC\u110C\u1165\u11A8
\u1100\u1175\u1100\u1161\u11AB
\u1100\u1175\u1100\u116A\u11AB
\u1100\u1175\u1102\u1167\u11B7
\u1100\u1175\u1102\u1173\u11BC
\u1100\u1175\u1103\u1169\u11A8\u1100\u116D
\u1100\u1175\u1103\u116E\u11BC
\u1100\u1175\u1105\u1169\u11A8
\u1100\u1175\u1105\u1173\u11B7
\u1100\u1175\u1107\u1165\u11B8
\u1100\u1175\u1107\u1169\u11AB
\u1100\u1175\u1107\u116E\u11AB
\u1100\u1175\u1108\u1173\u11B7
\u1100\u1175\u1109\u116E\u11A8\u1109\u1161
\u1100\u1175\u1109\u116E\u11AF
\u1100\u1175\u110B\u1165\u11A8
\u1100\u1175\u110B\u1165\u11B8
\u1100\u1175\u110B\u1169\u11AB
\u1100\u1175\u110B\u116E\u11AB
\u1100\u1175\u110B\u116F\u11AB
\u1100\u1175\u110C\u1165\u11A8
\u1100\u1175\u110C\u116E\u11AB
\u1100\u1175\u110E\u1175\u11B7
\u1100\u1175\u1112\u1169\u11AB
\u1100\u1175\u1112\u116C\u11A8
\u1100\u1175\u11AB\u1100\u1173\u11B8
\u1100\u1175\u11AB\u110C\u1161\u11BC
\u1100\u1175\u11AF\u110B\u1175
\u1100\u1175\u11B7\u1107\u1161\u11B8
\u1100\u1175\u11B7\u110E\u1175
\u1100\u1175\u11B7\u1111\u1169\u1100\u1169\u11BC\u1112\u1161\u11BC
\u1101\u1161\u11A8\u1103\u116E\u1100\u1175
\u1101\u1161\u11B7\u1108\u1161\u11A8
\u1101\u1162\u1103\u1161\u11AF\u110B\u1173\u11B7
\u1101\u1162\u1109\u1169\u1100\u1173\u11B7
\u1101\u1165\u11B8\u110C\u1175\u11AF
\u1101\u1169\u11A8\u1103\u1162\u1100\u1175
\u1101\u1169\u11BE\u110B\u1175\u11C1
\u1102\u1161\u1103\u1173\u11AF\u110B\u1175
\u1102\u1161\u1105\u1161\u11AB\u1112\u1175
\u1102\u1161\u1106\u1165\u110C\u1175
\u1102\u1161\u1106\u116E\u11AF
\u1102\u1161\u110E\u1175\u11B7\u1107\u1161\u11AB
\u1102\u1161\u1112\u1173\u11AF
\u1102\u1161\u11A8\u110B\u1167\u11B8
\u1102\u1161\u11AB\u1107\u1161\u11BC
\u1102\u1161\u11AF\u1100\u1162
\u1102\u1161\u11AF\u110A\u1175
\u1102\u1161\u11AF\u110D\u1161
\u1102\u1161\u11B7\u1102\u1167
\u1102\u1161\u11B7\u1103\u1162\u1106\u116E\u11AB
\u1102\u1161\u11B7\u1106\u1162
\u1102\u1161\u11B7\u1109\u1161\u11AB
\u1102\u1161\u11B7\u110C\u1161
\u1102\u1161\u11B7\u1111\u1167\u11AB
\u1102\u1161\u11B7\u1112\u1161\u11A8\u1109\u1162\u11BC
\u1102\u1161\u11BC\u1107\u1175
\u1102\u1161\u11C0\u1106\u1161\u11AF
\u1102\u1162\u1102\u1167\u11AB
\u1102\u1162\u110B\u116D\u11BC
\u1102\u1162\u110B\u1175\u11AF
\u1102\u1162\u11B7\u1107\u1175
\u1102\u1162\u11B7\u1109\u1162
\u1102\u1162\u11BA\u1106\u116E\u11AF
\u1102\u1162\u11BC\u1103\u1169\u11BC
\u1102\u1162\u11BC\u1106\u1167\u11AB
\u1102\u1162\u11BC\u1107\u1161\u11BC
\u1102\u1162\u11BC\u110C\u1161\u11BC\u1100\u1169
\u1102\u1166\u11A8\u1110\u1161\u110B\u1175
\u1102\u1166\u11BA\u110D\u1162
\u1102\u1169\u1103\u1169\u11BC
\u1102\u1169\u1105\u1161\u11AB\u1109\u1162\u11A8
\u1102\u1169\u1105\u1167\u11A8
\u1102\u1169\u110B\u1175\u11AB
\u1102\u1169\u11A8\u110B\u1173\u11B7
\u1102\u1169\u11A8\u110E\u1161
\u1102\u1169\u11A8\u1112\u116A
\u1102\u1169\u11AB\u1105\u1175
\u1102\u1169\u11AB\u1106\u116E\u11AB
\u1102\u1169\u11AB\u110C\u1162\u11BC
\u1102\u1169\u11AF\u110B\u1175
\u1102\u1169\u11BC\u1100\u116E
\u1102\u1169\u11BC\u1103\u1161\u11B7
\u1102\u1169\u11BC\u1106\u1175\u11AB
\u1102\u1169\u11BC\u1107\u116E
\u1102\u1169\u11BC\u110B\u1165\u11B8
\u1102\u1169\u11BC\u110C\u1161\u11BC
\u1102\u1169\u11BC\u110E\u1169\u11AB
\u1102\u1169\u11C1\u110B\u1175
\u1102\u116E\u11AB\u1103\u1169\u11BC\u110C\u1161
\u1102\u116E\u11AB\u1106\u116E\u11AF
\u1102\u116E\u11AB\u110A\u1165\u11B8
\u1102\u1172\u110B\u116D\u11A8
\u1102\u1173\u1101\u1175\u11B7
\u1102\u1173\u11A8\u1103\u1162
\u1102\u1173\u11BC\u1103\u1169\u11BC\u110C\u1165\u11A8
\u1102\u1173\u11BC\u1105\u1167\u11A8
\u1103\u1161\u1107\u1161\u11BC
\u1103\u1161\u110B\u1163\u11BC\u1109\u1165\u11BC
\u1103\u1161\u110B\u1173\u11B7
\u1103\u1161\u110B\u1175\u110B\u1165\u1110\u1173
\u1103\u1161\u1112\u1162\u11BC
\u1103\u1161\u11AB\u1100\u1168
\u1103\u1161\u11AB\u1100\u1169\u11AF
\u1103\u1161\u11AB\u1103\u1169\u11A8
\u1103\u1161\u11AB\u1106\u1161\u11BA
\u1103\u1161\u11AB\u1109\u116E\u11AB
\u1103\u1161\u11AB\u110B\u1165
\u1103\u1161\u11AB\u110B\u1171
\u1103\u1161\u11AB\u110C\u1165\u11B7
\u1103\u1161\u11AB\u110E\u1166
\u1103\u1161\u11AB\u110E\u116E
\u1103\u1161\u11AB\u1111\u1167\u11AB
\u1103\u1161\u11AB\u1111\u116E\u11BC
\u1103\u1161\u11AF\u1100\u1163\u11AF
\u1103\u1161\u11AF\u1105\u1165
\u1103\u1161\u11AF\u1105\u1167\u11A8
\u1103\u1161\u11AF\u1105\u1175
\u1103\u1161\u11B0\u1100\u1169\u1100\u1175
\u1103\u1161\u11B7\u1103\u1161\u11BC
\u1103\u1161\u11B7\u1107\u1162
\u1103\u1161\u11B7\u110B\u116D
\u1103\u1161\u11B7\u110B\u1175\u11B7
\u1103\u1161\u11B8\u1107\u1167\u11AB
\u1103\u1161\u11B8\u110C\u1161\u11BC
\u1103\u1161\u11BC\u1100\u1173\u11AB
\u1103\u1161\u11BC\u1107\u116E\u11AB\u1100\u1161\u11AB
\u1103\u1161\u11BC\u110B\u1167\u11AB\u1112\u1175
\u1103\u1161\u11BC\u110C\u1161\u11BC
\u1103\u1162\u1100\u1172\u1106\u1169
\u1103\u1162\u1102\u1161\u11BD
\u1103\u1162\u1103\u1161\u11AB\u1112\u1175
\u1103\u1162\u1103\u1161\u11B8
\u1103\u1162\u1103\u1169\u1109\u1175
\u1103\u1162\u1105\u1163\u11A8
\u1103\u1162\u1105\u1163\u11BC
\u1103\u1162\u1105\u1172\u11A8
\u1103\u1162\u1106\u116E\u11AB
\u1103\u1162\u1107\u116E\u1107\u116E\u11AB
\u1103\u1162\u1109\u1175\u11AB
\u1103\u1162\u110B\u1173\u11BC
\u1103\u1162\u110C\u1161\u11BC
\u1103\u1162\u110C\u1165\u11AB
\u1103\u1162\u110C\u1165\u11B8
\u1103\u1162\u110C\u116E\u11BC
\u1103\u1162\u110E\u1162\u11A8
\u1103\u1162\u110E\u116E\u11AF
\u1103\u1162\u110E\u116E\u11BC
\u1103\u1162\u1110\u1169\u11BC\u1105\u1167\u11BC
\u1103\u1162\u1112\u1161\u11A8
\u1103\u1162\u1112\u1161\u11AB\u1106\u1175\u11AB\u1100\u116E\u11A8
\u1103\u1162\u1112\u1161\u11B8\u1109\u1175\u11AF
\u1103\u1162\u1112\u1167\u11BC
\u1103\u1165\u11BC\u110B\u1165\u1105\u1175
\u1103\u1166\u110B\u1175\u1110\u1173
\u1103\u1169\u1103\u1162\u110E\u1166
\u1103\u1169\u1103\u1165\u11A8
\u1103\u1169\u1103\u116E\u11A8
\u1103\u1169\u1106\u1161\u11BC
\u1103\u1169\u1109\u1165\u1100\u116A\u11AB
\u1103\u1169\u1109\u1175\u11B7
\u1103\u1169\u110B\u116E\u11B7
\u1103\u1169\u110B\u1175\u11B8
\u1103\u1169\u110C\u1161\u1100\u1175
\u1103\u1169\u110C\u1165\u1112\u1175
\u1103\u1169\u110C\u1165\u11AB
\u1103\u1169\u110C\u116E\u11BC
\u1103\u1169\u110E\u1161\u11A8
\u1103\u1169\u11A8\u1100\u1161\u11B7
\u1103\u1169\u11A8\u1105\u1175\u11B8
\u1103\u1169\u11A8\u1109\u1165
\u1103\u1169\u11A8\u110B\u1175\u11AF
\u1103\u1169\u11A8\u110E\u1161\u11BC\u110C\u1165\u11A8
\u1103\u1169\u11BC\u1112\u116A\u110E\u1162\u11A8
\u1103\u1171\u11BA\u1106\u1169\u1109\u1173\u11B8
\u1103\u1171\u11BA\u1109\u1161\u11AB
\u1104\u1161\u11AF\u110B\u1161\u110B\u1175
\u1106\u1161\u1102\u116E\u1105\u1161
\u1106\u1161\u1102\u1173\u11AF
\u1106\u1161\u1103\u1161\u11BC
\u1106\u1161\u1105\u1161\u1110\u1169\u11AB
\u1106\u1161\u1105\u1167\u11AB
\u1106\u1161\u1106\u116E\u1105\u1175
\u1106\u1161\u1109\u1161\u110C\u1175
\u1106\u1161\u110B\u1163\u11A8
\u1106\u1161\u110B\u116D\u1102\u1166\u110C\u1173
\u1106\u1161\u110B\u1173\u11AF
\u1106\u1161\u110B\u1173\u11B7
\u1106\u1161\u110B\u1175\u110F\u1173
\u1106\u1161\u110C\u116E\u11BC
\u1106\u1161\u110C\u1175\u1106\u1161\u11A8
\u1106\u1161\u110E\u1161\u11AB\u1100\u1161\u110C\u1175
\u1106\u1161\u110E\u1161\u11AF
\u1106\u1161\u1112\u1173\u11AB
\u1106\u1161\u11A8\u1100\u1165\u11AF\u1105\u1175
\u1106\u1161\u11A8\u1102\u1162
\u1106\u1161\u11A8\u1109\u1161\u11BC
\u1106\u1161\u11AB\u1102\u1161\u11B7
\u1106\u1161\u11AB\u1103\u116E
\u1106\u1161\u11AB\u1109\u1166
\u1106\u1161\u11AB\u110B\u1163\u11A8
\u1106\u1161\u11AB\u110B\u1175\u11AF
\u1106\u1161\u11AB\u110C\u1165\u11B7
\u1106\u1161\u11AB\u110C\u1169\u11A8
\u1106\u1161\u11AB\u1112\u116A
\u1106\u1161\u11AD\u110B\u1175
\u1106\u1161\u11AF\u1100\u1175
\u1106\u1161\u11AF\u110A\u1173\u11B7
\u1106\u1161\u11AF\u1110\u116E
\u1106\u1161\u11B7\u1103\u1162\u1105\u1169
\u1106\u1161\u11BC\u110B\u116F\u11AB\u1100\u1167\u11BC
\u1106\u1162\u1102\u1167\u11AB
\u1106\u1162\u1103\u1161\u11AF
\u1106\u1162\u1105\u1167\u11A8
\u1106\u1162\u1107\u1165\u11AB
\u1106\u1162\u1109\u1173\u110F\u1165\u11B7
\u1106\u1162\u110B\u1175\u11AF
\u1106\u1162\u110C\u1161\u11BC
\u1106\u1162\u11A8\u110C\u116E
\u1106\u1165\u11A8\u110B\u1175
\u1106\u1165\u11AB\u110C\u1165
\u1106\u1165\u11AB\u110C\u1175
\u1106\u1165\u11AF\u1105\u1175
\u1106\u1166\u110B\u1175\u11AF
\u1106\u1167\u1102\u1173\u1105\u1175
\u1106\u1167\u110E\u1175\u11AF
\u1106\u1167\u11AB\u1103\u1161\u11B7
\u1106\u1167\u11AF\u110E\u1175
\u1106\u1167\u11BC\u1103\u1161\u11AB
\u1106\u1167\u11BC\u1105\u1167\u11BC
\u1106\u1167\u11BC\u110B\u1168
\u1106\u1167\u11BC\u110B\u1174
\u1106\u1167\u11BC\u110C\u1165\u11AF
\u1106\u1167\u11BC\u110E\u1175\u11BC
\u1106\u1167\u11BC\u1112\u1161\u11B7
\u1106\u1169\u1100\u1173\u11B7
\u1106\u1169\u1102\u1175\u1110\u1165
\u1106\u1169\u1103\u1166\u11AF
\u1106\u1169\u1103\u1173\u11AB
\u1106\u1169\u1107\u1165\u11B7
\u1106\u1169\u1109\u1173\u11B8
\u1106\u1169\u110B\u1163\u11BC
\u1106\u1169\u110B\u1175\u11B7
\u1106\u1169\u110C\u1169\u1105\u1175
\u1106\u1169\u110C\u1175\u11B8
\u1106\u1169\u1110\u116E\u11BC\u110B\u1175
\u1106\u1169\u11A8\u1100\u1165\u11AF\u110B\u1175
\u1106\u1169\u11A8\u1105\u1169\u11A8
\u1106\u1169\u11A8\u1109\u1161
\u1106\u1169\u11A8\u1109\u1169\u1105\u1175
\u1106\u1169\u11A8\u1109\u116E\u11B7
\u1106\u1169\u11A8\u110C\u1165\u11A8
\u1106\u1169\u11A8\u1111\u116D
\u1106\u1169\u11AF\u1105\u1162
\u1106\u1169\u11B7\u1106\u1162
\u1106\u1169\u11B7\u1106\u116E\u1100\u1166
\u1106\u1169\u11B7\u1109\u1161\u11AF
\u1106\u1169\u11B7\u1109\u1169\u11A8
\u1106\u1169\u11B7\u110C\u1175\u11BA
\u1106\u1169\u11B7\u1110\u1169\u11BC
\u1106\u1169\u11B8\u1109\u1175
\u1106\u116E\u1100\u116A\u11AB\u1109\u1175\u11B7
\u1106\u116E\u1100\u116E\u11BC\u1112\u116A
\u1106\u116E\u1103\u1165\u110B\u1171
\u1106\u116E\u1103\u1165\u11B7
\u1106\u116E\u1105\u1173\u11C1
\u1106\u116E\u1109\u1173\u11AB
\u1106\u116E\u110B\u1165\u11BA
\u1106\u116E\u110B\u1167\u11A8
\u1106\u116E\u110B\u116D\u11BC
\u1106\u116E\u110C\u1169\u1100\u1165\u11AB
\u1106\u116E\u110C\u1175\u1100\u1162
\u1106\u116E\u110E\u1165\u11A8
\u1106\u116E\u11AB\u1100\u116E
\u1106\u116E\u11AB\u1103\u1173\u11A8
\u1106\u116E\u11AB\u1107\u1165\u11B8
\u1106\u116E\u11AB\u1109\u1165
\u1106\u116E\u11AB\u110C\u1166
\u1106\u116E\u11AB\u1112\u1161\u11A8
\u1106\u116E\u11AB\u1112\u116A
\u1106\u116E\u11AF\u1100\u1161
\u1106\u116E\u11AF\u1100\u1165\u11AB
\u1106\u116E\u11AF\u1100\u1167\u11AF
\u1106\u116E\u11AF\u1100\u1169\u1100\u1175
\u1106\u116E\u11AF\u1105\u1169\u11AB
\u1106\u116E\u11AF\u1105\u1175\u1112\u1161\u11A8
\u1106\u116E\u11AF\u110B\u1173\u11B7
\u1106\u116E\u11AF\u110C\u1175\u11AF
\u1106\u116E\u11AF\u110E\u1166
\u1106\u1175\u1100\u116E\u11A8
\u1106\u1175\u1103\u1175\u110B\u1165
\u1106\u1175\u1109\u1161\u110B\u1175\u11AF
\u1106\u1175\u1109\u116E\u11AF
\u1106\u1175\u110B\u1167\u11A8
\u1106\u1175\u110B\u116D\u11BC\u1109\u1175\u11AF
\u1106\u1175\u110B\u116E\u11B7
\u1106\u1175\u110B\u1175\u11AB
\u1106\u1175\u1110\u1175\u11BC
\u1106\u1175\u1112\u1169\u11AB
\u1106\u1175\u11AB\u1100\u1161\u11AB
\u1106\u1175\u11AB\u110C\u1169\u11A8
\u1106\u1175\u11AB\u110C\u116E
\u1106\u1175\u11AE\u110B\u1173\u11B7
\u1106\u1175\u11AF\u1100\u1161\u1105\u116E
\u1106\u1175\u11AF\u1105\u1175\u1106\u1175\u1110\u1165
\u1106\u1175\u11C0\u1107\u1161\u1103\u1161\u11A8
\u1107\u1161\u1100\u1161\u110C\u1175
\u1107\u1161\u1100\u116E\u1102\u1175
\u1107\u1161\u1102\u1161\u1102\u1161
\u1107\u1161\u1102\u1173\u11AF
\u1107\u1161\u1103\u1161\u11A8
\u1107\u1161\u1103\u1161\u11BA\u1100\u1161
\u1107\u1161\u1105\u1161\u11B7
\u1107\u1161\u110B\u1175\u1105\u1165\u1109\u1173
\u1107\u1161\u1110\u1161\u11BC
\u1107\u1161\u11A8\u1106\u116E\u11AF\u1100\u116A\u11AB
\u1107\u1161\u11A8\u1109\u1161
\u1107\u1161\u11A8\u1109\u116E
\u1107\u1161\u11AB\u1103\u1162
\u1107\u1161\u11AB\u1103\u1173\u1109\u1175
\u1107\u1161\u11AB\u1106\u1161\u11AF
\u1107\u1161\u11AB\u1107\u1161\u11AF
\u1107\u1161\u11AB\u1109\u1165\u11BC
\u1107\u1161\u11AB\u110B\u1173\u11BC
\u1107\u1161\u11AB\u110C\u1161\u11BC
\u1107\u1161\u11AB\u110C\u116E\u11A8
\u1107\u1161\u11AB\u110C\u1175
\u1107\u1161\u11AB\u110E\u1161\u11AB
\u1107\u1161\u11AE\u110E\u1175\u11B7
\u1107\u1161\u11AF\u1100\u1161\u1105\u1161\u11A8
\u1107\u1161\u11AF\u1100\u1165\u11AF\u110B\u1173\u11B7
\u1107\u1161\u11AF\u1100\u1167\u11AB
\u1107\u1161\u11AF\u1103\u1161\u11AF
\u1107\u1161\u11AF\u1105\u1166
\u1107\u1161\u11AF\u1106\u1169\u11A8
\u1107\u1161\u11AF\u1107\u1161\u1103\u1161\u11A8
\u1107\u1161\u11AF\u1109\u1162\u11BC
\u1107\u1161\u11AF\u110B\u1173\u11B7
\u1107\u1161\u11AF\u110C\u1161\u1100\u116E\u11A8
\u1107\u1161\u11AF\u110C\u1165\u11AB
\u1107\u1161\u11AF\u1110\u1169\u11B8
\u1107\u1161\u11AF\u1111\u116D
\u1107\u1161\u11B7\u1112\u1161\u1102\u1173\u11AF
\u1107\u1161\u11B8\u1100\u1173\u1105\u1173\u11BA
\u1107\u1161\u11B8\u1106\u1161\u11BA
\u1107\u1161\u11B8\u1109\u1161\u11BC
\u1107\u1161\u11B8\u1109\u1169\u11C0
\u1107\u1161\u11BC\u1100\u1173\u11B7
\u1107\u1161\u11BC\u1106\u1167\u11AB
\u1107\u1161\u11BC\u1106\u116E\u11AB
\u1107\u1161\u11BC\u1107\u1161\u1103\u1161\u11A8
\u1107\u1161\u11BC\u1107\u1165\u11B8
\u1107\u1161\u11BC\u1109\u1169\u11BC
\u1107\u1161\u11BC\u1109\u1175\u11A8
\u1107\u1161\u11BC\u110B\u1161\u11AB
\u1107\u1161\u11BC\u110B\u116E\u11AF
\u1107\u1161\u11BC\u110C\u1175
\u1107\u1161\u11BC\u1112\u1161\u11A8
\u1107\u1161\u11BC\u1112\u1162
\u1107\u1161\u11BC\u1112\u1163\u11BC
\u1107\u1162\u1100\u1167\u11BC
\u1107\u1162\u1101\u1169\u11B8
\u1107\u1162\u1103\u1161\u11AF
\u1107\u1162\u1103\u1173\u1106\u1175\u11AB\u1110\u1165\u11AB
\u1107\u1162\u11A8\u1103\u116E\u1109\u1161\u11AB
\u1107\u1162\u11A8\u1109\u1162\u11A8
\u1107\u1162\u11A8\u1109\u1165\u11BC
\u1107\u1162\u11A8\u110B\u1175\u11AB
\u1107\u1162\u11A8\u110C\u1166
\u1107\u1162\u11A8\u1112\u116A\u110C\u1165\u11B7
\u1107\u1165\u1105\u1173\u11BA
\u1107\u1165\u1109\u1165\u11BA
\u1107\u1165\u1110\u1173\u11AB
\u1107\u1165\u11AB\u1100\u1162
\u1107\u1165\u11AB\u110B\u1167\u11A8
\u1107\u1165\u11AB\u110C\u1175
\u1107\u1165\u11AB\u1112\u1169
\u1107\u1165\u11AF\u1100\u1173\u11B7
\u1107\u1165\u11AF\u1105\u1166
\u1107\u1165\u11AF\u110A\u1165
\u1107\u1165\u11B7\u110B\u1171
\u1107\u1165\u11B7\u110B\u1175\u11AB
\u1107\u1165\u11B7\u110C\u116C
\u1107\u1165\u11B8\u1105\u1172\u11AF
\u1107\u1165\u11B8\u110B\u116F\u11AB
\u1107\u1165\u11B8\u110C\u1165\u11A8
\u1107\u1165\u11B8\u110E\u1175\u11A8
\u1107\u1166\u110B\u1175\u110C\u1175\u11BC
\u1107\u1166\u11AF\u1110\u1173
\u1107\u1167\u11AB\u1100\u1167\u11BC
\u1107\u1167\u11AB\u1103\u1169\u11BC
\u1107\u1167\u11AB\u1106\u1167\u11BC
\u1107\u1167\u11AB\u1109\u1175\u11AB
\u1107\u1167\u11AB\u1112\u1169\u1109\u1161
\u1107\u1167\u11AB\u1112\u116A
\u1107\u1167\u11AF\u1103\u1169
\u1107\u1167\u11AF\u1106\u1167\u11BC
\u1107\u1167\u11AF\u110B\u1175\u11AF
\u1107\u1167\u11BC\u1109\u1175\u11AF
\u1107\u1167\u11BC\u110B\u1161\u1105\u1175
\u1107\u1167\u11BC\u110B\u116F\u11AB
\u1107\u1169\u1100\u116A\u11AB
\u1107\u1169\u1102\u1165\u1109\u1173
\u1107\u1169\u1105\u1161\u1109\u1162\u11A8
\u1107\u1169\u1105\u1161\u11B7
\u1107\u1169\u1105\u1173\u11B7
\u1107\u1169\u1109\u1161\u11BC
\u1107\u1169\u110B\u1161\u11AB
\u1107\u1169\u110C\u1161\u1100\u1175
\u1107\u1169\u110C\u1161\u11BC
\u1107\u1169\u110C\u1165\u11AB
\u1107\u1169\u110C\u1169\u11AB
\u1107\u1169\u1110\u1169\u11BC
\u1107\u1169\u1111\u1167\u11AB\u110C\u1165\u11A8
\u1107\u1169\u1112\u1165\u11B7
\u1107\u1169\u11A8\u1103\u1169
\u1107\u1169\u11A8\u1109\u1161
\u1107\u1169\u11A8\u1109\u116E\u11BC\u110B\u1161
\u1107\u1169\u11A8\u1109\u1173\u11B8
\u1107\u1169\u11A9\u110B\u1173\u11B7
\u1107\u1169\u11AB\u1100\u1167\u11A8\u110C\u1165\u11A8
\u1107\u1169\u11AB\u1105\u1162
\u1107\u1169\u11AB\u1107\u116E
\u1107\u1169\u11AB\u1109\u1161
\u1107\u1169\u11AB\u1109\u1165\u11BC
\u1107\u1169\u11AB\u110B\u1175\u11AB
\u1107\u1169\u11AB\u110C\u1175\u11AF
\u1107\u1169\u11AF\u1111\u1166\u11AB
\u1107\u1169\u11BC\u1109\u1161
\u1107\u1169\u11BC\u110C\u1175
\u1107\u1169\u11BC\u1110\u116E
\u1107\u116E\u1100\u1173\u11AB
\u1107\u116E\u1101\u1173\u1105\u1165\u110B\u116E\u11B7
\u1107\u116E\u1103\u1161\u11B7
\u1107\u116E\u1103\u1169\u11BC\u1109\u1161\u11AB
\u1107\u116E\u1106\u116E\u11AB
\u1107\u116E\u1107\u116E\u11AB
\u1107\u116E\u1109\u1161\u11AB
\u1107\u116E\u1109\u1161\u11BC
\u1107\u116E\u110B\u1165\u11BF
\u1107\u116E\u110B\u1175\u11AB
\u1107\u116E\u110C\u1161\u11A8\u110B\u116D\u11BC
\u1107\u116E\u110C\u1161\u11BC
\u1107\u116E\u110C\u1165\u11BC
\u1107\u116E\u110C\u1169\u11A8
\u1107\u116E\u110C\u1175\u1105\u1165\u11AB\u1112\u1175
\u1107\u116E\u110E\u1175\u11AB
\u1107\u116E\u1110\u1161\u11A8
\u1107\u116E\u1111\u116E\u11B7
\u1107\u116E\u1112\u116C\u110C\u1161\u11BC
\u1107\u116E\u11A8\u1107\u116E
\u1107\u116E\u11A8\u1112\u1161\u11AB
\u1107\u116E\u11AB\u1102\u1169
\u1107\u116E\u11AB\u1105\u1163\u11BC
\u1107\u116E\u11AB\u1105\u1175
\u1107\u116E\u11AB\u1106\u1167\u11BC
\u1107\u116E\u11AB\u1109\u1165\u11A8
\u1107\u116E\u11AB\u110B\u1163
\u1107\u116E\u11AB\u110B\u1171\u1100\u1175
\u1107\u116E\u11AB\u1111\u1175\u11AF
\u1107\u116E\u11AB\u1112\u1169\u11BC\u1109\u1162\u11A8
\u1107\u116E\u11AF\u1100\u1169\u1100\u1175
\u1107\u116E\u11AF\u1100\u116A
\u1107\u116E\u11AF\u1100\u116D
\u1107\u116E\u11AF\u1101\u1169\u11BE
\u1107\u116E\u11AF\u1106\u1161\u11AB
\u1107\u116E\u11AF\u1107\u1165\u11B8
\u1107\u116E\u11AF\u1107\u1175\u11BE
\u1107\u116E\u11AF\u110B\u1161\u11AB
\u1107\u116E\u11AF\u110B\u1175\u110B\u1175\u11A8
\u1107\u116E\u11AF\u1112\u1162\u11BC
\u1107\u1173\u1105\u1162\u11AB\u1103\u1173
\u1107\u1175\u1100\u1173\u11A8
\u1107\u1175\u1102\u1161\u11AB
\u1107\u1175\u1102\u1175\u11AF
\u1107\u1175\u1103\u116E\u11AF\u1100\u1175
\u1107\u1175\u1103\u1175\u110B\u1169
\u1107\u1175\u1105\u1169\u1109\u1169
\u1107\u1175\u1106\u1161\u11AB
\u1107\u1175\u1106\u1167\u11BC
\u1107\u1175\u1106\u1175\u11AF
\u1107\u1175\u1107\u1161\u1105\u1161\u11B7
\u1107\u1175\u1107\u1175\u11B7\u1107\u1161\u11B8
\u1107\u1175\u1109\u1161\u11BC
\u1107\u1175\u110B\u116D\u11BC
\u1107\u1175\u110B\u1172\u11AF
\u1107\u1175\u110C\u116E\u11BC
\u1107\u1175\u1110\u1161\u1106\u1175\u11AB
\u1107\u1175\u1111\u1161\u11AB
\u1107\u1175\u11AF\u1103\u1175\u11BC
\u1107\u1175\u11BA\u1106\u116E\u11AF
\u1107\u1175\u11BA\u1107\u1161\u11BC\u110B\u116E\u11AF
\u1107\u1175\u11BA\u110C\u116E\u11AF\u1100\u1175
\u1107\u1175\u11BE\u1101\u1161\u11AF
\u1108\u1161\u11AF\u1100\u1161\u11AB\u1109\u1162\u11A8
\u1108\u1161\u11AF\u1105\u1162
\u1108\u1161\u11AF\u1105\u1175
\u1109\u1161\u1100\u1165\u11AB
\u1109\u1161\u1100\u1168\u110C\u1165\u11AF
\u1109\u1161\u1102\u1161\u110B\u1175
\u1109\u1161\u1102\u1163\u11BC
\u1109\u1161\u1105\u1161\u11B7
\u1109\u1161\u1105\u1161\u11BC
\u1109\u1161\u1105\u1175\u11B8
\u1109\u1161\u1106\u1169\u1102\u1175\u11B7
\u1109\u1161\u1106\u116E\u11AF
\u1109\u1161\u1107\u1161\u11BC
\u1109\u1161\u1109\u1161\u11BC
\u1109\u1161\u1109\u1162\u11BC\u1112\u116A\u11AF
\u1109\u1161\u1109\u1165\u11AF
\u1109\u1161\u1109\u1173\u11B7
\u1109\u1161\u1109\u1175\u11AF
\u1109\u1161\u110B\u1165\u11B8
\u1109\u1161\u110B\u116D\u11BC
\u1109\u1161\u110B\u116F\u11AF
\u1109\u1161\u110C\u1161\u11BC
\u1109\u1161\u110C\u1165\u11AB
\u1109\u1161\u110C\u1175\u11AB
\u1109\u1161\u110E\u1169\u11AB
\u1109\u1161\u110E\u116E\u11AB\u1100\u1175
\u1109\u1161\u1110\u1161\u11BC
\u1109\u1161\u1110\u116E\u1105\u1175
\u1109\u1161\u1112\u1173\u11AF
\u1109\u1161\u11AB\u1100\u1175\u11AF
\u1109\u1161\u11AB\u1107\u116E\u110B\u1175\u11AB\u1100\u116A
\u1109\u1161\u11AB\u110B\u1165\u11B8
\u1109\u1161\u11AB\u110E\u1162\u11A8
\u1109\u1161\u11AF\u1105\u1175\u11B7
\u1109\u1161\u11AF\u110B\u1175\u11AB
\u1109\u1161\u11AF\u110D\u1161\u11A8
\u1109\u1161\u11B7\u1100\u1168\u1110\u1161\u11BC
\u1109\u1161\u11B7\u1100\u116E\u11A8
\u1109\u1161\u11B7\u1109\u1175\u11B8
\u1109\u1161\u11B7\u110B\u116F\u11AF
\u1109\u1161\u11B7\u110E\u1169\u11AB
\u1109\u1161\u11BC\u1100\u116A\u11AB
\u1109\u1161\u11BC\u1100\u1173\u11B7
\u1109\u1161\u11BC\u1103\u1162
\u1109\u1161\u11BC\u1105\u1172
\u1109\u1161\u11BC\u1107\u1161\u11AB\u1100\u1175
\u1109\u1161\u11BC\u1109\u1161\u11BC
\u1109\u1161\u11BC\u1109\u1175\u11A8
\u1109\u1161\u11BC\u110B\u1165\u11B8
\u1109\u1161\u11BC\u110B\u1175\u11AB
\u1109\u1161\u11BC\u110C\u1161
\u1109\u1161\u11BC\u110C\u1165\u11B7
\u1109\u1161\u11BC\u110E\u1165
\u1109\u1161\u11BC\u110E\u116E
\u1109\u1161\u11BC\u1110\u1162
\u1109\u1161\u11BC\u1111\u116D
\u1109\u1161\u11BC\u1111\u116E\u11B7
\u1109\u1161\u11BC\u1112\u116A\u11BC
\u1109\u1162\u1107\u1167\u11A8
\u1109\u1162\u11A8\u1101\u1161\u11AF
\u1109\u1162\u11A8\u110B\u1167\u11AB\u1111\u1175\u11AF
\u1109\u1162\u11BC\u1100\u1161\u11A8
\u1109\u1162\u11BC\u1106\u1167\u11BC
\u1109\u1162\u11BC\u1106\u116E\u11AF
\u1109\u1162\u11BC\u1107\u1161\u11BC\u1109\u1169\u11BC
\u1109\u1162\u11BC\u1109\u1161\u11AB
\u1109\u1162\u11BC\u1109\u1165\u11AB
\u1109\u1162\u11BC\u1109\u1175\u11AB
\u1109\u1162\u11BC\u110B\u1175\u11AF
\u1109\u1162\u11BC\u1112\u116A\u11AF
\u1109\u1165\u1105\u1161\u11B8
\u1109\u1165\u1105\u1173\u11AB
\u1109\u1165\u1106\u1167\u11BC
\u1109\u1165\u1106\u1175\u11AB
\u1109\u1165\u1107\u1175\u1109\u1173
\u1109\u1165\u110B\u1163\u11BC
\u1109\u1165\u110B\u116E\u11AF
\u1109\u1165\u110C\u1165\u11A8
\u1109\u1165\u110C\u1165\u11B7
\u1109\u1165\u110D\u1169\u11A8
\u1109\u1165\u110F\u1173\u11AF
\u1109\u1165\u11A8\u1109\u1161
\u1109\u1165\u11A8\u110B\u1172
\u1109\u1165\u11AB\u1100\u1165
\u1109\u1165\u11AB\u1106\u116E\u11AF
\u1109\u1165\u11AB\u1107\u1162
\u1109\u1165\u11AB\u1109\u1162\u11BC
\u1109\u1165\u11AB\u1109\u116E
\u1109\u1165\u11AB\u110B\u116F\u11AB
\u1109\u1165\u11AB\u110C\u1161\u11BC
\u1109\u1165\u11AB\u110C\u1165\u11AB
\u1109\u1165\u11AB\u1110\u1162\u11A8
\u1109\u1165\u11AB\u1111\u116E\u11BC\u1100\u1175
\u1109\u1165\u11AF\u1100\u1165\u110C\u1175
\u1109\u1165\u11AF\u1102\u1161\u11AF
\u1109\u1165\u11AF\u1105\u1165\u11BC\u1110\u1161\u11BC
\u1109\u1165\u11AF\u1106\u1167\u11BC
\u1109\u1165\u11AF\u1106\u116E\u11AB
\u1109\u1165\u11AF\u1109\u1161
\u1109\u1165\u11AF\u110B\u1161\u11A8\u1109\u1161\u11AB
\u1109\u1165\u11AF\u110E\u1175
\u1109\u1165\u11AF\u1110\u1161\u11BC
\u1109\u1165\u11B8\u110A\u1175
\u1109\u1165\u11BC\u1100\u1169\u11BC
\u1109\u1165\u11BC\u1103\u1161\u11BC
\u1109\u1165\u11BC\u1106\u1167\u11BC
\u1109\u1165\u11BC\u1107\u1167\u11AF
\u1109\u1165\u11BC\u110B\u1175\u11AB
\u1109\u1165\u11BC\u110C\u1161\u11BC
\u1109\u1165\u11BC\u110C\u1165\u11A8
\u1109\u1165\u11BC\u110C\u1175\u11AF
\u1109\u1165\u11BC\u1112\u1161\u11B7
\u1109\u1166\u1100\u1173\u11B7
\u1109\u1166\u1106\u1175\u1102\u1161
\u1109\u1166\u1109\u1161\u11BC
\u1109\u1166\u110B\u116F\u11AF
\u1109\u1166\u110C\u1169\u11BC\u1103\u1162\u110B\u116A\u11BC
\u1109\u1166\u1110\u1161\u11A8
\u1109\u1166\u11AB\u1110\u1165
\u1109\u1166\u11AB\u1110\u1175\u1106\u1175\u1110\u1165
\u1109\u1166\u11BA\u110D\u1162
\u1109\u1169\u1100\u1172\u1106\u1169
\u1109\u1169\u1100\u1173\u11A8\u110C\u1165\u11A8
\u1109\u1169\u1100\u1173\u11B7
\u1109\u1169\u1102\u1161\u1100\u1175
\u1109\u1169\u1102\u1167\u11AB
\u1109\u1169\u1103\u1173\u11A8
\u1109\u1169\u1106\u1161\u11BC
\u1109\u1169\u1106\u116E\u11AB
\u1109\u1169\u1109\u1165\u11AF
\u1109\u1169\u1109\u1169\u11A8
\u1109\u1169\u110B\u1161\u1100\u116A
\u1109\u1169\u110B\u116D\u11BC
\u1109\u1169\u110B\u116F\u11AB
\u1109\u1169\u110B\u1173\u11B7
\u1109\u1169\u110C\u116E\u11BC\u1112\u1175
\u1109\u1169\u110C\u1175\u1111\u116E\u11B7
\u1109\u1169\u110C\u1175\u11AF
\u1109\u1169\u1111\u116E\u11BC
\u1109\u1169\u1112\u1167\u11BC
\u1109\u1169\u11A8\u1103\u1161\u11B7
\u1109\u1169\u11A8\u1103\u1169
\u1109\u1169\u11A8\u110B\u1169\u11BA
\u1109\u1169\u11AB\u1100\u1161\u1105\u1161\u11A8
\u1109\u1169\u11AB\u1100\u1175\u11AF
\u1109\u1169\u11AB\u1102\u1167
\u1109\u1169\u11AB\u1102\u1175\u11B7
\u1109\u1169\u11AB\u1103\u1173\u11BC
\u1109\u1169\u11AB\u1106\u1169\u11A8
\u1109\u1169\u11AB\u1108\u1167\u11A8
\u1109\u1169\u11AB\u1109\u1175\u11AF
\u1109\u1169\u11AB\u110C\u1175\u11AF
\u1109\u1169\u11AB\u1110\u1169\u11B8
\u1109\u1169\u11AB\u1112\u1162
\u1109\u1169\u11AF\u110C\u1175\u11A8\u1112\u1175
\u1109\u1169\u11B7\u110A\u1175
\u1109\u1169\u11BC\u110B\u1161\u110C\u1175
\u1109\u1169\u11BC\u110B\u1175
\u1109\u1169\u11BC\u1111\u1167\u11AB
\u1109\u116C\u1100\u1169\u1100\u1175
\u1109\u116D\u1111\u1175\u11BC
\u1109\u116E\u1100\u1165\u11AB
\u1109\u116E\u1102\u1167\u11AB
\u1109\u116E\u1103\u1161\u11AB
\u1109\u116E\u1103\u1169\u11BA\u1106\u116E\u11AF
\u1109\u116E\u1103\u1169\u11BC\u110C\u1165\u11A8
\u1109\u116E\u1106\u1167\u11AB
\u1109\u116E\u1106\u1167\u11BC
\u1109\u116E\u1107\u1161\u11A8
\u1109\u116E\u1109\u1161\u11BC
\u1109\u116E\u1109\u1165\u11A8
\u1109\u116E\u1109\u116E\u11AF
\u1109\u116E\u1109\u1175\u1105\u1169
\u1109\u116E\u110B\u1165\u11B8
\u1109\u116E\u110B\u1167\u11B7
\u1109\u116E\u110B\u1167\u11BC
\u1109\u116E\u110B\u1175\u11B8
\u1109\u116E\u110C\u116E\u11AB
\u1109\u116E\u110C\u1175\u11B8
\u1109\u116E\u110E\u116E\u11AF
\u1109\u116E\u110F\u1165\u11BA
\u1109\u116E\u1111\u1175\u11AF
\u1109\u116E\u1112\u1161\u11A8
\u1109\u116E\u1112\u1165\u11B7\u1109\u1162\u11BC
\u1109\u116E\u1112\u116A\u1100\u1175
\u1109\u116E\u11A8\u1102\u1167
\u1109\u116E\u11A8\u1109\u1169
\u1109\u116E\u11A8\u110C\u1166
\u1109\u116E\u11AB\u1100\u1161\u11AB
\u1109\u116E\u11AB\u1109\u1165
\u1109\u116E\u11AB\u1109\u116E
\u1109\u116E\u11AB\u1109\u1175\u11A8\u1100\u1161\u11AB
\u1109\u116E\u11AB\u110B\u1171
\u1109\u116E\u11AE\u1100\u1161\u1105\u1161\u11A8
\u1109\u116E\u11AF\u1107\u1167\u11BC
\u1109\u116E\u11AF\u110C\u1175\u11B8
\u1109\u116E\u11BA\u110C\u1161
\u1109\u1173\u1102\u1175\u11B7
\u1109\u1173\u1106\u116E\u11AF
\u1109\u1173\u1109\u1173\u1105\u1169
\u1109\u1173\u1109\u1173\u11BC
\u1109\u1173\u110B\u1170\u1110\u1165
\u1109\u1173\u110B\u1171\u110E\u1175
\u1109\u1173\u110F\u1166\u110B\u1175\u1110\u1173
\u1109\u1173\u1110\u1172\u1103\u1175\u110B\u1169
\u1109\u1173\u1110\u1173\u1105\u1166\u1109\u1173
\u1109\u1173\u1111\u1169\u110E\u1173
\u1109\u1173\u11AF\u110D\u1165\u11A8
\u1109\u1173\u11AF\u1111\u1173\u11B7
\u1109\u1173\u11B8\u1100\u116A\u11AB
\u1109\u1173\u11B8\u1100\u1175
\u1109\u1173\u11BC\u1100\u1162\u11A8
\u1109\u1173\u11BC\u1105\u1175
\u1109\u1173\u11BC\u1107\u116E
\u1109\u1173\u11BC\u110B\u116D\u11BC\u110E\u1161
\u1109\u1173\u11BC\u110C\u1175\u11AB
\u1109\u1175\u1100\u1161\u11A8
\u1109\u1175\u1100\u1161\u11AB
\u1109\u1175\u1100\u1169\u11AF
\u1109\u1175\u1100\u1173\u11B7\u110E\u1175
\u1109\u1175\u1102\u1161\u1105\u1175\u110B\u1169
\u1109\u1175\u1103\u1162\u11A8
\u1109\u1175\u1105\u1175\u110C\u1173
\u1109\u1175\u1106\u1166\u11AB\u1110\u1173
\u1109\u1175\u1106\u1175\u11AB
\u1109\u1175\u1107\u116E\u1106\u1169
\u1109\u1175\u1109\u1165\u11AB
\u1109\u1175\u1109\u1165\u11AF
\u1109\u1175\u1109\u1173\u1110\u1166\u11B7
\u1109\u1175\u110B\u1161\u1107\u1165\u110C\u1175
\u1109\u1175\u110B\u1165\u1106\u1165\u1102\u1175
\u1109\u1175\u110B\u116F\u11AF
\u1109\u1175\u110B\u1175\u11AB
\u1109\u1175\u110B\u1175\u11AF
\u1109\u1175\u110C\u1161\u11A8
\u1109\u1175\u110C\u1161\u11BC
\u1109\u1175\u110C\u1165\u11AF
\u1109\u1175\u110C\u1165\u11B7
\u1109\u1175\u110C\u116E\u11BC
\u1109\u1175\u110C\u1173\u11AB
\u1109\u1175\u110C\u1175\u11B8
\u1109\u1175\u110E\u1165\u11BC
\u1109\u1175\u1112\u1161\u11B8
\u1109\u1175\u1112\u1165\u11B7
\u1109\u1175\u11A8\u1100\u116E
\u1109\u1175\u11A8\u1100\u1175
\u1109\u1175\u11A8\u1103\u1161\u11BC
\u1109\u1175\u11A8\u1105\u1163\u11BC
\u1109\u1175\u11A8\u1105\u116D\u1111\u116E\u11B7
\u1109\u1175\u11A8\u1106\u116E\u11AF
\u1109\u1175\u11A8\u1108\u1161\u11BC
\u1109\u1175\u11A8\u1109\u1161
\u1109\u1175\u11A8\u1109\u1162\u11BC\u1112\u116A\u11AF
\u1109\u1175\u11A8\u110E\u1169
\u1109\u1175\u11A8\u1110\u1161\u11A8
\u1109\u1175\u11A8\u1111\u116E\u11B7
\u1109\u1175\u11AB\u1100\u1169
\u1109\u1175\u11AB\u1100\u1172
\u1109\u1175\u11AB\u1102\u1167\u11B7
\u1109\u1175\u11AB\u1106\u116E\u11AB
\u1109\u1175\u11AB\u1107\u1161\u11AF
\u1109\u1175\u11AB\u1107\u1175
\u1109\u1175\u11AB\u1109\u1161
\u1109\u1175\u11AB\u1109\u1166
\u1109\u1175\u11AB\u110B\u116D\u11BC
\u1109\u1175\u11AB\u110C\u1166\u1111\u116E\u11B7
\u1109\u1175\u11AB\u110E\u1165\u11BC
\u1109\u1175\u11AB\u110E\u1166
\u1109\u1175\u11AB\u1112\u116A
\u1109\u1175\u11AF\u1100\u1161\u11B7
\u1109\u1175\u11AF\u1102\u1162
\u1109\u1175\u11AF\u1105\u1167\u11A8
\u1109\u1175\u11AF\u1105\u1168
\u1109\u1175\u11AF\u1106\u1161\u11BC
\u1109\u1175\u11AF\u1109\u116E
\u1109\u1175\u11AF\u1109\u1173\u11B8
\u1109\u1175\u11AF\u1109\u1175
\u1109\u1175\u11AF\u110C\u1161\u11BC
\u1109\u1175\u11AF\u110C\u1165\u11BC
\u1109\u1175\u11AF\u110C\u1175\u11AF\u110C\u1165\u11A8
\u1109\u1175\u11AF\u110E\u1165\u11AB
\u1109\u1175\u11AF\u110E\u1166
\u1109\u1175\u11AF\u110F\u1165\u11BA
\u1109\u1175\u11AF\u1110\u1162
\u1109\u1175\u11AF\u1111\u1162
\u1109\u1175\u11AF\u1112\u1165\u11B7
\u1109\u1175\u11AF\u1112\u1167\u11AB
\u1109\u1175\u11B7\u1105\u1175
\u1109\u1175\u11B7\u1107\u116E\u1105\u1173\u11B7
\u1109\u1175\u11B7\u1109\u1161
\u1109\u1175\u11B7\u110C\u1161\u11BC
\u1109\u1175\u11B7\u110C\u1165\u11BC
\u1109\u1175\u11B7\u1111\u1161\u11AB
\u110A\u1161\u11BC\u1103\u116E\u11BC\u110B\u1175
\u110A\u1175\u1105\u1173\u11B7
\u110A\u1175\u110B\u1161\u11BA
\u110B\u1161\u1100\u1161\u110A\u1175
\u110B\u1161\u1102\u1161\u110B\u116E\u11AB\u1109\u1165
\u110B\u1161\u1103\u1173\u1102\u1175\u11B7
\u110B\u1161\u1103\u1173\u11AF
\u110B\u1161\u1109\u1171\u110B\u116E\u11B7
\u110B\u1161\u1109\u1173\u1111\u1161\u11AF\u1110\u1173
\u110B\u1161\u1109\u1175\u110B\u1161
\u110B\u1161\u110B\u116E\u11AF\u1105\u1165
\u110B\u1161\u110C\u1165\u110A\u1175
\u110B\u1161\u110C\u116E\u11B7\u1106\u1161
\u110B\u1161\u110C\u1175\u11A8
\u110B\u1161\u110E\u1175\u11B7
\u110B\u1161\u1111\u1161\u1110\u1173
\u110B\u1161\u1111\u1173\u1105\u1175\u110F\u1161
\u110B\u1161\u1111\u1173\u11B7
\u110B\u1161\u1112\u1169\u11B8
\u110B\u1161\u1112\u1173\u11AB
\u110B\u1161\u11A8\u1100\u1175
\u110B\u1161\u11A8\u1106\u1169\u11BC
\u110B\u1161\u11A8\u1109\u116E
\u110B\u1161\u11AB\u1100\u1162
\u110B\u1161\u11AB\u1100\u1167\u11BC
\u110B\u1161\u11AB\u1100\u116A
\u110B\u1161\u11AB\u1102\u1162
\u110B\u1161\u11AB\u1102\u1167\u11BC
\u110B\u1161\u11AB\u1103\u1169\u11BC
\u110B\u1161\u11AB\u1107\u1161\u11BC
\u110B\u1161\u11AB\u1107\u116E
\u110B\u1161\u11AB\u110C\u116E
\u110B\u1161\u11AF\u1105\u116E\u1106\u1175\u1102\u1172\u11B7
\u110B\u1161\u11AF\u110F\u1169\u110B\u1169\u11AF
\u110B\u1161\u11B7\u1109\u1175
\u110B\u1161\u11B7\u110F\u1165\u11BA
\u110B\u1161\u11B8\u1105\u1167\u11A8
\u110B\u1161\u11C1\u1102\u1161\u11AF
\u110B\u1161\u11C1\u1106\u116E\u11AB
\u110B\u1162\u110B\u1175\u11AB
\u110B\u1162\u110C\u1165\u11BC
\u110B\u1162\u11A8\u1109\u116E
\u110B\u1162\u11AF\u1107\u1165\u11B7
\u110B\u1163\u1100\u1161\u11AB
\u110B\u1163\u1103\u1161\u11AB
\u110B\u1163\u110B\u1169\u11BC
\u110B\u1163\u11A8\u1100\u1161\u11AB
\u110B\u1163\u11A8\u1100\u116E\u11A8
\u110B\u1163\u11A8\u1109\u1169\u11A8
\u110B\u1163\u11A8\u1109\u116E
\u110B\u1163\u11A8\u110C\u1165\u11B7
\u110B\u1163\u11A8\u1111\u116E\u11B7
\u110B\u1163\u11A8\u1112\u1169\u11AB\u1102\u1167
\u110B\u1163\u11BC\u1102\u1167\u11B7
\u110B\u1163\u11BC\u1105\u1167\u11A8
\u110B\u1163\u11BC\u1106\u1161\u11AF
\u110B\u1163\u11BC\u1107\u1162\u110E\u116E
\u110B\u1163\u11BC\u110C\u116E
\u110B\u1163\u11BC\u1111\u1161
\u110B\u1165\u1103\u116E\u11B7
\u110B\u1165\u1105\u1167\u110B\u116E\u11B7
\u110B\u1165\u1105\u1173\u11AB
\u110B\u1165\u110C\u1166\u11BA\u1107\u1161\u11B7
\u110B\u1165\u110D\u1162\u11BB\u1103\u1173\u11AB
\u110B\u1165\u110D\u1165\u1103\u1161\u1100\u1161
\u110B\u1165\u110D\u1165\u11AB\u110C\u1175
\u110B\u1165\u11AB\u1102\u1175
\u110B\u1165\u11AB\u1103\u1165\u11A8
\u110B\u1165\u11AB\u1105\u1169\u11AB
\u110B\u1165\u11AB\u110B\u1165
\u110B\u1165\u11AF\u1100\u116E\u11AF
\u110B\u1165\u11AF\u1105\u1173\u11AB
\u110B\u1165\u11AF\u110B\u1173\u11B7
\u110B\u1165\u11AF\u1111\u1175\u11BA
\u110B\u1165\u11B7\u1106\u1161
\u110B\u1165\u11B8\u1106\u116E
\u110B\u1165\u11B8\u110C\u1169\u11BC
\u110B\u1165\u11B8\u110E\u1166
\u110B\u1165\u11BC\u1103\u1165\u11BC\u110B\u1175
\u110B\u1165\u11BC\u1106\u1161\u11BC
\u110B\u1165\u11BC\u1110\u1165\u1105\u1175
\u110B\u1165\u11BD\u1100\u1173\u110C\u1166
\u110B\u1166\u1102\u1165\u110C\u1175
\u110B\u1166\u110B\u1165\u110F\u1165\u11AB
\u110B\u1166\u11AB\u110C\u1175\u11AB
\u110B\u1167\u1100\u1165\u11AB
\u110B\u1167\u1100\u1169\u1109\u1162\u11BC
\u110B\u1167\u1100\u116A\u11AB
\u110B\u1167\u1100\u116E\u11AB
\u110B\u1167\u1100\u116F\u11AB
\u110B\u1167\u1103\u1162\u1109\u1162\u11BC
\u110B\u1167\u1103\u1165\u11B2
\u110B\u1167\u1103\u1169\u11BC\u1109\u1162\u11BC
\u110B\u1167\u1103\u1173\u11AB
\u110B\u1167\u1105\u1169\u11AB
\u110B\u1167\u1105\u1173\u11B7
\u110B\u1167\u1109\u1165\u11BA
\u110B\u1167\u1109\u1165\u11BC
\u110B\u1167\u110B\u116A\u11BC
\u110B\u1167\u110B\u1175\u11AB
\u110B\u1167\u110C\u1165\u11AB\u1112\u1175
\u110B\u1167\u110C\u1175\u11A8\u110B\u116F\u11AB
\u110B\u1167\u1112\u1161\u11A8\u1109\u1162\u11BC
\u110B\u1167\u1112\u1162\u11BC
\u110B\u1167\u11A8\u1109\u1161
\u110B\u1167\u11A8\u1109\u1175
\u110B\u1167\u11A8\u1112\u1161\u11AF
\u110B\u1167\u11AB\u1100\u1167\u11AF
\u110B\u1167\u11AB\u1100\u116E
\u110B\u1167\u11AB\u1100\u1173\u11A8
\u110B\u1167\u11AB\u1100\u1175
\u110B\u1167\u11AB\u1105\u1161\u11A8
\u110B\u1167\u11AB\u1109\u1165\u11AF
\u110B\u1167\u11AB\u1109\u1166
\u110B\u1167\u11AB\u1109\u1169\u11A8
\u110B\u1167\u11AB\u1109\u1173\u11B8
\u110B\u1167\u11AB\u110B\u1162
\u110B\u1167\u11AB\u110B\u1168\u110B\u1175\u11AB
\u110B\u1167\u11AB\u110B\u1175\u11AB
\u110B\u1167\u11AB\u110C\u1161\u11BC
\u110B\u1167\u11AB\u110C\u116E
\u110B\u1167\u11AB\u110E\u116E\u11AF
\u110B\u1167\u11AB\u1111\u1175\u11AF
\u110B\u1167\u11AB\u1112\u1161\u11B8
\u110B\u1167\u11AB\u1112\u1172
\u110B\u1167\u11AF\u1100\u1175
\u110B\u1167\u11AF\u1106\u1162
\u110B\u1167\u11AF\u1109\u116C
\u110B\u1167\u11AF\u1109\u1175\u11B7\u1112\u1175
\u110B\u1167\u11AF\u110C\u1165\u11BC
\u110B\u1167\u11AF\u110E\u1161
\u110B\u1167\u11AF\u1112\u1173\u11AF
\u110B\u1167\u11B7\u1105\u1167
\u110B\u1167\u11B8\u1109\u1165
\u110B\u1167\u11BC\u1100\u116E\u11A8
\u110B\u1167\u11BC\u1102\u1161\u11B7
\u110B\u1167\u11BC\u1109\u1161\u11BC
\u110B\u1167\u11BC\u110B\u1163\u11BC
\u110B\u1167\u11BC\u110B\u1167\u11A8
\u110B\u1167\u11BC\u110B\u116E\u11BC
\u110B\u1167\u11BC\u110B\u116F\u11AB\u1112\u1175
\u110B\u1167\u11BC\u1112\u1161
\u110B\u1167\u11BC\u1112\u1163\u11BC
\u110B\u1167\u11BC\u1112\u1169\u11AB
\u110B\u1167\u11BC\u1112\u116A
\u110B\u1167\u11C1\u1100\u116E\u1105\u1175
\u110B\u1167\u11C1\u1107\u1161\u11BC
\u110B\u1167\u11C1\u110C\u1175\u11B8
\u110B\u1168\u1100\u1161\u11B7
\u110B\u1168\u1100\u1173\u11B7
\u110B\u1168\u1107\u1161\u11BC
\u110B\u1168\u1109\u1161\u11AB
\u110B\u1168\u1109\u1161\u11BC
\u110B\u1168\u1109\u1165\u11AB
\u110B\u1168\u1109\u116E\u11AF
\u110B\u1168\u1109\u1173\u11B8
\u110B\u1168\u1109\u1175\u11A8\u110C\u1161\u11BC
\u110B\u1168\u110B\u1163\u11A8
\u110B\u1168\u110C\u1165\u11AB
\u110B\u1168\u110C\u1165\u11AF
\u110B\u1168\u110C\u1165\u11BC
\u110B\u1168\u110F\u1165\u11AB\u1103\u1162
\u110B\u1168\u11BA\u1102\u1161\u11AF
\u110B\u1169\u1102\u1173\u11AF
\u110B\u1169\u1105\u1161\u11A8
\u110B\u1169\u1105\u1162\u11BA\u1103\u1169\u11BC\u110B\u1161\u11AB
\u110B\u1169\u1105\u1166\u11AB\u110C\u1175
\u110B\u1169\u1105\u1169\u110C\u1175
\u110B\u1169\u1105\u1173\u11AB\u1107\u1161\u11AF
\u110B\u1169\u1107\u1173\u11AB
\u110B\u1169\u1109\u1175\u11B8
\u110B\u1169\u110B\u1167\u11B7
\u110B\u1169\u110B\u116F\u11AF
\u110B\u1169\u110C\u1165\u11AB
\u110B\u1169\u110C\u1175\u11A8
\u110B\u1169\u110C\u1175\u11BC\u110B\u1165
\u110B\u1169\u1111\u1166\u1105\u1161
\u110B\u1169\u1111\u1175\u1109\u1173\u1110\u1166\u11AF
\u110B\u1169\u1112\u1175\u1105\u1167
\u110B\u1169\u11A8\u1109\u1161\u11BC
\u110B\u1169\u11A8\u1109\u116E\u1109\u116E
\u110B\u1169\u11AB\u1100\u1161\u11BD
\u110B\u1169\u11AB\u1105\u1161\u110B\u1175\u11AB
\u110B\u1169\u11AB\u1106\u1169\u11B7
\u110B\u1169\u11AB\u110C\u1169\u11BC\u110B\u1175\u11AF
\u110B\u1169\u11AB\u1110\u1169\u11BC
\u110B\u1169\u11AF\u1100\u1161\u110B\u1173\u11AF
\u110B\u1169\u11AF\u1105\u1175\u11B7\u1111\u1175\u11A8
\u110B\u1169\u11AF\u1112\u1162
\u110B\u1169\u11BA\u110E\u1161\u1105\u1175\u11B7
\u110B\u116A\u110B\u1175\u1109\u1167\u110E\u1173
\u110B\u116A\u110B\u1175\u11AB
\u110B\u116A\u11AB\u1109\u1165\u11BC
\u110B\u116A\u11AB\u110C\u1165\u11AB
\u110B\u116A\u11BC\u1107\u1175
\u110B\u116A\u11BC\u110C\u1161
\u110B\u116B\u1102\u1163\u1112\u1161\u1106\u1167\u11AB
\u110B\u116B\u11AB\u110C\u1175
\u110B\u116C\u1100\u1161\u11BA\u110C\u1175\u11B8
\u110B\u116C\u1100\u116E\u11A8
\u110B\u116C\u1105\u1169\u110B\u116E\u11B7
\u110B\u116C\u1109\u1161\u11B7\u110E\u1169\u11AB
\u110B\u116C\u110E\u116E\u11AF
\u110B\u116C\u110E\u1175\u11B7
\u110B\u116C\u1112\u1161\u11AF\u1106\u1165\u1102\u1175
\u110B\u116C\u11AB\u1107\u1161\u11AF
\u110B\u116C\u11AB\u1109\u1169\u11AB
\u110B\u116C\u11AB\u110D\u1169\u11A8
\u110B\u116D\u1100\u1173\u11B7
\u110B\u116D\u110B\u1175\u11AF
\u110B\u116D\u110C\u1173\u11B7
\u110B\u116D\u110E\u1165\u11BC
\u110B\u116D\u11BC\u1100\u1175
\u110B\u116D\u11BC\u1109\u1165
\u110B\u116D\u11BC\u110B\u1165
\u110B\u116E\u1109\u1161\u11AB
\u110B\u116E\u1109\u1165\u11AB
\u110B\u116E\u1109\u1173\u11BC
\u110B\u116E\u110B\u1167\u11AB\u1112\u1175
\u110B\u116E\u110C\u1165\u11BC
\u110B\u116E\u110E\u1166\u1100\u116E\u11A8
\u110B\u116E\u1111\u1167\u11AB
\u110B\u116E\u11AB\u1103\u1169\u11BC
\u110B\u116E\u11AB\u1106\u1167\u11BC
\u110B\u116E\u11AB\u1107\u1161\u11AB
\u110B\u116E\u11AB\u110C\u1165\u11AB
\u110B\u116E\u11AB\u1112\u1162\u11BC
\u110B\u116E\u11AF\u1109\u1161\u11AB
\u110B\u116E\u11AF\u110B\u1173\u11B7
\u110B\u116E\u11B7\u110C\u1175\u11A8\u110B\u1175\u11B7
\u110B\u116E\u11BA\u110B\u1165\u1105\u1173\u11AB
\u110B\u116E\u11BA\u110B\u1173\u11B7
\u110B\u116F\u1102\u1161\u11A8
\u110B\u116F\u11AB\u1100\u1169
\u110B\u116F\u11AB\u1105\u1162
\u110B\u116F\u11AB\u1109\u1165
\u110B\u116F\u11AB\u1109\u116E\u11BC\u110B\u1175
\u110B\u116F\u11AB\u110B\u1175\u11AB
\u110B\u116F\u11AB\u110C\u1161\u11BC
\u110B\u116F\u11AB\u1111\u1175\u1109\u1173
\u110B\u116F\u11AF\u1100\u1173\u11B8
\u110B\u116F\u11AF\u1103\u1173\u110F\u1165\u11B8
\u110B\u116F\u11AF\u1109\u1166
\u110B\u116F\u11AF\u110B\u116D\u110B\u1175\u11AF
\u110B\u1170\u110B\u1175\u1110\u1165
\u110B\u1171\u1107\u1161\u11AB
\u110B\u1171\u1107\u1165\u11B8
\u110B\u1171\u1109\u1165\u11BC
\u110B\u1171\u110B\u116F\u11AB
\u110B\u1171\u1112\u1165\u11B7
\u110B\u1171\u1112\u1167\u11B8
\u110B\u1171\u11BA\u1109\u1161\u1105\u1161\u11B7
\u110B\u1172\u1102\u1161\u11AB\u1112\u1175
\u110B\u1172\u1105\u1165\u11B8
\u110B\u1172\u1106\u1167\u11BC
\u110B\u1172\u1106\u116E\u11AF
\u110B\u1172\u1109\u1161\u11AB
\u110B\u1172\u110C\u1165\u11A8
\u110B\u1172\u110E\u1175\u110B\u116F\u11AB
\u110B\u1172\u1112\u1161\u11A8
\u110B\u1172\u1112\u1162\u11BC
\u110B\u1172\u1112\u1167\u11BC
\u110B\u1172\u11A8\u1100\u116E\u11AB
\u110B\u1172\u11A8\u1109\u1161\u11BC
\u110B\u1172\u11A8\u1109\u1175\u11B8
\u110B\u1172\u11A8\u110E\u1166
\u110B\u1173\u11AB\u1112\u1162\u11BC
\u110B\u1173\u11B7\u1105\u1167\u11A8
\u110B\u1173\u11B7\u1105\u116D
\u110B\u1173\u11B7\u1107\u1161\u11AB
\u110B\u1173\u11B7\u1109\u1165\u11BC
\u110B\u1173\u11B7\u1109\u1175\u11A8
\u110B\u1173\u11B7\u110B\u1161\u11A8
\u110B\u1173\u11B7\u110C\u116E
\u110B\u1174\u1100\u1167\u11AB
\u110B\u1174\u1102\u1169\u11AB
\u110B\u1174\u1106\u116E\u11AB
\u110B\u1174\u1107\u1169\u11A8
\u110B\u1174\u1109\u1175\u11A8
\u110B\u1174\u1109\u1175\u11B7
\u110B\u1174\u110B\u116C\u1105\u1169
\u110B\u1174\u110B\u116D\u11A8
\u110B\u1174\u110B\u116F\u11AB
\u110B\u1174\u1112\u1161\u11A8
\u110B\u1175\u1100\u1165\u11BA
\u110B\u1175\u1100\u1169\u11BA
\u110B\u1175\u1102\u1167\u11B7
\u110B\u1175\u1102\u1169\u11B7
\u110B\u1175\u1103\u1161\u11AF
\u110B\u1175\u1103\u1162\u1105\u1169
\u110B\u1175\u1103\u1169\u11BC
\u110B\u1175\u1105\u1165\u11C2\u1100\u1166
\u110B\u1175\u1105\u1167\u11A8\u1109\u1165
\u110B\u1175\u1105\u1169\u11AB\u110C\u1165\u11A8
\u110B\u1175\u1105\u1173\u11B7
\u110B\u1175\u1106\u1175\u11AB
\u110B\u1175\u1107\u1161\u11AF\u1109\u1169
\u110B\u1175\u1107\u1167\u11AF
\u110B\u1175\u1107\u116E\u11AF
\u110B\u1175\u1108\u1161\u11AF
\u110B\u1175\u1109\u1161\u11BC
\u110B\u1175\u1109\u1165\u11BC
\u110B\u1175\u1109\u1173\u11AF
\u110B\u1175\u110B\u1163\u1100\u1175
\u110B\u1175\u110B\u116D\u11BC
\u110B\u1175\u110B\u116E\u11BA
\u110B\u1175\u110B\u116F\u11AF
\u110B\u1175\u110B\u1173\u11A8\u1100\u1169
\u110B\u1175\u110B\u1175\u11A8
\u110B\u1175\u110C\u1165\u11AB
\u110B\u1175\u110C\u116E\u11BC
\u110B\u1175\u1110\u1173\u11AE\u1102\u1161\u11AF
\u110B\u1175\u1110\u1173\u11AF
\u110B\u1175\u1112\u1169\u11AB
\u110B\u1175\u11AB\u1100\u1161\u11AB
\u110B\u1175\u11AB\u1100\u1167\u11A8
\u110B\u1175\u11AB\u1100\u1169\u11BC
\u110B\u1175\u11AB\u1100\u116E
\u110B\u1175\u11AB\u1100\u1173\u11AB
\u110B\u1175\u11AB\u1100\u1175
\u110B\u1175\u11AB\u1103\u1169
\u110B\u1175\u11AB\u1105\u1172
\u110B\u1175\u11AB\u1106\u116E\u11AF
\u110B\u1175\u11AB\u1109\u1162\u11BC
\u110B\u1175\u11AB\u1109\u116B
\u110B\u1175\u11AB\u110B\u1167\u11AB
\u110B\u1175\u11AB\u110B\u116F\u11AB
\u110B\u1175\u11AB\u110C\u1162
\u110B\u1175\u11AB\u110C\u1169\u11BC
\u110B\u1175\u11AB\u110E\u1165\u11AB
\u110B\u1175\u11AB\u110E\u1166
\u110B\u1175\u11AB\u1110\u1165\u1102\u1166\u11BA
\u110B\u1175\u11AB\u1112\u1161
\u110B\u1175\u11AB\u1112\u1167\u11BC
\u110B\u1175\u11AF\u1100\u1169\u11B8
\u110B\u1175\u11AF\u1100\u1175
\u110B\u1175\u11AF\u1103\u1161\u11AB
\u110B\u1175\u11AF\u1103\u1162
\u110B\u1175\u11AF\u1103\u1173\u11BC
\u110B\u1175\u11AF\u1107\u1161\u11AB
\u110B\u1175\u11AF\u1107\u1169\u11AB
\u110B\u1175\u11AF\u1107\u116E
\u110B\u1175\u11AF\u1109\u1161\u11BC
\u110B\u1175\u11AF\u1109\u1162\u11BC
\u110B\u1175\u11AF\u1109\u1169\u11AB
\u110B\u1175\u11AF\u110B\u116D\u110B\u1175\u11AF
\u110B\u1175\u11AF\u110B\u116F\u11AF
\u110B\u1175\u11AF\u110C\u1165\u11BC
\u110B\u1175\u11AF\u110C\u1169\u11BC
\u110B\u1175\u11AF\u110C\u116E\u110B\u1175\u11AF
\u110B\u1175\u11AF\u110D\u1175\u11A8
\u110B\u1175\u11AF\u110E\u1166
\u110B\u1175\u11AF\u110E\u1175
\u110B\u1175\u11AF\u1112\u1162\u11BC
\u110B\u1175\u11AF\u1112\u116C\u110B\u116D\u11BC
\u110B\u1175\u11B7\u1100\u1173\u11B7
\u110B\u1175\u11B7\u1106\u116E
\u110B\u1175\u11B8\u1103\u1162
\u110B\u1175\u11B8\u1105\u1167\u11A8
\u110B\u1175\u11B8\u1106\u1161\u11BA
\u110B\u1175\u11B8\u1109\u1161
\u110B\u1175\u11B8\u1109\u116E\u11AF
\u110B\u1175\u11B8\u1109\u1175
\u110B\u1175\u11B8\u110B\u116F\u11AB
\u110B\u1175\u11B8\u110C\u1161\u11BC
\u110B\u1175\u11B8\u1112\u1161\u11A8
\u110C\u1161\u1100\u1161\u110B\u116D\u11BC
\u110C\u1161\u1100\u1167\u11A8
\u110C\u1161\u1100\u1173\u11A8
\u110C\u1161\u1103\u1169\u11BC
\u110C\u1161\u1105\u1161\u11BC
\u110C\u1161\u1107\u116E\u1109\u1175\u11B7
\u110C\u1161\u1109\u1175\u11A8
\u110C\u1161\u1109\u1175\u11AB
\u110C\u1161\u110B\u1167\u11AB
\u110C\u1161\u110B\u116F\u11AB
\u110C\u1161\u110B\u1172\u11AF
\u110C\u1161\u110C\u1165\u11AB\u1100\u1165
\u110C\u1161\u110C\u1165\u11BC
\u110C\u1161\u110C\u1169\u11AB\u1109\u1175\u11B7
\u110C\u1161\u1111\u1161\u11AB
\u110C\u1161\u11A8\u1100\u1161
\u110C\u1161\u11A8\u1102\u1167\u11AB
\u110C\u1161\u11A8\u1109\u1165\u11BC
\u110C\u1161\u11A8\u110B\u1165\u11B8
\u110C\u1161\u11A8\u110B\u116D\u11BC
\u110C\u1161\u11A8\u110B\u1173\u11AB\u1104\u1161\u11AF
\u110C\u1161\u11A8\u1111\u116E\u11B7
\u110C\u1161\u11AB\u1103\u1175
\u110C\u1161\u11AB\u1104\u1173\u11A8
\u110C\u1161\u11AB\u110E\u1175
\u110C\u1161\u11AF\u1106\u1169\u11BA
\u110C\u1161\u11B7\u1101\u1161\u11AB
\u110C\u1161\u11B7\u1109\u116E\u1112\u1161\u11B7
\u110C\u1161\u11B7\u1109\u1175
\u110C\u1161\u11B7\u110B\u1169\u11BA
\u110C\u1161\u11B7\u110C\u1161\u1105\u1175
\u110C\u1161\u11B8\u110C\u1175
\u110C\u1161\u11BC\u1100\u116A\u11AB
\u110C\u1161\u11BC\u1100\u116E\u11AB
\u110C\u1161\u11BC\u1100\u1175\u1100\u1161\u11AB
\u110C\u1161\u11BC\u1105\u1162
\u110C\u1161\u11BC\u1105\u1168
\u110C\u1161\u11BC\u1105\u1173
\u110C\u1161\u11BC\u1106\u1161
\u110C\u1161\u11BC\u1106\u1167\u11AB
\u110C\u1161\u11BC\u1106\u1169
\u110C\u1161\u11BC\u1106\u1175
\u110C\u1161\u11BC\u1107\u1175
\u110C\u1161\u11BC\u1109\u1161
\u110C\u1161\u11BC\u1109\u1169
\u110C\u1161\u11BC\u1109\u1175\u11A8
\u110C\u1161\u11BC\u110B\u1162\u110B\u1175\u11AB
\u110C\u1161\u11BC\u110B\u1175\u11AB
\u110C\u1161\u11BC\u110C\u1165\u11B7
\u110C\u1161\u11BC\u110E\u1161
\u110C\u1161\u11BC\u1112\u1161\u11A8\u1100\u1173\u11B7
\u110C\u1162\u1102\u1173\u11BC
\u110C\u1162\u1108\u1161\u11AF\u1105\u1175
\u110C\u1162\u1109\u1161\u11AB
\u110C\u1162\u1109\u1162\u11BC
\u110C\u1162\u110C\u1161\u11A8\u1102\u1167\u11AB
\u110C\u1162\u110C\u1165\u11BC
\u110C\u1162\u110E\u1162\u1100\u1175
\u110C\u1162\u1111\u1161\u11AB
\u110C\u1162\u1112\u1161\u11A8
\u110C\u1162\u1112\u116A\u11AF\u110B\u116D\u11BC
\u110C\u1165\u1100\u1165\u11BA
\u110C\u1165\u1100\u1169\u1105\u1175
\u110C\u1165\u1100\u1169\u11BA
\u110C\u1165\u1102\u1167\u11A8
\u110C\u1165\u1105\u1165\u11AB
\u110C\u1165\u1105\u1165\u11C2\u1100\u1166
\u110C\u1165\u1107\u1165\u11AB
\u110C\u1165\u110B\u116E\u11AF
\u110C\u1165\u110C\u1165\u11AF\u1105\u1169
\u110C\u1165\u110E\u116E\u11A8
\u110C\u1165\u11A8\u1100\u1173\u11A8
\u110C\u1165\u11A8\u1103\u1161\u11BC\u1112\u1175
\u110C\u1165\u11A8\u1109\u1165\u11BC
\u110C\u1165\u11A8\u110B\u116D\u11BC
\u110C\u1165\u11A8\u110B\u1173\u11BC
\u110C\u1165\u11AB\u1100\u1162
\u110C\u1165\u11AB\u1100\u1169\u11BC
\u110C\u1165\u11AB\u1100\u1175
\u110C\u1165\u11AB\u1103\u1161\u11AF
\u110C\u1165\u11AB\u1105\u1161\u1103\u1169
\u110C\u1165\u11AB\u1106\u1161\u11BC
\u110C\u1165\u11AB\u1106\u116E\u11AB
\u110C\u1165\u11AB\u1107\u1161\u11AB
\u110C\u1165\u11AB\u1107\u116E
\u110C\u1165\u11AB\u1109\u1166
\u110C\u1165\u11AB\u1109\u1175
\u110C\u1165\u11AB\u110B\u116D\u11BC
\u110C\u1165\u11AB\u110C\u1161
\u110C\u1165\u11AB\u110C\u1162\u11BC
\u110C\u1165\u11AB\u110C\u116E
\u110C\u1165\u11AB\u110E\u1165\u11AF
\u110C\u1165\u11AB\u110E\u1166
\u110C\u1165\u11AB\u1110\u1169\u11BC
\u110C\u1165\u11AB\u1112\u1167
\u110C\u1165\u11AB\u1112\u116E
\u110C\u1165\u11AF\u1103\u1162
\u110C\u1165\u11AF\u1106\u1161\u11BC
\u110C\u1165\u11AF\u1107\u1161\u11AB
\u110C\u1165\u11AF\u110B\u1163\u11A8
\u110C\u1165\u11AF\u110E\u1161
\u110C\u1165\u11B7\u1100\u1165\u11B7
\u110C\u1165\u11B7\u1109\u116E
\u110C\u1165\u11B7\u1109\u1175\u11B7
\u110C\u1165\u11B7\u110B\u116F\u11AB
\u110C\u1165\u11B7\u110C\u1165\u11B7
\u110C\u1165\u11B7\u110E\u1161
\u110C\u1165\u11B8\u1100\u1173\u11AB
\u110C\u1165\u11B8\u1109\u1175
\u110C\u1165\u11B8\u110E\u1169\u11A8
\u110C\u1165\u11BA\u1100\u1161\u1105\u1161\u11A8
\u110C\u1165\u11BC\u1100\u1165\u110C\u1161\u11BC
\u110C\u1165\u11BC\u1103\u1169
\u110C\u1165\u11BC\u1105\u1172\u110C\u1161\u11BC
\u110C\u1165\u11BC\u1105\u1175
\u110C\u1165\u11BC\u1106\u1161\u11AF
\u110C\u1165\u11BC\u1106\u1167\u11AB
\u110C\u1165\u11BC\u1106\u116E\u11AB
\u110C\u1165\u11BC\u1107\u1161\u11AB\u1103\u1162
\u110C\u1165\u11BC\u1107\u1169
\u110C\u1165\u11BC\u1107\u116E
\u110C\u1165\u11BC\u1107\u1175
\u110C\u1165\u11BC\u1109\u1161\u11BC
\u110C\u1165\u11BC\u1109\u1165\u11BC
\u110C\u1165\u11BC\u110B\u1169
\u110C\u1165\u11BC\u110B\u116F\u11AB
\u110C\u1165\u11BC\u110C\u1161\u11BC
\u110C\u1165\u11BC\u110C\u1175
\u110C\u1165\u11BC\u110E\u1175
\u110C\u1165\u11BC\u1112\u116A\u11A8\u1112\u1175
\u110C\u1166\u1100\u1169\u11BC
\u110C\u1166\u1100\u116A\u110C\u1165\u11B7
\u110C\u1166\u1103\u1162\u1105\u1169
\u110C\u1166\u1106\u1169\u11A8
\u110C\u1166\u1107\u1161\u11AF
\u110C\u1166\u1107\u1165\u11B8
\u110C\u1166\u1109\u1161\u11BA\u1102\u1161\u11AF
\u110C\u1166\u110B\u1161\u11AB
\u110C\u1166\u110B\u1175\u11AF
\u110C\u1166\u110C\u1161\u11A8
\u110C\u1166\u110C\u116E\u1103\u1169
\u110C\u1166\u110E\u116E\u11AF
\u110C\u1166\u1111\u116E\u11B7
\u110C\u1166\u1112\u1161\u11AB
\u110C\u1169\u1100\u1161\u11A8
\u110C\u1169\u1100\u1165\u11AB
\u110C\u1169\u1100\u1173\u11B7
\u110C\u1169\u1100\u1175\u11BC
\u110C\u1169\u1106\u1167\u11BC
\u110C\u1169\u1106\u1175\u1105\u116D
\u110C\u1169\u1109\u1161\u11BC
\u110C\u1169\u1109\u1165\u11AB
\u110C\u1169\u110B\u116D\u11BC\u1112\u1175
\u110C\u1169\u110C\u1165\u11AF
\u110C\u1169\u110C\u1165\u11BC
\u110C\u1169\u110C\u1175\u11A8
\u110C\u1169\u11AB\u1103\u1162\u11BA\u1106\u1161\u11AF
\u110C\u1169\u11AB\u110C\u1162
\u110C\u1169\u11AF\u110B\u1165\u11B8
\u110C\u1169\u11AF\u110B\u1173\u11B7
\u110C\u1169\u11BC\u1100\u116D
\u110C\u1169\u11BC\u1105\u1169
\u110C\u1169\u11BC\u1105\u1172
\u110C\u1169\u11BC\u1109\u1169\u1105\u1175
\u110C\u1169\u11BC\u110B\u1165\u11B8\u110B\u116F\u11AB
\u110C\u1169\u11BC\u110C\u1169\u11BC
\u110C\u1169\u11BC\u1112\u1161\u11B8
\u110C\u116A\u1109\u1165\u11A8
\u110C\u116C\u110B\u1175\u11AB
\u110C\u116E\u1100\u116A\u11AB\u110C\u1165\u11A8
\u110C\u116E\u1105\u1173\u11B7
\u110C\u116E\u1106\u1161\u11AF
\u110C\u116E\u1106\u1165\u1102\u1175
\u110C\u116E\u1106\u1165\u11A8
\u110C\u116E\u1106\u116E\u11AB
\u110C\u116E\u1106\u1175\u11AB
\u110C\u116E\u1107\u1161\u11BC
\u110C\u116E\u1107\u1167\u11AB
\u110C\u116E\u1109\u1175\u11A8
\u110C\u116E\u110B\u1175\u11AB
\u110C\u116E\u110B\u1175\u11AF
\u110C\u116E\u110C\u1161\u11BC
\u110C\u116E\u110C\u1165\u11AB\u110C\u1161
\u110C\u116E\u1110\u1162\u11A8
\u110C\u116E\u11AB\u1107\u1175
\u110C\u116E\u11AF\u1100\u1165\u1105\u1175
\u110C\u116E\u11AF\u1100\u1175
\u110C\u116E\u11AF\u1106\u116E\u1102\u1174
\u110C\u116E\u11BC\u1100\u1161\u11AB
\u110C\u116E\u11BC\u1100\u1168\u1107\u1161\u11BC\u1109\u1169\u11BC
\u110C\u116E\u11BC\u1100\u116E\u11A8
\u110C\u116E\u11BC\u1102\u1167\u11AB
\u110C\u116E\u11BC\u1103\u1161\u11AB
\u110C\u116E\u11BC\u1103\u1169\u11A8
\u110C\u116E\u11BC\u1107\u1161\u11AB
\u110C\u116E\u11BC\u1107\u116E
\u110C\u116E\u11BC\u1109\u1166
\u110C\u116E\u11BC\u1109\u1169\u1100\u1175\u110B\u1165\u11B8
\u110C\u116E\u11BC\u1109\u116E\u11AB
\u110C\u116E\u11BC\u110B\u1161\u11BC
\u110C\u116E\u11BC\u110B\u116D
\u110C\u116E\u11BC\u1112\u1161\u11A8\u1100\u116D
\u110C\u1173\u11A8\u1109\u1165\u11A8
\u110C\u1173\u11A8\u1109\u1175
\u110C\u1173\u11AF\u1100\u1165\u110B\u116E\u11B7
\u110C\u1173\u11BC\u1100\u1161
\u110C\u1173\u11BC\u1100\u1165
\u110C\u1173\u11BC\u1100\u116F\u11AB
\u110C\u1173\u11BC\u1109\u1161\u11BC
\u110C\u1173\u11BC\u1109\u1166
\u110C\u1175\u1100\u1161\u11A8
\u110C\u1175\u1100\u1161\u11B8
\u110C\u1175\u1100\u1167\u11BC
\u110C\u1175\u1100\u1173\u11A8\u1112\u1175
\u110C\u1175\u1100\u1173\u11B7
\u110C\u1175\u1100\u1173\u11B8
\u110C\u1175\u1102\u1173\u11BC
\u110C\u1175\u1105\u1173\u11B7\u1100\u1175\u11AF
\u110C\u1175\u1105\u1175\u1109\u1161\u11AB
\u110C\u1175\u1107\u1161\u11BC
\u110C\u1175\u1107\u116E\u11BC
\u110C\u1175\u1109\u1175\u11A8
\u110C\u1175\u110B\u1167\u11A8
\u110C\u1175\u110B\u116E\u1100\u1162
\u110C\u1175\u110B\u116F\u11AB
\u110C\u1175\u110C\u1165\u11A8
\u110C\u1175\u110C\u1165\u11B7
\u110C\u1175\u110C\u1175\u11AB
\u110C\u1175\u110E\u116E\u11AF
\u110C\u1175\u11A8\u1109\u1165\u11AB
\u110C\u1175\u11A8\u110B\u1165\u11B8
\u110C\u1175\u11A8\u110B\u116F\u11AB
\u110C\u1175\u11A8\u110C\u1161\u11BC
\u110C\u1175\u11AB\u1100\u1173\u11B8
\u110C\u1175\u11AB\u1103\u1169\u11BC
\u110C\u1175\u11AB\u1105\u1169
\u110C\u1175\u11AB\u1105\u116D
\u110C\u1175\u11AB\u1105\u1175
\u110C\u1175\u11AB\u110D\u1161
\u110C\u1175\u11AB\u110E\u1161\u11AF
\u110C\u1175\u11AB\u110E\u116E\u11AF
\u110C\u1175\u11AB\u1110\u1169\u11BC
\u110C\u1175\u11AB\u1112\u1162\u11BC
\u110C\u1175\u11AF\u1106\u116E\u11AB
\u110C\u1175\u11AF\u1107\u1167\u11BC
\u110C\u1175\u11AF\u1109\u1165
\u110C\u1175\u11B7\u110C\u1161\u11A8
\u110C\u1175\u11B8\u1103\u1161\u11AB
\u110C\u1175\u11B8\u110B\u1161\u11AB
\u110C\u1175\u11B8\u110C\u116E\u11BC
\u110D\u1161\u110C\u1173\u11BC
\u110D\u1175\u1101\u1165\u1100\u1175
\u110E\u1161\u1102\u1161\u11B7
\u110E\u1161\u1105\u1161\u1105\u1175
\u110E\u1161\u1105\u1163\u11BC
\u110E\u1161\u1105\u1175\u11B7
\u110E\u1161\u1107\u1167\u11AF
\u110E\u1161\u1109\u1165\u11AB
\u110E\u1161\u110E\u1173\u11B7
\u110E\u1161\u11A8\u1100\u1161\u11A8
\u110E\u1161\u11AB\u1106\u116E\u11AF
\u110E\u1161\u11AB\u1109\u1165\u11BC
\u110E\u1161\u11B7\u1100\u1161
\u110E\u1161\u11B7\u1100\u1175\u1105\u1173\u11B7
\u110E\u1161\u11B7\u1109\u1162
\u110E\u1161\u11B7\u1109\u1165\u11A8
\u110E\u1161\u11B7\u110B\u1167
\u110E\u1161\u11B7\u110B\u116C
\u110E\u1161\u11B7\u110C\u1169
\u110E\u1161\u11BA\u110C\u1161\u11AB
\u110E\u1161\u11BC\u1100\u1161
\u110E\u1161\u11BC\u1100\u1169
\u110E\u1161\u11BC\u1100\u116E
\u110E\u1161\u11BC\u1106\u116E\u11AB
\u110E\u1161\u11BC\u1107\u1161\u11A9
\u110E\u1161\u11BC\u110C\u1161\u11A8
\u110E\u1161\u11BC\u110C\u1169
\u110E\u1162\u1102\u1165\u11AF
\u110E\u1162\u110C\u1165\u11B7
\u110E\u1162\u11A8\u1100\u1161\u1107\u1161\u11BC
\u110E\u1162\u11A8\u1107\u1161\u11BC
\u110E\u1162\u11A8\u1109\u1161\u11BC
\u110E\u1162\u11A8\u110B\u1175\u11B7
\u110E\u1162\u11B7\u1111\u1175\u110B\u1165\u11AB
\u110E\u1165\u1107\u1165\u11AF
\u110E\u1165\u110B\u1173\u11B7
\u110E\u1165\u11AB\u1100\u116E\u11A8
\u110E\u1165\u11AB\u1103\u116E\u11BC
\u110E\u1165\u11AB\u110C\u1161\u11BC
\u110E\u1165\u11AB\u110C\u1162
\u110E\u1165\u11AB\u110E\u1165\u11AB\u1112\u1175
\u110E\u1165\u11AF\u1103\u1169
\u110E\u1165\u11AF\u110C\u1165\u1112\u1175
\u110E\u1165\u11AF\u1112\u1161\u11A8
\u110E\u1165\u11BA\u1102\u1161\u11AF
\u110E\u1165\u11BA\u110D\u1162
\u110E\u1165\u11BC\u1102\u1167\u11AB
\u110E\u1165\u11BC\u1107\u1161\u110C\u1175
\u110E\u1165\u11BC\u1109\u1169
\u110E\u1165\u11BC\u110E\u116E\u11AB
\u110E\u1166\u1100\u1168
\u110E\u1166\u1105\u1167\u11A8
\u110E\u1166\u110B\u1169\u11AB
\u110E\u1166\u110B\u1172\u11A8
\u110E\u1166\u110C\u116E\u11BC
\u110E\u1166\u1112\u1165\u11B7
\u110E\u1169\u1103\u1173\u11BC\u1112\u1161\u11A8\u1109\u1162\u11BC
\u110E\u1169\u1107\u1161\u11AB
\u110E\u1169\u1107\u1161\u11B8
\u110E\u1169\u1109\u1161\u11BC\u1112\u116A
\u110E\u1169\u1109\u116E\u11AB
\u110E\u1169\u110B\u1167\u1105\u1173\u11B7
\u110E\u1169\u110B\u116F\u11AB
\u110E\u1169\u110C\u1165\u1102\u1167\u11A8
\u110E\u1169\u110C\u1165\u11B7
\u110E\u1169\u110E\u1165\u11BC
\u110E\u1169\u110F\u1169\u11AF\u1105\u1175\u11BA
\u110E\u1169\u11BA\u1107\u116E\u11AF
\u110E\u1169\u11BC\u1100\u1161\u11A8
\u110E\u1169\u11BC\u1105\u1175
\u110E\u1169\u11BC\u110C\u1161\u11BC
\u110E\u116A\u11AF\u110B\u1167\u11BC
\u110E\u116C\u1100\u1173\u11AB
\u110E\u116C\u1109\u1161\u11BC
\u110E\u116C\u1109\u1165\u11AB
\u110E\u116C\u1109\u1175\u11AB
\u110E\u116C\u110B\u1161\u11A8
\u110E\u116C\u110C\u1169\u11BC
\u110E\u116E\u1109\u1165\u11A8
\u110E\u116E\u110B\u1165\u11A8
\u110E\u116E\u110C\u1175\u11AB
\u110E\u116E\u110E\u1165\u11AB
\u110E\u116E\u110E\u1173\u11A8
\u110E\u116E\u11A8\u1100\u116E
\u110E\u116E\u11A8\u1109\u1169
\u110E\u116E\u11A8\u110C\u1166
\u110E\u116E\u11A8\u1112\u1161
\u110E\u116E\u11AF\u1100\u1173\u11AB
\u110E\u116E\u11AF\u1107\u1161\u11AF
\u110E\u116E\u11AF\u1109\u1161\u11AB
\u110E\u116E\u11AF\u1109\u1175\u11AB
\u110E\u116E\u11AF\u110B\u1167\u11AB
\u110E\u116E\u11AF\u110B\u1175\u11B8
\u110E\u116E\u11AF\u110C\u1161\u11BC
\u110E\u116E\u11AF\u1111\u1161\u11AB
\u110E\u116E\u11BC\u1100\u1167\u11A8
\u110E\u116E\u11BC\u1100\u1169
\u110E\u116E\u11BC\u1103\u1169\u11AF
\u110E\u116E\u11BC\u1107\u116E\u11AB\u1112\u1175
\u110E\u116E\u11BC\u110E\u1165\u11BC\u1103\u1169
\u110E\u1171\u110B\u1165\u11B8
\u110E\u1171\u110C\u1175\u11A8
\u110E\u1171\u1112\u1163\u11BC
\u110E\u1175\u110B\u1163\u11A8
\u110E\u1175\u11AB\u1100\u116E
\u110E\u1175\u11AB\u110E\u1165\u11A8
\u110E\u1175\u11AF\u1109\u1175\u11B8
\u110E\u1175\u11AF\u110B\u116F\u11AF
\u110E\u1175\u11AF\u1111\u1161\u11AB
\u110E\u1175\u11B7\u1103\u1162
\u110E\u1175\u11B7\u1106\u116E\u11A8
\u110E\u1175\u11B7\u1109\u1175\u11AF
\u110E\u1175\u11BA\u1109\u1169\u11AF
\u110E\u1175\u11BC\u110E\u1161\u11AB
\u110F\u1161\u1106\u1166\u1105\u1161
\u110F\u1161\u110B\u116E\u11AB\u1110\u1165
\u110F\u1161\u11AF\u1100\u116E\u11A8\u1109\u116E
\u110F\u1162\u1105\u1175\u11A8\u1110\u1165
\u110F\u1162\u11B7\u1111\u1165\u1109\u1173
\u110F\u1162\u11B7\u1111\u1166\u110B\u1175\u11AB
\u110F\u1165\u1110\u1173\u11AB
\u110F\u1165\u11AB\u1103\u1175\u1109\u1167\u11AB
\u110F\u1165\u11AF\u1105\u1165
\u110F\u1165\u11B7\u1111\u1172\u1110\u1165
\u110F\u1169\u1101\u1175\u1105\u1175
\u110F\u1169\u1106\u1175\u1103\u1175
\u110F\u1169\u11AB\u1109\u1165\u1110\u1173
\u110F\u1169\u11AF\u1105\u1161
\u110F\u1169\u11B7\u1111\u1173\u11AF\u1105\u1166\u11A8\u1109\u1173
\u110F\u1169\u11BC\u1102\u1161\u1106\u116E\u11AF
\u110F\u116B\u1100\u1161\u11B7
\u110F\u116E\u1103\u1166\u1110\u1161
\u110F\u1173\u1105\u1175\u11B7
\u110F\u1173\u11AB\u1100\u1175\u11AF
\u110F\u1173\u11AB\u1104\u1161\u11AF
\u110F\u1173\u11AB\u1109\u1169\u1105\u1175
\u110F\u1173\u11AB\u110B\u1161\u1103\u1173\u11AF
\u110F\u1173\u11AB\u110B\u1165\u1106\u1165\u1102\u1175
\u110F\u1173\u11AB\u110B\u1175\u11AF
\u110F\u1173\u11AB\u110C\u1165\u11AF
\u110F\u1173\u11AF\u1105\u1162\u1109\u1175\u11A8
\u110F\u1173\u11AF\u1105\u1165\u11B8
\u110F\u1175\u11AF\u1105\u1169
\u1110\u1161\u110B\u1175\u11B8
\u1110\u1161\u110C\u1161\u1100\u1175
\u1110\u1161\u11A8\u1100\u116E
\u1110\u1161\u11A8\u110C\u1161
\u1110\u1161\u11AB\u1109\u1162\u11BC
\u1110\u1162\u1100\u116F\u11AB\u1103\u1169
\u1110\u1162\u110B\u1163\u11BC
\u1110\u1162\u1111\u116E\u11BC
\u1110\u1162\u11A8\u1109\u1175
\u1110\u1162\u11AF\u1105\u1165\u11AB\u1110\u1173
\u1110\u1165\u1102\u1165\u11AF
\u1110\u1165\u1106\u1175\u1102\u1165\u11AF
\u1110\u1166\u1102\u1175\u1109\u1173
\u1110\u1166\u1109\u1173\u1110\u1173
\u1110\u1166\u110B\u1175\u1107\u1173\u11AF
\u1110\u1166\u11AF\u1105\u1166\u1107\u1175\u110C\u1165\u11AB
\u1110\u1169\u1105\u1169\u11AB
\u1110\u1169\u1106\u1161\u1110\u1169
\u1110\u1169\u110B\u116D\u110B\u1175\u11AF
\u1110\u1169\u11BC\u1100\u1168
\u1110\u1169\u11BC\u1100\u116A
\u1110\u1169\u11BC\u1105\u1169
\u1110\u1169\u11BC\u1109\u1175\u11AB
\u1110\u1169\u11BC\u110B\u1167\u11A8
\u1110\u1169\u11BC\u110B\u1175\u11AF
\u1110\u1169\u11BC\u110C\u1161\u11BC
\u1110\u1169\u11BC\u110C\u1166
\u1110\u1169\u11BC\u110C\u1173\u11BC
\u1110\u1169\u11BC\u1112\u1161\u11B8
\u1110\u1169\u11BC\u1112\u116A
\u1110\u116C\u1100\u1173\u11AB
\u1110\u116C\u110B\u116F\u11AB
\u1110\u116C\u110C\u1175\u11A8\u1100\u1173\u11B7
\u1110\u1171\u1100\u1175\u11B7
\u1110\u1173\u1105\u1165\u11A8
\u1110\u1173\u11A8\u1100\u1173\u11B8
\u1110\u1173\u11A8\u1107\u1167\u11AF
\u1110\u1173\u11A8\u1109\u1165\u11BC
\u1110\u1173\u11A8\u1109\u116E
\u1110\u1173\u11A8\u110C\u1175\u11BC
\u1110\u1173\u11A8\u1112\u1175
\u1110\u1173\u11AB\u1110\u1173\u11AB\u1112\u1175
\u1110\u1175\u1109\u1167\u110E\u1173
\u1111\u1161\u1105\u1161\u11AB\u1109\u1162\u11A8
\u1111\u1161\u110B\u1175\u11AF
\u1111\u1161\u110E\u116E\u11AF\u1109\u1169
\u1111\u1161\u11AB\u1100\u1167\u11AF
\u1111\u1161\u11AB\u1103\u1161\u11AB
\u1111\u1161\u11AB\u1106\u1162
\u1111\u1161\u11AB\u1109\u1161
\u1111\u1161\u11AF\u1109\u1175\u11B8
\u1111\u1161\u11AF\u110B\u116F\u11AF
\u1111\u1161\u11B8\u1109\u1169\u11BC
\u1111\u1162\u1109\u1167\u11AB
\u1111\u1162\u11A8\u1109\u1173
\u1111\u1162\u11A8\u1109\u1175\u1106\u1175\u11AF\u1105\u1175
\u1111\u1162\u11AB\u1110\u1175
\u1111\u1165\u1109\u1166\u11AB\u1110\u1173
\u1111\u1166\u110B\u1175\u11AB\u1110\u1173
\u1111\u1167\u11AB\u1100\u1167\u11AB
\u1111\u1167\u11AB\u110B\u1174
\u1111\u1167\u11AB\u110C\u1175
\u1111\u1167\u11AB\u1112\u1175
\u1111\u1167\u11BC\u1100\u1161
\u1111\u1167\u11BC\u1100\u1172\u11AB
\u1111\u1167\u11BC\u1109\u1162\u11BC
\u1111\u1167\u11BC\u1109\u1169
\u1111\u1167\u11BC\u110B\u1163\u11BC
\u1111\u1167\u11BC\u110B\u1175\u11AF
\u1111\u1167\u11BC\u1112\u116A
\u1111\u1169\u1109\u1173\u1110\u1165
\u1111\u1169\u110B\u1175\u11AB\u1110\u1173
\u1111\u1169\u110C\u1161\u11BC
\u1111\u1169\u1112\u1161\u11B7
\u1111\u116D\u1106\u1167\u11AB
\u1111\u116D\u110C\u1165\u11BC
\u1111\u116D\u110C\u116E\u11AB
\u1111\u116D\u1112\u1167\u11AB
\u1111\u116E\u11B7\u1106\u1169\u11A8
\u1111\u116E\u11B7\u110C\u1175\u11AF
\u1111\u116E\u11BC\u1100\u1167\u11BC
\u1111\u116E\u11BC\u1109\u1169\u11A8
\u1111\u116E\u11BC\u1109\u1173\u11B8
\u1111\u1173\u1105\u1161\u11BC\u1109\u1173
\u1111\u1173\u1105\u1175\u11AB\u1110\u1165
\u1111\u1173\u11AF\u1105\u1161\u1109\u1173\u1110\u1175\u11A8
\u1111\u1175\u1100\u1169\u11AB
\u1111\u1175\u1106\u1161\u11BC
\u1111\u1175\u110B\u1161\u1102\u1169
\u1111\u1175\u11AF\u1105\u1173\u11B7
\u1111\u1175\u11AF\u1109\u116E
\u1111\u1175\u11AF\u110B\u116D
\u1111\u1175\u11AF\u110C\u1161
\u1111\u1175\u11AF\u1110\u1169\u11BC
\u1111\u1175\u11BC\u1100\u1168
\u1112\u1161\u1102\u1173\u1102\u1175\u11B7
\u1112\u1161\u1102\u1173\u11AF
\u1112\u1161\u1103\u1173\u110B\u1170\u110B\u1165
\u1112\u1161\u1105\u116E\u11BA\u1107\u1161\u11B7
\u1112\u1161\u1107\u1161\u11AB\u1100\u1175
\u1112\u1161\u1109\u116E\u11A8\u110C\u1175\u11B8
\u1112\u1161\u1109\u116E\u11AB
\u1112\u1161\u110B\u1167\u1110\u1173\u11AB
\u1112\u1161\u110C\u1175\u1106\u1161\u11AB
\u1112\u1161\u110E\u1165\u11AB
\u1112\u1161\u1111\u116E\u11B7
\u1112\u1161\u1111\u1175\u11AF
\u1112\u1161\u11A8\u1100\u116A
\u1112\u1161\u11A8\u1100\u116D
\u1112\u1161\u11A8\u1100\u1173\u11B8
\u1112\u1161\u11A8\u1100\u1175
\u1112\u1161\u11A8\u1102\u1167\u11AB
\u1112\u1161\u11A8\u1105\u1167\u11A8
\u1112\u1161\u11A8\u1107\u1165\u11AB
\u1112\u1161\u11A8\u1107\u116E\u1106\u1169
\u1112\u1161\u11A8\u1107\u1175
\u1112\u1161\u11A8\u1109\u1162\u11BC
\u1112\u1161\u11A8\u1109\u116E\u11AF
\u1112\u1161\u11A8\u1109\u1173\u11B8
\u1112\u1161\u11A8\u110B\u116D\u11BC\u1111\u116E\u11B7
\u1112\u1161\u11A8\u110B\u116F\u11AB
\u1112\u1161\u11A8\u110B\u1171
\u1112\u1161\u11A8\u110C\u1161
\u1112\u1161\u11A8\u110C\u1165\u11B7
\u1112\u1161\u11AB\u1100\u1168
\u1112\u1161\u11AB\u1100\u1173\u11AF
\u1112\u1161\u11AB\u1101\u1165\u1107\u1165\u11AB\u110B\u1166
\u1112\u1161\u11AB\u1102\u1161\u11BD
\u1112\u1161\u11AB\u1102\u116E\u11AB
\u1112\u1161\u11AB\u1103\u1169\u11BC\u110B\u1161\u11AB
\u1112\u1161\u11AB\u1104\u1162
\u1112\u1161\u11AB\u1105\u1161\u1109\u1161\u11AB
\u1112\u1161\u11AB\u1106\u1161\u1103\u1175
\u1112\u1161\u11AB\u1106\u116E\u11AB
\u1112\u1161\u11AB\u1107\u1165\u11AB
\u1112\u1161\u11AB\u1107\u1169\u11A8
\u1112\u1161\u11AB\u1109\u1175\u11A8
\u1112\u1161\u11AB\u110B\u1167\u1105\u1173\u11B7
\u1112\u1161\u11AB\u110D\u1169\u11A8
\u1112\u1161\u11AF\u1106\u1165\u1102\u1175
\u1112\u1161\u11AF\u110B\u1161\u1107\u1165\u110C\u1175
\u1112\u1161\u11AF\u110B\u1175\u11AB
\u1112\u1161\u11B7\u1101\u1166
\u1112\u1161\u11B7\u1107\u116E\u1105\u1169
\u1112\u1161\u11B8\u1100\u1167\u11A8
\u1112\u1161\u11B8\u1105\u1175\u110C\u1165\u11A8
\u1112\u1161\u11BC\u1100\u1169\u11BC
\u1112\u1161\u11BC\u1100\u116E
\u1112\u1161\u11BC\u1109\u1161\u11BC
\u1112\u1161\u11BC\u110B\u1174
\u1112\u1162\u1100\u1167\u11AF
\u1112\u1162\u1100\u116E\u11AB
\u1112\u1162\u1103\u1161\u11B8
\u1112\u1162\u1103\u1161\u11BC
\u1112\u1162\u1106\u116E\u11AF
\u1112\u1162\u1109\u1165\u11A8
\u1112\u1162\u1109\u1165\u11AF
\u1112\u1162\u1109\u116E\u110B\u116D\u11A8\u110C\u1161\u11BC
\u1112\u1162\u110B\u1161\u11AB
\u1112\u1162\u11A8\u1109\u1175\u11B7
\u1112\u1162\u11AB\u1103\u1173\u1107\u1162\u11A8
\u1112\u1162\u11B7\u1107\u1165\u1100\u1165
\u1112\u1162\u11BA\u1107\u1167\u11C0
\u1112\u1162\u11BA\u1109\u1161\u11AF
\u1112\u1162\u11BC\u1103\u1169\u11BC
\u1112\u1162\u11BC\u1107\u1169\u11A8
\u1112\u1162\u11BC\u1109\u1161
\u1112\u1162\u11BC\u110B\u116E\u11AB
\u1112\u1162\u11BC\u110B\u1171
\u1112\u1163\u11BC\u1100\u1175
\u1112\u1163\u11BC\u1109\u1161\u11BC
\u1112\u1163\u11BC\u1109\u116E
\u1112\u1165\u1105\u1161\u11A8
\u1112\u1165\u110B\u116D\u11BC
\u1112\u1166\u11AF\u1100\u1175
\u1112\u1167\u11AB\u1100\u116A\u11AB
\u1112\u1167\u11AB\u1100\u1173\u11B7
\u1112\u1167\u11AB\u1103\u1162
\u1112\u1167\u11AB\u1109\u1161\u11BC
\u1112\u1167\u11AB\u1109\u1175\u11AF
\u1112\u1167\u11AB\u110C\u1161\u11BC
\u1112\u1167\u11AB\u110C\u1162
\u1112\u1167\u11AB\u110C\u1175
\u1112\u1167\u11AF\u110B\u1162\u11A8
\u1112\u1167\u11B8\u1105\u1167\u11A8
\u1112\u1167\u11BC\u1107\u116E
\u1112\u1167\u11BC\u1109\u1161
\u1112\u1167\u11BC\u1109\u116E
\u1112\u1167\u11BC\u1109\u1175\u11A8
\u1112\u1167\u11BC\u110C\u1166
\u1112\u1167\u11BC\u1110\u1162
\u1112\u1167\u11BC\u1111\u1167\u11AB
\u1112\u1168\u1110\u1162\u11A8
\u1112\u1169\u1100\u1175\u1109\u1175\u11B7
\u1112\u1169\u1102\u1161\u11B7
\u1112\u1169\u1105\u1161\u11BC\u110B\u1175
\u1112\u1169\u1107\u1161\u11A8
\u1112\u1169\u1110\u1166\u11AF
\u1112\u1169\u1112\u1173\u11B8
\u1112\u1169\u11A8\u1109\u1175
\u1112\u1169\u11AF\u1105\u1169
\u1112\u1169\u11B7\u1111\u1166\u110B\u1175\u110C\u1175
\u1112\u1169\u11BC\u1107\u1169
\u1112\u1169\u11BC\u1109\u116E
\u1112\u1169\u11BC\u110E\u1161
\u1112\u116A\u1106\u1167\u11AB
\u1112\u116A\u1107\u116E\u11AB
\u1112\u116A\u1109\u1161\u11AF
\u1112\u116A\u110B\u116D\u110B\u1175\u11AF
\u1112\u116A\u110C\u1161\u11BC
\u1112\u116A\u1112\u1161\u11A8
\u1112\u116A\u11A8\u1107\u1169
\u1112\u116A\u11A8\u110B\u1175\u11AB
\u1112\u116A\u11A8\u110C\u1161\u11BC
\u1112\u116A\u11A8\u110C\u1165\u11BC
\u1112\u116A\u11AB\u1100\u1161\u11B8
\u1112\u116A\u11AB\u1100\u1167\u11BC
\u1112\u116A\u11AB\u110B\u1167\u11BC
\u1112\u116A\u11AB\u110B\u1172\u11AF
\u1112\u116A\u11AB\u110C\u1161
\u1112\u116A\u11AF\u1100\u1175
\u1112\u116A\u11AF\u1103\u1169\u11BC
\u1112\u116A\u11AF\u1107\u1161\u11AF\u1112\u1175
\u1112\u116A\u11AF\u110B\u116D\u11BC
\u1112\u116A\u11AF\u110D\u1161\u11A8
\u1112\u116C\u1100\u1167\u11AB
\u1112\u116C\u1100\u116A\u11AB
\u1112\u116C\u1107\u1169\u11A8
\u1112\u116C\u1109\u1162\u11A8
\u1112\u116C\u110B\u116F\u11AB
\u1112\u116C\u110C\u1161\u11BC
\u1112\u116C\u110C\u1165\u11AB
\u1112\u116C\u11BA\u1109\u116E
\u1112\u116C\u11BC\u1103\u1161\u11AB\u1107\u1169\u1103\u1169
\u1112\u116D\u110B\u1172\u11AF\u110C\u1165\u11A8
\u1112\u116E\u1107\u1161\u11AB
\u1112\u116E\u110E\u116E\u11BA\u1100\u1161\u1105\u116E
\u1112\u116E\u11AB\u1105\u1167\u11AB
\u1112\u116F\u11AF\u110A\u1175\u11AB
\u1112\u1172\u1109\u1175\u11A8
\u1112\u1172\u110B\u1175\u11AF
\u1112\u1172\u11BC\u1102\u1162
\u1112\u1173\u1105\u1173\u11B7
\u1112\u1173\u11A8\u1107\u1162\u11A8
\u1112\u1173\u11A8\u110B\u1175\u11AB
\u1112\u1173\u11AB\u110C\u1165\u11A8
\u1112\u1173\u11AB\u1112\u1175
\u1112\u1173\u11BC\u1106\u1175
\u1112\u1173\u11BC\u1107\u116E\u11AB
\u1112\u1174\u1100\u1169\u11A8
\u1112\u1174\u1106\u1161\u11BC
\u1112\u1174\u1109\u1162\u11BC
\u1112\u1174\u11AB\u1109\u1162\u11A8
\u1112\u1175\u11B7\u1101\u1165\u11BA`.split("\n");
    }
  });

  // node_modules/@scure/bip39/wordlists/simplified-chinese.js
  var require_simplified_chinese = __commonJS({
    "node_modules/@scure/bip39/wordlists/simplified-chinese.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `\u7684
\u4E00
\u662F
\u5728
\u4E0D
\u4E86
\u6709
\u548C
\u4EBA
\u8FD9
\u4E2D
\u5927
\u4E3A
\u4E0A
\u4E2A
\u56FD
\u6211
\u4EE5
\u8981
\u4ED6
\u65F6
\u6765
\u7528
\u4EEC
\u751F
\u5230
\u4F5C
\u5730
\u4E8E
\u51FA
\u5C31
\u5206
\u5BF9
\u6210
\u4F1A
\u53EF
\u4E3B
\u53D1
\u5E74
\u52A8
\u540C
\u5DE5
\u4E5F
\u80FD
\u4E0B
\u8FC7
\u5B50
\u8BF4
\u4EA7
\u79CD
\u9762
\u800C
\u65B9
\u540E
\u591A
\u5B9A
\u884C
\u5B66
\u6CD5
\u6240
\u6C11
\u5F97
\u7ECF
\u5341
\u4E09
\u4E4B
\u8FDB
\u7740
\u7B49
\u90E8
\u5EA6
\u5BB6
\u7535
\u529B
\u91CC
\u5982
\u6C34
\u5316
\u9AD8
\u81EA
\u4E8C
\u7406
\u8D77
\u5C0F
\u7269
\u73B0
\u5B9E
\u52A0
\u91CF
\u90FD
\u4E24
\u4F53
\u5236
\u673A
\u5F53
\u4F7F
\u70B9
\u4ECE
\u4E1A
\u672C
\u53BB
\u628A
\u6027
\u597D
\u5E94
\u5F00
\u5B83
\u5408
\u8FD8
\u56E0
\u7531
\u5176
\u4E9B
\u7136
\u524D
\u5916
\u5929
\u653F
\u56DB
\u65E5
\u90A3
\u793E
\u4E49
\u4E8B
\u5E73
\u5F62
\u76F8
\u5168
\u8868
\u95F4
\u6837
\u4E0E
\u5173
\u5404
\u91CD
\u65B0
\u7EBF
\u5185
\u6570
\u6B63
\u5FC3
\u53CD
\u4F60
\u660E
\u770B
\u539F
\u53C8
\u4E48
\u5229
\u6BD4
\u6216
\u4F46
\u8D28
\u6C14
\u7B2C
\u5411
\u9053
\u547D
\u6B64
\u53D8
\u6761
\u53EA
\u6CA1
\u7ED3
\u89E3
\u95EE
\u610F
\u5EFA
\u6708
\u516C
\u65E0
\u7CFB
\u519B
\u5F88
\u60C5
\u8005
\u6700
\u7ACB
\u4EE3
\u60F3
\u5DF2
\u901A
\u5E76
\u63D0
\u76F4
\u9898
\u515A
\u7A0B
\u5C55
\u4E94
\u679C
\u6599
\u8C61
\u5458
\u9769
\u4F4D
\u5165
\u5E38
\u6587
\u603B
\u6B21
\u54C1
\u5F0F
\u6D3B
\u8BBE
\u53CA
\u7BA1
\u7279
\u4EF6
\u957F
\u6C42
\u8001
\u5934
\u57FA
\u8D44
\u8FB9
\u6D41
\u8DEF
\u7EA7
\u5C11
\u56FE
\u5C71
\u7EDF
\u63A5
\u77E5
\u8F83
\u5C06
\u7EC4
\u89C1
\u8BA1
\u522B
\u5979
\u624B
\u89D2
\u671F
\u6839
\u8BBA
\u8FD0
\u519C
\u6307
\u51E0
\u4E5D
\u533A
\u5F3A
\u653E
\u51B3
\u897F
\u88AB
\u5E72
\u505A
\u5FC5
\u6218
\u5148
\u56DE
\u5219
\u4EFB
\u53D6
\u636E
\u5904
\u961F
\u5357
\u7ED9
\u8272
\u5149
\u95E8
\u5373
\u4FDD
\u6CBB
\u5317
\u9020
\u767E
\u89C4
\u70ED
\u9886
\u4E03
\u6D77
\u53E3
\u4E1C
\u5BFC
\u5668
\u538B
\u5FD7
\u4E16
\u91D1
\u589E
\u4E89
\u6D4E
\u9636
\u6CB9
\u601D
\u672F
\u6781
\u4EA4
\u53D7
\u8054
\u4EC0
\u8BA4
\u516D
\u5171
\u6743
\u6536
\u8BC1
\u6539
\u6E05
\u7F8E
\u518D
\u91C7
\u8F6C
\u66F4
\u5355
\u98CE
\u5207
\u6253
\u767D
\u6559
\u901F
\u82B1
\u5E26
\u5B89
\u573A
\u8EAB
\u8F66
\u4F8B
\u771F
\u52A1
\u5177
\u4E07
\u6BCF
\u76EE
\u81F3
\u8FBE
\u8D70
\u79EF
\u793A
\u8BAE
\u58F0
\u62A5
\u6597
\u5B8C
\u7C7B
\u516B
\u79BB
\u534E
\u540D
\u786E
\u624D
\u79D1
\u5F20
\u4FE1
\u9A6C
\u8282
\u8BDD
\u7C73
\u6574
\u7A7A
\u5143
\u51B5
\u4ECA
\u96C6
\u6E29
\u4F20
\u571F
\u8BB8
\u6B65
\u7FA4
\u5E7F
\u77F3
\u8BB0
\u9700
\u6BB5
\u7814
\u754C
\u62C9
\u6797
\u5F8B
\u53EB
\u4E14
\u7A76
\u89C2
\u8D8A
\u7EC7
\u88C5
\u5F71
\u7B97
\u4F4E
\u6301
\u97F3
\u4F17
\u4E66
\u5E03
\u590D
\u5BB9
\u513F
\u987B
\u9645
\u5546
\u975E
\u9A8C
\u8FDE
\u65AD
\u6DF1
\u96BE
\u8FD1
\u77FF
\u5343
\u5468
\u59D4
\u7D20
\u6280
\u5907
\u534A
\u529E
\u9752
\u7701
\u5217
\u4E60
\u54CD
\u7EA6
\u652F
\u822C
\u53F2
\u611F
\u52B3
\u4FBF
\u56E2
\u5F80
\u9178
\u5386
\u5E02
\u514B
\u4F55
\u9664
\u6D88
\u6784
\u5E9C
\u79F0
\u592A
\u51C6
\u7CBE
\u503C
\u53F7
\u7387
\u65CF
\u7EF4
\u5212
\u9009
\u6807
\u5199
\u5B58
\u5019
\u6BDB
\u4EB2
\u5FEB
\u6548
\u65AF
\u9662
\u67E5
\u6C5F
\u578B
\u773C
\u738B
\u6309
\u683C
\u517B
\u6613
\u7F6E
\u6D3E
\u5C42
\u7247
\u59CB
\u5374
\u4E13
\u72B6
\u80B2
\u5382
\u4EAC
\u8BC6
\u9002
\u5C5E
\u5706
\u5305
\u706B
\u4F4F
\u8C03
\u6EE1
\u53BF
\u5C40
\u7167
\u53C2
\u7EA2
\u7EC6
\u5F15
\u542C
\u8BE5
\u94C1
\u4EF7
\u4E25
\u9996
\u5E95
\u6DB2
\u5B98
\u5FB7
\u968F
\u75C5
\u82CF
\u5931
\u5C14
\u6B7B
\u8BB2
\u914D
\u5973
\u9EC4
\u63A8
\u663E
\u8C08
\u7F6A
\u795E
\u827A
\u5462
\u5E2D
\u542B
\u4F01
\u671B
\u5BC6
\u6279
\u8425
\u9879
\u9632
\u4E3E
\u7403
\u82F1
\u6C27
\u52BF
\u544A
\u674E
\u53F0
\u843D
\u6728
\u5E2E
\u8F6E
\u7834
\u4E9A
\u5E08
\u56F4
\u6CE8
\u8FDC
\u5B57
\u6750
\u6392
\u4F9B
\u6CB3
\u6001
\u5C01
\u53E6
\u65BD
\u51CF
\u6811
\u6EB6
\u600E
\u6B62
\u6848
\u8A00
\u58EB
\u5747
\u6B66
\u56FA
\u53F6
\u9C7C
\u6CE2
\u89C6
\u4EC5
\u8D39
\u7D27
\u7231
\u5DE6
\u7AE0
\u65E9
\u671D
\u5BB3
\u7EED
\u8F7B
\u670D
\u8BD5
\u98DF
\u5145
\u5175
\u6E90
\u5224
\u62A4
\u53F8
\u8DB3
\u67D0
\u7EC3
\u5DEE
\u81F4
\u677F
\u7530
\u964D
\u9ED1
\u72AF
\u8D1F
\u51FB
\u8303
\u7EE7
\u5174
\u4F3C
\u4F59
\u575A
\u66F2
\u8F93
\u4FEE
\u6545
\u57CE
\u592B
\u591F
\u9001
\u7B14
\u8239
\u5360
\u53F3
\u8D22
\u5403
\u5BCC
\u6625
\u804C
\u89C9
\u6C49
\u753B
\u529F
\u5DF4
\u8DDF
\u867D
\u6742
\u98DE
\u68C0
\u5438
\u52A9
\u5347
\u9633
\u4E92
\u521D
\u521B
\u6297
\u8003
\u6295
\u574F
\u7B56
\u53E4
\u5F84
\u6362
\u672A
\u8DD1
\u7559
\u94A2
\u66FE
\u7AEF
\u8D23
\u7AD9
\u7B80
\u8FF0
\u94B1
\u526F
\u5C3D
\u5E1D
\u5C04
\u8349
\u51B2
\u627F
\u72EC
\u4EE4
\u9650
\u963F
\u5BA3
\u73AF
\u53CC
\u8BF7
\u8D85
\u5FAE
\u8BA9
\u63A7
\u5DDE
\u826F
\u8F74
\u627E
\u5426
\u7EAA
\u76CA
\u4F9D
\u4F18
\u9876
\u7840
\u8F7D
\u5012
\u623F
\u7A81
\u5750
\u7C89
\u654C
\u7565
\u5BA2
\u8881
\u51B7
\u80DC
\u7EDD
\u6790
\u5757
\u5242
\u6D4B
\u4E1D
\u534F
\u8BC9
\u5FF5
\u9648
\u4ECD
\u7F57
\u76D0
\u53CB
\u6D0B
\u9519
\u82E6
\u591C
\u5211
\u79FB
\u9891
\u9010
\u9760
\u6DF7
\u6BCD
\u77ED
\u76AE
\u7EC8
\u805A
\u6C7D
\u6751
\u4E91
\u54EA
\u65E2
\u8DDD
\u536B
\u505C
\u70C8
\u592E
\u5BDF
\u70E7
\u8FC5
\u5883
\u82E5
\u5370
\u6D32
\u523B
\u62EC
\u6FC0
\u5B54
\u641E
\u751A
\u5BA4
\u5F85
\u6838
\u6821
\u6563
\u4FB5
\u5427
\u7532
\u6E38
\u4E45
\u83DC
\u5473
\u65E7
\u6A21
\u6E56
\u8D27
\u635F
\u9884
\u963B
\u6BEB
\u666E
\u7A33
\u4E59
\u5988
\u690D
\u606F
\u6269
\u94F6
\u8BED
\u6325
\u9152
\u5B88
\u62FF
\u5E8F
\u7EB8
\u533B
\u7F3A
\u96E8
\u5417
\u9488
\u5218
\u554A
\u6025
\u5531
\u8BEF
\u8BAD
\u613F
\u5BA1
\u9644
\u83B7
\u8336
\u9C9C
\u7CAE
\u65A4
\u5B69
\u8131
\u786B
\u80A5
\u5584
\u9F99
\u6F14
\u7236
\u6E10
\u8840
\u6B22
\u68B0
\u638C
\u6B4C
\u6C99
\u521A
\u653B
\u8C13
\u76FE
\u8BA8
\u665A
\u7C92
\u4E71
\u71C3
\u77DB
\u4E4E
\u6740
\u836F
\u5B81
\u9C81
\u8D35
\u949F
\u7164
\u8BFB
\u73ED
\u4F2F
\u9999
\u4ECB
\u8FEB
\u53E5
\u4E30
\u57F9
\u63E1
\u5170
\u62C5
\u5F26
\u86CB
\u6C89
\u5047
\u7A7F
\u6267
\u7B54
\u4E50
\u8C01
\u987A
\u70DF
\u7F29
\u5F81
\u8138
\u559C
\u677E
\u811A
\u56F0
\u5F02
\u514D
\u80CC
\u661F
\u798F
\u4E70
\u67D3
\u4E95
\u6982
\u6162
\u6015
\u78C1
\u500D
\u7956
\u7687
\u4FC3
\u9759
\u8865
\u8BC4
\u7FFB
\u8089
\u8DF5
\u5C3C
\u8863
\u5BBD
\u626C
\u68C9
\u5E0C
\u4F24
\u64CD
\u5782
\u79CB
\u5B9C
\u6C22
\u5957
\u7763
\u632F
\u67B6
\u4EAE
\u672B
\u5BAA
\u5E86
\u7F16
\u725B
\u89E6
\u6620
\u96F7
\u9500
\u8BD7
\u5EA7
\u5C45
\u6293
\u88C2
\u80DE
\u547C
\u5A18
\u666F
\u5A01
\u7EFF
\u6676
\u539A
\u76DF
\u8861
\u9E21
\u5B59
\u5EF6
\u5371
\u80F6
\u5C4B
\u4E61
\u4E34
\u9646
\u987E
\u6389
\u5440
\u706F
\u5C81
\u63AA
\u675F
\u8010
\u5267
\u7389
\u8D75
\u8DF3
\u54E5
\u5B63
\u8BFE
\u51EF
\u80E1
\u989D
\u6B3E
\u7ECD
\u5377
\u9F50
\u4F1F
\u84B8
\u6B96
\u6C38
\u5B97
\u82D7
\u5DDD
\u7089
\u5CA9
\u5F31
\u96F6
\u6768
\u594F
\u6CBF
\u9732
\u6746
\u63A2
\u6ED1
\u9547
\u996D
\u6D53
\u822A
\u6000
\u8D76
\u5E93
\u593A
\u4F0A
\u7075
\u7A0E
\u9014
\u706D
\u8D5B
\u5F52
\u53EC
\u9F13
\u64AD
\u76D8
\u88C1
\u9669
\u5EB7
\u552F
\u5F55
\u83CC
\u7EAF
\u501F
\u7CD6
\u76D6
\u6A2A
\u7B26
\u79C1
\u52AA
\u5802
\u57DF
\u67AA
\u6DA6
\u5E45
\u54C8
\u7ADF
\u719F
\u866B
\u6CFD
\u8111
\u58E4
\u78B3
\u6B27
\u904D
\u4FA7
\u5BE8
\u6562
\u5F7B
\u8651
\u659C
\u8584
\u5EAD
\u7EB3
\u5F39
\u9972
\u4F38
\u6298
\u9EA6
\u6E7F
\u6697
\u8377
\u74E6
\u585E
\u5E8A
\u7B51
\u6076
\u6237
\u8BBF
\u5854
\u5947
\u900F
\u6881
\u5200
\u65CB
\u8FF9
\u5361
\u6C2F
\u9047
\u4EFD
\u6BD2
\u6CE5
\u9000
\u6D17
\u6446
\u7070
\u5F69
\u5356
\u8017
\u590F
\u62E9
\u5FD9
\u94DC
\u732E
\u786C
\u4E88
\u7E41
\u5708
\u96EA
\u51FD
\u4EA6
\u62BD
\u7BC7
\u9635
\u9634
\u4E01
\u5C3A
\u8FFD
\u5806
\u96C4
\u8FCE
\u6CDB
\u7238
\u697C
\u907F
\u8C0B
\u5428
\u91CE
\u732A
\u65D7
\u7D2F
\u504F
\u5178
\u9986
\u7D22
\u79E6
\u8102
\u6F6E
\u7237
\u8C46
\u5FFD
\u6258
\u60CA
\u5851
\u9057
\u6108
\u6731
\u66FF
\u7EA4
\u7C97
\u503E
\u5C1A
\u75DB
\u695A
\u8C22
\u594B
\u8D2D
\u78E8
\u541B
\u6C60
\u65C1
\u788E
\u9AA8
\u76D1
\u6355
\u5F1F
\u66B4
\u5272
\u8D2F
\u6B8A
\u91CA
\u8BCD
\u4EA1
\u58C1
\u987F
\u5B9D
\u5348
\u5C18
\u95FB
\u63ED
\u70AE
\u6B8B
\u51AC
\u6865
\u5987
\u8B66
\u7EFC
\u62DB
\u5434
\u4ED8
\u6D6E
\u906D
\u5F90
\u60A8
\u6447
\u8C37
\u8D5E
\u7BB1
\u9694
\u8BA2
\u7537
\u5439
\u56ED
\u7EB7
\u5510
\u8D25
\u5B8B
\u73BB
\u5DE8
\u8015
\u5766
\u8363
\u95ED
\u6E7E
\u952E
\u51E1
\u9A7B
\u9505
\u6551
\u6069
\u5265
\u51DD
\u78B1
\u9F7F
\u622A
\u70BC
\u9EBB
\u7EBA
\u7981
\u5E9F
\u76DB
\u7248
\u7F13
\u51C0
\u775B
\u660C
\u5A5A
\u6D89
\u7B52
\u5634
\u63D2
\u5CB8
\u6717
\u5E84
\u8857
\u85CF
\u59D1
\u8D38
\u8150
\u5974
\u5566
\u60EF
\u4E58
\u4F19
\u6062
\u5300
\u7EB1
\u624E
\u8FA9
\u8033
\u5F6A
\u81E3
\u4EBF
\u7483
\u62B5
\u8109
\u79C0
\u8428
\u4FC4
\u7F51
\u821E
\u5E97
\u55B7
\u7EB5
\u5BF8
\u6C57
\u6302
\u6D2A
\u8D3A
\u95EA
\u67EC
\u7206
\u70EF
\u6D25
\u7A3B
\u5899
\u8F6F
\u52C7
\u50CF
\u6EDA
\u5398
\u8499
\u82B3
\u80AF
\u5761
\u67F1
\u8361
\u817F
\u4EEA
\u65C5
\u5C3E
\u8F67
\u51B0
\u8D21
\u767B
\u9ECE
\u524A
\u94BB
\u52D2
\u9003
\u969C
\u6C28
\u90ED
\u5CF0
\u5E01
\u6E2F
\u4F0F
\u8F68
\u4EA9
\u6BD5
\u64E6
\u83AB
\u523A
\u6D6A
\u79D8
\u63F4
\u682A
\u5065
\u552E
\u80A1
\u5C9B
\u7518
\u6CE1
\u7761
\u7AE5
\u94F8
\u6C64
\u9600
\u4F11
\u6C47
\u820D
\u7267
\u7ED5
\u70B8
\u54F2
\u78F7
\u7EE9
\u670B
\u6DE1
\u5C16
\u542F
\u9677
\u67F4
\u5448
\u5F92
\u989C
\u6CEA
\u7A0D
\u5FD8
\u6CF5
\u84DD
\u62D6
\u6D1E
\u6388
\u955C
\u8F9B
\u58EE
\u950B
\u8D2B
\u865A
\u5F2F
\u6469
\u6CF0
\u5E7C
\u5EF7
\u5C0A
\u7A97
\u7EB2
\u5F04
\u96B6
\u7591
\u6C0F
\u5BAB
\u59D0
\u9707
\u745E
\u602A
\u5C24
\u7434
\u5FAA
\u63CF
\u819C
\u8FDD
\u5939
\u8170
\u7F18
\u73E0
\u7A77
\u68EE
\u679D
\u7AF9
\u6C9F
\u50AC
\u7EF3
\u5FC6
\u90A6
\u5269
\u5E78
\u6D46
\u680F
\u62E5
\u7259
\u8D2E
\u793C
\u6EE4
\u94A0
\u7EB9
\u7F62
\u62CD
\u54B1
\u558A
\u8896
\u57C3
\u52E4
\u7F5A
\u7126
\u6F5C
\u4F0D
\u58A8
\u6B32
\u7F1D
\u59D3
\u520A
\u9971
\u4EFF
\u5956
\u94DD
\u9B3C
\u4E3D
\u8DE8
\u9ED8
\u6316
\u94FE
\u626B
\u559D
\u888B
\u70AD
\u6C61
\u5E55
\u8BF8
\u5F27
\u52B1
\u6885
\u5976
\u6D01
\u707E
\u821F
\u9274
\u82EF
\u8BBC
\u62B1
\u6BC1
\u61C2
\u5BD2
\u667A
\u57D4
\u5BC4
\u5C4A
\u8DC3
\u6E21
\u6311
\u4E39
\u8270
\u8D1D
\u78B0
\u62D4
\u7239
\u6234
\u7801
\u68A6
\u82BD
\u7194
\u8D64
\u6E14
\u54ED
\u656C
\u9897
\u5954
\u94C5
\u4EF2
\u864E
\u7A00
\u59B9
\u4E4F
\u73CD
\u7533
\u684C
\u9075
\u5141
\u9686
\u87BA
\u4ED3
\u9B4F
\u9510
\u6653
\u6C2E
\u517C
\u9690
\u788D
\u8D6B
\u62E8
\u5FE0
\u8083
\u7F38
\u7275
\u62A2
\u535A
\u5DE7
\u58F3
\u5144
\u675C
\u8BAF
\u8BDA
\u78A7
\u7965
\u67EF
\u9875
\u5DE1
\u77E9
\u60B2
\u704C
\u9F84
\u4F26
\u7968
\u5BFB
\u6842
\u94FA
\u5723
\u6050
\u6070
\u90D1
\u8DA3
\u62AC
\u8352
\u817E
\u8D34
\u67D4
\u6EF4
\u731B
\u9614
\u8F86
\u59BB
\u586B
\u64A4
\u50A8
\u7B7E
\u95F9
\u6270
\u7D2B
\u7802
\u9012
\u620F
\u540A
\u9676
\u4F10
\u5582
\u7597
\u74F6
\u5A46
\u629A
\u81C2
\u6478
\u5FCD
\u867E
\u8721
\u90BB
\u80F8
\u5DE9
\u6324
\u5076
\u5F03
\u69FD
\u52B2
\u4E73
\u9093
\u5409
\u4EC1
\u70C2
\u7816
\u79DF
\u4E4C
\u8230
\u4F34
\u74DC
\u6D45
\u4E19
\u6682
\u71E5
\u6A61
\u67F3
\u8FF7
\u6696
\u724C
\u79E7
\u80C6
\u8BE6
\u7C27
\u8E0F
\u74F7
\u8C31
\u5446
\u5BBE
\u7CCA
\u6D1B
\u8F89
\u6124
\u7ADE
\u9699
\u6012
\u7C98
\u4E43
\u7EEA
\u80A9
\u7C4D
\u654F
\u6D82
\u7199
\u7686
\u4FA6
\u60AC
\u6398
\u4EAB
\u7EA0
\u9192
\u72C2
\u9501
\u6DC0
\u6068
\u7272
\u9738
\u722C
\u8D4F
\u9006
\u73A9
\u9675
\u795D
\u79D2
\u6D59
\u8C8C
\u5F79
\u5F7C
\u6089
\u9E2D
\u8D8B
\u51E4
\u6668
\u755C
\u8F88
\u79E9
\u5375
\u7F72
\u68AF
\u708E
\u6EE9
\u68CB
\u9A71
\u7B5B
\u5CE1
\u5192
\u5565
\u5BFF
\u8BD1
\u6D78
\u6CC9
\u5E3D
\u8FDF
\u7845
\u7586
\u8D37
\u6F0F
\u7A3F
\u51A0
\u5AE9
\u80C1
\u82AF
\u7262
\u53DB
\u8680
\u5965
\u9E23
\u5CAD
\u7F8A
\u51ED
\u4E32
\u5858
\u7ED8
\u9175
\u878D
\u76C6
\u9521
\u5E99
\u7B79
\u51BB
\u8F85
\u6444
\u88AD
\u7B4B
\u62D2
\u50DA
\u65F1
\u94BE
\u9E1F
\u6F06
\u6C88
\u7709
\u758F
\u6DFB
\u68D2
\u7A57
\u785D
\u97E9
\u903C
\u626D
\u4FA8
\u51C9
\u633A
\u7897
\u683D
\u7092
\u676F
\u60A3
\u998F
\u529D
\u8C6A
\u8FBD
\u52C3
\u9E3F
\u65E6
\u540F
\u62DC
\u72D7
\u57CB
\u8F8A
\u63A9
\u996E
\u642C
\u9A82
\u8F9E
\u52FE
\u6263
\u4F30
\u848B
\u7ED2
\u96FE
\u4E08
\u6735
\u59C6
\u62DF
\u5B87
\u8F91
\u9655
\u96D5
\u507F
\u84C4
\u5D07
\u526A
\u5021
\u5385
\u54AC
\u9A76
\u85AF
\u5237
\u65A5
\u756A
\u8D4B
\u5949
\u4F5B
\u6D47
\u6F2B
\u66FC
\u6247
\u9499
\u6843
\u6276
\u4ED4
\u8FD4
\u4FD7
\u4E8F
\u8154
\u978B
\u68F1
\u8986
\u6846
\u6084
\u53D4
\u649E
\u9A97
\u52D8
\u65FA
\u6CB8
\u5B64
\u5410
\u5B5F
\u6E20
\u5C48
\u75BE
\u5999
\u60DC
\u4EF0
\u72E0
\u80C0
\u8C10
\u629B
\u9709
\u6851
\u5C97
\u561B
\u8870
\u76D7
\u6E17
\u810F
\u8D56
\u6D8C
\u751C
\u66F9
\u9605
\u808C
\u54E9
\u5389
\u70C3
\u7EAC
\u6BC5
\u6628
\u4F2A
\u75C7
\u716E
\u53F9
\u9489
\u642D
\u830E
\u7B3C
\u9177
\u5077
\u5F13
\u9525
\u6052
\u6770
\u5751
\u9F3B
\u7FFC
\u7EB6
\u53D9
\u72F1
\u902E
\u7F50
\u7EDC
\u68DA
\u6291
\u81A8
\u852C
\u5BFA
\u9AA4
\u7A46
\u51B6
\u67AF
\u518C
\u5C38
\u51F8
\u7EC5
\u576F
\u727A
\u7130
\u8F70
\u6B23
\u664B
\u7626
\u5FA1
\u952D
\u9526
\u4E27
\u65EC
\u953B
\u5784
\u641C
\u6251
\u9080
\u4EAD
\u916F
\u8FC8
\u8212
\u8106
\u9176
\u95F2
\u5FE7
\u915A
\u987D
\u7FBD
\u6DA8
\u5378
\u4ED7
\u966A
\u8F9F
\u60E9
\u676D
\u59DA
\u809A
\u6349
\u98D8
\u6F02
\u6606
\u6B3A
\u543E
\u90CE
\u70F7
\u6C41
\u5475
\u9970
\u8427
\u96C5
\u90AE
\u8FC1
\u71D5
\u6492
\u59FB
\u8D74
\u5BB4
\u70E6
\u503A
\u5E10
\u6591
\u94C3
\u65E8
\u9187
\u8463
\u997C
\u96CF
\u59FF
\u62CC
\u5085
\u8179
\u59A5
\u63C9
\u8D24
\u62C6
\u6B6A
\u8461
\u80FA
\u4E22
\u6D69
\u5FBD
\u6602
\u57AB
\u6321
\u89C8
\u8D2A
\u6170
\u7F34
\u6C6A
\u614C
\u51AF
\u8BFA
\u59DC
\u8C0A
\u51F6
\u52A3
\u8BEC
\u8000
\u660F
\u8EBA
\u76C8
\u9A91
\u4E54
\u6EAA
\u4E1B
\u5362
\u62B9
\u95F7
\u54A8
\u522E
\u9A7E
\u7F06
\u609F
\u6458
\u94D2
\u63B7
\u9887
\u5E7B
\u67C4
\u60E0
\u60E8
\u4F73
\u4EC7
\u814A
\u7A9D
\u6DA4
\u5251
\u77A7
\u5821
\u6CFC
\u8471
\u7F69
\u970D
\u635E
\u80CE
\u82CD
\u6EE8
\u4FE9
\u6345
\u6E58
\u780D
\u971E
\u90B5
\u8404
\u75AF
\u6DEE
\u9042
\u718A
\u7CAA
\u70D8
\u5BBF
\u6863
\u6208
\u9A73
\u5AC2
\u88D5
\u5F99
\u7BAD
\u6350
\u80A0
\u6491
\u6652
\u8FA8
\u6BBF
\u83B2
\u644A
\u6405
\u9171
\u5C4F
\u75AB
\u54C0
\u8521
\u5835
\u6CAB
\u76B1
\u7545
\u53E0
\u9601
\u83B1
\u6572
\u8F96
\u94A9
\u75D5
\u575D
\u5DF7
\u997F
\u7978
\u4E18
\u7384
\u6E9C
\u66F0
\u903B
\u5F6D
\u5C1D
\u537F
\u59A8
\u8247
\u541E
\u97E6
\u6028
\u77EE
\u6B47`.split("\n");
    }
  });

  // node_modules/@scure/bip39/wordlists/spanish.js
  var require_spanish = __commonJS({
    "node_modules/@scure/bip39/wordlists/spanish.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `a\u0301baco
abdomen
abeja
abierto
abogado
abono
aborto
abrazo
abrir
abuelo
abuso
acabar
academia
acceso
accio\u0301n
aceite
acelga
acento
aceptar
a\u0301cido
aclarar
acne\u0301
acoger
acoso
activo
acto
actriz
actuar
acudir
acuerdo
acusar
adicto
admitir
adoptar
adorno
aduana
adulto
ae\u0301reo
afectar
aficio\u0301n
afinar
afirmar
a\u0301gil
agitar
agoni\u0301a
agosto
agotar
agregar
agrio
agua
agudo
a\u0301guila
aguja
ahogo
ahorro
aire
aislar
ajedrez
ajeno
ajuste
alacra\u0301n
alambre
alarma
alba
a\u0301lbum
alcalde
aldea
alegre
alejar
alerta
aleta
alfiler
alga
algodo\u0301n
aliado
aliento
alivio
alma
almeja
almi\u0301bar
altar
alteza
altivo
alto
altura
alumno
alzar
amable
amante
amapola
amargo
amasar
a\u0301mbar
a\u0301mbito
ameno
amigo
amistad
amor
amparo
amplio
ancho
anciano
ancla
andar
ande\u0301n
anemia
a\u0301ngulo
anillo
a\u0301nimo
ani\u0301s
anotar
antena
antiguo
antojo
anual
anular
anuncio
an\u0303adir
an\u0303ejo
an\u0303o
apagar
aparato
apetito
apio
aplicar
apodo
aporte
apoyo
aprender
aprobar
apuesta
apuro
arado
aran\u0303a
arar
a\u0301rbitro
a\u0301rbol
arbusto
archivo
arco
arder
ardilla
arduo
a\u0301rea
a\u0301rido
aries
armoni\u0301a
arne\u0301s
aroma
arpa
arpo\u0301n
arreglo
arroz
arruga
arte
artista
asa
asado
asalto
ascenso
asegurar
aseo
asesor
asiento
asilo
asistir
asno
asombro
a\u0301spero
astilla
astro
astuto
asumir
asunto
atajo
ataque
atar
atento
ateo
a\u0301tico
atleta
a\u0301tomo
atraer
atroz
atu\u0301n
audaz
audio
auge
aula
aumento
ausente
autor
aval
avance
avaro
ave
avellana
avena
avestruz
avio\u0301n
aviso
ayer
ayuda
ayuno
azafra\u0301n
azar
azote
azu\u0301car
azufre
azul
baba
babor
bache
bahi\u0301a
baile
bajar
balanza
balco\u0301n
balde
bambu\u0301
banco
banda
ban\u0303o
barba
barco
barniz
barro
ba\u0301scula
basto\u0301n
basura
batalla
bateri\u0301a
batir
batuta
bau\u0301l
bazar
bebe\u0301
bebida
bello
besar
beso
bestia
bicho
bien
bingo
blanco
bloque
blusa
boa
bobina
bobo
boca
bocina
boda
bodega
boina
bola
bolero
bolsa
bomba
bondad
bonito
bono
bonsa\u0301i
borde
borrar
bosque
bote
boti\u0301n
bo\u0301veda
bozal
bravo
brazo
brecha
breve
brillo
brinco
brisa
broca
broma
bronce
brote
bruja
brusco
bruto
buceo
bucle
bueno
buey
bufanda
bufo\u0301n
bu\u0301ho
buitre
bulto
burbuja
burla
burro
buscar
butaca
buzo\u0301n
caballo
cabeza
cabina
cabra
cacao
cada\u0301ver
cadena
caer
cafe\u0301
cai\u0301da
caima\u0301n
caja
cajo\u0301n
cal
calamar
calcio
caldo
calidad
calle
calma
calor
calvo
cama
cambio
camello
camino
campo
ca\u0301ncer
candil
canela
canguro
canica
canto
can\u0303a
can\u0303o\u0301n
caoba
caos
capaz
capita\u0301n
capote
captar
capucha
cara
carbo\u0301n
ca\u0301rcel
careta
carga
carin\u0303o
carne
carpeta
carro
carta
casa
casco
casero
caspa
castor
catorce
catre
caudal
causa
cazo
cebolla
ceder
cedro
celda
ce\u0301lebre
celoso
ce\u0301lula
cemento
ceniza
centro
cerca
cerdo
cereza
cero
cerrar
certeza
ce\u0301sped
cetro
chacal
chaleco
champu\u0301
chancla
chapa
charla
chico
chiste
chivo
choque
choza
chuleta
chupar
ciclo\u0301n
ciego
cielo
cien
cierto
cifra
cigarro
cima
cinco
cine
cinta
cipre\u0301s
circo
ciruela
cisne
cita
ciudad
clamor
clan
claro
clase
clave
cliente
clima
cli\u0301nica
cobre
coccio\u0301n
cochino
cocina
coco
co\u0301digo
codo
cofre
coger
cohete
coji\u0301n
cojo
cola
colcha
colegio
colgar
colina
collar
colmo
columna
combate
comer
comida
co\u0301modo
compra
conde
conejo
conga
conocer
consejo
contar
copa
copia
corazo\u0301n
corbata
corcho
cordo\u0301n
corona
correr
coser
cosmos
costa
cra\u0301neo
cra\u0301ter
crear
crecer
crei\u0301do
crema
cri\u0301a
crimen
cripta
crisis
cromo
cro\u0301nica
croqueta
crudo
cruz
cuadro
cuarto
cuatro
cubo
cubrir
cuchara
cuello
cuento
cuerda
cuesta
cueva
cuidar
culebra
culpa
culto
cumbre
cumplir
cuna
cuneta
cuota
cupo\u0301n
cu\u0301pula
curar
curioso
curso
curva
cutis
dama
danza
dar
dardo
da\u0301til
deber
de\u0301bil
de\u0301cada
decir
dedo
defensa
definir
dejar
delfi\u0301n
delgado
delito
demora
denso
dental
deporte
derecho
derrota
desayuno
deseo
desfile
desnudo
destino
desvi\u0301o
detalle
detener
deuda
di\u0301a
diablo
diadema
diamante
diana
diario
dibujo
dictar
diente
dieta
diez
difi\u0301cil
digno
dilema
diluir
dinero
directo
dirigir
disco
disen\u0303o
disfraz
diva
divino
doble
doce
dolor
domingo
don
donar
dorado
dormir
dorso
dos
dosis
drago\u0301n
droga
ducha
duda
duelo
duen\u0303o
dulce
du\u0301o
duque
durar
dureza
duro
e\u0301bano
ebrio
echar
eco
ecuador
edad
edicio\u0301n
edificio
editor
educar
efecto
eficaz
eje
ejemplo
elefante
elegir
elemento
elevar
elipse
e\u0301lite
elixir
elogio
eludir
embudo
emitir
emocio\u0301n
empate
empen\u0303o
empleo
empresa
enano
encargo
enchufe
enci\u0301a
enemigo
enero
enfado
enfermo
engan\u0303o
enigma
enlace
enorme
enredo
ensayo
ensen\u0303ar
entero
entrar
envase
envi\u0301o
e\u0301poca
equipo
erizo
escala
escena
escolar
escribir
escudo
esencia
esfera
esfuerzo
espada
espejo
espi\u0301a
esposa
espuma
esqui\u0301
estar
este
estilo
estufa
etapa
eterno
e\u0301tica
etnia
evadir
evaluar
evento
evitar
exacto
examen
exceso
excusa
exento
exigir
exilio
existir
e\u0301xito
experto
explicar
exponer
extremo
fa\u0301brica
fa\u0301bula
fachada
fa\u0301cil
factor
faena
faja
falda
fallo
falso
faltar
fama
familia
famoso
farao\u0301n
farmacia
farol
farsa
fase
fatiga
fauna
favor
fax
febrero
fecha
feliz
feo
feria
feroz
fe\u0301rtil
fervor
festi\u0301n
fiable
fianza
fiar
fibra
ficcio\u0301n
ficha
fideo
fiebre
fiel
fiera
fiesta
figura
fijar
fijo
fila
filete
filial
filtro
fin
finca
fingir
finito
firma
flaco
flauta
flecha
flor
flota
fluir
flujo
flu\u0301or
fobia
foca
fogata
fogo\u0301n
folio
folleto
fondo
forma
forro
fortuna
forzar
fosa
foto
fracaso
fra\u0301gil
franja
frase
fraude
frei\u0301r
freno
fresa
fri\u0301o
frito
fruta
fuego
fuente
fuerza
fuga
fumar
funcio\u0301n
funda
furgo\u0301n
furia
fusil
fu\u0301tbol
futuro
gacela
gafas
gaita
gajo
gala
galeri\u0301a
gallo
gamba
ganar
gancho
ganga
ganso
garaje
garza
gasolina
gastar
gato
gavila\u0301n
gemelo
gemir
gen
ge\u0301nero
genio
gente
geranio
gerente
germen
gesto
gigante
gimnasio
girar
giro
glaciar
globo
gloria
gol
golfo
goloso
golpe
goma
gordo
gorila
gorra
gota
goteo
gozar
grada
gra\u0301fico
grano
grasa
gratis
grave
grieta
grillo
gripe
gris
grito
grosor
gru\u0301a
grueso
grumo
grupo
guante
guapo
guardia
guerra
gui\u0301a
guin\u0303o
guion
guiso
guitarra
gusano
gustar
haber
ha\u0301bil
hablar
hacer
hacha
hada
hallar
hamaca
harina
haz
hazan\u0303a
hebilla
hebra
hecho
helado
helio
hembra
herir
hermano
he\u0301roe
hervir
hielo
hierro
hi\u0301gado
higiene
hijo
himno
historia
hocico
hogar
hoguera
hoja
hombre
hongo
honor
honra
hora
hormiga
horno
hostil
hoyo
hueco
huelga
huerta
hueso
huevo
huida
huir
humano
hu\u0301medo
humilde
humo
hundir
huraca\u0301n
hurto
icono
ideal
idioma
i\u0301dolo
iglesia
iglu\u0301
igual
ilegal
ilusio\u0301n
imagen
ima\u0301n
imitar
impar
imperio
imponer
impulso
incapaz
i\u0301ndice
inerte
infiel
informe
ingenio
inicio
inmenso
inmune
innato
insecto
instante
intere\u0301s
i\u0301ntimo
intuir
inu\u0301til
invierno
ira
iris
ironi\u0301a
isla
islote
jabali\u0301
jabo\u0301n
jamo\u0301n
jarabe
jardi\u0301n
jarra
jaula
jazmi\u0301n
jefe
jeringa
jinete
jornada
joroba
joven
joya
juerga
jueves
juez
jugador
jugo
juguete
juicio
junco
jungla
junio
juntar
ju\u0301piter
jurar
justo
juvenil
juzgar
kilo
koala
labio
lacio
lacra
lado
ladro\u0301n
lagarto
la\u0301grima
laguna
laico
lamer
la\u0301mina
la\u0301mpara
lana
lancha
langosta
lanza
la\u0301piz
largo
larva
la\u0301stima
lata
la\u0301tex
latir
laurel
lavar
lazo
leal
leccio\u0301n
leche
lector
leer
legio\u0301n
legumbre
lejano
lengua
lento
len\u0303a
leo\u0301n
leopardo
lesio\u0301n
letal
letra
leve
leyenda
libertad
libro
licor
li\u0301der
lidiar
lienzo
liga
ligero
lima
li\u0301mite
limo\u0301n
limpio
lince
lindo
li\u0301nea
lingote
lino
linterna
li\u0301quido
liso
lista
litera
litio
litro
llaga
llama
llanto
llave
llegar
llenar
llevar
llorar
llover
lluvia
lobo
locio\u0301n
loco
locura
lo\u0301gica
logro
lombriz
lomo
lonja
lote
lucha
lucir
lugar
lujo
luna
lunes
lupa
lustro
luto
luz
maceta
macho
madera
madre
maduro
maestro
mafia
magia
mago
mai\u0301z
maldad
maleta
malla
malo
mama\u0301
mambo
mamut
manco
mando
manejar
manga
maniqui\u0301
manjar
mano
manso
manta
man\u0303ana
mapa
ma\u0301quina
mar
marco
marea
marfil
margen
marido
ma\u0301rmol
marro\u0301n
martes
marzo
masa
ma\u0301scara
masivo
matar
materia
matiz
matriz
ma\u0301ximo
mayor
mazorca
mecha
medalla
medio
me\u0301dula
mejilla
mejor
melena
melo\u0301n
memoria
menor
mensaje
mente
menu\u0301
mercado
merengue
me\u0301rito
mes
meso\u0301n
meta
meter
me\u0301todo
metro
mezcla
miedo
miel
miembro
miga
mil
milagro
militar
millo\u0301n
mimo
mina
minero
mi\u0301nimo
minuto
miope
mirar
misa
miseria
misil
mismo
mitad
mito
mochila
mocio\u0301n
moda
modelo
moho
mojar
molde
moler
molino
momento
momia
monarca
moneda
monja
monto
mon\u0303o
morada
morder
moreno
morir
morro
morsa
mortal
mosca
mostrar
motivo
mover
mo\u0301vil
mozo
mucho
mudar
mueble
muela
muerte
muestra
mugre
mujer
mula
muleta
multa
mundo
mun\u0303eca
mural
muro
mu\u0301sculo
museo
musgo
mu\u0301sica
muslo
na\u0301car
nacio\u0301n
nadar
naipe
naranja
nariz
narrar
nasal
natal
nativo
natural
na\u0301usea
naval
nave
navidad
necio
ne\u0301ctar
negar
negocio
negro
neo\u0301n
nervio
neto
neutro
nevar
nevera
nicho
nido
niebla
nieto
nin\u0303ez
nin\u0303o
ni\u0301tido
nivel
nobleza
noche
no\u0301mina
noria
norma
norte
nota
noticia
novato
novela
novio
nube
nuca
nu\u0301cleo
nudillo
nudo
nuera
nueve
nuez
nulo
nu\u0301mero
nutria
oasis
obeso
obispo
objeto
obra
obrero
observar
obtener
obvio
oca
ocaso
oce\u0301ano
ochenta
ocho
ocio
ocre
octavo
octubre
oculto
ocupar
ocurrir
odiar
odio
odisea
oeste
ofensa
oferta
oficio
ofrecer
ogro
oi\u0301do
oi\u0301r
ojo
ola
oleada
olfato
olivo
olla
olmo
olor
olvido
ombligo
onda
onza
opaco
opcio\u0301n
o\u0301pera
opinar
oponer
optar
o\u0301ptica
opuesto
oracio\u0301n
orador
oral
o\u0301rbita
orca
orden
oreja
o\u0301rgano
orgi\u0301a
orgullo
oriente
origen
orilla
oro
orquesta
oruga
osadi\u0301a
oscuro
osezno
oso
ostra
oton\u0303o
otro
oveja
o\u0301vulo
o\u0301xido
oxi\u0301geno
oyente
ozono
pacto
padre
paella
pa\u0301gina
pago
pai\u0301s
pa\u0301jaro
palabra
palco
paleta
pa\u0301lido
palma
paloma
palpar
pan
panal
pa\u0301nico
pantera
pan\u0303uelo
papa\u0301
papel
papilla
paquete
parar
parcela
pared
parir
paro
pa\u0301rpado
parque
pa\u0301rrafo
parte
pasar
paseo
pasio\u0301n
paso
pasta
pata
patio
patria
pausa
pauta
pavo
payaso
peato\u0301n
pecado
pecera
pecho
pedal
pedir
pegar
peine
pelar
peldan\u0303o
pelea
peligro
pellejo
pelo
peluca
pena
pensar
pen\u0303o\u0301n
peo\u0301n
peor
pepino
pequen\u0303o
pera
percha
perder
pereza
perfil
perico
perla
permiso
perro
persona
pesa
pesca
pe\u0301simo
pestan\u0303a
pe\u0301talo
petro\u0301leo
pez
pezun\u0303a
picar
picho\u0301n
pie
piedra
pierna
pieza
pijama
pilar
piloto
pimienta
pino
pintor
pinza
pin\u0303a
piojo
pipa
pirata
pisar
piscina
piso
pista
pito\u0301n
pizca
placa
plan
plata
playa
plaza
pleito
pleno
plomo
pluma
plural
pobre
poco
poder
podio
poema
poesi\u0301a
poeta
polen
polici\u0301a
pollo
polvo
pomada
pomelo
pomo
pompa
poner
porcio\u0301n
portal
posada
poseer
posible
poste
potencia
potro
pozo
prado
precoz
pregunta
premio
prensa
preso
previo
primo
pri\u0301ncipe
prisio\u0301n
privar
proa
probar
proceso
producto
proeza
profesor
programa
prole
promesa
pronto
propio
pro\u0301ximo
prueba
pu\u0301blico
puchero
pudor
pueblo
puerta
puesto
pulga
pulir
pulmo\u0301n
pulpo
pulso
puma
punto
pun\u0303al
pun\u0303o
pupa
pupila
pure\u0301
quedar
queja
quemar
querer
queso
quieto
qui\u0301mica
quince
quitar
ra\u0301bano
rabia
rabo
racio\u0301n
radical
rai\u0301z
rama
rampa
rancho
rango
rapaz
ra\u0301pido
rapto
rasgo
raspa
rato
rayo
raza
razo\u0301n
reaccio\u0301n
realidad
reban\u0303o
rebote
recaer
receta
rechazo
recoger
recreo
recto
recurso
red
redondo
reducir
reflejo
reforma
refra\u0301n
refugio
regalo
regir
regla
regreso
rehe\u0301n
reino
rei\u0301r
reja
relato
relevo
relieve
relleno
reloj
remar
remedio
remo
rencor
rendir
renta
reparto
repetir
reposo
reptil
res
rescate
resina
respeto
resto
resumen
retiro
retorno
retrato
reunir
reve\u0301s
revista
rey
rezar
rico
riego
rienda
riesgo
rifa
ri\u0301gido
rigor
rinco\u0301n
rin\u0303o\u0301n
ri\u0301o
riqueza
risa
ritmo
rito
rizo
roble
roce
rociar
rodar
rodeo
rodilla
roer
rojizo
rojo
romero
romper
ron
ronco
ronda
ropa
ropero
rosa
rosca
rostro
rotar
rubi\u0301
rubor
rudo
rueda
rugir
ruido
ruina
ruleta
rulo
rumbo
rumor
ruptura
ruta
rutina
sa\u0301bado
saber
sabio
sable
sacar
sagaz
sagrado
sala
saldo
salero
salir
salmo\u0301n
salo\u0301n
salsa
salto
salud
salvar
samba
sancio\u0301n
sandi\u0301a
sanear
sangre
sanidad
sano
santo
sapo
saque
sardina
sarte\u0301n
sastre
sata\u0301n
sauna
saxofo\u0301n
seccio\u0301n
seco
secreto
secta
sed
seguir
seis
sello
selva
semana
semilla
senda
sensor
sen\u0303al
sen\u0303or
separar
sepia
sequi\u0301a
ser
serie
sermo\u0301n
servir
sesenta
sesio\u0301n
seta
setenta
severo
sexo
sexto
sidra
siesta
siete
siglo
signo
si\u0301laba
silbar
silencio
silla
si\u0301mbolo
simio
sirena
sistema
sitio
situar
sobre
socio
sodio
sol
solapa
soldado
soledad
so\u0301lido
soltar
solucio\u0301n
sombra
sondeo
sonido
sonoro
sonrisa
sopa
soplar
soporte
sordo
sorpresa
sorteo
soste\u0301n
so\u0301tano
suave
subir
suceso
sudor
suegra
suelo
suen\u0303o
suerte
sufrir
sujeto
sulta\u0301n
sumar
superar
suplir
suponer
supremo
sur
surco
suren\u0303o
surgir
susto
sutil
tabaco
tabique
tabla
tabu\u0301
taco
tacto
tajo
talar
talco
talento
talla
talo\u0301n
taman\u0303o
tambor
tango
tanque
tapa
tapete
tapia
tapo\u0301n
taquilla
tarde
tarea
tarifa
tarjeta
tarot
tarro
tarta
tatuaje
tauro
taza
tazo\u0301n
teatro
techo
tecla
te\u0301cnica
tejado
tejer
tejido
tela
tele\u0301fono
tema
temor
templo
tenaz
tender
tener
tenis
tenso
teori\u0301a
terapia
terco
te\u0301rmino
ternura
terror
tesis
tesoro
testigo
tetera
texto
tez
tibio
tiburo\u0301n
tiempo
tienda
tierra
tieso
tigre
tijera
tilde
timbre
ti\u0301mido
timo
tinta
ti\u0301o
ti\u0301pico
tipo
tira
tiro\u0301n
tita\u0301n
ti\u0301tere
ti\u0301tulo
tiza
toalla
tobillo
tocar
tocino
todo
toga
toldo
tomar
tono
tonto
topar
tope
toque
to\u0301rax
torero
tormenta
torneo
toro
torpedo
torre
torso
tortuga
tos
tosco
toser
to\u0301xico
trabajo
tractor
traer
tra\u0301fico
trago
traje
tramo
trance
trato
trauma
trazar
tre\u0301bol
tregua
treinta
tren
trepar
tres
tribu
trigo
tripa
triste
triunfo
trofeo
trompa
tronco
tropa
trote
trozo
truco
trueno
trufa
tuberi\u0301a
tubo
tuerto
tumba
tumor
tu\u0301nel
tu\u0301nica
turbina
turismo
turno
tutor
ubicar
u\u0301lcera
umbral
unidad
unir
universo
uno
untar
un\u0303a
urbano
urbe
urgente
urna
usar
usuario
u\u0301til
utopi\u0301a
uva
vaca
vaci\u0301o
vacuna
vagar
vago
vaina
vajilla
vale
va\u0301lido
valle
valor
va\u0301lvula
vampiro
vara
variar
varo\u0301n
vaso
vecino
vector
vehi\u0301culo
veinte
vejez
vela
velero
veloz
vena
vencer
venda
veneno
vengar
venir
venta
venus
ver
verano
verbo
verde
vereda
verja
verso
verter
vi\u0301a
viaje
vibrar
vicio
vi\u0301ctima
vida
vi\u0301deo
vidrio
viejo
viernes
vigor
vil
villa
vinagre
vino
vin\u0303edo
violi\u0301n
viral
virgo
virtud
visor
vi\u0301spera
vista
vitamina
viudo
vivaz
vivero
vivir
vivo
volca\u0301n
volumen
volver
voraz
votar
voto
voz
vuelo
vulgar
yacer
yate
yegua
yema
yerno
yeso
yodo
yoga
yogur
zafiro
zanja
zapato
zarza
zona
zorro
zumo
zurdo`.split("\n");
    }
  });

  // node_modules/@scure/bip39/wordlists/traditional-chinese.js
  var require_traditional_chinese = __commonJS({
    "node_modules/@scure/bip39/wordlists/traditional-chinese.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.wordlist = void 0;
      exports2.wordlist = `\u7684
\u4E00
\u662F
\u5728
\u4E0D
\u4E86
\u6709
\u548C
\u4EBA
\u9019
\u4E2D
\u5927
\u70BA
\u4E0A
\u500B
\u570B
\u6211
\u4EE5
\u8981
\u4ED6
\u6642
\u4F86
\u7528
\u5011
\u751F
\u5230
\u4F5C
\u5730
\u65BC
\u51FA
\u5C31
\u5206
\u5C0D
\u6210
\u6703
\u53EF
\u4E3B
\u767C
\u5E74
\u52D5
\u540C
\u5DE5
\u4E5F
\u80FD
\u4E0B
\u904E
\u5B50
\u8AAA
\u7522
\u7A2E
\u9762
\u800C
\u65B9
\u5F8C
\u591A
\u5B9A
\u884C
\u5B78
\u6CD5
\u6240
\u6C11
\u5F97
\u7D93
\u5341
\u4E09
\u4E4B
\u9032
\u8457
\u7B49
\u90E8
\u5EA6
\u5BB6
\u96FB
\u529B
\u88E1
\u5982
\u6C34
\u5316
\u9AD8
\u81EA
\u4E8C
\u7406
\u8D77
\u5C0F
\u7269
\u73FE
\u5BE6
\u52A0
\u91CF
\u90FD
\u5169
\u9AD4
\u5236
\u6A5F
\u7576
\u4F7F
\u9EDE
\u5F9E
\u696D
\u672C
\u53BB
\u628A
\u6027
\u597D
\u61C9
\u958B
\u5B83
\u5408
\u9084
\u56E0
\u7531
\u5176
\u4E9B
\u7136
\u524D
\u5916
\u5929
\u653F
\u56DB
\u65E5
\u90A3
\u793E
\u7FA9
\u4E8B
\u5E73
\u5F62
\u76F8
\u5168
\u8868
\u9593
\u6A23
\u8207
\u95DC
\u5404
\u91CD
\u65B0
\u7DDA
\u5167
\u6578
\u6B63
\u5FC3
\u53CD
\u4F60
\u660E
\u770B
\u539F
\u53C8
\u9EBC
\u5229
\u6BD4
\u6216
\u4F46
\u8CEA
\u6C23
\u7B2C
\u5411
\u9053
\u547D
\u6B64
\u8B8A
\u689D
\u53EA
\u6C92
\u7D50
\u89E3
\u554F
\u610F
\u5EFA
\u6708
\u516C
\u7121
\u7CFB
\u8ECD
\u5F88
\u60C5
\u8005
\u6700
\u7ACB
\u4EE3
\u60F3
\u5DF2
\u901A
\u4E26
\u63D0
\u76F4
\u984C
\u9EE8
\u7A0B
\u5C55
\u4E94
\u679C
\u6599
\u8C61
\u54E1
\u9769
\u4F4D
\u5165
\u5E38
\u6587
\u7E3D
\u6B21
\u54C1
\u5F0F
\u6D3B
\u8A2D
\u53CA
\u7BA1
\u7279
\u4EF6
\u9577
\u6C42
\u8001
\u982D
\u57FA
\u8CC7
\u908A
\u6D41
\u8DEF
\u7D1A
\u5C11
\u5716
\u5C71
\u7D71
\u63A5
\u77E5
\u8F03
\u5C07
\u7D44
\u898B
\u8A08
\u5225
\u5979
\u624B
\u89D2
\u671F
\u6839
\u8AD6
\u904B
\u8FB2
\u6307
\u5E7E
\u4E5D
\u5340
\u5F37
\u653E
\u6C7A
\u897F
\u88AB
\u5E79
\u505A
\u5FC5
\u6230
\u5148
\u56DE
\u5247
\u4EFB
\u53D6
\u64DA
\u8655
\u968A
\u5357
\u7D66
\u8272
\u5149
\u9580
\u5373
\u4FDD
\u6CBB
\u5317
\u9020
\u767E
\u898F
\u71B1
\u9818
\u4E03
\u6D77
\u53E3
\u6771
\u5C0E
\u5668
\u58D3
\u5FD7
\u4E16
\u91D1
\u589E
\u722D
\u6FDF
\u968E
\u6CB9
\u601D
\u8853
\u6975
\u4EA4
\u53D7
\u806F
\u4EC0
\u8A8D
\u516D
\u5171
\u6B0A
\u6536
\u8B49
\u6539
\u6E05
\u7F8E
\u518D
\u63A1
\u8F49
\u66F4
\u55AE
\u98A8
\u5207
\u6253
\u767D
\u6559
\u901F
\u82B1
\u5E36
\u5B89
\u5834
\u8EAB
\u8ECA
\u4F8B
\u771F
\u52D9
\u5177
\u842C
\u6BCF
\u76EE
\u81F3
\u9054
\u8D70
\u7A4D
\u793A
\u8B70
\u8072
\u5831
\u9B25
\u5B8C
\u985E
\u516B
\u96E2
\u83EF
\u540D
\u78BA
\u624D
\u79D1
\u5F35
\u4FE1
\u99AC
\u7BC0
\u8A71
\u7C73
\u6574
\u7A7A
\u5143
\u6CC1
\u4ECA
\u96C6
\u6EAB
\u50B3
\u571F
\u8A31
\u6B65
\u7FA4
\u5EE3
\u77F3
\u8A18
\u9700
\u6BB5
\u7814
\u754C
\u62C9
\u6797
\u5F8B
\u53EB
\u4E14
\u7A76
\u89C0
\u8D8A
\u7E54
\u88DD
\u5F71
\u7B97
\u4F4E
\u6301
\u97F3
\u773E
\u66F8
\u5E03
\u590D
\u5BB9
\u5152
\u9808
\u969B
\u5546
\u975E
\u9A57
\u9023
\u65B7
\u6DF1
\u96E3
\u8FD1
\u7926
\u5343
\u9031
\u59D4
\u7D20
\u6280
\u5099
\u534A
\u8FA6
\u9752
\u7701
\u5217
\u7FD2
\u97FF
\u7D04
\u652F
\u822C
\u53F2
\u611F
\u52DE
\u4FBF
\u5718
\u5F80
\u9178
\u6B77
\u5E02
\u514B
\u4F55
\u9664
\u6D88
\u69CB
\u5E9C
\u7A31
\u592A
\u6E96
\u7CBE
\u503C
\u865F
\u7387
\u65CF
\u7DAD
\u5283
\u9078
\u6A19
\u5BEB
\u5B58
\u5019
\u6BDB
\u89AA
\u5FEB
\u6548
\u65AF
\u9662
\u67E5
\u6C5F
\u578B
\u773C
\u738B
\u6309
\u683C
\u990A
\u6613
\u7F6E
\u6D3E
\u5C64
\u7247
\u59CB
\u537B
\u5C08
\u72C0
\u80B2
\u5EE0
\u4EAC
\u8B58
\u9069
\u5C6C
\u5713
\u5305
\u706B
\u4F4F
\u8ABF
\u6EFF
\u7E23
\u5C40
\u7167
\u53C3
\u7D05
\u7D30
\u5F15
\u807D
\u8A72
\u9435
\u50F9
\u56B4
\u9996
\u5E95
\u6DB2
\u5B98
\u5FB7
\u96A8
\u75C5
\u8607
\u5931
\u723E
\u6B7B
\u8B1B
\u914D
\u5973
\u9EC3
\u63A8
\u986F
\u8AC7
\u7F6A
\u795E
\u85DD
\u5462
\u5E2D
\u542B
\u4F01
\u671B
\u5BC6
\u6279
\u71DF
\u9805
\u9632
\u8209
\u7403
\u82F1
\u6C27
\u52E2
\u544A
\u674E
\u53F0
\u843D
\u6728
\u5E6B
\u8F2A
\u7834
\u4E9E
\u5E2B
\u570D
\u6CE8
\u9060
\u5B57
\u6750
\u6392
\u4F9B
\u6CB3
\u614B
\u5C01
\u53E6
\u65BD
\u6E1B
\u6A39
\u6EB6
\u600E
\u6B62
\u6848
\u8A00
\u58EB
\u5747
\u6B66
\u56FA
\u8449
\u9B5A
\u6CE2
\u8996
\u50C5
\u8CBB
\u7DCA
\u611B
\u5DE6
\u7AE0
\u65E9
\u671D
\u5BB3
\u7E8C
\u8F15
\u670D
\u8A66
\u98DF
\u5145
\u5175
\u6E90
\u5224
\u8B77
\u53F8
\u8DB3
\u67D0
\u7DF4
\u5DEE
\u81F4
\u677F
\u7530
\u964D
\u9ED1
\u72AF
\u8CA0
\u64CA
\u8303
\u7E7C
\u8208
\u4F3C
\u9918
\u5805
\u66F2
\u8F38
\u4FEE
\u6545
\u57CE
\u592B
\u5920
\u9001
\u7B46
\u8239
\u4F54
\u53F3
\u8CA1
\u5403
\u5BCC
\u6625
\u8077
\u89BA
\u6F22
\u756B
\u529F
\u5DF4
\u8DDF
\u96D6
\u96DC
\u98DB
\u6AA2
\u5438
\u52A9
\u6607
\u967D
\u4E92
\u521D
\u5275
\u6297
\u8003
\u6295
\u58DE
\u7B56
\u53E4
\u5F91
\u63DB
\u672A
\u8DD1
\u7559
\u92FC
\u66FE
\u7AEF
\u8CAC
\u7AD9
\u7C21
\u8FF0
\u9322
\u526F
\u76E1
\u5E1D
\u5C04
\u8349
\u885D
\u627F
\u7368
\u4EE4
\u9650
\u963F
\u5BA3
\u74B0
\u96D9
\u8ACB
\u8D85
\u5FAE
\u8B93
\u63A7
\u5DDE
\u826F
\u8EF8
\u627E
\u5426
\u7D00
\u76CA
\u4F9D
\u512A
\u9802
\u790E
\u8F09
\u5012
\u623F
\u7A81
\u5750
\u7C89
\u6575
\u7565
\u5BA2
\u8881
\u51B7
\u52DD
\u7D55
\u6790
\u584A
\u5291
\u6E2C
\u7D72
\u5354
\u8A34
\u5FF5
\u9673
\u4ECD
\u7F85
\u9E7D
\u53CB
\u6D0B
\u932F
\u82E6
\u591C
\u5211
\u79FB
\u983B
\u9010
\u9760
\u6DF7
\u6BCD
\u77ED
\u76AE
\u7D42
\u805A
\u6C7D
\u6751
\u96F2
\u54EA
\u65E2
\u8DDD
\u885B
\u505C
\u70C8
\u592E
\u5BDF
\u71D2
\u8FC5
\u5883
\u82E5
\u5370
\u6D32
\u523B
\u62EC
\u6FC0
\u5B54
\u641E
\u751A
\u5BA4
\u5F85
\u6838
\u6821
\u6563
\u4FB5
\u5427
\u7532
\u904A
\u4E45
\u83DC
\u5473
\u820A
\u6A21
\u6E56
\u8CA8
\u640D
\u9810
\u963B
\u6BEB
\u666E
\u7A69
\u4E59
\u5ABD
\u690D
\u606F
\u64F4
\u9280
\u8A9E
\u63EE
\u9152
\u5B88
\u62FF
\u5E8F
\u7D19
\u91AB
\u7F3A
\u96E8
\u55CE
\u91DD
\u5289
\u554A
\u6025
\u5531
\u8AA4
\u8A13
\u9858
\u5BE9
\u9644
\u7372
\u8336
\u9BAE
\u7CE7
\u65A4
\u5B69
\u812B
\u786B
\u80A5
\u5584
\u9F8D
\u6F14
\u7236
\u6F38
\u8840
\u6B61
\u68B0
\u638C
\u6B4C
\u6C99
\u525B
\u653B
\u8B02
\u76FE
\u8A0E
\u665A
\u7C92
\u4E82
\u71C3
\u77DB
\u4E4E
\u6BBA
\u85E5
\u5BE7
\u9B6F
\u8CB4
\u9418
\u7164
\u8B80
\u73ED
\u4F2F
\u9999
\u4ECB
\u8FEB
\u53E5
\u8C50
\u57F9
\u63E1
\u862D
\u64D4
\u5F26
\u86CB
\u6C89
\u5047
\u7A7F
\u57F7
\u7B54
\u6A02
\u8AB0
\u9806
\u7159
\u7E2E
\u5FB5
\u81C9
\u559C
\u677E
\u8173
\u56F0
\u7570
\u514D
\u80CC
\u661F
\u798F
\u8CB7
\u67D3
\u4E95
\u6982
\u6162
\u6015
\u78C1
\u500D
\u7956
\u7687
\u4FC3
\u975C
\u88DC
\u8A55
\u7FFB
\u8089
\u8E10
\u5C3C
\u8863
\u5BEC
\u63DA
\u68C9
\u5E0C
\u50B7
\u64CD
\u5782
\u79CB
\u5B9C
\u6C2B
\u5957
\u7763
\u632F
\u67B6
\u4EAE
\u672B
\u61B2
\u6176
\u7DE8
\u725B
\u89F8
\u6620
\u96F7
\u92B7
\u8A69
\u5EA7
\u5C45
\u6293
\u88C2
\u80DE
\u547C
\u5A18
\u666F
\u5A01
\u7DA0
\u6676
\u539A
\u76DF
\u8861
\u96DE
\u5B6B
\u5EF6
\u5371
\u81A0
\u5C4B
\u9109
\u81E8
\u9678
\u9867
\u6389
\u5440
\u71C8
\u6B72
\u63AA
\u675F
\u8010
\u5287
\u7389
\u8D99
\u8DF3
\u54E5
\u5B63
\u8AB2
\u51F1
\u80E1
\u984D
\u6B3E
\u7D39
\u5377
\u9F4A
\u5049
\u84B8
\u6B96
\u6C38
\u5B97
\u82D7
\u5DDD
\u7210
\u5CA9
\u5F31
\u96F6
\u694A
\u594F
\u6CBF
\u9732
\u687F
\u63A2
\u6ED1
\u93AE
\u98EF
\u6FC3
\u822A
\u61F7
\u8D95
\u5EAB
\u596A
\u4F0A
\u9748
\u7A05
\u9014
\u6EC5
\u8CFD
\u6B78
\u53EC
\u9F13
\u64AD
\u76E4
\u88C1
\u96AA
\u5EB7
\u552F
\u9304
\u83CC
\u7D14
\u501F
\u7CD6
\u84CB
\u6A6B
\u7B26
\u79C1
\u52AA
\u5802
\u57DF
\u69CD
\u6F64
\u5E45
\u54C8
\u7ADF
\u719F
\u87F2
\u6FA4
\u8166
\u58E4
\u78B3
\u6B50
\u904D
\u5074
\u5BE8
\u6562
\u5FB9
\u616E
\u659C
\u8584
\u5EAD
\u7D0D
\u5F48
\u98FC
\u4F38
\u6298
\u9EA5
\u6FD5
\u6697
\u8377
\u74E6
\u585E
\u5E8A
\u7BC9
\u60E1
\u6236
\u8A2A
\u5854
\u5947
\u900F
\u6881
\u5200
\u65CB
\u8DE1
\u5361
\u6C2F
\u9047
\u4EFD
\u6BD2
\u6CE5
\u9000
\u6D17
\u64FA
\u7070
\u5F69
\u8CE3
\u8017
\u590F
\u64C7
\u5FD9
\u9285
\u737B
\u786C
\u4E88
\u7E41
\u5708
\u96EA
\u51FD
\u4EA6
\u62BD
\u7BC7
\u9663
\u9670
\u4E01
\u5C3A
\u8FFD
\u5806
\u96C4
\u8FCE
\u6CDB
\u7238
\u6A13
\u907F
\u8B00
\u5678
\u91CE
\u8C6C
\u65D7
\u7D2F
\u504F
\u5178
\u9928
\u7D22
\u79E6
\u8102
\u6F6E
\u723A
\u8C46
\u5FFD
\u6258
\u9A5A
\u5851
\u907A
\u6108
\u6731
\u66FF
\u7E96
\u7C97
\u50BE
\u5C1A
\u75DB
\u695A
\u8B1D
\u596E
\u8CFC
\u78E8
\u541B
\u6C60
\u65C1
\u788E
\u9AA8
\u76E3
\u6355
\u5F1F
\u66B4
\u5272
\u8CAB
\u6B8A
\u91CB
\u8A5E
\u4EA1
\u58C1
\u9813
\u5BF6
\u5348
\u5875
\u805E
\u63ED
\u70AE
\u6B98
\u51AC
\u6A4B
\u5A66
\u8B66
\u7D9C
\u62DB
\u5433
\u4ED8
\u6D6E
\u906D
\u5F90
\u60A8
\u6416
\u8C37
\u8D0A
\u7BB1
\u9694
\u8A02
\u7537
\u5439
\u5712
\u7D1B
\u5510
\u6557
\u5B8B
\u73BB
\u5DE8
\u8015
\u5766
\u69AE
\u9589
\u7063
\u9375
\u51E1
\u99D0
\u934B
\u6551
\u6069
\u525D
\u51DD
\u9E7C
\u9F52
\u622A
\u7149
\u9EBB
\u7D21
\u7981
\u5EE2
\u76DB
\u7248
\u7DE9
\u6DE8
\u775B
\u660C
\u5A5A
\u6D89
\u7B52
\u5634
\u63D2
\u5CB8
\u6717
\u838A
\u8857
\u85CF
\u59D1
\u8CBF
\u8150
\u5974
\u5566
\u6163
\u4E58
\u5925
\u6062
\u52FB
\u7D17
\u624E
\u8FAF
\u8033
\u5F6A
\u81E3
\u5104
\u7483
\u62B5
\u8108
\u79C0
\u85A9
\u4FC4
\u7DB2
\u821E
\u5E97
\u5674
\u7E31
\u5BF8
\u6C57
\u639B
\u6D2A
\u8CC0
\u9583
\u67EC
\u7206
\u70EF
\u6D25
\u7A3B
\u7246
\u8EDF
\u52C7
\u50CF
\u6EFE
\u5398
\u8499
\u82B3
\u80AF
\u5761
\u67F1
\u76EA
\u817F
\u5100
\u65C5
\u5C3E
\u8ECB
\u51B0
\u8CA2
\u767B
\u9ECE
\u524A
\u947D
\u52D2
\u9003
\u969C
\u6C28
\u90ED
\u5CF0
\u5E63
\u6E2F
\u4F0F
\u8ECC
\u755D
\u7562
\u64E6
\u83AB
\u523A
\u6D6A
\u79D8
\u63F4
\u682A
\u5065
\u552E
\u80A1
\u5CF6
\u7518
\u6CE1
\u7761
\u7AE5
\u9444
\u6E6F
\u95A5
\u4F11
\u532F
\u820D
\u7267
\u7E5E
\u70B8
\u54F2
\u78F7
\u7E3E
\u670B
\u6DE1
\u5C16
\u555F
\u9677
\u67F4
\u5448
\u5F92
\u984F
\u6DDA
\u7A0D
\u5FD8
\u6CF5
\u85CD
\u62D6
\u6D1E
\u6388
\u93E1
\u8F9B
\u58EF
\u92D2
\u8CA7
\u865B
\u5F4E
\u6469
\u6CF0
\u5E7C
\u5EF7
\u5C0A
\u7A97
\u7DB1
\u5F04
\u96B8
\u7591
\u6C0F
\u5BAE
\u59D0
\u9707
\u745E
\u602A
\u5C24
\u7434
\u5FAA
\u63CF
\u819C
\u9055
\u593E
\u8170
\u7DE3
\u73E0
\u7AAE
\u68EE
\u679D
\u7AF9
\u6E9D
\u50AC
\u7E69
\u61B6
\u90A6
\u5269
\u5E78
\u6F3F
\u6B04
\u64C1
\u7259
\u8CAF
\u79AE
\u6FFE
\u9209
\u7D0B
\u7F77
\u62CD
\u54B1
\u558A
\u8896
\u57C3
\u52E4
\u7F70
\u7126
\u6F5B
\u4F0D
\u58A8
\u6B32
\u7E2B
\u59D3
\u520A
\u98FD
\u4EFF
\u734E
\u92C1
\u9B3C
\u9E97
\u8DE8
\u9ED8
\u6316
\u93C8
\u6383
\u559D
\u888B
\u70AD
\u6C61
\u5E55
\u8AF8
\u5F27
\u52F5
\u6885
\u5976
\u6F54
\u707D
\u821F
\u9451
\u82EF
\u8A1F
\u62B1
\u6BC0
\u61C2
\u5BD2
\u667A
\u57D4
\u5BC4
\u5C46
\u8E8D
\u6E21
\u6311
\u4E39
\u8271
\u8C9D
\u78B0
\u62D4
\u7239
\u6234
\u78BC
\u5922
\u82BD
\u7194
\u8D64
\u6F01
\u54ED
\u656C
\u9846
\u5954
\u925B
\u4EF2
\u864E
\u7A00
\u59B9
\u4E4F
\u73CD
\u7533
\u684C
\u9075
\u5141
\u9686
\u87BA
\u5009
\u9B4F
\u92B3
\u66C9
\u6C2E
\u517C
\u96B1
\u7919
\u8D6B
\u64A5
\u5FE0
\u8085
\u7F38
\u727D
\u6436
\u535A
\u5DE7
\u6BBC
\u5144
\u675C
\u8A0A
\u8AA0
\u78A7
\u7965
\u67EF
\u9801
\u5DE1
\u77E9
\u60B2
\u704C
\u9F61
\u502B
\u7968
\u5C0B
\u6842
\u92EA
\u8056
\u6050
\u6070
\u912D
\u8DA3
\u62AC
\u8352
\u9A30
\u8CBC
\u67D4
\u6EF4
\u731B
\u95CA
\u8F1B
\u59BB
\u586B
\u64A4
\u5132
\u7C3D
\u9B27
\u64FE
\u7D2B
\u7802
\u905E
\u6232
\u540A
\u9676
\u4F10
\u9935
\u7642
\u74F6
\u5A46
\u64AB
\u81C2
\u6478
\u5FCD
\u8766
\u881F
\u9130
\u80F8
\u978F
\u64E0
\u5076
\u68C4
\u69FD
\u52C1
\u4E73
\u9127
\u5409
\u4EC1
\u721B
\u78DA
\u79DF
\u70CF
\u8266
\u4F34
\u74DC
\u6DFA
\u4E19
\u66AB
\u71E5
\u6A61
\u67F3
\u8FF7
\u6696
\u724C
\u79E7
\u81BD
\u8A73
\u7C27
\u8E0F
\u74F7
\u8B5C
\u5446
\u8CD3
\u7CCA
\u6D1B
\u8F1D
\u61A4
\u7AF6
\u9699
\u6012
\u7C98
\u4E43
\u7DD2
\u80A9
\u7C4D
\u654F
\u5857
\u7199
\u7686
\u5075
\u61F8
\u6398
\u4EAB
\u7CFE
\u9192
\u72C2
\u9396
\u6DC0
\u6068
\u7272
\u9738
\u722C
\u8CDE
\u9006
\u73A9
\u9675
\u795D
\u79D2
\u6D59
\u8C8C
\u5F79
\u5F7C
\u6089
\u9D28
\u8DA8
\u9CF3
\u6668
\u755C
\u8F29
\u79E9
\u5375
\u7F72
\u68AF
\u708E
\u7058
\u68CB
\u9A45
\u7BE9
\u5CFD
\u5192
\u5565
\u58FD
\u8B6F
\u6D78
\u6CC9
\u5E3D
\u9072
\u77FD
\u7586
\u8CB8
\u6F0F
\u7A3F
\u51A0
\u5AE9
\u8105
\u82AF
\u7262
\u53DB
\u8755
\u5967
\u9CF4
\u5DBA
\u7F8A
\u6191
\u4E32
\u5858
\u7E6A
\u9175
\u878D
\u76C6
\u932B
\u5EDF
\u7C4C
\u51CD
\u8F14
\u651D
\u8972
\u7B4B
\u62D2
\u50DA
\u65F1
\u9240
\u9CE5
\u6F06
\u6C88
\u7709
\u758F
\u6DFB
\u68D2
\u7A57
\u785D
\u97D3
\u903C
\u626D
\u50D1
\u6DBC
\u633A
\u7897
\u683D
\u7092
\u676F
\u60A3
\u993E
\u52F8
\u8C6A
\u907C
\u52C3
\u9D3B
\u65E6
\u540F
\u62DC
\u72D7
\u57CB
\u8F25
\u63A9
\u98F2
\u642C
\u7F75
\u8FAD
\u52FE
\u6263
\u4F30
\u8523
\u7D68
\u9727
\u4E08
\u6735
\u59C6
\u64EC
\u5B87
\u8F2F
\u965D
\u96D5
\u511F
\u84C4
\u5D07
\u526A
\u5021
\u5EF3
\u54AC
\u99DB
\u85AF
\u5237
\u65A5
\u756A
\u8CE6
\u5949
\u4F5B
\u6F86
\u6F2B
\u66FC
\u6247
\u9223
\u6843
\u6276
\u4ED4
\u8FD4
\u4FD7
\u8667
\u8154
\u978B
\u68F1
\u8986
\u6846
\u6084
\u53D4
\u649E
\u9A19
\u52D8
\u65FA
\u6CB8
\u5B64
\u5410
\u5B5F
\u6E20
\u5C48
\u75BE
\u5999
\u60DC
\u4EF0
\u72E0
\u8139
\u8AE7
\u62CB
\u9EF4
\u6851
\u5D17
\u561B
\u8870
\u76DC
\u6EF2
\u81DF
\u8CF4
\u6E67
\u751C
\u66F9
\u95B1
\u808C
\u54E9
\u53B2
\u70F4
\u7DEF
\u6BC5
\u6628
\u507D
\u75C7
\u716E
\u5606
\u91D8
\u642D
\u8396
\u7C60
\u9177
\u5077
\u5F13
\u9310
\u6046
\u5091
\u5751
\u9F3B
\u7FFC
\u7DB8
\u6558
\u7344
\u902E
\u7F50
\u7D61
\u68DA
\u6291
\u81A8
\u852C
\u5BFA
\u9A5F
\u7A46
\u51B6
\u67AF
\u518A
\u5C4D
\u51F8
\u7D33
\u576F
\u72A7
\u7130
\u8F5F
\u6B23
\u6649
\u7626
\u79A6
\u9320
\u9326
\u55AA
\u65EC
\u935B
\u58DF
\u641C
\u64B2
\u9080
\u4EAD
\u916F
\u9081
\u8212
\u8106
\u9176
\u9592
\u6182
\u915A
\u9811
\u7FBD
\u6F32
\u5378
\u4ED7
\u966A
\u95E2
\u61F2
\u676D
\u59DA
\u809A
\u6349
\u98C4
\u6F02
\u6606
\u6B3A
\u543E
\u90CE
\u70F7
\u6C41
\u5475
\u98FE
\u856D
\u96C5
\u90F5
\u9077
\u71D5
\u6492
\u59FB
\u8D74
\u5BB4
\u7169
\u50B5
\u5E33
\u6591
\u9234
\u65E8
\u9187
\u8463
\u9905
\u96DB
\u59FF
\u62CC
\u5085
\u8179
\u59A5
\u63C9
\u8CE2
\u62C6
\u6B6A
\u8461
\u80FA
\u4E1F
\u6D69
\u5FBD
\u6602
\u588A
\u64CB
\u89BD
\u8CAA
\u6170
\u7E73
\u6C6A
\u614C
\u99AE
\u8AFE
\u59DC
\u8ABC
\u5147
\u52A3
\u8AA3
\u8000
\u660F
\u8EBA
\u76C8
\u9A0E
\u55AC
\u6EAA
\u53E2
\u76E7
\u62B9
\u60B6
\u8AEE
\u522E
\u99D5
\u7E9C
\u609F
\u6458
\u927A
\u64F2
\u9817
\u5E7B
\u67C4
\u60E0
\u6158
\u4F73
\u4EC7
\u81D8
\u7AA9
\u6ECC
\u528D
\u77A7
\u5821
\u6F51
\u8525
\u7F69
\u970D
\u6488
\u80CE
\u84BC
\u6FF1
\u5006
\u6345
\u6E58
\u780D
\u971E
\u90B5
\u8404
\u760B
\u6DEE
\u9042
\u718A
\u7CDE
\u70D8
\u5BBF
\u6A94
\u6208
\u99C1
\u5AC2
\u88D5
\u5F99
\u7BAD
\u6350
\u8178
\u6490
\u66EC
\u8FA8
\u6BBF
\u84EE
\u6524
\u652A
\u91AC
\u5C4F
\u75AB
\u54C0
\u8521
\u5835
\u6CAB
\u76BA
\u66A2
\u758A
\u95A3
\u840A
\u6572
\u8F44
\u9264
\u75D5
\u58E9
\u5DF7
\u9913
\u798D
\u4E18
\u7384
\u6E9C
\u66F0
\u908F
\u5F6D
\u5617
\u537F
\u59A8
\u8247
\u541E
\u97CB
\u6028
\u77EE
\u6B47`.split("\n");
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports2, module2) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            // Used to reproduce behavior of `batchedUpdates` in legacy mode.
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format3) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format3, args);
              }
            }
          }
          function error(format3) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format3, args);
              }
            }
          }
          function printWarning(level2, format3, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format3 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format3);
              Function.prototype.apply.call(console[level2], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            /**
             * Checks whether or not this composite component is mounted.
             * @param {ReactClass} publicInstance The instance we want to test.
             * @return {boolean} True if mounted, false otherwise.
             * @protected
             * @final
             */
            isMounted: function(publicInstance) {
              return false;
            },
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            /**
             * Replaces all of the state. Always use this or `setState` to mutate state.
             * You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} completeState Next state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            /**
             * Sets a subset of the state. This only exists because _pendingState is
             * internal. This provides a merging strategy that is not available to deep
             * properties which is confusing. TODO: Expose pendingState or don't use it
             * during the merge.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} partialState Next partial state to be merged with state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} Name of the calling function in the public API.
             * @internal
             */
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign2 = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component(props, context2, updater) {
            this.props = props;
            this.context = context2;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component.prototype.isReactComponent = {};
          Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component.prototype;
          function PureComponent(props, context2, updater) {
            this.props = props;
            this.context = context2;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign2(pureComponentPrototype, Component.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray3(a2) {
            return isArrayImpl(a2);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context2 = type;
                  return getContextName(context2) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x8) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement(type, config2, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config2);
                }
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              self2 = config2.__self === void 0 ? null : config2.__self;
              source = config2.__source === void 0 ? null : config2.__source;
              for (propName in config2) {
                if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i4 = 0; i4 < childrenLength; i4++) {
                childArray[i4] = arguments[i4 + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement(element, config2, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign2({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config2) {
                if (hasOwnProperty.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config2[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config2[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i4 = 0; i4 < childrenLength; i4++) {
                childArray[i4] = arguments[i4 + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement(object2) {
            return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape2(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index2) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape2("" + element.key);
            }
            return index2.toString(36);
          }
          function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray3(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c3) {
                  return c3;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                      // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                      // eslint-disable-next-line react-internal/safe-string-coercion
                      escapeUserProvidedKey("" + mappedChild.key) + "/"
                    ) : "") + childKey
                  );
                }
                array2.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray3(children)) {
              for (var i4 = 0; i4 < children.length; i4++) {
                child = children[i4];
                nextName = nextNamePrefix + getElementKey(child, i4);
                subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator2 = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator2.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context2) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context2, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n4 = 0;
            mapChildren(children, function() {
              n4++;
            });
            return n4;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext(defaultValue) {
            var context2 = {
              $$typeof: REACT_CONTEXT_TYPE,
              // As a workaround to support multiple concurrent renderers, we categorize
              // some renderers as primary and others as secondary. We only expect
              // there to be two concurrent renderers at most: React Native (primary) and
              // Fabric (secondary); React DOM (primary) and React ART (secondary).
              // Secondary renderers store their context values on separate fields.
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              // Used to track how many concurrent renderers this context currently
              // supports within in a single renderer. Such as parallel server rendering.
              _threadCount: 0,
              // These are circular
              Provider: null,
              Consumer: null,
              // Add these to use same hidden class in VM as ServerContext
              _defaultValue: null,
              _globalName: null
            };
            context2.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context2
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context2
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context2.Provider;
                  },
                  set: function(_Provider) {
                    context2.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context2._currentValue;
                  },
                  set: function(_currentValue) {
                    context2._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context2._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context2._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context2._threadCount;
                  },
                  set: function(_threadCount) {
                    context2._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context2.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context2.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context2.Consumer = Consumer;
            }
            {
              context2._currentRenderer = null;
              context2._currentRenderer2 = null;
            }
            return context2;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              // We use these fields to store the result.
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType2 = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType2, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType2, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType2, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType2;
          }
          function forwardRef(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render.name && !render.displayName) {
                    render.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo(type, compare2) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare2 === void 0 ? null : compare2
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
          }
          function useLayoutEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x8) {
                  var match = x8.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x8) {
                    control = x8;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x8) {
                    control = x8;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x8) {
                  control = x8;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s4 = sampleLines.length - 1;
                var c3 = controlLines.length - 1;
                while (s4 >= 1 && c3 >= 0 && sampleLines[s4] !== controlLines[c3]) {
                  c3--;
                }
                for (; s4 >= 1 && c3 >= 0; s4--, c3--) {
                  if (sampleLines[s4] !== controlLines[c3]) {
                    if (s4 !== 1 || c3 !== 1) {
                      do {
                        s4--;
                        c3--;
                        if (c3 < 0 || sampleLines[s4] !== controlLines[c3]) {
                          var _frame = "\n" + sampleLines[s4].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s4 >= 1 && c3 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x8) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray3(node)) {
              for (var i4 = 0; i4 < node.length; i4++) {
                var child = node[i4];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator2 = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator2.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i4 = 0; i4 < keys.length; i4++) {
                var key = keys[i4];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray3(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i4 = 2; i4 < arguments.length; i4++) {
                validateChildKeys(arguments[i4], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i4 = 2; i4 < arguments.length; i4++) {
              validateChildKeys(arguments[i4], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module2 && module2[requireString];
                enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error2) {
                popActScope(prevActScopeDepth);
                throw error2;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error2) {
                      popActScope(prevActScopeDepth);
                      reject(error2);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error2) {
                  reject(error2);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i4 = 0;
                try {
                  for (; i4 < queue.length; i4++) {
                    var callback = queue[i4];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error2) {
                  queue = queue.slice(i4 + 1);
                  throw error2;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports2.Children = Children;
          exports2.Component = Component;
          exports2.Fragment = REACT_FRAGMENT_TYPE;
          exports2.Profiler = REACT_PROFILER_TYPE;
          exports2.PureComponent = PureComponent;
          exports2.StrictMode = REACT_STRICT_MODE_TYPE;
          exports2.Suspense = REACT_SUSPENSE_TYPE;
          exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports2.cloneElement = cloneElement$1;
          exports2.createContext = createContext;
          exports2.createElement = createElement$1;
          exports2.createFactory = createFactory;
          exports2.createRef = createRef;
          exports2.forwardRef = forwardRef;
          exports2.isValidElement = isValidElement;
          exports2.lazy = lazy;
          exports2.memo = memo;
          exports2.startTransition = startTransition;
          exports2.unstable_act = act;
          exports2.useCallback = useCallback;
          exports2.useContext = useContext;
          exports2.useDebugValue = useDebugValue;
          exports2.useDeferredValue = useDeferredValue;
          exports2.useEffect = useEffect;
          exports2.useId = useId;
          exports2.useImperativeHandle = useImperativeHandle;
          exports2.useInsertionEffect = useInsertionEffect;
          exports2.useLayoutEffect = useLayoutEffect;
          exports2.useMemo = useMemo;
          exports2.useReducer = useReducer;
          exports2.useRef = useRef;
          exports2.useState = useState;
          exports2.useSyncExternalStore = useSyncExternalStore;
          exports2.useTransition = useTransition;
          exports2.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports2, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_development();
      }
    }
  });

  // node_modules/tuple-database/helpers/iterateTuples.js
  var require_iterateTuples = __commonJS({
    "node_modules/tuple-database/helpers/iterateTuples.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getWrittenTuples = exports2.iterateWrittenTuples = void 0;
      function* iterateWrittenTuples(write) {
        for (const { key } of write.set || []) {
          yield key;
        }
        for (const tuple of write.remove || []) {
          yield tuple;
        }
      }
      exports2.iterateWrittenTuples = iterateWrittenTuples;
      function getWrittenTuples(write) {
        return Array.from(iterateWrittenTuples(write));
      }
      exports2.getWrittenTuples = getWrittenTuples;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/rng.js
  var require_rng = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/rng.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = rng;
      var getRandomValues;
      var rnds8 = new Uint8Array(16);
      function rng() {
        if (!getRandomValues) {
          getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
          if (!getRandomValues) {
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
          }
        }
        return getRandomValues(rnds8);
      }
    }
  });

  // node_modules/uuid/dist/commonjs-browser/regex.js
  var require_regex = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/regex.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/validate.js
  var require_validate = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/validate.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _regex = _interopRequireDefault(require_regex());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function validate(uuid) {
        return typeof uuid === "string" && _regex.default.test(uuid);
      }
      var _default = validate;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/stringify.js
  var require_stringify = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/stringify.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      exports2.unsafeStringify = unsafeStringify;
      var _validate = _interopRequireDefault(require_validate());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var byteToHex = [];
      for (let i4 = 0; i4 < 256; ++i4) {
        byteToHex.push((i4 + 256).toString(16).slice(1));
      }
      function unsafeStringify(arr, offset = 0) {
        return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
      }
      function stringify2(arr, offset = 0) {
        const uuid = unsafeStringify(arr, offset);
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Stringified UUID is invalid");
        }
        return uuid;
      }
      var _default = stringify2;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v1.js
  var require_v1 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v1.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _rng = _interopRequireDefault(require_rng());
      var _stringify = require_stringify();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _nodeId;
      var _clockseq;
      var _lastMSecs = 0;
      var _lastNSecs = 0;
      function v1(options, buf, offset) {
        let i4 = buf && offset || 0;
        const b4 = buf || new Array(16);
        options = options || {};
        let node = options.node || _nodeId;
        let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
        if (node == null || clockseq == null) {
          const seedBytes = options.random || (options.rng || _rng.default)();
          if (node == null) {
            node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
          }
          if (clockseq == null) {
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
          }
        }
        let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
        let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
        const dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt2 < 0 && options.clockseq === void 0) {
          clockseq = clockseq + 1 & 16383;
        }
        if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
          nsecs = 0;
        }
        if (nsecs >= 1e4) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
        b4[i4++] = tl >>> 24 & 255;
        b4[i4++] = tl >>> 16 & 255;
        b4[i4++] = tl >>> 8 & 255;
        b4[i4++] = tl & 255;
        const tmh = msecs / 4294967296 * 1e4 & 268435455;
        b4[i4++] = tmh >>> 8 & 255;
        b4[i4++] = tmh & 255;
        b4[i4++] = tmh >>> 24 & 15 | 16;
        b4[i4++] = tmh >>> 16 & 255;
        b4[i4++] = clockseq >>> 8 | 128;
        b4[i4++] = clockseq & 255;
        for (let n4 = 0; n4 < 6; ++n4) {
          b4[i4 + n4] = node[n4];
        }
        return buf || (0, _stringify.unsafeStringify)(b4);
      }
      var _default = v1;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/parse.js
  var require_parse = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/parse.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _validate = _interopRequireDefault(require_validate());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function parse2(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }
        let v7;
        const arr = new Uint8Array(16);
        arr[0] = (v7 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
        arr[1] = v7 >>> 16 & 255;
        arr[2] = v7 >>> 8 & 255;
        arr[3] = v7 & 255;
        arr[4] = (v7 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
        arr[5] = v7 & 255;
        arr[6] = (v7 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
        arr[7] = v7 & 255;
        arr[8] = (v7 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
        arr[9] = v7 & 255;
        arr[10] = (v7 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
        arr[11] = v7 / 4294967296 & 255;
        arr[12] = v7 >>> 24 & 255;
        arr[13] = v7 >>> 16 & 255;
        arr[14] = v7 >>> 8 & 255;
        arr[15] = v7 & 255;
        return arr;
      }
      var _default = parse2;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v35.js
  var require_v35 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v35.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.URL = exports2.DNS = void 0;
      exports2.default = v35;
      var _stringify = require_stringify();
      var _parse = _interopRequireDefault(require_parse());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function stringToBytes2(str) {
        str = unescape(encodeURIComponent(str));
        const bytes2 = [];
        for (let i4 = 0; i4 < str.length; ++i4) {
          bytes2.push(str.charCodeAt(i4));
        }
        return bytes2;
      }
      var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      exports2.DNS = DNS;
      var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
      exports2.URL = URL2;
      function v35(name, version7, hashfunc) {
        function generateUUID(value, namespace, buf, offset) {
          var _namespace;
          if (typeof value === "string") {
            value = stringToBytes2(value);
          }
          if (typeof namespace === "string") {
            namespace = (0, _parse.default)(namespace);
          }
          if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
          }
          let bytes2 = new Uint8Array(16 + value.length);
          bytes2.set(namespace);
          bytes2.set(value, namespace.length);
          bytes2 = hashfunc(bytes2);
          bytes2[6] = bytes2[6] & 15 | version7;
          bytes2[8] = bytes2[8] & 63 | 128;
          if (buf) {
            offset = offset || 0;
            for (let i4 = 0; i4 < 16; ++i4) {
              buf[offset + i4] = bytes2[i4];
            }
            return buf;
          }
          return (0, _stringify.unsafeStringify)(bytes2);
        }
        try {
          generateUUID.name = name;
        } catch (err) {
        }
        generateUUID.DNS = DNS;
        generateUUID.URL = URL2;
        return generateUUID;
      }
    }
  });

  // node_modules/uuid/dist/commonjs-browser/md5.js
  var require_md5 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/md5.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      function md5(bytes2) {
        if (typeof bytes2 === "string") {
          const msg = unescape(encodeURIComponent(bytes2));
          bytes2 = new Uint8Array(msg.length);
          for (let i4 = 0; i4 < msg.length; ++i4) {
            bytes2[i4] = msg.charCodeAt(i4);
          }
        }
        return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
      }
      function md5ToHexEncodedArray(input) {
        const output2 = [];
        const length32 = input.length * 32;
        const hexTab = "0123456789abcdef";
        for (let i4 = 0; i4 < length32; i4 += 8) {
          const x8 = input[i4 >> 5] >>> i4 % 32 & 255;
          const hex2 = parseInt(hexTab.charAt(x8 >>> 4 & 15) + hexTab.charAt(x8 & 15), 16);
          output2.push(hex2);
        }
        return output2;
      }
      function getOutputLength(inputLength8) {
        return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
      }
      function wordsToMd5(x8, len) {
        x8[len >> 5] |= 128 << len % 32;
        x8[getOutputLength(len) - 1] = len;
        let a2 = 1732584193;
        let b4 = -271733879;
        let c3 = -1732584194;
        let d6 = 271733878;
        for (let i4 = 0; i4 < x8.length; i4 += 16) {
          const olda = a2;
          const oldb = b4;
          const oldc = c3;
          const oldd = d6;
          a2 = md5ff(a2, b4, c3, d6, x8[i4], 7, -680876936);
          d6 = md5ff(d6, a2, b4, c3, x8[i4 + 1], 12, -389564586);
          c3 = md5ff(c3, d6, a2, b4, x8[i4 + 2], 17, 606105819);
          b4 = md5ff(b4, c3, d6, a2, x8[i4 + 3], 22, -1044525330);
          a2 = md5ff(a2, b4, c3, d6, x8[i4 + 4], 7, -176418897);
          d6 = md5ff(d6, a2, b4, c3, x8[i4 + 5], 12, 1200080426);
          c3 = md5ff(c3, d6, a2, b4, x8[i4 + 6], 17, -1473231341);
          b4 = md5ff(b4, c3, d6, a2, x8[i4 + 7], 22, -45705983);
          a2 = md5ff(a2, b4, c3, d6, x8[i4 + 8], 7, 1770035416);
          d6 = md5ff(d6, a2, b4, c3, x8[i4 + 9], 12, -1958414417);
          c3 = md5ff(c3, d6, a2, b4, x8[i4 + 10], 17, -42063);
          b4 = md5ff(b4, c3, d6, a2, x8[i4 + 11], 22, -1990404162);
          a2 = md5ff(a2, b4, c3, d6, x8[i4 + 12], 7, 1804603682);
          d6 = md5ff(d6, a2, b4, c3, x8[i4 + 13], 12, -40341101);
          c3 = md5ff(c3, d6, a2, b4, x8[i4 + 14], 17, -1502002290);
          b4 = md5ff(b4, c3, d6, a2, x8[i4 + 15], 22, 1236535329);
          a2 = md5gg(a2, b4, c3, d6, x8[i4 + 1], 5, -165796510);
          d6 = md5gg(d6, a2, b4, c3, x8[i4 + 6], 9, -1069501632);
          c3 = md5gg(c3, d6, a2, b4, x8[i4 + 11], 14, 643717713);
          b4 = md5gg(b4, c3, d6, a2, x8[i4], 20, -373897302);
          a2 = md5gg(a2, b4, c3, d6, x8[i4 + 5], 5, -701558691);
          d6 = md5gg(d6, a2, b4, c3, x8[i4 + 10], 9, 38016083);
          c3 = md5gg(c3, d6, a2, b4, x8[i4 + 15], 14, -660478335);
          b4 = md5gg(b4, c3, d6, a2, x8[i4 + 4], 20, -405537848);
          a2 = md5gg(a2, b4, c3, d6, x8[i4 + 9], 5, 568446438);
          d6 = md5gg(d6, a2, b4, c3, x8[i4 + 14], 9, -1019803690);
          c3 = md5gg(c3, d6, a2, b4, x8[i4 + 3], 14, -187363961);
          b4 = md5gg(b4, c3, d6, a2, x8[i4 + 8], 20, 1163531501);
          a2 = md5gg(a2, b4, c3, d6, x8[i4 + 13], 5, -1444681467);
          d6 = md5gg(d6, a2, b4, c3, x8[i4 + 2], 9, -51403784);
          c3 = md5gg(c3, d6, a2, b4, x8[i4 + 7], 14, 1735328473);
          b4 = md5gg(b4, c3, d6, a2, x8[i4 + 12], 20, -1926607734);
          a2 = md5hh(a2, b4, c3, d6, x8[i4 + 5], 4, -378558);
          d6 = md5hh(d6, a2, b4, c3, x8[i4 + 8], 11, -2022574463);
          c3 = md5hh(c3, d6, a2, b4, x8[i4 + 11], 16, 1839030562);
          b4 = md5hh(b4, c3, d6, a2, x8[i4 + 14], 23, -35309556);
          a2 = md5hh(a2, b4, c3, d6, x8[i4 + 1], 4, -1530992060);
          d6 = md5hh(d6, a2, b4, c3, x8[i4 + 4], 11, 1272893353);
          c3 = md5hh(c3, d6, a2, b4, x8[i4 + 7], 16, -155497632);
          b4 = md5hh(b4, c3, d6, a2, x8[i4 + 10], 23, -1094730640);
          a2 = md5hh(a2, b4, c3, d6, x8[i4 + 13], 4, 681279174);
          d6 = md5hh(d6, a2, b4, c3, x8[i4], 11, -358537222);
          c3 = md5hh(c3, d6, a2, b4, x8[i4 + 3], 16, -722521979);
          b4 = md5hh(b4, c3, d6, a2, x8[i4 + 6], 23, 76029189);
          a2 = md5hh(a2, b4, c3, d6, x8[i4 + 9], 4, -640364487);
          d6 = md5hh(d6, a2, b4, c3, x8[i4 + 12], 11, -421815835);
          c3 = md5hh(c3, d6, a2, b4, x8[i4 + 15], 16, 530742520);
          b4 = md5hh(b4, c3, d6, a2, x8[i4 + 2], 23, -995338651);
          a2 = md5ii(a2, b4, c3, d6, x8[i4], 6, -198630844);
          d6 = md5ii(d6, a2, b4, c3, x8[i4 + 7], 10, 1126891415);
          c3 = md5ii(c3, d6, a2, b4, x8[i4 + 14], 15, -1416354905);
          b4 = md5ii(b4, c3, d6, a2, x8[i4 + 5], 21, -57434055);
          a2 = md5ii(a2, b4, c3, d6, x8[i4 + 12], 6, 1700485571);
          d6 = md5ii(d6, a2, b4, c3, x8[i4 + 3], 10, -1894986606);
          c3 = md5ii(c3, d6, a2, b4, x8[i4 + 10], 15, -1051523);
          b4 = md5ii(b4, c3, d6, a2, x8[i4 + 1], 21, -2054922799);
          a2 = md5ii(a2, b4, c3, d6, x8[i4 + 8], 6, 1873313359);
          d6 = md5ii(d6, a2, b4, c3, x8[i4 + 15], 10, -30611744);
          c3 = md5ii(c3, d6, a2, b4, x8[i4 + 6], 15, -1560198380);
          b4 = md5ii(b4, c3, d6, a2, x8[i4 + 13], 21, 1309151649);
          a2 = md5ii(a2, b4, c3, d6, x8[i4 + 4], 6, -145523070);
          d6 = md5ii(d6, a2, b4, c3, x8[i4 + 11], 10, -1120210379);
          c3 = md5ii(c3, d6, a2, b4, x8[i4 + 2], 15, 718787259);
          b4 = md5ii(b4, c3, d6, a2, x8[i4 + 9], 21, -343485551);
          a2 = safeAdd(a2, olda);
          b4 = safeAdd(b4, oldb);
          c3 = safeAdd(c3, oldc);
          d6 = safeAdd(d6, oldd);
        }
        return [a2, b4, c3, d6];
      }
      function bytesToWords(input) {
        if (input.length === 0) {
          return [];
        }
        const length8 = input.length * 8;
        const output2 = new Uint32Array(getOutputLength(length8));
        for (let i4 = 0; i4 < length8; i4 += 8) {
          output2[i4 >> 5] |= (input[i4 / 8] & 255) << i4 % 32;
        }
        return output2;
      }
      function safeAdd(x8, y4) {
        const lsw = (x8 & 65535) + (y4 & 65535);
        const msw = (x8 >> 16) + (y4 >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5cmn(q4, a2, b4, x8, s4, t3) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q4), safeAdd(x8, t3)), s4), b4);
      }
      function md5ff(a2, b4, c3, d6, x8, s4, t3) {
        return md5cmn(b4 & c3 | ~b4 & d6, a2, b4, x8, s4, t3);
      }
      function md5gg(a2, b4, c3, d6, x8, s4, t3) {
        return md5cmn(b4 & d6 | c3 & ~d6, a2, b4, x8, s4, t3);
      }
      function md5hh(a2, b4, c3, d6, x8, s4, t3) {
        return md5cmn(b4 ^ c3 ^ d6, a2, b4, x8, s4, t3);
      }
      function md5ii(a2, b4, c3, d6, x8, s4, t3) {
        return md5cmn(c3 ^ (b4 | ~d6), a2, b4, x8, s4, t3);
      }
      var _default = md5;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v3.js
  var require_v3 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v3.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _v = _interopRequireDefault(require_v35());
      var _md = _interopRequireDefault(require_md5());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v32 = (0, _v.default)("v3", 48, _md.default);
      var _default = v32;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/native.js
  var require_native = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/native.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
      var _default = {
        randomUUID
      };
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v4.js
  var require_v4 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v4.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _native = _interopRequireDefault(require_native());
      var _rng = _interopRequireDefault(require_rng());
      var _stringify = require_stringify();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function v42(options, buf, offset) {
        if (_native.default.randomUUID && !buf && !options) {
          return _native.default.randomUUID();
        }
        options = options || {};
        const rnds = options.random || (options.rng || _rng.default)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i4 = 0; i4 < 16; ++i4) {
            buf[offset + i4] = rnds[i4];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(rnds);
      }
      var _default = v42;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/sha1.js
  var require_sha1 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/sha1.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      function f5(s4, x8, y4, z5) {
        switch (s4) {
          case 0:
            return x8 & y4 ^ ~x8 & z5;
          case 1:
            return x8 ^ y4 ^ z5;
          case 2:
            return x8 & y4 ^ x8 & z5 ^ y4 & z5;
          case 3:
            return x8 ^ y4 ^ z5;
        }
      }
      function ROTL(x8, n4) {
        return x8 << n4 | x8 >>> 32 - n4;
      }
      function sha1(bytes2) {
        const K4 = [1518500249, 1859775393, 2400959708, 3395469782];
        const H3 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if (typeof bytes2 === "string") {
          const msg = unescape(encodeURIComponent(bytes2));
          bytes2 = [];
          for (let i4 = 0; i4 < msg.length; ++i4) {
            bytes2.push(msg.charCodeAt(i4));
          }
        } else if (!Array.isArray(bytes2)) {
          bytes2 = Array.prototype.slice.call(bytes2);
        }
        bytes2.push(128);
        const l4 = bytes2.length / 4 + 2;
        const N2 = Math.ceil(l4 / 16);
        const M6 = new Array(N2);
        for (let i4 = 0; i4 < N2; ++i4) {
          const arr = new Uint32Array(16);
          for (let j3 = 0; j3 < 16; ++j3) {
            arr[j3] = bytes2[i4 * 64 + j3 * 4] << 24 | bytes2[i4 * 64 + j3 * 4 + 1] << 16 | bytes2[i4 * 64 + j3 * 4 + 2] << 8 | bytes2[i4 * 64 + j3 * 4 + 3];
          }
          M6[i4] = arr;
        }
        M6[N2 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
        M6[N2 - 1][14] = Math.floor(M6[N2 - 1][14]);
        M6[N2 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
        for (let i4 = 0; i4 < N2; ++i4) {
          const W4 = new Uint32Array(80);
          for (let t3 = 0; t3 < 16; ++t3) {
            W4[t3] = M6[i4][t3];
          }
          for (let t3 = 16; t3 < 80; ++t3) {
            W4[t3] = ROTL(W4[t3 - 3] ^ W4[t3 - 8] ^ W4[t3 - 14] ^ W4[t3 - 16], 1);
          }
          let a2 = H3[0];
          let b4 = H3[1];
          let c3 = H3[2];
          let d6 = H3[3];
          let e = H3[4];
          for (let t3 = 0; t3 < 80; ++t3) {
            const s4 = Math.floor(t3 / 20);
            const T4 = ROTL(a2, 5) + f5(s4, b4, c3, d6) + e + K4[s4] + W4[t3] >>> 0;
            e = d6;
            d6 = c3;
            c3 = ROTL(b4, 30) >>> 0;
            b4 = a2;
            a2 = T4;
          }
          H3[0] = H3[0] + a2 >>> 0;
          H3[1] = H3[1] + b4 >>> 0;
          H3[2] = H3[2] + c3 >>> 0;
          H3[3] = H3[3] + d6 >>> 0;
          H3[4] = H3[4] + e >>> 0;
        }
        return [H3[0] >> 24 & 255, H3[0] >> 16 & 255, H3[0] >> 8 & 255, H3[0] & 255, H3[1] >> 24 & 255, H3[1] >> 16 & 255, H3[1] >> 8 & 255, H3[1] & 255, H3[2] >> 24 & 255, H3[2] >> 16 & 255, H3[2] >> 8 & 255, H3[2] & 255, H3[3] >> 24 & 255, H3[3] >> 16 & 255, H3[3] >> 8 & 255, H3[3] & 255, H3[4] >> 24 & 255, H3[4] >> 16 & 255, H3[4] >> 8 & 255, H3[4] & 255];
      }
      var _default = sha1;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/v5.js
  var require_v5 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/v5.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _v = _interopRequireDefault(require_v35());
      var _sha = _interopRequireDefault(require_sha1());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v52 = (0, _v.default)("v5", 80, _sha.default);
      var _default = v52;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/nil.js
  var require_nil = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/nil.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _default = "00000000-0000-0000-0000-000000000000";
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/version.js
  var require_version23 = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _validate = _interopRequireDefault(require_validate());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function version7(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }
        return parseInt(uuid.slice(14, 15), 16);
      }
      var _default = version7;
      exports2.default = _default;
    }
  });

  // node_modules/uuid/dist/commonjs-browser/index.js
  var require_commonjs_browser = __commonJS({
    "node_modules/uuid/dist/commonjs-browser/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      Object.defineProperty(exports2, "NIL", {
        enumerable: true,
        get: function get3() {
          return _nil.default;
        }
      });
      Object.defineProperty(exports2, "parse", {
        enumerable: true,
        get: function get3() {
          return _parse.default;
        }
      });
      Object.defineProperty(exports2, "stringify", {
        enumerable: true,
        get: function get3() {
          return _stringify.default;
        }
      });
      Object.defineProperty(exports2, "v1", {
        enumerable: true,
        get: function get3() {
          return _v.default;
        }
      });
      Object.defineProperty(exports2, "v3", {
        enumerable: true,
        get: function get3() {
          return _v2.default;
        }
      });
      Object.defineProperty(exports2, "v4", {
        enumerable: true,
        get: function get3() {
          return _v3.default;
        }
      });
      Object.defineProperty(exports2, "v5", {
        enumerable: true,
        get: function get3() {
          return _v4.default;
        }
      });
      Object.defineProperty(exports2, "validate", {
        enumerable: true,
        get: function get3() {
          return _validate.default;
        }
      });
      Object.defineProperty(exports2, "version", {
        enumerable: true,
        get: function get3() {
          return _version.default;
        }
      });
      var _v = _interopRequireDefault(require_v1());
      var _v2 = _interopRequireDefault(require_v3());
      var _v3 = _interopRequireDefault(require_v4());
      var _v4 = _interopRequireDefault(require_v5());
      var _nil = _interopRequireDefault(require_nil());
      var _version = _interopRequireDefault(require_version23());
      var _validate = _interopRequireDefault(require_validate());
      var _stringify = _interopRequireDefault(require_stringify());
      var _parse = _interopRequireDefault(require_parse());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    }
  });

  // node_modules/crypt/crypt.js
  var require_crypt = __commonJS({
    "node_modules/crypt/crypt.js"(exports2, module2) {
      (function() {
        var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
          // Bit-wise rotation left
          rotl: function(n4, b4) {
            return n4 << b4 | n4 >>> 32 - b4;
          },
          // Bit-wise rotation right
          rotr: function(n4, b4) {
            return n4 << 32 - b4 | n4 >>> b4;
          },
          // Swap big-endian to little-endian and vice versa
          endian: function(n4) {
            if (n4.constructor == Number) {
              return crypt.rotl(n4, 8) & 16711935 | crypt.rotl(n4, 24) & 4278255360;
            }
            for (var i4 = 0; i4 < n4.length; i4++)
              n4[i4] = crypt.endian(n4[i4]);
            return n4;
          },
          // Generate an array of any length of random bytes
          randomBytes: function(n4) {
            for (var bytes2 = []; n4 > 0; n4--)
              bytes2.push(Math.floor(Math.random() * 256));
            return bytes2;
          },
          // Convert a byte array to big-endian 32-bit words
          bytesToWords: function(bytes2) {
            for (var words = [], i4 = 0, b4 = 0; i4 < bytes2.length; i4++, b4 += 8)
              words[b4 >>> 5] |= bytes2[i4] << 24 - b4 % 32;
            return words;
          },
          // Convert big-endian 32-bit words to a byte array
          wordsToBytes: function(words) {
            for (var bytes2 = [], b4 = 0; b4 < words.length * 32; b4 += 8)
              bytes2.push(words[b4 >>> 5] >>> 24 - b4 % 32 & 255);
            return bytes2;
          },
          // Convert a byte array to a hex string
          bytesToHex: function(bytes2) {
            for (var hex2 = [], i4 = 0; i4 < bytes2.length; i4++) {
              hex2.push((bytes2[i4] >>> 4).toString(16));
              hex2.push((bytes2[i4] & 15).toString(16));
            }
            return hex2.join("");
          },
          // Convert a hex string to a byte array
          hexToBytes: function(hex2) {
            for (var bytes2 = [], c3 = 0; c3 < hex2.length; c3 += 2)
              bytes2.push(parseInt(hex2.substr(c3, 2), 16));
            return bytes2;
          },
          // Convert a byte array to a base-64 string
          bytesToBase64: function(bytes2) {
            for (var base643 = [], i4 = 0; i4 < bytes2.length; i4 += 3) {
              var triplet = bytes2[i4] << 16 | bytes2[i4 + 1] << 8 | bytes2[i4 + 2];
              for (var j3 = 0; j3 < 4; j3++)
                if (i4 * 8 + j3 * 6 <= bytes2.length * 8)
                  base643.push(base64map.charAt(triplet >>> 6 * (3 - j3) & 63));
                else
                  base643.push("=");
            }
            return base643.join("");
          },
          // Convert a base-64 string to a byte array
          base64ToBytes: function(base643) {
            base643 = base643.replace(/[^A-Z0-9+\/]/ig, "");
            for (var bytes2 = [], i4 = 0, imod4 = 0; i4 < base643.length; imod4 = ++i4 % 4) {
              if (imod4 == 0)
                continue;
              bytes2.push((base64map.indexOf(base643.charAt(i4 - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base643.charAt(i4)) >>> 6 - imod4 * 2);
            }
            return bytes2;
          }
        };
        module2.exports = crypt;
      })();
    }
  });

  // node_modules/charenc/charenc.js
  var require_charenc = __commonJS({
    "node_modules/charenc/charenc.js"(exports2, module2) {
      var charenc = {
        // UTF-8 encoding
        utf8: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
          },
          // Convert a byte array to a string
          bytesToString: function(bytes2) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes2)));
          }
        },
        // Binary encoding
        bin: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            for (var bytes2 = [], i4 = 0; i4 < str.length; i4++)
              bytes2.push(str.charCodeAt(i4) & 255);
            return bytes2;
          },
          // Convert a byte array to a string
          bytesToString: function(bytes2) {
            for (var str = [], i4 = 0; i4 < bytes2.length; i4++)
              str.push(String.fromCharCode(bytes2[i4]));
            return str.join("");
          }
        }
      };
      module2.exports = charenc;
    }
  });

  // node_modules/is-buffer/index.js
  var require_is_buffer = __commonJS({
    "node_modules/is-buffer/index.js"(exports2, module2) {
      module2.exports = function(obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };
      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
      }
    }
  });

  // node_modules/md5/md5.js
  var require_md52 = __commonJS({
    "node_modules/md5/md5.js"(exports2, module2) {
      (function() {
        var crypt = require_crypt(), utf82 = require_charenc().utf8, isBuffer = require_is_buffer(), bin = require_charenc().bin, md5 = function(message, options) {
          if (message.constructor == String)
            if (options && options.encoding === "binary")
              message = bin.stringToBytes(message);
            else
              message = utf82.stringToBytes(message);
          else if (isBuffer(message))
            message = Array.prototype.slice.call(message, 0);
          else if (!Array.isArray(message) && message.constructor !== Uint8Array)
            message = message.toString();
          var m5 = crypt.bytesToWords(message), l4 = message.length * 8, a2 = 1732584193, b4 = -271733879, c3 = -1732584194, d6 = 271733878;
          for (var i4 = 0; i4 < m5.length; i4++) {
            m5[i4] = (m5[i4] << 8 | m5[i4] >>> 24) & 16711935 | (m5[i4] << 24 | m5[i4] >>> 8) & 4278255360;
          }
          m5[l4 >>> 5] |= 128 << l4 % 32;
          m5[(l4 + 64 >>> 9 << 4) + 14] = l4;
          var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;
          for (var i4 = 0; i4 < m5.length; i4 += 16) {
            var aa = a2, bb = b4, cc = c3, dd = d6;
            a2 = FF(a2, b4, c3, d6, m5[i4 + 0], 7, -680876936);
            d6 = FF(d6, a2, b4, c3, m5[i4 + 1], 12, -389564586);
            c3 = FF(c3, d6, a2, b4, m5[i4 + 2], 17, 606105819);
            b4 = FF(b4, c3, d6, a2, m5[i4 + 3], 22, -1044525330);
            a2 = FF(a2, b4, c3, d6, m5[i4 + 4], 7, -176418897);
            d6 = FF(d6, a2, b4, c3, m5[i4 + 5], 12, 1200080426);
            c3 = FF(c3, d6, a2, b4, m5[i4 + 6], 17, -1473231341);
            b4 = FF(b4, c3, d6, a2, m5[i4 + 7], 22, -45705983);
            a2 = FF(a2, b4, c3, d6, m5[i4 + 8], 7, 1770035416);
            d6 = FF(d6, a2, b4, c3, m5[i4 + 9], 12, -1958414417);
            c3 = FF(c3, d6, a2, b4, m5[i4 + 10], 17, -42063);
            b4 = FF(b4, c3, d6, a2, m5[i4 + 11], 22, -1990404162);
            a2 = FF(a2, b4, c3, d6, m5[i4 + 12], 7, 1804603682);
            d6 = FF(d6, a2, b4, c3, m5[i4 + 13], 12, -40341101);
            c3 = FF(c3, d6, a2, b4, m5[i4 + 14], 17, -1502002290);
            b4 = FF(b4, c3, d6, a2, m5[i4 + 15], 22, 1236535329);
            a2 = GG(a2, b4, c3, d6, m5[i4 + 1], 5, -165796510);
            d6 = GG(d6, a2, b4, c3, m5[i4 + 6], 9, -1069501632);
            c3 = GG(c3, d6, a2, b4, m5[i4 + 11], 14, 643717713);
            b4 = GG(b4, c3, d6, a2, m5[i4 + 0], 20, -373897302);
            a2 = GG(a2, b4, c3, d6, m5[i4 + 5], 5, -701558691);
            d6 = GG(d6, a2, b4, c3, m5[i4 + 10], 9, 38016083);
            c3 = GG(c3, d6, a2, b4, m5[i4 + 15], 14, -660478335);
            b4 = GG(b4, c3, d6, a2, m5[i4 + 4], 20, -405537848);
            a2 = GG(a2, b4, c3, d6, m5[i4 + 9], 5, 568446438);
            d6 = GG(d6, a2, b4, c3, m5[i4 + 14], 9, -1019803690);
            c3 = GG(c3, d6, a2, b4, m5[i4 + 3], 14, -187363961);
            b4 = GG(b4, c3, d6, a2, m5[i4 + 8], 20, 1163531501);
            a2 = GG(a2, b4, c3, d6, m5[i4 + 13], 5, -1444681467);
            d6 = GG(d6, a2, b4, c3, m5[i4 + 2], 9, -51403784);
            c3 = GG(c3, d6, a2, b4, m5[i4 + 7], 14, 1735328473);
            b4 = GG(b4, c3, d6, a2, m5[i4 + 12], 20, -1926607734);
            a2 = HH(a2, b4, c3, d6, m5[i4 + 5], 4, -378558);
            d6 = HH(d6, a2, b4, c3, m5[i4 + 8], 11, -2022574463);
            c3 = HH(c3, d6, a2, b4, m5[i4 + 11], 16, 1839030562);
            b4 = HH(b4, c3, d6, a2, m5[i4 + 14], 23, -35309556);
            a2 = HH(a2, b4, c3, d6, m5[i4 + 1], 4, -1530992060);
            d6 = HH(d6, a2, b4, c3, m5[i4 + 4], 11, 1272893353);
            c3 = HH(c3, d6, a2, b4, m5[i4 + 7], 16, -155497632);
            b4 = HH(b4, c3, d6, a2, m5[i4 + 10], 23, -1094730640);
            a2 = HH(a2, b4, c3, d6, m5[i4 + 13], 4, 681279174);
            d6 = HH(d6, a2, b4, c3, m5[i4 + 0], 11, -358537222);
            c3 = HH(c3, d6, a2, b4, m5[i4 + 3], 16, -722521979);
            b4 = HH(b4, c3, d6, a2, m5[i4 + 6], 23, 76029189);
            a2 = HH(a2, b4, c3, d6, m5[i4 + 9], 4, -640364487);
            d6 = HH(d6, a2, b4, c3, m5[i4 + 12], 11, -421815835);
            c3 = HH(c3, d6, a2, b4, m5[i4 + 15], 16, 530742520);
            b4 = HH(b4, c3, d6, a2, m5[i4 + 2], 23, -995338651);
            a2 = II(a2, b4, c3, d6, m5[i4 + 0], 6, -198630844);
            d6 = II(d6, a2, b4, c3, m5[i4 + 7], 10, 1126891415);
            c3 = II(c3, d6, a2, b4, m5[i4 + 14], 15, -1416354905);
            b4 = II(b4, c3, d6, a2, m5[i4 + 5], 21, -57434055);
            a2 = II(a2, b4, c3, d6, m5[i4 + 12], 6, 1700485571);
            d6 = II(d6, a2, b4, c3, m5[i4 + 3], 10, -1894986606);
            c3 = II(c3, d6, a2, b4, m5[i4 + 10], 15, -1051523);
            b4 = II(b4, c3, d6, a2, m5[i4 + 1], 21, -2054922799);
            a2 = II(a2, b4, c3, d6, m5[i4 + 8], 6, 1873313359);
            d6 = II(d6, a2, b4, c3, m5[i4 + 15], 10, -30611744);
            c3 = II(c3, d6, a2, b4, m5[i4 + 6], 15, -1560198380);
            b4 = II(b4, c3, d6, a2, m5[i4 + 13], 21, 1309151649);
            a2 = II(a2, b4, c3, d6, m5[i4 + 4], 6, -145523070);
            d6 = II(d6, a2, b4, c3, m5[i4 + 11], 10, -1120210379);
            c3 = II(c3, d6, a2, b4, m5[i4 + 2], 15, 718787259);
            b4 = II(b4, c3, d6, a2, m5[i4 + 9], 21, -343485551);
            a2 = a2 + aa >>> 0;
            b4 = b4 + bb >>> 0;
            c3 = c3 + cc >>> 0;
            d6 = d6 + dd >>> 0;
          }
          return crypt.endian([a2, b4, c3, d6]);
        };
        md5._ff = function(a2, b4, c3, d6, x8, s4, t3) {
          var n4 = a2 + (b4 & c3 | ~b4 & d6) + (x8 >>> 0) + t3;
          return (n4 << s4 | n4 >>> 32 - s4) + b4;
        };
        md5._gg = function(a2, b4, c3, d6, x8, s4, t3) {
          var n4 = a2 + (b4 & d6 | c3 & ~d6) + (x8 >>> 0) + t3;
          return (n4 << s4 | n4 >>> 32 - s4) + b4;
        };
        md5._hh = function(a2, b4, c3, d6, x8, s4, t3) {
          var n4 = a2 + (b4 ^ c3 ^ d6) + (x8 >>> 0) + t3;
          return (n4 << s4 | n4 >>> 32 - s4) + b4;
        };
        md5._ii = function(a2, b4, c3, d6, x8, s4, t3) {
          var n4 = a2 + (c3 ^ (b4 | ~d6)) + (x8 >>> 0) + t3;
          return (n4 << s4 | n4 >>> 32 - s4) + b4;
        };
        md5._blocksize = 16;
        md5._digestsize = 16;
        module2.exports = function(message, options) {
          if (message === void 0 || message === null)
            throw new Error("Illegal argument " + message);
          var digestbytes = crypt.wordsToBytes(md5(message, options));
          return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
        };
      })();
    }
  });

  // node_modules/tuple-database/helpers/randomId.js
  var require_randomId = __commonJS({
    "node_modules/tuple-database/helpers/randomId.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomId = void 0;
      var lodash_1 = require_lodash();
      var uuid = __importStar(require_commonjs_browser());
      var md5_1 = __importDefault(require_md52());
      function randomId(seed) {
        if (seed) {
          const hexStr = (0, md5_1.default)(seed);
          const bytes2 = (0, lodash_1.chunk)(hexStr, 2).map((chars) => parseInt(chars.join(""), 16));
          return uuid.v4({ random: bytes2 });
        } else {
          return uuid.v4();
        }
      }
      exports2.randomId = randomId;
    }
  });

  // node_modules/tuple-database/helpers/mutableFilter.js
  var require_mutableFilter = __commonJS({
    "node_modules/tuple-database/helpers/mutableFilter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mutableFilter = void 0;
      function mutableFilter(array2, fn) {
        let i4 = 0;
        while (true) {
          if (i4 >= array2.length)
            break;
          const item = array2[i4];
          if (fn(item)) {
            i4++;
          } else {
            array2.splice(i4, 1);
          }
        }
      }
      exports2.mutableFilter = mutableFilter;
    }
  });

  // node_modules/tuple-database/helpers/outdent.js
  var require_outdent = __commonJS({
    "node_modules/tuple-database/helpers/outdent.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.outdent = void 0;
      var tabToSpaces = 2;
      function convertTabsToSpaces(line) {
        return line.replace(/\t/g, " ".repeat(tabToSpaces));
      }
      function getIndentCount(line) {
        let indent = 0;
        for (const char of line) {
          if (char === " ") {
            indent += 1;
          } else {
            return indent;
          }
        }
        return indent;
      }
      function outdent(contents) {
        let lines = contents.split("\n").map(convertTabsToSpaces);
        if (lines[0].trim() === "") {
          lines = lines.slice(1);
        }
        if (lines[lines.length - 1].trim() === "") {
          lines = lines.slice(0, lines.length - 1);
        }
        const indentCounts = lines.map(getIndentCount);
        const minIndentCount = Math.min(...indentCounts);
        const trimmedLines = lines.map((line) => line.slice(minIndentCount));
        return trimmedLines.join("\n");
      }
      exports2.outdent = outdent;
    }
  });

  // node_modules/tuple-database/storage/types.js
  var require_types2 = __commonJS({
    "node_modules/tuple-database/storage/types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MAX = exports2.MIN = void 0;
      exports2.MIN = null;
      exports2.MAX = true;
    }
  });

  // node_modules/elen/src/binary64.js
  var require_binary64 = __commonJS({
    "node_modules/elen/src/binary64.js"(exports2, module2) {
      var MAX_EXPONENT = 2047;
      var MAX_MANTISSA = 4503599627370495;
      function construct({ sign: sign2, exponent, mantissa }) {
        if (sign2 !== 0 && sign2 !== 1) {
          throw new Error(`Invalid value for sign: ${sign2}.`);
        }
        if (typeof exponent !== "number" || exponent < 0 || MAX_EXPONENT < exponent) {
          throw new Error(`Invalid value for exponent: ${exponent}.`);
        }
        if (typeof mantissa !== "number" || mantissa < 0 || MAX_MANTISSA < mantissa) {
          throw new Error(`Invalid value for mantissa: ${mantissa}.`);
        }
        const buffer2 = new ArrayBuffer(8);
        const floatArray = new Float64Array(buffer2);
        const intArray = new Uint8Array(buffer2);
        setSign(sign2, intArray);
        setExponent(exponent, intArray);
        setMantissa(mantissa, intArray);
        return floatArray[0];
      }
      function deconstruct(n4) {
        if (typeof n4 !== "number") {
          throw new Error(`Value is not of type number: ${n4}.`);
        }
        const buffer2 = new ArrayBuffer(8);
        const floatArray = new Float64Array(buffer2);
        const intArray = new Uint8Array(buffer2);
        floatArray[0] = n4;
        return {
          sign: getSign(intArray),
          exponent: getExponent(intArray),
          mantissa: getMantissa(intArray)
        };
      }
      function getSign(intArray) {
        return shiftRight2(intArray[7], 7);
      }
      function setSign(sign2, intArray) {
        intArray[7] |= shiftLeft2(sign2, 7);
      }
      function getExponent(intArray) {
        let r2 = 0;
        r2 += shiftLeft2(intArray[7] & 127, 4);
        r2 += shiftRight2(intArray[6], 4);
        return r2;
      }
      function setExponent(exponent, intArray) {
        intArray[7] |= shiftRight2(exponent, 4);
        intArray[6] |= shiftLeft2(exponent & 15, 4);
      }
      function getMantissa(intArray) {
        let r2 = 0;
        r2 += shiftLeft2(intArray[6] & 15, 48);
        r2 += shiftLeft2(intArray[5], 40);
        r2 += shiftLeft2(intArray[4], 32);
        r2 += shiftLeft2(intArray[3], 24);
        r2 += shiftLeft2(intArray[2], 16);
        r2 += shiftLeft2(intArray[1], 8);
        r2 += intArray[0];
        return r2;
      }
      function setMantissa(mantissa, intArray) {
        intArray[6] |= shiftRight2(mantissa, 48) & 255;
        intArray[5] |= shiftRight2(mantissa, 40) & 255;
        intArray[4] |= shiftRight2(mantissa, 32) & 255;
        intArray[3] |= shiftRight2(mantissa, 24) & 255;
        intArray[2] |= shiftRight2(mantissa, 16) & 255;
        intArray[1] |= shiftRight2(mantissa, 8) & 255;
        intArray[0] |= mantissa & 255;
      }
      function shiftLeft2(n4, bits) {
        return n4 * Math.pow(2, bits);
      }
      function shiftRight2(n4, bits) {
        return Math.floor(n4 / Math.pow(2, bits));
      }
      module2.exports = { MAX_EXPONENT, MAX_MANTISSA, construct, deconstruct };
    }
  });

  // node_modules/elen/src/elen.js
  var require_elen = __commonJS({
    "node_modules/elen/src/elen.js"(exports2, module2) {
      var binary64 = require_binary64();
      var LENGTH_MARKER = ";";
      var SIGN_NON_NEGATIVE = ">";
      var SIGN_NEGATIVE = "<";
      function encode(n4) {
        if (typeof n4 !== "number") {
          throw new Error(`Value is not of type number: ${n4}.`);
        }
        const { sign: sign2, exponent, mantissa } = binary64.deconstruct(n4);
        let r2 = "";
        r2 += sign2 === 1 ? SIGN_NEGATIVE : SIGN_NON_NEGATIVE;
        r2 += elen(sign2 === 1 ? binary64.MAX_EXPONENT - exponent : exponent);
        r2 += elen(sign2 === 1 ? binary64.MAX_MANTISSA - mantissa : mantissa);
        return r2;
      }
      function elen(n4) {
        let r2 = "";
        if (n4 > 0) {
          r2 += LENGTH_MARKER;
        }
        const s4 = n4.toString();
        if (s4.length > 1) {
          r2 += elen(s4.length);
        }
        r2 += s4;
        return r2;
      }
      function decode(s4) {
        if (typeof s4 !== "string") {
          throw new Error(`Value is not of type string: ${s4}.`);
        }
        const { signLength, sign: sign2 } = parseSign(s4, 0);
        const { exponentLength, exponent } = parseExponent(s4, sign2, signLength);
        const { mantissaLength, mantissa } = parseMantissa(s4, sign2, signLength + exponentLength);
        decodeAssert(s4.length === signLength + exponentLength + mantissaLength, s4);
        return binary64.construct({ sign: sign2, exponent, mantissa });
      }
      function parseSign(s4, i4) {
        decodeAssert(i4 < s4.length, s4);
        if (s4[i4] === SIGN_NON_NEGATIVE) {
          return { signLength: 1, sign: 0 };
        }
        if (s4[i4] === SIGN_NEGATIVE) {
          return { signLength: 1, sign: 1 };
        }
        decodeAssert(false, s4);
      }
      function parseExponent(s4, sign2, i4) {
        decodeAssert(i4 < s4.length, s4);
        if (s4[i4] === "0") {
          return { exponentLength: 1, exponent: sign2 === 0 ? 0 : binary64.MAX_EXPONENT };
        }
        let j3 = i4, l4 = 0, t3, n4;
        while (s4[j3] === LENGTH_MARKER) {
          l4 = l4 + 1;
          j3 = j3 + 1;
        }
        decodeAssert(l4 !== 0, s4);
        n4 = 1;
        while (l4 > 0) {
          t3 = n4;
          n4 = Number.parseInt(s4.substr(j3, n4));
          decodeAssert(n4 > 0, s4);
          j3 = j3 + t3;
          l4 = l4 - 1;
        }
        return { exponentLength: j3 - i4, exponent: sign2 === 0 ? n4 : binary64.MAX_EXPONENT - n4 };
      }
      function parseMantissa(s4, sign2, i4) {
        decodeAssert(i4 < s4.length, s4);
        if (s4[i4] === "0") {
          return { mantissaLength: 1, mantissa: sign2 === 0 ? 0 : binary64.MAX_MANTISSA };
        }
        let j3 = i4, l4 = 0, t3, n4;
        while (s4[j3] === LENGTH_MARKER) {
          l4 = l4 + 1;
          j3 = j3 + 1;
        }
        decodeAssert(l4 !== 0, s4);
        n4 = 1;
        while (l4 > 0) {
          t3 = n4;
          n4 = Number.parseInt(s4.substr(j3, n4));
          decodeAssert(n4 > 0, s4);
          j3 = j3 + t3;
          l4 = l4 - 1;
        }
        return { mantissaLength: j3 - i4, mantissa: sign2 === 0 ? n4 : binary64.MAX_MANTISSA - n4 };
      }
      function decodeAssert(condition, input) {
        if (!condition) {
          throw new Error(`Input is not a valid ELEN-encoded number: ${input}.`);
        }
      }
      module2.exports = { encode, decode };
    }
  });

  // node_modules/tuple-database/helpers/compare.js
  var require_compare = __commonJS({
    "node_modules/tuple-database/helpers/compare.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.compare = void 0;
      function compare2(a2, b4) {
        if (a2 > b4) {
          return 1;
        }
        if (a2 < b4) {
          return -1;
        }
        return 0;
      }
      exports2.compare = compare2;
    }
  });

  // node_modules/tuple-database/helpers/Unreachable.js
  var require_Unreachable = __commonJS({
    "node_modules/tuple-database/helpers/Unreachable.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.UnreachableError = void 0;
      var UnreachableError = class extends Error {
        constructor(obj, message) {
          super((message + ": " || "Unreachable: ") + obj);
        }
      };
      exports2.UnreachableError = UnreachableError;
    }
  });

  // node_modules/tuple-database/helpers/codec.js
  var require_codec = __commonJS({
    "node_modules/tuple-database/helpers/codec.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeTuple = exports2.encodeTuple = exports2.decodeValue = exports2.encodingTypeOf = exports2.encodeValue = exports2.encodingRank = exports2.encodingByte = void 0;
      var elen = __importStar(require_elen());
      var lodash_1 = require_lodash();
      var compare_1 = require_compare();
      var Unreachable_1 = require_Unreachable();
      exports2.encodingByte = {
        null: "b",
        object: "c",
        array: "d",
        number: "e",
        string: "f",
        boolean: "g"
      };
      exports2.encodingRank = (0, lodash_1.sortBy)(Object.entries(exports2.encodingByte), ([key, value]) => value).map(([key]) => key);
      function encodeValue(value) {
        if (value === null) {
          return exports2.encodingByte.null;
        }
        if (value === true || value === false) {
          return exports2.encodingByte.boolean + value;
        }
        if (typeof value === "string") {
          return exports2.encodingByte.string + value;
        }
        if (typeof value === "number") {
          return exports2.encodingByte.number + elen.encode(value);
        }
        if (Array.isArray(value)) {
          return exports2.encodingByte.array + encodeTuple2(value);
        }
        if (typeof value === "object") {
          return exports2.encodingByte.object + encodeObjectValue(value);
        }
        throw new Unreachable_1.UnreachableError(value, "Unknown value type");
      }
      exports2.encodeValue = encodeValue;
      function encodingTypeOf(value) {
        if (value === null) {
          return "null";
        }
        if (value === true || value === false) {
          return "boolean";
        }
        if (typeof value === "string") {
          return "string";
        }
        if (typeof value === "number") {
          return "number";
        }
        if (Array.isArray(value)) {
          return "array";
        }
        if (typeof value === "object") {
          return "object";
        }
        throw new Unreachable_1.UnreachableError(value, "Unknown value type");
      }
      exports2.encodingTypeOf = encodingTypeOf;
      var decodeType = (0, lodash_1.invert)(exports2.encodingByte);
      function decodeValue(str) {
        const encoding = decodeType[str[0]];
        const rest = str.slice(1);
        if (encoding === "null") {
          return null;
        }
        if (encoding === "boolean") {
          return JSON.parse(rest);
        }
        if (encoding === "string") {
          return rest;
        }
        if (encoding === "number") {
          return elen.decode(rest);
        }
        if (encoding === "array") {
          return decodeTuple2(rest);
        }
        if (encoding === "object") {
          return decodeObjectValue(rest);
        }
        throw new Unreachable_1.UnreachableError(encoding, "Invalid encoding byte");
      }
      exports2.decodeValue = decodeValue;
      function encodeTuple2(tuple) {
        return tuple.map((value, i4) => {
          const encoded = encodeValue(value);
          return encoded.replace(/\x01/g, "").replace(/\x00/g, "\0") + "\0";
        }).join("");
      }
      exports2.encodeTuple = encodeTuple2;
      function decodeTuple2(str) {
        if (str === "") {
          return [];
        }
        const re4 = /(\x01(\x01|\x00)|\x00)/g;
        const tuple = [];
        let start = 0;
        while (true) {
          const match = re4.exec(str);
          if (match === null) {
            return tuple;
          }
          if (match[0][0] === "") {
            continue;
          }
          const end = match.index;
          const escaped = str.slice(start, end);
          const unescaped = escaped.replace(/\x01\x01/g, "").replace(/\x01\x00/g, "\0");
          const decoded = decodeValue(unescaped);
          tuple.push(decoded);
          start = end + 1;
        }
      }
      exports2.decodeTuple = decodeTuple2;
      function encodeObjectValue(obj) {
        if (!(0, lodash_1.isPlainObject)(obj)) {
          throw new Error("Cannot serialize this object.");
        }
        const entries = Object.entries(obj).sort(([k1], [k22]) => (0, compare_1.compare)(k1, k22)).filter(([key, value]) => value !== void 0);
        return encodeTuple2(entries);
      }
      function decodeObjectValue(str) {
        const entries = decodeTuple2(str);
        const obj = {};
        for (const [key, value] of entries) {
          obj[key] = value;
        }
        return obj;
      }
    }
  });

  // node_modules/tuple-database/helpers/compareTuple.js
  var require_compareTuple = __commonJS({
    "node_modules/tuple-database/helpers/compareTuple.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TupleToString = exports2.ValueToString = exports2.compareTuple = exports2.compareValue = void 0;
      var lodash_1 = require_lodash();
      var codec_1 = require_codec();
      var compare_1 = require_compare();
      var Unreachable_1 = require_Unreachable();
      function compareValue(a2, b4) {
        const at2 = (0, codec_1.encodingTypeOf)(a2);
        const bt3 = (0, codec_1.encodingTypeOf)(b4);
        if (at2 === bt3) {
          if (at2 === "array") {
            return compareTuple(a2, b4);
          } else if (at2 === "object") {
            if (a2 === b4)
              return 0;
            if ((0, lodash_1.isPlainObject)(a2)) {
              if ((0, lodash_1.isPlainObject)(b4)) {
                return compareObject(a2, b4);
              } else {
                return -1;
              }
            } else if ((0, lodash_1.isPlainObject)(b4)) {
              return 1;
            } else {
              return 1;
            }
          } else if (at2 === "boolean") {
            return (0, compare_1.compare)(a2, b4);
          } else if (at2 === "null") {
            return 0;
          } else if (at2 === "number") {
            return (0, compare_1.compare)(a2, b4);
          } else if (at2 === "string") {
            return (0, compare_1.compare)(a2, b4);
          } else {
            throw new Unreachable_1.UnreachableError(at2);
          }
        }
        return (0, compare_1.compare)(codec_1.encodingRank.indexOf(at2), codec_1.encodingRank.indexOf(bt3));
      }
      exports2.compareValue = compareValue;
      function compareObject(a2, b4) {
        const ae3 = Object.entries(a2).filter(([k3, v7]) => v7 !== void 0).sort(([k1], [k22]) => (0, compare_1.compare)(k1, k22));
        const be2 = Object.entries(b4).filter(([k3, v7]) => v7 !== void 0).sort(([k1], [k22]) => (0, compare_1.compare)(k1, k22));
        const len = Math.min(ae3.length, be2.length);
        for (let i4 = 0; i4 < len; i4++) {
          const [ak, av] = ae3[i4];
          const [bk, bv] = be2[i4];
          const dir = compareValue(ak, bk);
          if (dir === 0) {
            const dir2 = compareValue(av, bv);
            if (dir2 === 0) {
              continue;
            }
            return dir2;
          }
          return dir;
        }
        if (ae3.length > be2.length) {
          return 1;
        } else if (ae3.length < be2.length) {
          return -1;
        } else {
          return 0;
        }
      }
      function compareTuple(a2, b4) {
        const len = Math.min(a2.length, b4.length);
        for (let i4 = 0; i4 < len; i4++) {
          const dir = compareValue(a2[i4], b4[i4]);
          if (dir === 0) {
            continue;
          }
          return dir;
        }
        if (a2.length > b4.length) {
          return 1;
        } else if (a2.length < b4.length) {
          return -1;
        } else {
          return 0;
        }
      }
      exports2.compareTuple = compareTuple;
      function ValueToString(value) {
        if (value === null) {
          return "null";
        } else {
          return JSON.stringify(value);
        }
      }
      exports2.ValueToString = ValueToString;
      function TupleToString(tuple) {
        return `[${tuple.map(ValueToString).join(",")}]`;
      }
      exports2.TupleToString = TupleToString;
    }
  });

  // node_modules/tuple-database/helpers/binarySearch.js
  var require_binarySearch = __commonJS({
    "node_modules/tuple-database/helpers/binarySearch.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.binarySearchAssociativeList = exports2.binarySearch = exports2.generalizedBinarySearch = void 0;
      function generalizedBinarySearch(getValue, cmp) {
        return function(list, item) {
          var min = 0;
          var max = list.length - 1;
          while (min <= max) {
            var k3 = max + min >> 1;
            var dir = cmp(item, getValue(list[k3]));
            if (dir > 0) {
              min = k3 + 1;
            } else if (dir < 0) {
              max = k3 - 1;
            } else {
              return { found: k3 };
            }
          }
          return { closest: min };
        };
      }
      exports2.generalizedBinarySearch = generalizedBinarySearch;
      function binarySearch(list, item, cmp) {
        return generalizedBinarySearch((x8) => x8, cmp)(list, item);
      }
      exports2.binarySearch = binarySearch;
      function binarySearchAssociativeList(list, item, cmp) {
        return generalizedBinarySearch((x8) => x8[0], cmp)(list, item);
      }
      exports2.binarySearchAssociativeList = binarySearchAssociativeList;
    }
  });

  // node_modules/tuple-database/helpers/sortedList.js
  var require_sortedList = __commonJS({
    "node_modules/tuple-database/helpers/sortedList.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.scan = exports2.remove = exports2.exists = exports2.get = exports2.set = void 0;
      var binarySearch_1 = require_binarySearch();
      function set4(list, item, cmp) {
        const result = (0, binarySearch_1.binarySearch)(list, item, cmp);
        if (result.found !== void 0) {
          list.splice(result.found, 1, item);
        } else {
          list.splice(result.closest, 0, item);
        }
      }
      exports2.set = set4;
      function get3(list, item, cmp) {
        const result = (0, binarySearch_1.binarySearch)(list, item, cmp);
        if (result.found === void 0)
          return;
        return list[result.found];
      }
      exports2.get = get3;
      function exists2(list, item, cmp) {
        const result = (0, binarySearch_1.binarySearch)(list, item, cmp);
        return result.found !== void 0;
      }
      exports2.exists = exists2;
      function remove2(list, item, cmp) {
        let { found } = (0, binarySearch_1.binarySearch)(list, item, cmp);
        if (found !== void 0) {
          return list.splice(found, 1)[0];
        }
      }
      exports2.remove = remove2;
      function scan2(list, args, cmp) {
        const start = args.gte || args.gt;
        const end = args.lte || args.lt;
        if (start !== void 0 && end !== void 0 && cmp(start, end) > 0) {
          throw new Error("Invalid bounds.");
        }
        let lowerSearchBound;
        let upperSearchBound;
        if (start === void 0) {
          lowerSearchBound = 0;
        } else {
          const result = (0, binarySearch_1.binarySearch)(list, start, cmp);
          if (result.found === void 0) {
            lowerSearchBound = result.closest;
          } else {
            if (args.gt)
              lowerSearchBound = result.found + 1;
            else
              lowerSearchBound = result.found;
          }
        }
        if (end === void 0) {
          upperSearchBound = list.length;
        } else {
          const result = (0, binarySearch_1.binarySearch)(list, end, cmp);
          if (result.found === void 0) {
            upperSearchBound = result.closest;
          } else {
            if (args.lt)
              upperSearchBound = result.found;
            else
              upperSearchBound = result.found + 1;
          }
        }
        const lowerDataBound = args.reverse && args.limit ? Math.max(lowerSearchBound, upperSearchBound - args.limit) : lowerSearchBound;
        const upperDataBound = !args.reverse && args.limit ? Math.min(lowerSearchBound + args.limit, upperSearchBound) : upperSearchBound;
        return args.reverse ? list.slice(lowerDataBound, upperDataBound).reverse() : list.slice(lowerDataBound, upperDataBound);
      }
      exports2.scan = scan2;
    }
  });

  // node_modules/tuple-database/helpers/sortedTupleArray.js
  var require_sortedTupleArray = __commonJS({
    "node_modules/tuple-database/helpers/sortedTupleArray.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.scan = exports2.isTupleWithinBounds = exports2.getPrefixContainingBounds = exports2.normalizeTupleBounds = exports2.MaxTuple = exports2.remove = exports2.exists = exports2.set = void 0;
      var lodash_1 = require_lodash();
      var types_1 = require_types2();
      var compareTuple_1 = require_compareTuple();
      var sortedList = __importStar(require_sortedList());
      function set4(data, tuple) {
        return sortedList.set(data, tuple, compareTuple_1.compareTuple);
      }
      exports2.set = set4;
      function exists2(data, tuple) {
        return sortedList.exists(data, tuple, compareTuple_1.compareTuple);
      }
      exports2.exists = exists2;
      function remove2(data, tuple) {
        return sortedList.remove(data, tuple, compareTuple_1.compareTuple);
      }
      exports2.remove = remove2;
      exports2.MaxTuple = [types_1.MAX, types_1.MAX, types_1.MAX, types_1.MAX, types_1.MAX, types_1.MAX, types_1.MAX, types_1.MAX, types_1.MAX, types_1.MAX];
      function normalizeTupleBounds(args) {
        let gte;
        let gt2;
        let lte;
        let lt;
        if (args.gte) {
          if (args.prefix) {
            gte = [...args.prefix, ...args.gte];
          } else {
            gte = [...args.gte];
          }
        } else if (args.gt) {
          if (args.prefix) {
            gt2 = [...args.prefix, ...args.gt];
          } else {
            gt2 = [...args.gt];
          }
        } else if (args.prefix) {
          gte = [...args.prefix];
        }
        if (args.lte) {
          if (args.prefix) {
            lte = [...args.prefix, ...args.lte];
          } else {
            lte = [...args.lte];
          }
        } else if (args.lt) {
          if (args.prefix) {
            lt = [...args.prefix, ...args.lt];
          } else {
            lt = [...args.lt];
          }
        } else if (args.prefix) {
          lte = [...args.prefix, ...exports2.MaxTuple];
        }
        return (0, lodash_1.omitBy)({ gte, gt: gt2, lte, lt }, (x8) => x8 === void 0);
      }
      exports2.normalizeTupleBounds = normalizeTupleBounds;
      function getPrefixContainingBounds(bounds) {
        const prefix = [];
        const start = bounds.gt || bounds.gte || [];
        const end = bounds.lt || bounds.lte || [];
        const len = Math.min(start.length, end.length);
        for (let i4 = 0; i4 < len; i4++) {
          if (start[i4] === end[i4]) {
            prefix.push(start[i4]);
          } else {
            break;
          }
        }
        return prefix;
      }
      exports2.getPrefixContainingBounds = getPrefixContainingBounds;
      function isTupleWithinBounds(tuple, bounds) {
        if (bounds.gt) {
          if ((0, compareTuple_1.compareTuple)(tuple, bounds.gt) !== 1) {
            return false;
          }
        }
        if (bounds.gte) {
          if ((0, compareTuple_1.compareTuple)(tuple, bounds.gte) === -1) {
            return false;
          }
        }
        if (bounds.lt) {
          if ((0, compareTuple_1.compareTuple)(tuple, bounds.lt) !== -1) {
            return false;
          }
        }
        if (bounds.lte) {
          if ((0, compareTuple_1.compareTuple)(tuple, bounds.lte) === 1) {
            return false;
          }
        }
        return true;
      }
      exports2.isTupleWithinBounds = isTupleWithinBounds;
      function scan2(data, args = {}) {
        const { limit, reverse: reverse2, ...rest } = args;
        const bounds = normalizeTupleBounds(rest);
        return sortedList.scan(data, { limit, reverse: reverse2, ...bounds }, compareTuple_1.compareTuple);
      }
      exports2.scan = scan2;
    }
  });

  // node_modules/tuple-database/database/ConcurrencyLog.js
  var require_ConcurrencyLog = __commonJS({
    "node_modules/tuple-database/database/ConcurrencyLog.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ConcurrencyLog = exports2.ReadWriteConflictError = void 0;
      var mutableFilter_1 = require_mutableFilter();
      var outdent_1 = require_outdent();
      var sortedTupleArray_1 = require_sortedTupleArray();
      var ReadWriteConflictError = class extends Error {
        constructor(txId, writeTuple, readBounds) {
          const message = (0, outdent_1.outdent)(`
      ReadWriteConflictError: ${txId}
      Write to tuple ${writeTuple}
      conflicted with a read at the bounds ${readBounds}
    `);
          super(message);
        }
      };
      exports2.ReadWriteConflictError = ReadWriteConflictError;
      var ConcurrencyLog = class {
        constructor() {
          this.log = [];
        }
        // O(1)
        /** Record a read. */
        read(txId, bounds) {
          this.log.push({ type: "read", txId, bounds });
        }
        // O(n)
        /** Add writes to the log only if there is a conflict with a read. */
        write(txId, tuple) {
          for (const item of this.log) {
            if (item.type === "read" && (0, sortedTupleArray_1.isTupleWithinBounds)(tuple, item.bounds)) {
              this.log.push({ type: "write", tuple, txId });
              break;
            }
          }
        }
        // O(n^2/4)
        /** Determine if any reads conflict with writes. */
        commit(txId) {
          try {
            const reads = [];
            for (const item of this.log) {
              if (item.type === "read") {
                if (item.txId === txId) {
                  reads.push(item.bounds);
                }
              } else if (item.type === "write") {
                for (const read of reads) {
                  if ((0, sortedTupleArray_1.isTupleWithinBounds)(item.tuple, read)) {
                    throw new ReadWriteConflictError(item.txId, item.tuple, read);
                  }
                }
              }
            }
          } finally {
            this.cleanupReads(txId);
            this.cleanupWrites();
          }
        }
        cancel(txId) {
          this.cleanupReads(txId);
          this.cleanupWrites();
        }
        // O(n)
        /** Cleanup any reads for this transaction. */
        cleanupReads(txId) {
          (0, mutableFilter_1.mutableFilter)(this.log, (item) => {
            const txRead = item.txId === txId && item.type === "read";
            return !txRead;
          });
        }
        // O(n)
        /** Cleanup any writes that don't have conflicting reads. */
        cleanupWrites() {
          const reads = [];
          (0, mutableFilter_1.mutableFilter)(this.log, (item) => {
            if (item.type === "read") {
              reads.push(item.bounds);
              return true;
            } else {
              for (const read of reads) {
                if ((0, sortedTupleArray_1.isTupleWithinBounds)(item.tuple, read)) {
                  return true;
                }
              }
              return false;
            }
          });
        }
      };
      exports2.ConcurrencyLog = ConcurrencyLog;
    }
  });

  // node_modules/tuple-database/helpers/maybeWaitForPromises.js
  var require_maybeWaitForPromises = __commonJS({
    "node_modules/tuple-database/helpers/maybeWaitForPromises.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.maybePromiseAll = void 0;
      function maybePromiseAll(values) {
        if (values.some((value) => value instanceof Promise))
          return Promise.all(values.map((value) => {
            if (value instanceof Promise) {
              return value.catch((error) => console.error(error));
            } else {
              return value;
            }
          }));
        else
          return values;
      }
      exports2.maybePromiseAll = maybePromiseAll;
    }
  });

  // node_modules/tuple-database/helpers/sortedTupleValuePairs.js
  var require_sortedTupleValuePairs = __commonJS({
    "node_modules/tuple-database/helpers/sortedTupleValuePairs.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.scan = exports2.exists = exports2.get = exports2.remove = exports2.set = void 0;
      var compareTuple_1 = require_compareTuple();
      var sortedList = __importStar(require_sortedList());
      var sortedTupleArray_1 = require_sortedTupleArray();
      function compareTupleValuePair(a2, b4) {
        return (0, compareTuple_1.compareTuple)(a2.key, b4.key);
      }
      function compareTupleValuePairReverse(a2, b4) {
        return (0, compareTuple_1.compareTuple)(a2.key, b4.key) * -1;
      }
      function set4(data, key, value, reverse2 = false) {
        return sortedList.set(data, { key, value }, reverse2 ? compareTupleValuePairReverse : compareTupleValuePair);
      }
      exports2.set = set4;
      function remove2(data, key, reverse2 = false) {
        return sortedList.remove(data, { key, value: null }, reverse2 ? compareTupleValuePairReverse : compareTupleValuePair);
      }
      exports2.remove = remove2;
      function get3(data, key, reverse2 = false) {
        const pair = sortedList.get(data, { key, value: null }, reverse2 ? compareTupleValuePairReverse : compareTupleValuePair);
        if (pair !== void 0)
          return pair.value;
      }
      exports2.get = get3;
      function exists2(data, key, reverse2 = false) {
        return sortedList.exists(data, { key, value: null }, reverse2 ? compareTupleValuePairReverse : compareTupleValuePair);
      }
      exports2.exists = exists2;
      function normalizeTupleValuePairBounds(args) {
        const bounds = (0, sortedTupleArray_1.normalizeTupleBounds)(args);
        const { gt: gt2, lt, gte, lte } = bounds;
        return {
          gt: gt2 ? { key: gt2, value: null } : void 0,
          gte: gte ? { key: gte, value: null } : void 0,
          lt: lt ? { key: lt, value: null } : void 0,
          lte: lte ? { key: lte, value: null } : void 0
        };
      }
      function scan2(data, args = {}) {
        const { limit, reverse: reverse2, ...rest } = args;
        const bounds = normalizeTupleValuePairBounds(rest);
        return sortedList.scan(data, { limit, reverse: reverse2, ...bounds }, compareTupleValuePair);
      }
      exports2.scan = scan2;
    }
  });

  // node_modules/tuple-database/storage/InMemoryTupleStorage.js
  var require_InMemoryTupleStorage = __commonJS({
    "node_modules/tuple-database/storage/InMemoryTupleStorage.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.InMemoryTupleStorage = void 0;
      var tv = __importStar(require_sortedTupleValuePairs());
      var InMemoryTupleStorage = class {
        constructor(data) {
          this.data = data || [];
        }
        scan(args) {
          return tv.scan(this.data, args);
        }
        commit(writes) {
          const { set: set4, remove: remove2 } = writes;
          for (const tuple of remove2 || []) {
            tv.remove(this.data, tuple);
          }
          for (const { key, value } of set4 || []) {
            tv.set(this.data, key, value);
          }
        }
        close() {
        }
      };
      exports2.InMemoryTupleStorage = InMemoryTupleStorage;
    }
  });

  // node_modules/tuple-database/database/async/AsyncReactivityTracker.js
  var require_AsyncReactivityTracker = __commonJS({
    "node_modules/tuple-database/database/async/AsyncReactivityTracker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AsyncReactivityTracker = void 0;
      var maybeWaitForPromises_1 = require_maybeWaitForPromises();
      var randomId_1 = require_randomId();
      var sortedTupleArray_1 = require_sortedTupleArray();
      var InMemoryTupleStorage_1 = require_InMemoryTupleStorage();
      var types_1 = require_types2();
      var AsyncReactivityTracker = class {
        constructor() {
          this.listenersDb = new InMemoryTupleStorage_1.InMemoryTupleStorage();
        }
        subscribe(args, callback) {
          return subscribe(this.listenersDb, args, callback);
        }
        computeReactivityEmits(writes) {
          return getReactivityEmits(this.listenersDb, writes);
        }
        async emit(emits, txId) {
          let promises = [];
          for (const [callback, writes] of emits.entries()) {
            try {
              promises.push(callback(writes, txId));
            } catch (error) {
              console.error(error);
            }
          }
          return (0, maybeWaitForPromises_1.maybePromiseAll)(promises);
        }
      };
      exports2.AsyncReactivityTracker = AsyncReactivityTracker;
      function iterateTuplePrefixes(tuple) {
        const prefixes = [tuple];
        for (let i4 = 0; i4 < tuple.length; i4++) {
          const prefix = tuple.slice(0, i4);
          prefixes.push(prefix);
        }
        return prefixes;
      }
      function getListenersForTuplePrefix(listenersDb, tuple) {
        const listeners = [];
        for (const prefix of iterateTuplePrefixes(tuple)) {
          const results = listenersDb.scan({
            gte: [prefix],
            lte: [[...prefix, types_1.MIN]]
          });
          for (const { value } of results) {
            listeners.push(value);
          }
        }
        return listeners;
      }
      function getListenerCallbacksForTuple(listenersDb, tuple) {
        const callbacks = [];
        for (const listener of getListenersForTuplePrefix(listenersDb, tuple)) {
          const { callback, bounds } = listener;
          if ((0, sortedTupleArray_1.isTupleWithinBounds)(tuple, bounds)) {
            callbacks.push(callback);
          } else {
          }
        }
        return callbacks;
      }
      function getReactivityEmits(listenersDb, writes) {
        const emits = /* @__PURE__ */ new Map();
        for (const { key, value } of writes.set || []) {
          const callbacks = getListenerCallbacksForTuple(listenersDb, key);
          for (const callback of callbacks) {
            if (!emits.has(callback))
              emits.set(callback, { set: [], remove: [] });
            emits.get(callback).set.push({ key, value });
          }
        }
        for (const tuple of writes.remove || []) {
          const callbacks = getListenerCallbacksForTuple(listenersDb, tuple);
          for (const callback of callbacks) {
            if (!emits.has(callback))
              emits.set(callback, { set: [], remove: [] });
            emits.get(callback).remove.push(tuple);
          }
        }
        return emits;
      }
      function subscribe(listenersDb, args, callback) {
        const prefix = (0, sortedTupleArray_1.getPrefixContainingBounds)(args);
        const id3 = (0, randomId_1.randomId)();
        const value = { callback, bounds: args };
        listenersDb.commit({ set: [{ key: [prefix, id3], value }] });
        const unsubscribe = () => {
          listenersDb.commit({ remove: [[prefix, id3]] });
        };
        return unsubscribe;
      }
    }
  });

  // node_modules/tuple-database/database/async/AsyncTupleDatabase.js
  var require_AsyncTupleDatabase = __commonJS({
    "node_modules/tuple-database/database/async/AsyncTupleDatabase.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AsyncTupleDatabase = void 0;
      var iterateTuples_1 = require_iterateTuples();
      var randomId_1 = require_randomId();
      var ConcurrencyLog_1 = require_ConcurrencyLog();
      var AsyncReactivityTracker_1 = require_AsyncReactivityTracker();
      var AsyncTupleDatabase = class {
        constructor(storage) {
          this.storage = storage;
          this.log = new ConcurrencyLog_1.ConcurrencyLog();
          this.reactivity = new AsyncReactivityTracker_1.AsyncReactivityTracker();
        }
        async scan(args = {}, txId) {
          const { reverse: reverse2, limit, ...bounds } = args;
          if (txId)
            this.log.read(txId, bounds);
          return this.storage.scan({ ...bounds, reverse: reverse2, limit });
        }
        async subscribe(args, callback) {
          return this.reactivity.subscribe(args, callback);
        }
        async commit(writes, txId) {
          const emits = this.reactivity.computeReactivityEmits(writes);
          if (txId)
            this.log.commit(txId);
          for (const tuple of (0, iterateTuples_1.iterateWrittenTuples)(writes)) {
            this.log.write(txId, tuple);
          }
          await this.storage.commit(writes);
          return this.reactivity.emit(emits, txId || (0, randomId_1.randomId)());
        }
        async cancel(txId) {
          this.log.cancel(txId);
        }
        async close() {
          await this.storage.close();
        }
      };
      exports2.AsyncTupleDatabase = AsyncTupleDatabase;
    }
  });

  // node_modules/tuple-database/helpers/subspaceHelpers.js
  var require_subspaceHelpers = __commonJS({
    "node_modules/tuple-database/helpers/subspaceHelpers.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.normalizeSubspaceScanArgs = exports2.removePrefixFromTupleValuePairs = exports2.removePrefixFromTuple = exports2.removePrefixFromWriteOps = exports2.prependPrefixToWriteOps = exports2.prependPrefixToTuple = void 0;
      var lodash_1 = require_lodash();
      var sortedTupleArray_1 = require_sortedTupleArray();
      function prependPrefixToTuple(prefix, tuple) {
        return [...prefix, ...tuple];
      }
      exports2.prependPrefixToTuple = prependPrefixToTuple;
      function prependPrefixToTuples(prefix, tuples) {
        return tuples.map((tuple) => prependPrefixToTuple(prefix, tuple));
      }
      function prependPrefixToTupleValuePair(prefix, pair) {
        const { key, value } = pair;
        return {
          key: prependPrefixToTuple(prefix, key),
          value
        };
      }
      function prependPrefixToTupleValuePairs(prefix, pairs) {
        return pairs.map((pair) => prependPrefixToTupleValuePair(prefix, pair));
      }
      function prependPrefixToWriteOps(prefix, writes) {
        const set4 = writes.set ? prependPrefixToTupleValuePairs(prefix, writes.set) : void 0;
        const remove2 = writes.remove ? prependPrefixToTuples(prefix, writes.remove) : void 0;
        return { set: set4, remove: remove2 };
      }
      exports2.prependPrefixToWriteOps = prependPrefixToWriteOps;
      function removePrefixFromWriteOps(prefix, writes) {
        const set4 = writes.set ? removePrefixFromTupleValuePairs(prefix, writes.set) : void 0;
        const remove2 = writes.remove ? removePrefixFromTuples(prefix, writes.remove) : void 0;
        return { set: set4, remove: remove2 };
      }
      exports2.removePrefixFromWriteOps = removePrefixFromWriteOps;
      function removePrefixFromTuple(prefix, tuple) {
        if (!(0, lodash_1.isEqual)(tuple.slice(0, prefix.length), prefix)) {
          throw new Error("Invalid prefix: " + JSON.stringify({ prefix, tuple }));
        }
        return tuple.slice(prefix.length);
      }
      exports2.removePrefixFromTuple = removePrefixFromTuple;
      function removePrefixFromTuples(prefix, tuples) {
        return tuples.map((tuple) => removePrefixFromTuple(prefix, tuple));
      }
      function removePrefixFromTupleValuePair(prefix, pair) {
        const { key, value } = pair;
        return { key: removePrefixFromTuple(prefix, key), value };
      }
      function removePrefixFromTupleValuePairs(prefix, pairs) {
        return pairs.map((pair) => removePrefixFromTupleValuePair(prefix, pair));
      }
      exports2.removePrefixFromTupleValuePairs = removePrefixFromTupleValuePairs;
      function normalizeSubspaceScanArgs(subspacePrefix, args) {
        const prefix = args.prefix ? [...subspacePrefix, ...args.prefix] : subspacePrefix;
        const bounds = (0, sortedTupleArray_1.normalizeTupleBounds)({ ...args, prefix });
        const { limit, reverse: reverse2 } = args;
        return (0, lodash_1.omitBy)({ ...bounds, limit, reverse: reverse2 }, (x8) => x8 === void 0);
      }
      exports2.normalizeSubspaceScanArgs = normalizeSubspaceScanArgs;
    }
  });

  // node_modules/tuple-database/database/async/AsyncTupleDatabaseClient.js
  var require_AsyncTupleDatabaseClient = __commonJS({
    "node_modules/tuple-database/database/async/AsyncTupleDatabaseClient.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AsyncTupleSubspaceTransaction = exports2.AsyncTupleRootTransaction = exports2.AsyncTupleDatabaseClient = void 0;
      var randomId_1 = require_randomId();
      var t3 = __importStar(require_sortedTupleArray());
      var tv = __importStar(require_sortedTupleValuePairs());
      var subspaceHelpers_1 = require_subspaceHelpers();
      var AsyncTupleDatabaseClient = class {
        constructor(db, subspacePrefix = []) {
          this.db = db;
          this.subspacePrefix = subspacePrefix;
        }
        async scan(args = {}, txId) {
          const storageScanArgs = (0, subspaceHelpers_1.normalizeSubspaceScanArgs)(this.subspacePrefix, args);
          const pairs = await this.db.scan(storageScanArgs, txId);
          const result = (0, subspaceHelpers_1.removePrefixFromTupleValuePairs)(this.subspacePrefix, pairs);
          return result;
        }
        async subscribe(args, callback) {
          const storageScanArgs = (0, subspaceHelpers_1.normalizeSubspaceScanArgs)(this.subspacePrefix, args);
          return this.db.subscribe(storageScanArgs, (write, txId) => {
            return callback((0, subspaceHelpers_1.removePrefixFromWriteOps)(this.subspacePrefix, write), txId);
          });
        }
        async commit(writes, txId) {
          const prefixedWrites = (0, subspaceHelpers_1.prependPrefixToWriteOps)(this.subspacePrefix, writes);
          await this.db.commit(prefixedWrites, txId);
        }
        async cancel(txId) {
          return this.db.cancel(txId);
        }
        async get(tuple, txId) {
          const items = await this.scan({ gte: tuple, lte: tuple }, txId);
          if (items.length === 0)
            return;
          if (items.length > 1)
            throw new Error("Get expects only one value.");
          const pair = items[0];
          return pair.value;
        }
        async exists(tuple, txId) {
          const items = await this.scan({ gte: tuple, lte: tuple }, txId);
          if (items.length === 0)
            return false;
          return items.length >= 1;
        }
        // Subspace
        subspace(prefix) {
          const subspacePrefix = [...this.subspacePrefix, ...prefix];
          return new AsyncTupleDatabaseClient(this.db, subspacePrefix);
        }
        // Transaction
        transact(txId, writes) {
          const id3 = txId || (0, randomId_1.randomId)();
          return new AsyncTupleRootTransaction(this.db, this.subspacePrefix, id3, writes);
        }
        async close() {
          return this.db.close();
        }
      };
      exports2.AsyncTupleDatabaseClient = AsyncTupleDatabaseClient;
      var AsyncTupleRootTransaction = class {
        constructor(db, subspacePrefix, id3, writes) {
          this.db = db;
          this.subspacePrefix = subspacePrefix;
          this.id = id3;
          this.committed = false;
          this.canceled = false;
          this.writes = { set: [], remove: [], ...writes };
        }
        checkActive() {
          if (this.committed)
            throw new Error("Transaction already committed");
          if (this.canceled)
            throw new Error("Transaction already canceled");
        }
        async scan(args = {}) {
          this.checkActive();
          const { limit: resultLimit, ...scanArgs } = (0, subspaceHelpers_1.normalizeSubspaceScanArgs)(this.subspacePrefix, args);
          const sets = tv.scan(this.writes.set, scanArgs);
          const removes = t3.scan(this.writes.remove, scanArgs);
          const scanLimit = resultLimit ? resultLimit + removes.length : void 0;
          const pairs = await this.db.scan({ ...scanArgs, limit: scanLimit }, this.id);
          const result = (0, subspaceHelpers_1.removePrefixFromTupleValuePairs)(this.subspacePrefix, pairs);
          for (const { key: fullTuple, value } of sets) {
            const tuple = (0, subspaceHelpers_1.removePrefixFromTuple)(this.subspacePrefix, fullTuple);
            tv.set(result, tuple, value, scanArgs.reverse);
          }
          for (const fullTuple of removes) {
            const tuple = (0, subspaceHelpers_1.removePrefixFromTuple)(this.subspacePrefix, fullTuple);
            tv.remove(result, tuple, scanArgs.reverse);
          }
          if (resultLimit) {
            if (result.length > resultLimit) {
              result.splice(resultLimit, result.length);
            }
          }
          return result;
        }
        async get(tuple) {
          this.checkActive();
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          if (tv.exists(this.writes.set, fullTuple)) {
            return tv.get(this.writes.set, fullTuple);
          }
          if (t3.exists(this.writes.remove, fullTuple)) {
            return;
          }
          const items = await this.db.scan({ gte: fullTuple, lte: fullTuple }, this.id);
          if (items.length === 0)
            return;
          if (items.length > 1)
            throw new Error("Get expects only one value.");
          const pair = items[0];
          return pair.value;
        }
        async exists(tuple) {
          this.checkActive();
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          if (tv.exists(this.writes.set, fullTuple)) {
            return true;
          }
          if (t3.exists(this.writes.remove, fullTuple)) {
            return false;
          }
          const items = await this.db.scan({ gte: fullTuple, lte: fullTuple }, this.id);
          if (items.length === 0)
            return false;
          return items.length >= 1;
        }
        // ReadApis
        set(tuple, value) {
          this.checkActive();
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          t3.remove(this.writes.remove, fullTuple);
          tv.set(this.writes.set, fullTuple, value);
          return this;
        }
        remove(tuple) {
          this.checkActive();
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          tv.remove(this.writes.set, fullTuple);
          t3.set(this.writes.remove, fullTuple);
          return this;
        }
        write(writes) {
          this.checkActive();
          const { set: set4, remove: remove2 } = writes;
          for (const tuple of remove2 || []) {
            this.remove(tuple);
          }
          for (const { key, value } of set4 || []) {
            this.set(key, value);
          }
          return this;
        }
        async commit() {
          this.checkActive();
          this.committed = true;
          return this.db.commit(this.writes, this.id);
        }
        async cancel() {
          this.checkActive();
          this.canceled = true;
          return this.db.cancel(this.id);
        }
        subspace(prefix) {
          this.checkActive();
          return new AsyncTupleSubspaceTransaction(this, prefix);
        }
      };
      exports2.AsyncTupleRootTransaction = AsyncTupleRootTransaction;
      var AsyncTupleSubspaceTransaction = class {
        constructor(tx, subspacePrefix) {
          this.tx = tx;
          this.subspacePrefix = subspacePrefix;
        }
        async scan(args = {}) {
          const storageScanArgs = (0, subspaceHelpers_1.normalizeSubspaceScanArgs)(this.subspacePrefix, args);
          const pairs = await this.tx.scan(storageScanArgs);
          const result = (0, subspaceHelpers_1.removePrefixFromTupleValuePairs)(this.subspacePrefix, pairs);
          return result;
        }
        async get(tuple) {
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          return this.tx.get(fullTuple);
        }
        async exists(tuple) {
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          return this.tx.exists(fullTuple);
        }
        // ReadApis
        set(tuple, value) {
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          this.tx.set(fullTuple, value);
          return this;
        }
        remove(tuple) {
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          this.tx.remove(fullTuple);
          return this;
        }
        write(writes) {
          const { set: set4, remove: remove2 } = writes;
          for (const tuple of remove2 || []) {
            this.remove(tuple);
          }
          for (const { key, value } of set4 || []) {
            this.set(key, value);
          }
          return this;
        }
        subspace(prefix) {
          return new AsyncTupleSubspaceTransaction(this.tx, [
            ...this.subspacePrefix,
            ...prefix
          ]);
        }
      };
      exports2.AsyncTupleSubspaceTransaction = AsyncTupleSubspaceTransaction;
    }
  });

  // node_modules/tuple-database/database/async/asyncTypes.js
  var require_asyncTypes = __commonJS({
    "node_modules/tuple-database/database/async/asyncTypes.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/tuple-database/helpers/isEmptyWrites.js
  var require_isEmptyWrites = __commonJS({
    "node_modules/tuple-database/helpers/isEmptyWrites.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isEmptyWrites = void 0;
      function isEmptyWrites(writes) {
        var _a, _b;
        if ((_a = writes.remove) === null || _a === void 0 ? void 0 : _a.length)
          return false;
        if ((_b = writes.set) === null || _b === void 0 ? void 0 : _b.length)
          return false;
        return true;
      }
      exports2.isEmptyWrites = isEmptyWrites;
    }
  });

  // node_modules/tuple-database/helpers/Queue.js
  var require_Queue = __commonJS({
    "node_modules/tuple-database/helpers/Queue.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Queue = void 0;
      var Queue = class {
        enqueue(fn) {
          if (this.currentPromise) {
            const nextPromise = this.currentPromise.then(fn).then((result2) => {
              if (this.currentPromise === nextPromise)
                this.currentPromise = void 0;
              return result2;
            });
            this.currentPromise = nextPromise;
            return nextPromise;
          }
          const result = fn();
          if (result instanceof Promise) {
            const nextPromise = result.then((result2) => {
              if (this.currentPromise === nextPromise)
                this.currentPromise = void 0;
              return result2;
            });
            this.currentPromise = nextPromise;
            return nextPromise;
          }
          return result;
        }
      };
      exports2.Queue = Queue;
    }
  });

  // node_modules/tuple-database/database/async/subscribeQueryAsync.js
  var require_subscribeQueryAsync = __commonJS({
    "node_modules/tuple-database/database/async/subscribeQueryAsync.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.subscribeQueryAsync = void 0;
      var isEmptyWrites_1 = require_isEmptyWrites();
      var Queue_1 = require_Queue();
      var AsyncTupleDatabaseClient_1 = require_AsyncTupleDatabaseClient();
      var throwError = () => {
        throw new Error();
      };
      async function subscribeQueryAsync(db, fn, callback) {
        let destroyed = false;
        const listeners = /* @__PURE__ */ new Set();
        const compute = () => fn(listenDb);
        const resetListeners = () => {
          listeners.forEach((destroy2) => destroy2());
          listeners.clear();
        };
        let lastComputedTxId;
        const recompute = async (txId) => {
          if (destroyed)
            return;
          if (txId === lastComputedTxId)
            return;
          lastComputedTxId = txId;
          resetListeners();
          const result2 = await compute();
          callback(result2);
        };
        const recomputeQueue = new Queue_1.Queue();
        const listenDb = new AsyncTupleDatabaseClient_1.AsyncTupleDatabaseClient({
          scan: async (args, txId) => {
            const destroy2 = await db.subscribe(args, async (_writes, txId2) => recomputeQueue.enqueue(() => recompute(txId2)));
            listeners.add(destroy2);
            const results = await db.scan(args);
            return results;
          },
          cancel: async (txId) => {
            await db.cancel(txId);
          },
          commit: async (writes, txId) => {
            if (!(0, isEmptyWrites_1.isEmptyWrites)(writes))
              throw new Error("No writing in a subscribeQueryAsync.");
            await db.commit({}, txId);
          },
          subscribe: throwError,
          close: throwError
        });
        const result = await compute();
        const destroy = () => {
          resetListeners();
          destroyed = true;
        };
        return { result, destroy };
      }
      exports2.subscribeQueryAsync = subscribeQueryAsync;
    }
  });

  // node_modules/tuple-database/database/async/retryAsync.js
  var require_retryAsync = __commonJS({
    "node_modules/tuple-database/database/async/retryAsync.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.retryAsync = void 0;
      var ConcurrencyLog_1 = require_ConcurrencyLog();
      async function retryAsync(retries, fn) {
        while (true) {
          try {
            const result = await fn();
            return result;
          } catch (error) {
            if (retries <= 0)
              throw error;
            const isConflict = error instanceof ConcurrencyLog_1.ReadWriteConflictError;
            if (!isConflict)
              throw error;
            retries -= 1;
          }
        }
      }
      exports2.retryAsync = retryAsync;
    }
  });

  // node_modules/tuple-database/database/async/transactionalReadWriteAsync.js
  var require_transactionalReadWriteAsync = __commonJS({
    "node_modules/tuple-database/database/async/transactionalReadWriteAsync.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.transactionalAsyncQuery = exports2.transactionalReadWriteAsync = void 0;
      var retryAsync_1 = require_retryAsync();
      function transactionalReadWriteAsync(retries = 5) {
        return function(fn) {
          return async function(dbOrTx, ...args) {
            if ("set" in dbOrTx)
              return fn(dbOrTx, ...args);
            return await (0, retryAsync_1.retryAsync)(retries, async () => {
              const tx = dbOrTx.transact();
              const result = await fn(tx, ...args);
              await tx.commit();
              return result;
            });
          };
        };
      }
      exports2.transactionalReadWriteAsync = transactionalReadWriteAsync;
      exports2.transactionalAsyncQuery = transactionalReadWriteAsync;
    }
  });

  // node_modules/tuple-database/database/sync/TupleDatabaseClient.js
  var require_TupleDatabaseClient = __commonJS({
    "node_modules/tuple-database/database/sync/TupleDatabaseClient.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o3, v7) {
        Object.defineProperty(o3, "default", { enumerable: true, value: v7 });
      } : function(o3, v7) {
        o3["default"] = v7;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k3 in mod3)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k3))
              __createBinding(result, mod3, k3);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TupleSubspaceTransaction = exports2.TupleRootTransaction = exports2.TupleDatabaseClient = void 0;
      var randomId_1 = require_randomId();
      var t3 = __importStar(require_sortedTupleArray());
      var tv = __importStar(require_sortedTupleValuePairs());
      var subspaceHelpers_1 = require_subspaceHelpers();
      var TupleDatabaseClient = class {
        constructor(db, subspacePrefix = []) {
          this.db = db;
          this.subspacePrefix = subspacePrefix;
        }
        scan(args = {}, txId) {
          const storageScanArgs = (0, subspaceHelpers_1.normalizeSubspaceScanArgs)(this.subspacePrefix, args);
          const pairs = this.db.scan(storageScanArgs, txId);
          const result = (0, subspaceHelpers_1.removePrefixFromTupleValuePairs)(this.subspacePrefix, pairs);
          return result;
        }
        subscribe(args, callback) {
          const storageScanArgs = (0, subspaceHelpers_1.normalizeSubspaceScanArgs)(this.subspacePrefix, args);
          return this.db.subscribe(storageScanArgs, (write, txId) => {
            return callback((0, subspaceHelpers_1.removePrefixFromWriteOps)(this.subspacePrefix, write), txId);
          });
        }
        commit(writes, txId) {
          const prefixedWrites = (0, subspaceHelpers_1.prependPrefixToWriteOps)(this.subspacePrefix, writes);
          this.db.commit(prefixedWrites, txId);
        }
        cancel(txId) {
          return this.db.cancel(txId);
        }
        get(tuple, txId) {
          const items = this.scan({ gte: tuple, lte: tuple }, txId);
          if (items.length === 0)
            return;
          if (items.length > 1)
            throw new Error("Get expects only one value.");
          const pair = items[0];
          return pair.value;
        }
        exists(tuple, txId) {
          const items = this.scan({ gte: tuple, lte: tuple }, txId);
          if (items.length === 0)
            return false;
          return items.length >= 1;
        }
        // Subspace
        subspace(prefix) {
          const subspacePrefix = [...this.subspacePrefix, ...prefix];
          return new TupleDatabaseClient(this.db, subspacePrefix);
        }
        // Transaction
        transact(txId, writes) {
          const id3 = txId || (0, randomId_1.randomId)();
          return new TupleRootTransaction(this.db, this.subspacePrefix, id3, writes);
        }
        close() {
          return this.db.close();
        }
      };
      exports2.TupleDatabaseClient = TupleDatabaseClient;
      var TupleRootTransaction = class {
        constructor(db, subspacePrefix, id3, writes) {
          this.db = db;
          this.subspacePrefix = subspacePrefix;
          this.id = id3;
          this.committed = false;
          this.canceled = false;
          this.writes = { set: [], remove: [], ...writes };
        }
        checkActive() {
          if (this.committed)
            throw new Error("Transaction already committed");
          if (this.canceled)
            throw new Error("Transaction already canceled");
        }
        scan(args = {}) {
          this.checkActive();
          const { limit: resultLimit, ...scanArgs } = (0, subspaceHelpers_1.normalizeSubspaceScanArgs)(this.subspacePrefix, args);
          const sets = tv.scan(this.writes.set, scanArgs);
          const removes = t3.scan(this.writes.remove, scanArgs);
          const scanLimit = resultLimit ? resultLimit + removes.length : void 0;
          const pairs = this.db.scan({ ...scanArgs, limit: scanLimit }, this.id);
          const result = (0, subspaceHelpers_1.removePrefixFromTupleValuePairs)(this.subspacePrefix, pairs);
          for (const { key: fullTuple, value } of sets) {
            const tuple = (0, subspaceHelpers_1.removePrefixFromTuple)(this.subspacePrefix, fullTuple);
            tv.set(result, tuple, value, scanArgs.reverse);
          }
          for (const fullTuple of removes) {
            const tuple = (0, subspaceHelpers_1.removePrefixFromTuple)(this.subspacePrefix, fullTuple);
            tv.remove(result, tuple, scanArgs.reverse);
          }
          if (resultLimit) {
            if (result.length > resultLimit) {
              result.splice(resultLimit, result.length);
            }
          }
          return result;
        }
        get(tuple) {
          this.checkActive();
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          if (tv.exists(this.writes.set, fullTuple)) {
            return tv.get(this.writes.set, fullTuple);
          }
          if (t3.exists(this.writes.remove, fullTuple)) {
            return;
          }
          const items = this.db.scan({ gte: fullTuple, lte: fullTuple }, this.id);
          if (items.length === 0)
            return;
          if (items.length > 1)
            throw new Error("Get expects only one value.");
          const pair = items[0];
          return pair.value;
        }
        exists(tuple) {
          this.checkActive();
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          if (tv.exists(this.writes.set, fullTuple)) {
            return true;
          }
          if (t3.exists(this.writes.remove, fullTuple)) {
            return false;
          }
          const items = this.db.scan({ gte: fullTuple, lte: fullTuple }, this.id);
          if (items.length === 0)
            return false;
          return items.length >= 1;
        }
        // ReadApis
        set(tuple, value) {
          this.checkActive();
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          t3.remove(this.writes.remove, fullTuple);
          tv.set(this.writes.set, fullTuple, value);
          return this;
        }
        remove(tuple) {
          this.checkActive();
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          tv.remove(this.writes.set, fullTuple);
          t3.set(this.writes.remove, fullTuple);
          return this;
        }
        write(writes) {
          this.checkActive();
          const { set: set4, remove: remove2 } = writes;
          for (const tuple of remove2 || []) {
            this.remove(tuple);
          }
          for (const { key, value } of set4 || []) {
            this.set(key, value);
          }
          return this;
        }
        commit() {
          this.checkActive();
          this.committed = true;
          return this.db.commit(this.writes, this.id);
        }
        cancel() {
          this.checkActive();
          this.canceled = true;
          return this.db.cancel(this.id);
        }
        subspace(prefix) {
          this.checkActive();
          return new TupleSubspaceTransaction(this, prefix);
        }
      };
      exports2.TupleRootTransaction = TupleRootTransaction;
      var TupleSubspaceTransaction = class {
        constructor(tx, subspacePrefix) {
          this.tx = tx;
          this.subspacePrefix = subspacePrefix;
        }
        scan(args = {}) {
          const storageScanArgs = (0, subspaceHelpers_1.normalizeSubspaceScanArgs)(this.subspacePrefix, args);
          const pairs = this.tx.scan(storageScanArgs);
          const result = (0, subspaceHelpers_1.removePrefixFromTupleValuePairs)(this.subspacePrefix, pairs);
          return result;
        }
        get(tuple) {
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          return this.tx.get(fullTuple);
        }
        exists(tuple) {
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          return this.tx.exists(fullTuple);
        }
        // ReadApis
        set(tuple, value) {
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          this.tx.set(fullTuple, value);
          return this;
        }
        remove(tuple) {
          const fullTuple = (0, subspaceHelpers_1.prependPrefixToTuple)(this.subspacePrefix, tuple);
          this.tx.remove(fullTuple);
          return this;
        }
        write(writes) {
          const { set: set4, remove: remove2 } = writes;
          for (const tuple of remove2 || []) {
            this.remove(tuple);
          }
          for (const { key, value } of set4 || []) {
            this.set(key, value);
          }
          return this;
        }
        subspace(prefix) {
          return new TupleSubspaceTransaction(this.tx, [
            ...this.subspacePrefix,
            ...prefix
          ]);
        }
      };
      exports2.TupleSubspaceTransaction = TupleSubspaceTransaction;
    }
  });

  // node_modules/tuple-database/database/sync/subscribeQuery.js
  var require_subscribeQuery = __commonJS({
    "node_modules/tuple-database/database/sync/subscribeQuery.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.subscribeQuery = void 0;
      var isEmptyWrites_1 = require_isEmptyWrites();
      var Queue_1 = require_Queue();
      var TupleDatabaseClient_1 = require_TupleDatabaseClient();
      var throwError = () => {
        throw new Error();
      };
      function subscribeQuery(db, fn, callback) {
        let destroyed = false;
        const listeners = /* @__PURE__ */ new Set();
        const compute = () => fn(listenDb);
        const resetListeners = () => {
          listeners.forEach((destroy2) => destroy2());
          listeners.clear();
        };
        let lastComputedTxId;
        const recompute = (txId) => {
          if (destroyed)
            return;
          if (txId === lastComputedTxId)
            return;
          lastComputedTxId = txId;
          resetListeners();
          const result2 = compute();
          callback(result2);
        };
        const recomputeQueue = new Queue_1.Queue();
        const listenDb = new TupleDatabaseClient_1.TupleDatabaseClient({
          scan: (args, txId) => {
            const destroy2 = db.subscribe(args, (_writes, txId2) => recomputeQueue.enqueue(() => recompute(txId2)));
            listeners.add(destroy2);
            const results = db.scan(args);
            return results;
          },
          cancel: (txId) => {
            db.cancel(txId);
          },
          commit: (writes, txId) => {
            if (!(0, isEmptyWrites_1.isEmptyWrites)(writes))
              throw new Error("No writing in a subscribeQuery.");
            db.commit({}, txId);
          },
          subscribe: throwError,
          close: throwError
        });
        const result = compute();
        const destroy = () => {
          resetListeners();
          destroyed = true;
        };
        return { result, destroy };
      }
      exports2.subscribeQuery = subscribeQuery;
    }
  });

  // node_modules/tuple-database/database/sync/retry.js
  var require_retry2 = __commonJS({
    "node_modules/tuple-database/database/sync/retry.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.retry = void 0;
      var ConcurrencyLog_1 = require_ConcurrencyLog();
      function retry(retries, fn) {
        while (true) {
          try {
            const result = fn();
            return result;
          } catch (error) {
            if (retries <= 0)
              throw error;
            const isConflict = error instanceof ConcurrencyLog_1.ReadWriteConflictError;
            if (!isConflict)
              throw error;
            retries -= 1;
          }
        }
      }
      exports2.retry = retry;
    }
  });

  // node_modules/tuple-database/database/sync/transactionalReadWrite.js
  var require_transactionalReadWrite = __commonJS({
    "node_modules/tuple-database/database/sync/transactionalReadWrite.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.transactionalQuery = exports2.transactionalReadWrite = void 0;
      var retry_1 = require_retry2();
      function transactionalReadWrite(retries = 5) {
        return function(fn) {
          return function(dbOrTx, ...args) {
            if ("set" in dbOrTx)
              return fn(dbOrTx, ...args);
            return (0, retry_1.retry)(retries, () => {
              const tx = dbOrTx.transact();
              const result = fn(tx, ...args);
              tx.commit();
              return result;
            });
          };
        };
      }
      exports2.transactionalReadWrite = transactionalReadWrite;
      exports2.transactionalQuery = transactionalReadWrite;
    }
  });

  // node_modules/tuple-database/database/sync/ReactivityTracker.js
  var require_ReactivityTracker = __commonJS({
    "node_modules/tuple-database/database/sync/ReactivityTracker.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ReactivityTracker = void 0;
      var maybeWaitForPromises_1 = require_maybeWaitForPromises();
      var randomId_1 = require_randomId();
      var sortedTupleArray_1 = require_sortedTupleArray();
      var InMemoryTupleStorage_1 = require_InMemoryTupleStorage();
      var types_1 = require_types2();
      var ReactivityTracker = class {
        constructor() {
          this.listenersDb = new InMemoryTupleStorage_1.InMemoryTupleStorage();
        }
        subscribe(args, callback) {
          return subscribe(this.listenersDb, args, callback);
        }
        computeReactivityEmits(writes) {
          return getReactivityEmits(this.listenersDb, writes);
        }
        emit(emits, txId) {
          let promises = [];
          for (const [callback, writes] of emits.entries()) {
            try {
              promises.push(callback(writes, txId));
            } catch (error) {
              console.error(error);
            }
          }
          return (0, maybeWaitForPromises_1.maybePromiseAll)(promises);
        }
      };
      exports2.ReactivityTracker = ReactivityTracker;
      function iterateTuplePrefixes(tuple) {
        const prefixes = [tuple];
        for (let i4 = 0; i4 < tuple.length; i4++) {
          const prefix = tuple.slice(0, i4);
          prefixes.push(prefix);
        }
        return prefixes;
      }
      function getListenersForTuplePrefix(listenersDb, tuple) {
        const listeners = [];
        for (const prefix of iterateTuplePrefixes(tuple)) {
          const results = listenersDb.scan({
            gte: [prefix],
            lte: [[...prefix, types_1.MIN]]
          });
          for (const { value } of results) {
            listeners.push(value);
          }
        }
        return listeners;
      }
      function getListenerCallbacksForTuple(listenersDb, tuple) {
        const callbacks = [];
        for (const listener of getListenersForTuplePrefix(listenersDb, tuple)) {
          const { callback, bounds } = listener;
          if ((0, sortedTupleArray_1.isTupleWithinBounds)(tuple, bounds)) {
            callbacks.push(callback);
          } else {
          }
        }
        return callbacks;
      }
      function getReactivityEmits(listenersDb, writes) {
        const emits = /* @__PURE__ */ new Map();
        for (const { key, value } of writes.set || []) {
          const callbacks = getListenerCallbacksForTuple(listenersDb, key);
          for (const callback of callbacks) {
            if (!emits.has(callback))
              emits.set(callback, { set: [], remove: [] });
            emits.get(callback).set.push({ key, value });
          }
        }
        for (const tuple of writes.remove || []) {
          const callbacks = getListenerCallbacksForTuple(listenersDb, tuple);
          for (const callback of callbacks) {
            if (!emits.has(callback))
              emits.set(callback, { set: [], remove: [] });
            emits.get(callback).remove.push(tuple);
          }
        }
        return emits;
      }
      function subscribe(listenersDb, args, callback) {
        const prefix = (0, sortedTupleArray_1.getPrefixContainingBounds)(args);
        const id3 = (0, randomId_1.randomId)();
        const value = { callback, bounds: args };
        listenersDb.commit({ set: [{ key: [prefix, id3], value }] });
        const unsubscribe = () => {
          listenersDb.commit({ remove: [[prefix, id3]] });
        };
        return unsubscribe;
      }
    }
  });

  // node_modules/tuple-database/database/sync/TupleDatabase.js
  var require_TupleDatabase = __commonJS({
    "node_modules/tuple-database/database/sync/TupleDatabase.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TupleDatabase = void 0;
      var iterateTuples_1 = require_iterateTuples();
      var randomId_1 = require_randomId();
      var ConcurrencyLog_1 = require_ConcurrencyLog();
      var ReactivityTracker_1 = require_ReactivityTracker();
      var TupleDatabase = class {
        constructor(storage) {
          this.storage = storage;
          this.log = new ConcurrencyLog_1.ConcurrencyLog();
          this.reactivity = new ReactivityTracker_1.ReactivityTracker();
        }
        scan(args = {}, txId) {
          const { reverse: reverse2, limit, ...bounds } = args;
          if (txId)
            this.log.read(txId, bounds);
          return this.storage.scan({ ...bounds, reverse: reverse2, limit });
        }
        subscribe(args, callback) {
          return this.reactivity.subscribe(args, callback);
        }
        commit(writes, txId) {
          const emits = this.reactivity.computeReactivityEmits(writes);
          if (txId)
            this.log.commit(txId);
          for (const tuple of (0, iterateTuples_1.iterateWrittenTuples)(writes)) {
            this.log.write(txId, tuple);
          }
          this.storage.commit(writes);
          return this.reactivity.emit(emits, txId || (0, randomId_1.randomId)());
        }
        cancel(txId) {
          this.log.cancel(txId);
        }
        close() {
          this.storage.close();
        }
      };
      exports2.TupleDatabase = TupleDatabase;
    }
  });

  // node_modules/tuple-database/database/sync/types.js
  var require_types3 = __commonJS({
    "node_modules/tuple-database/database/sync/types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/tuple-database/database/transactionalWrite.js
  var require_transactionalWrite = __commonJS({
    "node_modules/tuple-database/database/transactionalWrite.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.transactionalWrite = void 0;
      var retry_1 = require_retry2();
      function transactionalWrite(retries = 5) {
        return function(fn) {
          return function(dbOrTx, ...args) {
            if ("set" in dbOrTx)
              return fn(dbOrTx, ...args);
            return (0, retry_1.retry)(retries, () => {
              const tx = dbOrTx.transact();
              const result = fn(tx, ...args);
              tx.commit();
              return result;
            });
          };
        };
      }
      exports2.transactionalWrite = transactionalWrite;
    }
  });

  // node_modules/tuple-database/database/types.js
  var require_types4 = __commonJS({
    "node_modules/tuple-database/database/types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // node_modules/tuple-database/helpers/namedTupleToObject.js
  var require_namedTupleToObject = __commonJS({
    "node_modules/tuple-database/helpers/namedTupleToObject.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.namedTupleToObject = void 0;
      var lodash_1 = require_lodash();
      function isNamedTupleItem(value) {
        return (0, lodash_1.isPlainObject)(value);
      }
      function namedTupleToObject(key) {
        const obj = key.filter(isNamedTupleItem).reduce((obj2, item) => Object.assign(obj2, item), {});
        return obj;
      }
      exports2.namedTupleToObject = namedTupleToObject;
    }
  });

  // node_modules/tuple-database/main.js
  var require_main = __commonJS({
    "node_modules/tuple-database/main.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m5, k3);
        if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m5[k3];
          } };
        }
        Object.defineProperty(o3, k22, desc);
      } : function(o3, m5, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o3[k22] = m5[k3];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m5, exports3) {
        for (var p2 in m5)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding(exports3, m5, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar(require_AsyncTupleDatabase(), exports2);
      __exportStar(require_AsyncTupleDatabaseClient(), exports2);
      __exportStar(require_asyncTypes(), exports2);
      __exportStar(require_subscribeQueryAsync(), exports2);
      __exportStar(require_transactionalReadWriteAsync(), exports2);
      __exportStar(require_subscribeQuery(), exports2);
      __exportStar(require_transactionalReadWrite(), exports2);
      __exportStar(require_TupleDatabase(), exports2);
      __exportStar(require_TupleDatabaseClient(), exports2);
      __exportStar(require_types3(), exports2);
      __exportStar(require_transactionalWrite(), exports2);
      __exportStar(require_types4(), exports2);
      __exportStar(require_namedTupleToObject(), exports2);
      __exportStar(require_InMemoryTupleStorage(), exports2);
      __exportStar(require_types2(), exports2);
    }
  });

  // src/common/Config.ts
  var defaultGameConfig = {
    slotNum: 9,
    composeNumMin: 2,
    composeNumMax: 7,
    cardRatio: 2,
    typeNum: 16,
    cardSize: 44,
    removeRule: 1 /* DISCONTINUE */,
    viewSize: 9,
    totalNum: 25,
    stageNum: 3
  };

  // src/game/GameCard.ts
  var { regClass, property } = Laya;
  var GameCard = class extends Laya.Script {
    alphabet;
    Text;
    uid = -1;
    touchFlag = true;
    constructor() {
      super();
    }
    onAwake() {
      this.alphabet.on(Laya.Event.CLICK, this, this.onClickEvent.bind(this));
    }
    onClickEvent() {
      if (this.touchFlag == false) {
        return;
      }
      Laya.stage.event("TouchCard" /* TouchCard */, this.uid);
    }
    SetID(uid2) {
      this.Text.text = uid2;
    }
    SetAlphabet(alphabet2) {
      if (this.alphabet != void 0) {
        this.alphabet.texture = alphabet2;
      }
    }
  };
  __decorateClass([
    property({ type: Laya.Image })
  ], GameCard.prototype, "alphabet", 2);
  __decorateClass([
    property({ type: Laya.Text })
  ], GameCard.prototype, "Text", 2);
  GameCard = __decorateClass([
    regClass("7e141d25-8680-47b8-ba7a-591891ac425f")
  ], GameCard);

  // src/game/GameRank.generated.ts
  var GameRankBase = class extends Laya.Dialog {
    panel;
  };

  // src/game/GameRank.ts
  var { regClass: regClass2, property: property2 } = Laya;
  var GameRank = class extends GameRankBase {
    text = "";
    constructor() {
      super();
    }
    onOpened(param) {
      Laya.loader.load("resources/prefab/P_rankItem.lh").then((res) => {
        for (var i4 = 0; i4 < 10; i4++) {
          let item = res.create();
          let script = item.getComponent(Laya.Script);
          const temp = {
            id: i4.toString(),
            score: i4,
            index: i4
          };
          script.SetData(temp);
          item.y = i4 * 60;
          this.panel.addChildAt(item, i4);
        }
      });
    }
  };
  __decorateClass([
    property2(String)
  ], GameRank.prototype, "text", 2);
  GameRank = __decorateClass([
    regClass2("8203a5f5-90bc-460a-8000-7566f19f2d96")
  ], GameRank);

  // src/game/GameRankItem.ts
  var { regClass: regClass3, property: property3 } = Laya;
  var GameRankItem = class extends Laya.Script {
    rank;
    playerid;
    score;
    bg;
    constructor() {
      super();
    }
    onAwake() {
    }
    SetData(param) {
      this.rank = param.index;
      this.playerid.text = param.id;
      this.score.text = param.score;
      this.bg.color = param.index % 2 == 0 ? "3f6065" : "447844";
    }
    onOpened(param) {
    }
    onDisable() {
    }
  };
  __decorateClass([
    property3({ type: Laya.Label })
  ], GameRankItem.prototype, "rank", 2);
  __decorateClass([
    property3({ type: Laya.Label })
  ], GameRankItem.prototype, "playerid", 2);
  __decorateClass([
    property3({ type: Laya.Label })
  ], GameRankItem.prototype, "score", 2);
  __decorateClass([
    property3({ type: Laya.Image })
  ], GameRankItem.prototype, "bg", 2);
  GameRankItem = __decorateClass([
    regClass3("03da6766-2714-4250-9a61-d0385a46186e")
  ], GameRankItem);

  // src/game/GameResult.generated.ts
  var GameResultBase = class extends Laya.Dialog {
    Text;
  };

  // src/game/GameResult.ts
  var { regClass: regClass4, property: property4 } = Laya;
  var GameResult = class extends GameResultBase {
    type = 0;
    constructor() {
      super();
    }
    onAwake() {
      this.Text.text = "";
    }
    onOpened(param) {
      this.Text.text = param.text;
      this.type = param.type;
    }
    onDisable() {
    }
    onClosed(type) {
      Laya.stage.event("RestartGame" /* RestartGame */, this.type);
    }
  };
  GameResult = __decorateClass([
    regClass4("a170962e-a220-47de-bf55-4d6d50f2e100")
  ], GameResult);

  // src/common/RandomMgr.ts
  var RandomMgr = class {
    seed = -1;
    _a = 214013;
    _b = 2531011;
    _m = 4294967296;
    constructor() {
    }
    init(seed) {
      this.seed = seed;
    }
    rand(length) {
      this.seed = (this.seed * this._a + this._b) % this._m;
      return this.seed % length;
    }
    randomNum(minNum, maxNum) {
      return this.rand(maxNum - minNum + 1) + minNum;
    }
  };

  // src/scene/Game.generated.ts
  var GameBase = class extends Laya.Scene {
    bg;
    slot_bg;
    score_text;
    view;
    Mask;
  };

  // src/scene/Game.ts
  var { regClass: regClass5, property: property5 } = Laya;
  var Game = class extends GameBase {
    randMgr;
    chessBoard = [];
    res = null;
    card_res = null;
    cardNodeMap = /* @__PURE__ */ new Map();
    cardMap = /* @__PURE__ */ new Map();
    curSlotNum = 0;
    slotArea;
    score = 0;
    gameConfig;
    cardMoveSpeed = 1;
    slotCardMoveSpeed = 0.5;
    playerOpCards;
    stageNum = 0;
    async onAwake() {
      console.log("Game start");
      await Laya.loader.load("resources/prefab/P_card.lh").then((res) => {
        this.res = res;
      });
      await Laya.loader.load("resources/atlas/letter/letter.atlas", Laya.Loader.ATLAS).then((res) => {
        this.card_res = res;
      });
      this.gameConfig = defaultGameConfig;
      this.view.size(this.gameConfig.viewSize * this.gameConfig.cardSize, this.gameConfig.viewSize * this.gameConfig.cardSize);
      Laya.stage.on("TouchCard" /* TouchCard */, this, this.onTouchCardEvent.bind(this));
      Laya.stage.on("RestartGame" /* RestartGame */, this, this.RestartGame.bind(this));
      Laya.Tween.to(this.Mask, { alpha: 0 }, 1500, Laya.Ease.linearIn);
      this.onInitGame(this.gameConfig);
    }
    onDestroy() {
      for (let node of this.cardNodeMap) {
        node[1].removeSelf();
      }
      this.cardNodeMap.clear();
    }
    initMap(mapConfig) {
      this.gameConfig = {
        slotNum: this.getConfigValue(mapConfig, 0 /* SlotNum */),
        composeNumMin: this.getConfigValue(mapConfig, 1 /* ComposeNumMin */),
        composeNumMax: this.getConfigValue(mapConfig, 2 /* ComposeNumMax */),
        typeNum: this.getConfigValue(mapConfig, 4 /* TypeNum */),
        cardRatio: this.getConfigValue(mapConfig, 3 /* CardRatio */),
        cardSize: this.getConfigValue(mapConfig, 5 /* CardSize */),
        removeRule: this.getConfigValue(mapConfig, 6 /* RemoveRule */),
        viewSize: this.getConfigValue(mapConfig, 7 /* ViewSize */),
        totalNum: this.getConfigValue(mapConfig, 8 /* TotalNum */),
        stageNum: this.getConfigValue(mapConfig, 9 /* StageNum */)
      };
    }
    getConfigValue(config2, configType) {
      let result = 0;
      const _type = Number(configType);
      const t3 = config2.config >> BigInt(16 * _type);
      result = Number(t3 % BigInt(2 ** 16));
      return result;
    }
    onActionFinishEvent() {
      Laya.Scene.open("resources/scene/Login.ls", true, null, null, null);
      Laya.Scene.close("resources/scene/Game.ls");
      Laya.Scene.destroy("resources/scene/Game.ls");
    }
    onChangeScene() {
      Laya.Tween.to(this.Mask, { alpha: 1 }, 1200, Laya.Ease.linearIn, Laya.Handler.create(this, this.onActionFinishEvent.bind(this)));
    }
    RestartGame(type) {
      if (type == 0) {
        this.onChangeScene();
        return;
      } else if (type == 1) {
        this.stageNum++;
        if (this.stageNum == this.gameConfig.stageNum) {
          this.onChangeScene();
        }
      }
      this.onInitGame(this.gameConfig);
    }
    onTouchCardEvent(uid2) {
      if (!this.cardMap.has(uid2)) {
        return;
      }
      const status = this.cardMap.get(uid2).state;
      if (status == 0) {
        this.onTouchViewCardEvent(uid2);
      } else if (status == 1) {
        this.onTouchSlotCardEvent(uid2);
      }
    }
    onTouchViewCardEvent(uid2) {
      if (!this.cardMap.has(uid2)) {
        return;
      }
      let card = this.cardMap.get(uid2);
      if (card.state != 0) {
        return;
      }
      for (let i4 = this.cardMap.size - 1; i4 > uid2; i4--) {
        if (this.cardMap.get(i4).state == 0) {
          if (this.checkOverLap(this.cardMap.get(i4), this.cardMap.get(uid2))) {
            return;
          }
        }
      }
      for (let i4 = uid2 - 1; i4 > 0; i4--) {
        if (this.cardMap.get(i4).state == 0) {
          if (this.checkOverLap(this.cardMap.get(i4), this.cardMap.get(uid2))) {
            this.cardMap.get(i4).upBlockNum -= 1;
            if (this.cardMap.get(i4).upBlockNum == 0) {
              this.cardNodeMap.get(i4).gray = false;
            }
          }
        }
      }
      this.onMoveTouchCard(uid2);
    }
    onMoveTouchCard(uid2) {
      this.curSlotNum++;
      this.playerOpCards.push(uid2);
      if (this.curSlotNum > this.gameConfig.slotNum) {
        this.onPopResult(0 /* DEFEAT */, this.score.toString());
        return;
      }
      this.cardMap.get(uid2).state = 1;
      this.cardNodeMap.get(uid2).zOrder = 999;
      const cPoint = new Laya.Point(this.cardNodeMap.get(uid2).x, this.cardNodeMap.get(uid2).y);
      let movePoint = new Laya.Point(0, 0);
      this.slot_bg.localToGlobal(movePoint, false);
      this.view.globalToLocal(movePoint, false);
      movePoint.x += (this.curSlotNum - 1) * (this.gameConfig.cardSize + 8) + 22;
      movePoint.y += 18;
      const sTime = this.calcDistance(cPoint, movePoint) / this.cardMoveSpeed;
      let script = this.cardNodeMap.get(uid2).getComponent(Laya.Script);
      script.touchFlag = false;
      this.slotArea[this.curSlotNum - 1] = uid2;
      Laya.Tween.to(this.cardNodeMap.get(uid2), movePoint, sTime, Laya.Ease.linearIn, Laya.Handler.create(this, this.onMoveCardFinishEvent.bind(this), [uid2]));
    }
    calcDistance(a2, b4) {
      return Math.sqrt(Math.pow(a2.x - b4.x, 2) + Math.pow(a2.y - b4.y, 2));
    }
    onMoveCardFinishEvent(args) {
      const uid2 = args;
      let script = this.cardNodeMap.get(uid2).getComponent(Laya.Script);
      script.touchFlag = true;
    }
    onMoveSlotCardFinishEvent(args) {
      const uid2 = args;
      let script = this.cardNodeMap.get(uid2).getComponent(Laya.Script);
      script.touchFlag = true;
    }
    onTouchSlotCardEvent(uid2) {
      if (!this.cardNodeMap.has(uid2)) {
        return;
      }
      let flag = true;
      for (let element of this.cardMap) {
        if (element[1].state == 0 /* Normal */) {
          flag = false;
          break;
        }
      }
      if (flag && this.cardNodeMap.size < this.gameConfig.composeNumMax) {
        let tempMap = /* @__PURE__ */ new Set();
        flag = true;
        for (let element of this.cardNodeMap) {
          const type2 = this.cardMap.get(element[0]).type;
          if (tempMap.has(type2)) {
            flag = false;
            break;
          } else {
            tempMap.add(type2);
          }
        }
        if (flag) {
          this.onPopResult(0 /* DEFEAT */, this.score.toString());
        }
      }
      let newSlot = [];
      let n4 = 0;
      const type = this.cardMap.get(uid2).type;
      let removeArray = [];
      if (this.gameConfig.removeRule == 0 /* CONTINUE */) {
        let p_index = 0;
        for (let i4 = 0; i4 < this.slotArea.length; i4++) {
          if (this.slotArea[i4] == uid2) {
            p_index = i4;
            break;
          }
        }
        for (let i4 = p_index; i4 < this.slotArea.length; i4++) {
          if (this.slotArea[i4] == -1) {
            break;
          }
          if (this.cardMap.get(this.slotArea[i4]).type == type) {
            removeArray.push(i4);
            n4++;
            if (n4 >= this.gameConfig.composeNumMax) {
              break;
            }
          } else {
            break;
          }
        }
        if (n4 < this.gameConfig.composeNumMax) {
          for (let i4 = p_index - 1; i4 >= 0; i4--) {
            if (this.slotArea[i4] == -1) {
              break;
            }
            if (this.cardMap.get(this.slotArea[i4]).type == type) {
              removeArray.push(i4);
              n4++;
              if (n4 >= this.gameConfig.composeNumMax) {
                break;
              }
            } else {
              break;
            }
          }
        }
        if (n4 < this.gameConfig.composeNumMin) {
          return;
        }
        this.curSlotNum -= n4;
        for (let index2 = 0; index2 < removeArray.length; index2++) {
          const id3 = this.slotArea[removeArray[index2]];
          this.cardNodeMap.get(id3).removeSelf();
          this.cardNodeMap.delete(id3);
          this.cardMap.get(id3).state = 2;
          this.slotArea[removeArray[index2]] = -1;
        }
        for (let index2 = 0; index2 < this.slotArea.length; index2++) {
          const element = this.slotArea[index2];
          if (element != -1) {
            newSlot.push(element);
          }
        }
        const dC = this.slotArea.length - this.curSlotNum;
        for (let index2 = 0; index2 < dC; index2++) {
          newSlot.push(-1);
        }
      } else if (this.gameConfig.removeRule == 1 /* DISCONTINUE */) {
        for (let i4 = 0; i4 < this.slotArea.length; i4++) {
          const id3 = this.slotArea[i4];
          if (id3 == -1) {
            break;
          }
          if (this.cardMap.get(id3).type == type) {
            removeArray.push(i4);
            n4++;
            if (n4 >= this.gameConfig.composeNumMax) {
              break;
            }
          }
        }
        if (n4 < this.gameConfig.composeNumMin) {
          return;
        }
        this.curSlotNum -= n4;
        for (let index2 = 0; index2 < removeArray.length; index2++) {
          const id3 = this.slotArea[removeArray[index2]];
          this.cardNodeMap.get(id3).removeSelf();
          this.cardNodeMap.delete(id3);
          this.cardMap.get(id3).state = 2;
          this.slotArea[removeArray[index2]] = -1;
        }
        for (let index2 = 0; index2 < this.slotArea.length; index2++) {
          const element = this.slotArea[index2];
          if (element != -1) {
            newSlot.push(element);
          }
        }
        const dC = this.slotArea.length - this.curSlotNum;
        for (let index2 = 0; index2 < dC; index2++) {
          newSlot.push(-1);
        }
      }
      this.playerOpCards.push(uid2);
      this.score += Math.pow(2, n4 - this.gameConfig.composeNumMin);
      this.score_text.text = this.score.toString();
      this.slotArea = newSlot;
      for (let i4 = 0; i4 < this.slotArea.length; i4++) {
        const index2 = this.slotArea[i4];
        if (index2 == -1 && !this.cardNodeMap.has(index2)) {
          continue;
        }
        const cPoint = new Laya.Point(this.cardNodeMap.get(index2).x, this.cardNodeMap.get(index2).y);
        let movePoint = new Laya.Point(0, 0);
        this.slot_bg.localToGlobal(movePoint, false);
        this.view.globalToLocal(movePoint, false);
        movePoint.x += i4 * (this.gameConfig.cardSize + 8) + 22;
        movePoint.y += 18;
        const sTime = this.calcDistance(cPoint, movePoint) / this.slotCardMoveSpeed;
        let script = this.cardNodeMap.get(index2).getComponent(Laya.Script);
        script.touchFlag = false;
        Laya.Tween.to(this.cardNodeMap.get(index2), movePoint, sTime, Laya.Ease.linearIn, Laya.Handler.create(this, this.onMoveSlotCardFinishEvent.bind(this), [index2]));
      }
      if (this.cardNodeMap.size == 0) {
        this.onPopResult(1 /* VICTORY */, this.score.toString());
        return;
      }
    }
    onInitGame(gameConfig) {
      this.gameConfig = gameConfig;
      for (let node of this.cardNodeMap) {
        node[1].removeSelf();
      }
      this.cardNodeMap.clear();
      this.cardMap.clear();
      this.curSlotNum = 0;
      this.slotArea = new Array(gameConfig.slotNum).fill(-1);
      this.score_text.text = this.score.toString();
      this.playerOpCards = [];
      const blockNumUnit = gameConfig.composeNumMax * gameConfig.cardRatio * gameConfig.typeNum;
      const seed = 1e3;
      this.randMgr = new RandomMgr();
      this.randMgr.init(seed);
      let AllBlockArray = Array();
      let typeArray = Array();
      this.getRandomTypeArray(typeArray);
      const viewMax = 2 * (gameConfig.viewSize - 1);
      const typeNum = gameConfig.typeNum;
      for (let i4 = 0; i4 < blockNumUnit; ++i4) {
        let rx = this.randMgr.randomNum(0, viewMax) * gameConfig.cardSize / 2;
        let ry = this.randMgr.randomNum(0, viewMax) * gameConfig.cardSize / 2;
        const newBlock = {
          id: i4 + 1,
          x: rx,
          y: ry,
          state: 0,
          type: typeArray[i4 % typeNum],
          upBlockNum: 0
        };
        AllBlockArray.push(newBlock);
      }
      this.shuffleBlocks(AllBlockArray);
      this.initCard(AllBlockArray);
      for (let index2 = 0; index2 < AllBlockArray.length; index2++) {
        const element = AllBlockArray[index2];
        this.cardMap.set(element.id, element);
      }
      this.gameStart();
    }
    getRandomTypeArray(typeArray) {
      const totalNum = this.gameConfig.totalNum;
      const typeNum = this.gameConfig.typeNum;
      let totalArray = Array();
      for (let i4 = 0; i4 < totalNum; i4++) {
        totalArray.push(i4);
      }
      for (let i4 = 0; i4 < typeNum; i4++) {
        let j3 = this.randMgr.randomNum(0, totalNum - i4 - 1);
        typeArray[i4] = totalArray[j3];
        totalArray[j3] = totalArray[totalNum - i4 - 1];
      }
    }
    shuffleBlocks(blocks) {
      const length = blocks.length;
      let j3;
      for (let i4 = 1; i4 < length; i4++) {
        j3 = this.randMgr.randomNum(0, i4);
        blocks[i4].type = blocks[i4].type ^ blocks[j3].type;
        blocks[j3].type = blocks[i4].type ^ blocks[j3].type;
        blocks[i4].type = blocks[i4].type ^ blocks[j3].type;
      }
    }
    initCard(blockInfo) {
      for (let i4 = 0; i4 < blockInfo.length; i4++) {
        const info = blockInfo[i4];
        let ct2 = this.res.create();
        let script = ct2.getComponent(Laya.Script);
        script.uid = info.id;
        let res = Laya.loader.getRes(`atlas/letter/letter_${info.type + 1}.png`);
        script.SetAlphabet(res);
        ct2.x = this.view.width / 4;
        ct2.y = this.view.height / 4;
        ct2.zOrder = info.id;
        for (let j3 = blockInfo.length - 1; j3 > i4; j3--) {
          if (this.checkOverLap(blockInfo[j3], info)) {
            blockInfo[i4].upBlockNum++;
            ct2.gray = true;
          }
        }
        this.view.addChild(ct2);
        this.cardNodeMap.set(info.id, ct2);
      }
    }
    gameStart() {
      console.log("-----");
      const basePoint = new Laya.Point(0, 0);
      for (let element of this.cardMap) {
        const info = element[1];
        const node = this.cardNodeMap.get(info.id);
        let movePoint = new Laya.Point(info.x, info.y);
        const sTime = this.calcDistance(basePoint, movePoint) / this.slotCardMoveSpeed;
        let script = node.getComponent(Laya.Script);
        script.touchFlag = false;
        Laya.Tween.to(node, movePoint, sTime, Laya.Ease.linearIn, Laya.Handler.create(this, this.onMoveSlotCardFinishEvent.bind(this), [info.id]));
      }
    }
    genLevelBlockPos = (curBlocks, nextBlocks, minX, minY, maxX, maxY) => {
      for (let i4 = 0; i4 < nextBlocks.length; i4++) {
        const block = nextBlocks[i4];
        block.x = this.randMgr.randomNum(minX, maxX);
        block.y = this.randMgr.randomNum(minY, maxY);
        for (let j3 = 0; j3 < curBlocks.length; j3++) {
          const element = curBlocks[j3];
          if (this.checkOverLap(block, element)) {
          }
        }
        curBlocks.push(block);
      }
    };
    checkOverLap(a2, b4) {
      if (b4.y + this.gameConfig.cardSize < a2.y || b4.y > a2.y + this.gameConfig.cardSize || b4.x + this.gameConfig.cardSize < a2.x || b4.x > a2.x + this.gameConfig.cardSize) {
        return false;
      }
      return true;
    }
    genLevelRelation = (gameConfig, block) => {
    };
    onPopDialog(message) {
      Laya.Scene.open("resources/prefab/P_dialog.lh", false, { "text": message });
    }
    async onPopResult(type, message) {
      console.log(this.playerOpCards);
      const ret = true;
      if (ret) {
        if (type == 0 /* DEFEAT */) {
          Laya.Scene.open("resources/prefab/P_defeat.lh", false, { "text": message, "type": type });
        } else {
          Laya.Scene.open("resources/prefab/P_victory.lh", false, { "text": message, "type": type });
        }
      } else {
        console.log("\u9A8C\u8BC1\u5931\u8D25\uFF01");
      }
    }
  };
  Game = __decorateClass([
    regClass5("bdf5ca8f-7e4d-42e8-8ecc-77639bf319f4")
  ], Game);

  // node_modules/mobx/dist/mobx.esm.js
  var niceErrors = {
    0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
    1: function _(annotationType, key) {
      return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
    },
    /*
    2(prop) {
        return `invalid decorator for '${prop.toString()}'`
    },
    3(prop) {
        return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
    },
    4(prop) {
        return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
    },
    */
    5: "'keys()' can only be used on observable objects, arrays, sets and maps",
    6: "'values()' can only be used on observable objects, arrays, sets and maps",
    7: "'entries()' can only be used on observable objects, arrays and maps",
    8: "'set()' can only be used on observable objects, arrays and maps",
    9: "'remove()' can only be used on observable objects, arrays and maps",
    10: "'has()' can only be used on observable objects, arrays and maps",
    11: "'get()' can only be used on observable objects, arrays and maps",
    12: "Invalid annotation",
    13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
    14: "Intercept handlers should return nothing or a change object",
    15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
    16: "Modification exception: the internal structure of an observable array was changed.",
    17: function _2(index2, length) {
      return "[mobx.array] Index out of bounds, " + index2 + " is larger than " + length;
    },
    18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
    19: function _3(other) {
      return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
    },
    20: function _4(other) {
      return "Cannot initialize map from " + other;
    },
    21: function _5(dataStructure) {
      return "Cannot convert to map from '" + dataStructure + "'";
    },
    22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
    23: "It is not possible to get index atoms from arrays",
    24: function _6(thing) {
      return "Cannot obtain administration from " + thing;
    },
    25: function _7(property7, name) {
      return "the entry '" + property7 + "' does not exist in the observable map '" + name + "'";
    },
    26: "please specify a property",
    27: function _8(property7, name) {
      return "no observable property '" + property7.toString() + "' found on the observable object '" + name + "'";
    },
    28: function _9(thing) {
      return "Cannot obtain atom from " + thing;
    },
    29: "Expecting some object",
    30: "invalid action stack. did you forget to finish an action?",
    31: "missing option for computed: get",
    32: function _10(name, derivation) {
      return "Cycle detected in computation " + name + ": " + derivation;
    },
    33: function _11(name) {
      return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
    },
    34: function _12(name) {
      return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
    },
    35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
    36: "isolateGlobalState should be called before MobX is running any reactions",
    37: function _13(method) {
      return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
    },
    38: "'ownKeys()' can only be used on observable objects",
    39: "'defineProperty()' can only be used on observable objects"
  };
  var errors = true ? niceErrors : {};
  function die(error) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (true) {
      var e = typeof error === "string" ? error : errors[error];
      if (typeof e === "function")
        e = e.apply(null, args);
      throw new Error("[MobX] " + e);
    }
    throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
  }
  var mockGlobal = {};
  function getGlobal() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    return mockGlobal;
  }
  var assign = Object.assign;
  var getDescriptor = Object.getOwnPropertyDescriptor;
  var defineProperty = Object.defineProperty;
  var objectPrototype = Object.prototype;
  var EMPTY_ARRAY = [];
  Object.freeze(EMPTY_ARRAY);
  var EMPTY_OBJECT = {};
  Object.freeze(EMPTY_OBJECT);
  var hasProxy = typeof Proxy !== "undefined";
  var plainObjectString = /* @__PURE__ */ Object.toString();
  function assertProxies() {
    if (!hasProxy) {
      die(true ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
    }
  }
  function warnAboutProxyRequirement(msg) {
    if (globalState.verifyProxies) {
      die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
    }
  }
  function getNextId() {
    return ++globalState.mobxGuid;
  }
  function once(func) {
    var invoked = false;
    return function() {
      if (invoked) {
        return;
      }
      invoked = true;
      return func.apply(this, arguments);
    };
  }
  var noop = function noop2() {
  };
  function isFunction(fn) {
    return typeof fn === "function";
  }
  function isStringish(value) {
    var t3 = typeof value;
    switch (t3) {
      case "string":
      case "symbol":
      case "number":
        return true;
    }
    return false;
  }
  function isObject(value) {
    return value !== null && typeof value === "object";
  }
  function isPlainObject(value) {
    if (!isObject(value)) {
      return false;
    }
    var proto2 = Object.getPrototypeOf(value);
    if (proto2 == null) {
      return true;
    }
    var protoConstructor = Object.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
    return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
  }
  function isGenerator(obj) {
    var constructor = obj == null ? void 0 : obj.constructor;
    if (!constructor) {
      return false;
    }
    if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
      return true;
    }
    return false;
  }
  function addHiddenProp(object2, propName, value) {
    defineProperty(object2, propName, {
      enumerable: false,
      writable: true,
      configurable: true,
      value
    });
  }
  function addHiddenFinalProp(object2, propName, value) {
    defineProperty(object2, propName, {
      enumerable: false,
      writable: false,
      configurable: true,
      value
    });
  }
  function createInstanceofPredicate(name, theClass) {
    var propName = "isMobX" + name;
    theClass.prototype[propName] = true;
    return function(x8) {
      return isObject(x8) && x8[propName] === true;
    };
  }
  function isES6Map(thing) {
    return thing instanceof Map;
  }
  function isES6Set(thing) {
    return thing instanceof Set;
  }
  var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
  function getPlainObjectKeys(object2) {
    var keys = Object.keys(object2);
    if (!hasGetOwnPropertySymbols) {
      return keys;
    }
    var symbols = Object.getOwnPropertySymbols(object2);
    if (!symbols.length) {
      return keys;
    }
    return [].concat(keys, symbols.filter(function(s4) {
      return objectPrototype.propertyIsEnumerable.call(object2, s4);
    }));
  }
  var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
  } : (
    /* istanbul ignore next */
    Object.getOwnPropertyNames
  );
  function stringifyKey(key) {
    if (typeof key === "string") {
      return key;
    }
    if (typeof key === "symbol") {
      return key.toString();
    }
    return new String(key).toString();
  }
  function toPrimitive(value) {
    return value === null ? null : typeof value === "object" ? "" + value : value;
  }
  function hasProp(target, prop) {
    return objectPrototype.hasOwnProperty.call(target, prop);
  }
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
    var res = {};
    ownKeys(target).forEach(function(key) {
      res[key] = getDescriptor(target, key);
    });
    return res;
  };
  function _defineProperties(target, props) {
    for (var i4 = 0; i4 < props.length; i4++) {
      var descriptor = props[i4];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o3, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
      o4.__proto__ = p3;
      return o4;
    };
    return _setPrototypeOf(o3, p2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _unsupportedIterableToArray(o3, minLen) {
    if (!o3)
      return;
    if (typeof o3 === "string")
      return _arrayLikeToArray(o3, minLen);
    var n4 = Object.prototype.toString.call(o3).slice(8, -1);
    if (n4 === "Object" && o3.constructor)
      n4 = o3.constructor.name;
    if (n4 === "Map" || n4 === "Set")
      return Array.from(o3);
    if (n4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
      return _arrayLikeToArray(o3, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i4 = 0, arr2 = new Array(len); i4 < len; i4++)
      arr2[i4] = arr[i4];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o3, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
    if (it)
      return (it = it.call(o3)).next.bind(it);
    if (Array.isArray(o3) || (it = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
      if (it)
        o3 = it;
      var i4 = 0;
      return function() {
        if (i4 >= o3.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o3[i4++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
  function createDecoratorAnnotation(annotation) {
    function decorator(target, property7) {
      storeAnnotation(target, property7, annotation);
    }
    return Object.assign(decorator, annotation);
  }
  function storeAnnotation(prototype, key, annotation) {
    if (!hasProp(prototype, storedAnnotationsSymbol)) {
      addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
    }
    if (isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
      var fieldName = prototype.constructor.name + ".prototype." + key.toString();
      die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
    }
    assertNotDecorated(prototype, annotation, key);
    if (!isOverride(annotation)) {
      prototype[storedAnnotationsSymbol][key] = annotation;
    }
  }
  function assertNotDecorated(prototype, annotation, key) {
    if (!isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
      var fieldName = prototype.constructor.name + ".prototype." + key.toString();
      var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
      var requestedAnnotationType = annotation.annotationType_;
      die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overridden by subclass.");
    }
  }
  var $mobx = /* @__PURE__ */ Symbol("mobx administration");
  var Atom = /* @__PURE__ */ function() {
    function Atom2(name_) {
      if (name_ === void 0) {
        name_ = true ? "Atom@" + getNextId() : "Atom";
      }
      this.name_ = void 0;
      this.isPendingUnobservation_ = false;
      this.isBeingObserved_ = false;
      this.observers_ = /* @__PURE__ */ new Set();
      this.diffValue_ = 0;
      this.lastAccessedBy_ = 0;
      this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
      this.onBOL = void 0;
      this.onBUOL = void 0;
      this.name_ = name_;
    }
    var _proto = Atom2.prototype;
    _proto.onBO = function onBO() {
      if (this.onBOL) {
        this.onBOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.onBUO = function onBUO() {
      if (this.onBUOL) {
        this.onBUOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.reportObserved = function reportObserved$1() {
      return reportObserved(this);
    };
    _proto.reportChanged = function reportChanged() {
      startBatch();
      propagateChanged(this);
      globalState.stateVersion = globalState.stateVersion < Number.MAX_SAFE_INTEGER ? globalState.stateVersion + 1 : Number.MIN_SAFE_INTEGER;
      endBatch();
    };
    _proto.toString = function toString3() {
      return this.name_;
    };
    return Atom2;
  }();
  var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
  function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (onBecomeObservedHandler === void 0) {
      onBecomeObservedHandler = noop;
    }
    if (onBecomeUnobservedHandler === void 0) {
      onBecomeUnobservedHandler = noop;
    }
    var atom = new Atom(name);
    if (onBecomeObservedHandler !== noop) {
      onBecomeObserved(atom, onBecomeObservedHandler);
    }
    if (onBecomeUnobservedHandler !== noop) {
      onBecomeUnobserved(atom, onBecomeUnobservedHandler);
    }
    return atom;
  }
  function identityComparer(a2, b4) {
    return a2 === b4;
  }
  function structuralComparer(a2, b4) {
    return deepEqual(a2, b4);
  }
  function shallowComparer(a2, b4) {
    return deepEqual(a2, b4, 1);
  }
  function defaultComparer(a2, b4) {
    if (Object.is) {
      return Object.is(a2, b4);
    }
    return a2 === b4 ? a2 !== 0 || 1 / a2 === 1 / b4 : a2 !== a2 && b4 !== b4;
  }
  var comparer = {
    identity: identityComparer,
    structural: structuralComparer,
    "default": defaultComparer,
    shallow: shallowComparer
  };
  function deepEnhancer(v7, _18, name) {
    if (isObservable(v7)) {
      return v7;
    }
    if (Array.isArray(v7)) {
      return observable.array(v7, {
        name
      });
    }
    if (isPlainObject(v7)) {
      return observable.object(v7, void 0, {
        name
      });
    }
    if (isES6Map(v7)) {
      return observable.map(v7, {
        name
      });
    }
    if (isES6Set(v7)) {
      return observable.set(v7, {
        name
      });
    }
    if (typeof v7 === "function" && !isAction(v7) && !isFlow(v7)) {
      if (isGenerator(v7)) {
        return flow(v7);
      } else {
        return autoAction(name, v7);
      }
    }
    return v7;
  }
  function shallowEnhancer(v7, _18, name) {
    if (v7 === void 0 || v7 === null) {
      return v7;
    }
    if (isObservableObject(v7) || isObservableArray(v7) || isObservableMap(v7) || isObservableSet(v7)) {
      return v7;
    }
    if (Array.isArray(v7)) {
      return observable.array(v7, {
        name,
        deep: false
      });
    }
    if (isPlainObject(v7)) {
      return observable.object(v7, void 0, {
        name,
        deep: false
      });
    }
    if (isES6Map(v7)) {
      return observable.map(v7, {
        name,
        deep: false
      });
    }
    if (isES6Set(v7)) {
      return observable.set(v7, {
        name,
        deep: false
      });
    }
    if (true) {
      die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
    }
  }
  function referenceEnhancer(newValue) {
    return newValue;
  }
  function refStructEnhancer(v7, oldValue) {
    if (isObservable(v7)) {
      die("observable.struct should not be used with observable values");
    }
    if (deepEqual(v7, oldValue)) {
      return oldValue;
    }
    return v7;
  }
  var OVERRIDE = "override";
  function isOverride(annotation) {
    return annotation.annotationType_ === OVERRIDE;
  }
  function createActionAnnotation(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$1,
      extend_: extend_$1
    };
  }
  function make_$1(adm, key, descriptor, source) {
    var _this$options_;
    if ((_this$options_ = this.options_) != null && _this$options_.bound) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
    }
    if (source === adm.target_) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
    }
    if (isAction(descriptor.value)) {
      return 1;
    }
    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
    defineProperty(source, key, actionDescriptor);
    return 2;
  }
  function extend_$1(adm, key, descriptor, proxyTrap) {
    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
    return adm.defineProperty_(key, actionDescriptor, proxyTrap);
  }
  function assertActionDescriptor(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var value = _ref2.value;
    if (!isFunction(value)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
    }
  }
  function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
    var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
    if (safeDescriptors === void 0) {
      safeDescriptors = globalState.safeDescriptors;
    }
    assertActionDescriptor(adm, annotation, key, descriptor);
    var value = descriptor.value;
    if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
      var _adm$proxy_;
      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return {
      value: createAction(
        (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
        value,
        (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
        // https://github.com/mobxjs/mobx/discussions/3140
        (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
      ),
      // Non-configurable for classes
      // prevents accidental field redefinition in subclass
      configurable: safeDescriptors ? adm.isPlainObject_ : true,
      // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
      enumerable: false,
      // Non-obsevable, therefore non-writable
      // Also prevents rewriting in subclass constructor
      writable: safeDescriptors ? false : true
    };
  }
  function createFlowAnnotation(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$2,
      extend_: extend_$2
    };
  }
  function make_$2(adm, key, descriptor, source) {
    var _this$options_;
    if (source === adm.target_) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
    }
    if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
      if (this.extend_(adm, key, descriptor, false) === null) {
        return 0;
      }
    }
    if (isFlow(descriptor.value)) {
      return 1;
    }
    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
    defineProperty(source, key, flowDescriptor);
    return 2;
  }
  function extend_$2(adm, key, descriptor, proxyTrap) {
    var _this$options_2;
    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
    return adm.defineProperty_(key, flowDescriptor, proxyTrap);
  }
  function assertFlowDescriptor(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var value = _ref2.value;
    if (!isFunction(value)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
    }
  }
  function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
    if (safeDescriptors === void 0) {
      safeDescriptors = globalState.safeDescriptors;
    }
    assertFlowDescriptor(adm, annotation, key, descriptor);
    var value = descriptor.value;
    if (!isFlow(value)) {
      value = flow(value);
    }
    if (bound) {
      var _adm$proxy_;
      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
      value.isMobXFlow = true;
    }
    return {
      value,
      // Non-configurable for classes
      // prevents accidental field redefinition in subclass
      configurable: safeDescriptors ? adm.isPlainObject_ : true,
      // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
      enumerable: false,
      // Non-obsevable, therefore non-writable
      // Also prevents rewriting in subclass constructor
      writable: safeDescriptors ? false : true
    };
  }
  function createComputedAnnotation(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$3,
      extend_: extend_$3
    };
  }
  function make_$3(adm, key, descriptor) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  function extend_$3(adm, key, descriptor, proxyTrap) {
    assertComputedDescriptor(adm, this, key, descriptor);
    return adm.defineComputedProperty_(key, _extends({}, this.options_, {
      get: descriptor.get,
      set: descriptor.set
    }), proxyTrap);
  }
  function assertComputedDescriptor(adm, _ref, key, _ref2) {
    var annotationType_ = _ref.annotationType_;
    var get3 = _ref2.get;
    if (!get3) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
    }
  }
  function createObservableAnnotation(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$4,
      extend_: extend_$4
    };
  }
  function make_$4(adm, key, descriptor) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  function extend_$4(adm, key, descriptor, proxyTrap) {
    var _this$options_$enhanc, _this$options_;
    assertObservableDescriptor(adm, this, key, descriptor);
    return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
  }
  function assertObservableDescriptor(adm, _ref, key, descriptor) {
    var annotationType_ = _ref.annotationType_;
    if (!("value" in descriptor)) {
      die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
    }
  }
  var AUTO = "true";
  var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
  function createAutoAnnotation(options) {
    return {
      annotationType_: AUTO,
      options_: options,
      make_: make_$5,
      extend_: extend_$5
    };
  }
  function make_$5(adm, key, descriptor, source) {
    var _this$options_3, _this$options_4;
    if (descriptor.get) {
      return computed.make_(adm, key, descriptor, source);
    }
    if (descriptor.set) {
      var set4 = createAction(key.toString(), descriptor.set);
      if (source === adm.target_) {
        return adm.defineProperty_(key, {
          configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
          set: set4
        }) === null ? 0 : 2;
      }
      defineProperty(source, key, {
        configurable: true,
        set: set4
      });
      return 2;
    }
    if (source !== adm.target_ && typeof descriptor.value === "function") {
      var _this$options_2;
      if (isGenerator(descriptor.value)) {
        var _this$options_;
        var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
        return flowAnnotation2.make_(adm, key, descriptor, source);
      }
      var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
      return actionAnnotation2.make_(adm, key, descriptor, source);
    }
    var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
    if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
      var _adm$proxy_;
      descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return observableAnnotation2.make_(adm, key, descriptor, source);
  }
  function extend_$5(adm, key, descriptor, proxyTrap) {
    var _this$options_5, _this$options_6;
    if (descriptor.get) {
      return computed.extend_(adm, key, descriptor, proxyTrap);
    }
    if (descriptor.set) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: createAction(key.toString(), descriptor.set)
      }, proxyTrap);
    }
    if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
      var _adm$proxy_2;
      descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
    }
    var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
    return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
  }
  var OBSERVABLE = "observable";
  var OBSERVABLE_REF = "observable.ref";
  var OBSERVABLE_SHALLOW = "observable.shallow";
  var OBSERVABLE_STRUCT = "observable.struct";
  var defaultCreateObservableOptions = {
    deep: true,
    name: void 0,
    defaultDecorator: void 0,
    proxy: true
  };
  Object.freeze(defaultCreateObservableOptions);
  function asCreateObservableOptions(thing) {
    return thing || defaultCreateObservableOptions;
  }
  var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
  var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
    enhancer: referenceEnhancer
  });
  var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
    enhancer: shallowEnhancer
  });
  var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
    enhancer: refStructEnhancer
  });
  var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
  function getEnhancerFromOptions(options) {
    return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
  }
  function getAnnotationFromOptions(options) {
    var _options$defaultDecor;
    return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
  }
  function getEnhancerFromAnnotation(annotation) {
    var _annotation$options_$, _annotation$options_;
    return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
  }
  function createObservable(v7, arg2, arg3) {
    if (isStringish(arg2)) {
      storeAnnotation(v7, arg2, observableAnnotation);
      return;
    }
    if (isObservable(v7)) {
      return v7;
    }
    if (isPlainObject(v7)) {
      return observable.object(v7, arg2, arg3);
    }
    if (Array.isArray(v7)) {
      return observable.array(v7, arg2);
    }
    if (isES6Map(v7)) {
      return observable.map(v7, arg2);
    }
    if (isES6Set(v7)) {
      return observable.set(v7, arg2);
    }
    if (typeof v7 === "object" && v7 !== null) {
      return v7;
    }
    return observable.box(v7, arg2);
  }
  assign(createObservable, observableDecoratorAnnotation);
  var observableFactories = {
    box: function box(value, options) {
      var o3 = asCreateObservableOptions(options);
      return new ObservableValue(value, getEnhancerFromOptions(o3), o3.name, true, o3.equals);
    },
    array: function array(initialValues, options) {
      var o3 = asCreateObservableOptions(options);
      return (globalState.useProxies === false || o3.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o3), o3.name);
    },
    map: function map(initialValues, options) {
      var o3 = asCreateObservableOptions(options);
      return new ObservableMap(initialValues, getEnhancerFromOptions(o3), o3.name);
    },
    set: function set(initialValues, options) {
      var o3 = asCreateObservableOptions(options);
      return new ObservableSet(initialValues, getEnhancerFromOptions(o3), o3.name);
    },
    object: function object(props, decorators, options) {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    },
    ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
    shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
    deep: observableDecoratorAnnotation,
    struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
  };
  var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
  var COMPUTED = "computed";
  var COMPUTED_STRUCT = "computed.struct";
  var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
  var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
    equals: comparer.structural
  });
  var computed = function computed2(arg1, arg2) {
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, computedAnnotation);
    }
    if (isPlainObject(arg1)) {
      return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
    }
    if (true) {
      if (!isFunction(arg1)) {
        die("First argument to `computed` should be an expression.");
      }
      if (isFunction(arg2)) {
        die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
      }
    }
    var opts = isPlainObject(arg2) ? arg2 : {};
    opts.get = arg1;
    opts.name || (opts.name = arg1.name || "");
    return new ComputedValue(opts);
  };
  Object.assign(computed, computedAnnotation);
  computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
  var _getDescriptor$config;
  var _getDescriptor;
  var currentActionId = 0;
  var nextActionId = 1;
  var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
  }, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
  var tmpNameDescriptor = {
    value: "action",
    configurable: true,
    writable: false,
    enumerable: false
  };
  function createAction(actionName, fn, autoAction2, ref) {
    if (autoAction2 === void 0) {
      autoAction2 = false;
    }
    if (true) {
      if (!isFunction(fn)) {
        die("`action` can only be invoked on functions");
      }
      if (typeof actionName !== "string" || !actionName) {
        die("actions should have valid names, got: '" + actionName + "'");
      }
    }
    function res() {
      return executeAction(actionName, autoAction2, fn, ref || this, arguments);
    }
    res.isMobxAction = true;
    if (isFunctionNameConfigurable) {
      tmpNameDescriptor.value = actionName;
      defineProperty(res, "name", tmpNameDescriptor);
    }
    return res;
  }
  function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
    var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
    try {
      return fn.apply(scope, args);
    } catch (err) {
      runInfo.error_ = err;
      throw err;
    } finally {
      _endAction(runInfo);
    }
  }
  function _startAction(actionName, canRunAsDerivation, scope, args) {
    var notifySpy_ = isSpyEnabled() && !!actionName;
    var startTime_ = 0;
    if (notifySpy_) {
      startTime_ = Date.now();
      var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
      spyReportStart({
        type: ACTION,
        name: actionName,
        object: scope,
        arguments: flattenedArgs
      });
    }
    var prevDerivation_ = globalState.trackingDerivation;
    var runAsAction = !canRunAsDerivation || !prevDerivation_;
    startBatch();
    var prevAllowStateChanges_ = globalState.allowStateChanges;
    if (runAsAction) {
      untrackedStart();
      prevAllowStateChanges_ = allowStateChangesStart(true);
    }
    var prevAllowStateReads_ = allowStateReadsStart(true);
    var runInfo = {
      runAsAction_: runAsAction,
      prevDerivation_,
      prevAllowStateChanges_,
      prevAllowStateReads_,
      notifySpy_,
      startTime_,
      actionId_: nextActionId++,
      parentActionId_: currentActionId
    };
    currentActionId = runInfo.actionId_;
    return runInfo;
  }
  function _endAction(runInfo) {
    if (currentActionId !== runInfo.actionId_) {
      die(30);
    }
    currentActionId = runInfo.parentActionId_;
    if (runInfo.error_ !== void 0) {
      globalState.suppressReactionErrors = true;
    }
    allowStateChangesEnd(runInfo.prevAllowStateChanges_);
    allowStateReadsEnd(runInfo.prevAllowStateReads_);
    endBatch();
    if (runInfo.runAsAction_) {
      untrackedEnd(runInfo.prevDerivation_);
    }
    if (runInfo.notifySpy_) {
      spyReportEnd({
        time: Date.now() - runInfo.startTime_
      });
    }
    globalState.suppressReactionErrors = false;
  }
  function allowStateChanges(allowStateChanges2, func) {
    var prev = allowStateChangesStart(allowStateChanges2);
    try {
      return func();
    } finally {
      allowStateChangesEnd(prev);
    }
  }
  function allowStateChangesStart(allowStateChanges2) {
    var prev = globalState.allowStateChanges;
    globalState.allowStateChanges = allowStateChanges2;
    return prev;
  }
  function allowStateChangesEnd(prev) {
    globalState.allowStateChanges = prev;
  }
  var _Symbol$toPrimitive;
  var CREATE = "create";
  _Symbol$toPrimitive = Symbol.toPrimitive;
  var ObservableValue = /* @__PURE__ */ function(_Atom) {
    _inheritsLoose(ObservableValue2, _Atom);
    function ObservableValue2(value, enhancer, name_, notifySpy, equals2) {
      var _this;
      if (name_ === void 0) {
        name_ = true ? "ObservableValue@" + getNextId() : "ObservableValue";
      }
      if (notifySpy === void 0) {
        notifySpy = true;
      }
      if (equals2 === void 0) {
        equals2 = comparer["default"];
      }
      _this = _Atom.call(this, name_) || this;
      _this.enhancer = void 0;
      _this.name_ = void 0;
      _this.equals = void 0;
      _this.hasUnreportedChange_ = false;
      _this.interceptors_ = void 0;
      _this.changeListeners_ = void 0;
      _this.value_ = void 0;
      _this.dehancer = void 0;
      _this.enhancer = enhancer;
      _this.name_ = name_;
      _this.equals = equals2;
      _this.value_ = enhancer(value, void 0, name_);
      if (notifySpy && isSpyEnabled()) {
        spyReport({
          type: CREATE,
          object: _assertThisInitialized(_this),
          observableKind: "value",
          debugObjectName: _this.name_,
          newValue: "" + _this.value_
        });
      }
      return _this;
    }
    var _proto = ObservableValue2.prototype;
    _proto.dehanceValue = function dehanceValue(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.set = function set4(newValue) {
      var oldValue = this.value_;
      newValue = this.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        if (notifySpy) {
          spyReportStart({
            type: UPDATE,
            object: this,
            observableKind: "value",
            debugObjectName: this.name_,
            newValue,
            oldValue
          });
        }
        this.setNewValue_(newValue);
        if (notifySpy) {
          spyReportEnd();
        }
      }
    };
    _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
      checkIfStateModificationsAreAllowed(this);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this,
          type: UPDATE,
          newValue
        });
        if (!change) {
          return globalState.UNCHANGED;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer(newValue, this.value_, this.name_);
      return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
    };
    _proto.setNewValue_ = function setNewValue_(newValue) {
      var oldValue = this.value_;
      this.value_ = newValue;
      this.reportChanged();
      if (hasListeners(this)) {
        notifyListeners(this, {
          type: UPDATE,
          object: this,
          newValue,
          oldValue
        });
      }
    };
    _proto.get = function get3() {
      this.reportObserved();
      return this.dehanceValue(this.value_);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately) {
        listener({
          observableKind: "value",
          debugObjectName: this.name_,
          object: this,
          type: UPDATE,
          newValue: this.value_,
          oldValue: void 0
        });
      }
      return registerListener(this, listener);
    };
    _proto.raw = function raw() {
      return this.value_;
    };
    _proto.toJSON = function toJSON2() {
      return this.get();
    };
    _proto.toString = function toString3() {
      return this.name_ + "[" + this.value_ + "]";
    };
    _proto.valueOf = function valueOf() {
      return toPrimitive(this.get());
    };
    _proto[_Symbol$toPrimitive] = function() {
      return this.valueOf();
    };
    return ObservableValue2;
  }(Atom);
  var isObservableValue = /* @__PURE__ */ createInstanceofPredicate("ObservableValue", ObservableValue);
  var _Symbol$toPrimitive$1;
  _Symbol$toPrimitive$1 = Symbol.toPrimitive;
  var ComputedValue = /* @__PURE__ */ function() {
    function ComputedValue2(options) {
      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      this.observing_ = [];
      this.newObserving_ = null;
      this.isBeingObserved_ = false;
      this.isPendingUnobservation_ = false;
      this.observers_ = /* @__PURE__ */ new Set();
      this.diffValue_ = 0;
      this.runId_ = 0;
      this.lastAccessedBy_ = 0;
      this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      this.unboundDepsCount_ = 0;
      this.value_ = new CaughtException(null);
      this.name_ = void 0;
      this.triggeredBy_ = void 0;
      this.isComputing_ = false;
      this.isRunningSetter_ = false;
      this.derivation = void 0;
      this.setter_ = void 0;
      this.isTracing_ = TraceMode.NONE;
      this.scope_ = void 0;
      this.equals_ = void 0;
      this.requiresReaction_ = void 0;
      this.keepAlive_ = void 0;
      this.onBOL = void 0;
      this.onBUOL = void 0;
      if (!options.get) {
        die(31);
      }
      this.derivation = options.get;
      this.name_ = options.name || (true ? "ComputedValue@" + getNextId() : "ComputedValue");
      if (options.set) {
        this.setter_ = createAction(true ? this.name_ + "-setter" : "ComputedValue-setter", options.set);
      }
      this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
      this.scope_ = options.context;
      this.requiresReaction_ = options.requiresReaction;
      this.keepAlive_ = !!options.keepAlive;
    }
    var _proto = ComputedValue2.prototype;
    _proto.onBecomeStale_ = function onBecomeStale_() {
      propagateMaybeChanged(this);
    };
    _proto.onBO = function onBO() {
      if (this.onBOL) {
        this.onBOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.onBUO = function onBUO() {
      if (this.onBUOL) {
        this.onBUOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.get = function get3() {
      if (this.isComputing_) {
        die(32, this.name_, this.derivation);
      }
      if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
      this.observers_.size === 0 && !this.keepAlive_) {
        if (shouldCompute(this)) {
          this.warnAboutUntrackedRead_();
          startBatch();
          this.value_ = this.computeValue_(false);
          endBatch();
        }
      } else {
        reportObserved(this);
        if (shouldCompute(this)) {
          var prevTrackingContext = globalState.trackingContext;
          if (this.keepAlive_ && !prevTrackingContext) {
            globalState.trackingContext = this;
          }
          if (this.trackAndCompute()) {
            propagateChangeConfirmed(this);
          }
          globalState.trackingContext = prevTrackingContext;
        }
      }
      var result = this.value_;
      if (isCaughtException(result)) {
        throw result.cause;
      }
      return result;
    };
    _proto.set = function set4(value) {
      if (this.setter_) {
        if (this.isRunningSetter_) {
          die(33, this.name_);
        }
        this.isRunningSetter_ = true;
        try {
          this.setter_.call(this.scope_, value);
        } finally {
          this.isRunningSetter_ = false;
        }
      } else {
        die(34, this.name_);
      }
    };
    _proto.trackAndCompute = function trackAndCompute() {
      var oldValue = this.value_;
      var wasSuspended = (
        /* see #1208 */
        this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
      );
      var newValue = this.computeValue_(true);
      var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
      if (changed) {
        this.value_ = newValue;
        if (isSpyEnabled()) {
          spyReport({
            observableKind: "computed",
            debugObjectName: this.name_,
            object: this.scope_,
            type: "update",
            oldValue,
            newValue
          });
        }
      }
      return changed;
    };
    _proto.computeValue_ = function computeValue_(track) {
      this.isComputing_ = true;
      var prev = allowStateChangesStart(false);
      var res;
      if (track) {
        res = trackDerivedFunction(this, this.derivation, this.scope_);
      } else {
        if (globalState.disableErrorBoundaries === true) {
          res = this.derivation.call(this.scope_);
        } else {
          try {
            res = this.derivation.call(this.scope_);
          } catch (e) {
            res = new CaughtException(e);
          }
        }
      }
      allowStateChangesEnd(prev);
      this.isComputing_ = false;
      return res;
    };
    _proto.suspend_ = function suspend_() {
      if (!this.keepAlive_) {
        clearObserving(this);
        this.value_ = void 0;
        if (this.isTracing_ !== TraceMode.NONE) {
          console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
        }
      }
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      var _this = this;
      var firstTime = true;
      var prevValue = void 0;
      return autorun(function() {
        var newValue = _this.get();
        if (!firstTime || fireImmediately) {
          var prevU = untrackedStart();
          listener({
            observableKind: "computed",
            debugObjectName: _this.name_,
            type: UPDATE,
            object: _this,
            newValue,
            oldValue: prevValue
          });
          untrackedEnd(prevU);
        }
        firstTime = false;
        prevValue = newValue;
      });
    };
    _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
      if (false) {
        return;
      }
      if (this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
      }
      if (typeof this.requiresReaction_ === "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) {
        console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
      }
    };
    _proto.toString = function toString3() {
      return this.name_ + "[" + this.derivation.toString() + "]";
    };
    _proto.valueOf = function valueOf() {
      return toPrimitive(this.get());
    };
    _proto[_Symbol$toPrimitive$1] = function() {
      return this.valueOf();
    };
    return ComputedValue2;
  }();
  var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
  var IDerivationState_;
  (function(IDerivationState_2) {
    IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
    IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
    IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
    IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
  })(IDerivationState_ || (IDerivationState_ = {}));
  var TraceMode;
  (function(TraceMode2) {
    TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
    TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
    TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
  })(TraceMode || (TraceMode = {}));
  var CaughtException = function CaughtException2(cause) {
    this.cause = void 0;
    this.cause = cause;
  };
  function isCaughtException(e) {
    return e instanceof CaughtException;
  }
  function shouldCompute(derivation) {
    switch (derivation.dependenciesState_) {
      case IDerivationState_.UP_TO_DATE_:
        return false;
      case IDerivationState_.NOT_TRACKING_:
      case IDerivationState_.STALE_:
        return true;
      case IDerivationState_.POSSIBLY_STALE_: {
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart();
        var obs = derivation.observing_, l4 = obs.length;
        for (var i4 = 0; i4 < l4; i4++) {
          var obj = obs[i4];
          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            }
            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }
        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
    }
  }
  function checkIfStateModificationsAreAllowed(atom) {
    if (false) {
      return;
    }
    var hasObservers = atom.observers_.size > 0;
    if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) {
      console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
    }
  }
  function checkIfStateReadsAreAllowed(observable3) {
    if (!globalState.allowStateReads && globalState.observableRequiresReaction) {
      console.warn("[mobx] Observable '" + observable3.name_ + "' being read outside a reactive context.");
    }
  }
  function trackDerivedFunction(derivation, f5, context2) {
    var prevAllowStateReads = allowStateReadsStart(true);
    changeDependenciesStateTo0(derivation);
    derivation.newObserving_ = new Array(derivation.observing_.length + 100);
    derivation.unboundDepsCount_ = 0;
    derivation.runId_ = ++globalState.runId;
    var prevTracking = globalState.trackingDerivation;
    globalState.trackingDerivation = derivation;
    globalState.inBatch++;
    var result;
    if (globalState.disableErrorBoundaries === true) {
      result = f5.call(context2);
    } else {
      try {
        result = f5.call(context2);
      } catch (e) {
        result = new CaughtException(e);
      }
    }
    globalState.inBatch--;
    globalState.trackingDerivation = prevTracking;
    bindDependencies(derivation);
    warnAboutDerivationWithoutDependencies(derivation);
    allowStateReadsEnd(prevAllowStateReads);
    return result;
  }
  function warnAboutDerivationWithoutDependencies(derivation) {
    if (false) {
      return;
    }
    if (derivation.observing_.length !== 0) {
      return;
    }
    if (typeof derivation.requiresObservable_ === "boolean" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {
      console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
    }
  }
  function bindDependencies(derivation) {
    var prevObserving = derivation.observing_;
    var observing = derivation.observing_ = derivation.newObserving_;
    var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
    var i0 = 0, l4 = derivation.unboundDepsCount_;
    for (var i4 = 0; i4 < l4; i4++) {
      var dep = observing[i4];
      if (dep.diffValue_ === 0) {
        dep.diffValue_ = 1;
        if (i0 !== i4) {
          observing[i0] = dep;
        }
        i0++;
      }
      if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
        lowestNewObservingDerivationState = dep.dependenciesState_;
      }
    }
    observing.length = i0;
    derivation.newObserving_ = null;
    l4 = prevObserving.length;
    while (l4--) {
      var _dep = prevObserving[l4];
      if (_dep.diffValue_ === 0) {
        removeObserver(_dep, derivation);
      }
      _dep.diffValue_ = 0;
    }
    while (i0--) {
      var _dep2 = observing[i0];
      if (_dep2.diffValue_ === 1) {
        _dep2.diffValue_ = 0;
        addObserver(_dep2, derivation);
      }
    }
    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
      derivation.dependenciesState_ = lowestNewObservingDerivationState;
      derivation.onBecomeStale_();
    }
  }
  function clearObserving(derivation) {
    var obs = derivation.observing_;
    derivation.observing_ = [];
    var i4 = obs.length;
    while (i4--) {
      removeObserver(obs[i4], derivation);
    }
    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
  }
  function untracked(action2) {
    var prev = untrackedStart();
    try {
      return action2();
    } finally {
      untrackedEnd(prev);
    }
  }
  function untrackedStart() {
    var prev = globalState.trackingDerivation;
    globalState.trackingDerivation = null;
    return prev;
  }
  function untrackedEnd(prev) {
    globalState.trackingDerivation = prev;
  }
  function allowStateReadsStart(allowStateReads) {
    var prev = globalState.allowStateReads;
    globalState.allowStateReads = allowStateReads;
    return prev;
  }
  function allowStateReadsEnd(prev) {
    globalState.allowStateReads = prev;
  }
  function changeDependenciesStateTo0(derivation) {
    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      return;
    }
    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
    var obs = derivation.observing_;
    var i4 = obs.length;
    while (i4--) {
      obs[i4].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  }
  var MobXGlobals = function MobXGlobals2() {
    this.version = 6;
    this.UNCHANGED = {};
    this.trackingDerivation = null;
    this.trackingContext = null;
    this.runId = 0;
    this.mobxGuid = 0;
    this.inBatch = 0;
    this.pendingUnobservations = [];
    this.pendingReactions = [];
    this.isRunningReactions = false;
    this.allowStateChanges = false;
    this.allowStateReads = true;
    this.enforceActions = true;
    this.spyListeners = [];
    this.globalReactionErrorHandlers = [];
    this.computedRequiresReaction = false;
    this.reactionRequiresObservable = false;
    this.observableRequiresReaction = false;
    this.disableErrorBoundaries = false;
    this.suppressReactionErrors = false;
    this.useProxies = true;
    this.verifyProxies = false;
    this.safeDescriptors = true;
    this.stateVersion = Number.MIN_SAFE_INTEGER;
  };
  var canMergeGlobalState = true;
  var isolateCalled = false;
  var globalState = /* @__PURE__ */ function() {
    var global2 = /* @__PURE__ */ getGlobal();
    if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
      canMergeGlobalState = false;
    }
    if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
      canMergeGlobalState = false;
    }
    if (!canMergeGlobalState) {
      setTimeout(function() {
        if (!isolateCalled) {
          die(35);
        }
      }, 1);
      return new MobXGlobals();
    } else if (global2.__mobxGlobals) {
      global2.__mobxInstanceCount += 1;
      if (!global2.__mobxGlobals.UNCHANGED) {
        global2.__mobxGlobals.UNCHANGED = {};
      }
      return global2.__mobxGlobals;
    } else {
      global2.__mobxInstanceCount = 1;
      return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
    }
  }();
  function addObserver(observable3, node) {
    observable3.observers_.add(node);
    if (observable3.lowestObserverState_ > node.dependenciesState_) {
      observable3.lowestObserverState_ = node.dependenciesState_;
    }
  }
  function removeObserver(observable3, node) {
    observable3.observers_["delete"](node);
    if (observable3.observers_.size === 0) {
      queueForUnobservation(observable3);
    }
  }
  function queueForUnobservation(observable3) {
    if (observable3.isPendingUnobservation_ === false) {
      observable3.isPendingUnobservation_ = true;
      globalState.pendingUnobservations.push(observable3);
    }
  }
  function startBatch() {
    globalState.inBatch++;
  }
  function endBatch() {
    if (--globalState.inBatch === 0) {
      runReactions();
      var list = globalState.pendingUnobservations;
      for (var i4 = 0; i4 < list.length; i4++) {
        var observable3 = list[i4];
        observable3.isPendingUnobservation_ = false;
        if (observable3.observers_.size === 0) {
          if (observable3.isBeingObserved_) {
            observable3.isBeingObserved_ = false;
            observable3.onBUO();
          }
          if (observable3 instanceof ComputedValue) {
            observable3.suspend_();
          }
        }
      }
      globalState.pendingUnobservations = [];
    }
  }
  function reportObserved(observable3) {
    checkIfStateReadsAreAllowed(observable3);
    var derivation = globalState.trackingDerivation;
    if (derivation !== null) {
      if (derivation.runId_ !== observable3.lastAccessedBy_) {
        observable3.lastAccessedBy_ = derivation.runId_;
        derivation.newObserving_[derivation.unboundDepsCount_++] = observable3;
        if (!observable3.isBeingObserved_ && globalState.trackingContext) {
          observable3.isBeingObserved_ = true;
          observable3.onBO();
        }
      }
      return observable3.isBeingObserved_;
    } else if (observable3.observers_.size === 0 && globalState.inBatch > 0) {
      queueForUnobservation(observable3);
    }
    return false;
  }
  function propagateChanged(observable3) {
    if (observable3.lowestObserverState_ === IDerivationState_.STALE_) {
      return;
    }
    observable3.lowestObserverState_ = IDerivationState_.STALE_;
    observable3.observers_.forEach(function(d6) {
      if (d6.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        if (d6.isTracing_ !== TraceMode.NONE) {
          logTraceInfo(d6, observable3);
        }
        d6.onBecomeStale_();
      }
      d6.dependenciesState_ = IDerivationState_.STALE_;
    });
  }
  function propagateChangeConfirmed(observable3) {
    if (observable3.lowestObserverState_ === IDerivationState_.STALE_) {
      return;
    }
    observable3.lowestObserverState_ = IDerivationState_.STALE_;
    observable3.observers_.forEach(function(d6) {
      if (d6.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
        d6.dependenciesState_ = IDerivationState_.STALE_;
        if (d6.isTracing_ !== TraceMode.NONE) {
          logTraceInfo(d6, observable3);
        }
      } else if (d6.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        observable3.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
    });
  }
  function propagateMaybeChanged(observable3) {
    if (observable3.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
      return;
    }
    observable3.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
    observable3.observers_.forEach(function(d6) {
      if (d6.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        d6.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
        d6.onBecomeStale_();
      }
    });
  }
  function logTraceInfo(derivation, observable3) {
    console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable3.name_ + "'");
    if (derivation.isTracing_ === TraceMode.BREAK) {
      var lines = [];
      printDepTree(getDependencyTree(derivation), lines, 1);
      new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable3.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
    }
  }
  function printDepTree(tree, lines, depth) {
    if (lines.length >= 1e3) {
      lines.push("(and many more)");
      return;
    }
    lines.push("" + "	".repeat(depth - 1) + tree.name);
    if (tree.dependencies) {
      tree.dependencies.forEach(function(child) {
        return printDepTree(child, lines, depth + 1);
      });
    }
  }
  var Reaction = /* @__PURE__ */ function() {
    function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
      if (name_ === void 0) {
        name_ = true ? "Reaction@" + getNextId() : "Reaction";
      }
      this.name_ = void 0;
      this.onInvalidate_ = void 0;
      this.errorHandler_ = void 0;
      this.requiresObservable_ = void 0;
      this.observing_ = [];
      this.newObserving_ = [];
      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      this.diffValue_ = 0;
      this.runId_ = 0;
      this.unboundDepsCount_ = 0;
      this.isDisposed_ = false;
      this.isScheduled_ = false;
      this.isTrackPending_ = false;
      this.isRunning_ = false;
      this.isTracing_ = TraceMode.NONE;
      this.name_ = name_;
      this.onInvalidate_ = onInvalidate_;
      this.errorHandler_ = errorHandler_;
      this.requiresObservable_ = requiresObservable_;
    }
    var _proto = Reaction2.prototype;
    _proto.onBecomeStale_ = function onBecomeStale_() {
      this.schedule_();
    };
    _proto.schedule_ = function schedule_() {
      if (!this.isScheduled_) {
        this.isScheduled_ = true;
        globalState.pendingReactions.push(this);
        runReactions();
      }
    };
    _proto.isScheduled = function isScheduled() {
      return this.isScheduled_;
    };
    _proto.runReaction_ = function runReaction_() {
      if (!this.isDisposed_) {
        startBatch();
        this.isScheduled_ = false;
        var prev = globalState.trackingContext;
        globalState.trackingContext = this;
        if (shouldCompute(this)) {
          this.isTrackPending_ = true;
          try {
            this.onInvalidate_();
            if (this.isTrackPending_ && isSpyEnabled()) {
              spyReport({
                name: this.name_,
                type: "scheduled-reaction"
              });
            }
          } catch (e) {
            this.reportExceptionInDerivation_(e);
          }
        }
        globalState.trackingContext = prev;
        endBatch();
      }
    };
    _proto.track = function track(fn) {
      if (this.isDisposed_) {
        return;
      }
      startBatch();
      var notify = isSpyEnabled();
      var startTime;
      if (notify) {
        startTime = Date.now();
        spyReportStart({
          name: this.name_,
          type: "reaction"
        });
      }
      this.isRunning_ = true;
      var prevReaction = globalState.trackingContext;
      globalState.trackingContext = this;
      var result = trackDerivedFunction(this, fn, void 0);
      globalState.trackingContext = prevReaction;
      this.isRunning_ = false;
      this.isTrackPending_ = false;
      if (this.isDisposed_) {
        clearObserving(this);
      }
      if (isCaughtException(result)) {
        this.reportExceptionInDerivation_(result.cause);
      }
      if (notify) {
        spyReportEnd({
          time: Date.now() - startTime
        });
      }
      endBatch();
    };
    _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
      var _this = this;
      if (this.errorHandler_) {
        this.errorHandler_(error, this);
        return;
      }
      if (globalState.disableErrorBoundaries) {
        throw error;
      }
      var message = true ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
      if (!globalState.suppressReactionErrors) {
        console.error(message, error);
      } else if (true) {
        console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
      }
      if (isSpyEnabled()) {
        spyReport({
          type: "error",
          name: this.name_,
          message,
          error: "" + error
        });
      }
      globalState.globalReactionErrorHandlers.forEach(function(f5) {
        return f5(error, _this);
      });
    };
    _proto.dispose = function dispose() {
      if (!this.isDisposed_) {
        this.isDisposed_ = true;
        if (!this.isRunning_) {
          startBatch();
          clearObserving(this);
          endBatch();
        }
      }
    };
    _proto.getDisposer_ = function getDisposer_() {
      var r2 = this.dispose.bind(this);
      r2[$mobx] = this;
      return r2;
    };
    _proto.toString = function toString3() {
      return "Reaction[" + this.name_ + "]";
    };
    _proto.trace = function trace$1(enterBreakPoint) {
      if (enterBreakPoint === void 0) {
        enterBreakPoint = false;
      }
      trace(this, enterBreakPoint);
    };
    return Reaction2;
  }();
  var MAX_REACTION_ITERATIONS = 100;
  var reactionScheduler = function reactionScheduler2(f5) {
    return f5();
  };
  function runReactions() {
    if (globalState.inBatch > 0 || globalState.isRunningReactions) {
      return;
    }
    reactionScheduler(runReactionsHelper);
  }
  function runReactionsHelper() {
    globalState.isRunningReactions = true;
    var allReactions = globalState.pendingReactions;
    var iterations = 0;
    while (allReactions.length > 0) {
      if (++iterations === MAX_REACTION_ITERATIONS) {
        console.error(true ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
        allReactions.splice(0);
      }
      var remainingReactions = allReactions.splice(0);
      for (var i4 = 0, l4 = remainingReactions.length; i4 < l4; i4++) {
        remainingReactions[i4].runReaction_();
      }
    }
    globalState.isRunningReactions = false;
  }
  var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
  function isSpyEnabled() {
    return !!globalState.spyListeners.length;
  }
  function spyReport(event) {
    if (false) {
      return;
    }
    if (!globalState.spyListeners.length) {
      return;
    }
    var listeners = globalState.spyListeners;
    for (var i4 = 0, l4 = listeners.length; i4 < l4; i4++) {
      listeners[i4](event);
    }
  }
  function spyReportStart(event) {
    if (false) {
      return;
    }
    var change = _extends({}, event, {
      spyReportStart: true
    });
    spyReport(change);
  }
  var END_EVENT = {
    type: "report-end",
    spyReportEnd: true
  };
  function spyReportEnd(change) {
    if (false) {
      return;
    }
    if (change) {
      spyReport(_extends({}, change, {
        type: "report-end",
        spyReportEnd: true
      }));
    } else {
      spyReport(END_EVENT);
    }
  }
  function spy(listener) {
    if (false) {
      console.warn("[mobx.spy] Is a no-op in production builds");
      return function() {
      };
    } else {
      globalState.spyListeners.push(listener);
      return once(function() {
        globalState.spyListeners = globalState.spyListeners.filter(function(l4) {
          return l4 !== listener;
        });
      });
    }
  }
  var ACTION = "action";
  var ACTION_BOUND = "action.bound";
  var AUTOACTION = "autoAction";
  var AUTOACTION_BOUND = "autoAction.bound";
  var DEFAULT_ACTION_NAME = "<unnamed action>";
  var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
  var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
    bound: true
  });
  var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
    autoAction: true
  });
  var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
    autoAction: true,
    bound: true
  });
  function createActionFactory(autoAction2) {
    var res = function action2(arg1, arg2) {
      if (isFunction(arg1)) {
        return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
      }
      if (isFunction(arg2)) {
        return createAction(arg1, arg2, autoAction2);
      }
      if (isStringish(arg2)) {
        return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
      }
      if (isStringish(arg1)) {
        return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
          name: arg1,
          autoAction: autoAction2
        }));
      }
      if (true) {
        die("Invalid arguments for `action`");
      }
    };
    return res;
  }
  var action = /* @__PURE__ */ createActionFactory(false);
  Object.assign(action, actionAnnotation);
  var autoAction = /* @__PURE__ */ createActionFactory(true);
  Object.assign(autoAction, autoActionAnnotation);
  action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
  autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
  function runInAction(fn) {
    return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, void 0);
  }
  function isAction(thing) {
    return isFunction(thing) && thing.isMobxAction === true;
  }
  function autorun(view, opts) {
    var _opts$name, _opts;
    if (opts === void 0) {
      opts = EMPTY_OBJECT;
    }
    if (true) {
      if (!isFunction(view)) {
        die("Autorun expects a function as first argument");
      }
      if (isAction(view)) {
        die("Autorun does not accept actions since actions are untrackable");
      }
    }
    var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : true ? view.name || "Autorun@" + getNextId() : "Autorun";
    var runSync = !opts.scheduler && !opts.delay;
    var reaction2;
    if (runSync) {
      reaction2 = new Reaction(name, function() {
        this.track(reactionRunner);
      }, opts.onError, opts.requiresObservable);
    } else {
      var scheduler = createSchedulerFromOptions(opts);
      var isScheduled = false;
      reaction2 = new Reaction(name, function() {
        if (!isScheduled) {
          isScheduled = true;
          scheduler(function() {
            isScheduled = false;
            if (!reaction2.isDisposed_) {
              reaction2.track(reactionRunner);
            }
          });
        }
      }, opts.onError, opts.requiresObservable);
    }
    function reactionRunner() {
      view(reaction2);
    }
    reaction2.schedule_();
    return reaction2.getDisposer_();
  }
  var run = function run2(f5) {
    return f5();
  };
  function createSchedulerFromOptions(opts) {
    return opts.scheduler ? opts.scheduler : opts.delay ? function(f5) {
      return setTimeout(f5, opts.delay);
    } : run;
  }
  function reaction(expression, effect, opts) {
    var _opts$name2;
    if (opts === void 0) {
      opts = EMPTY_OBJECT;
    }
    if (true) {
      if (!isFunction(expression) || !isFunction(effect)) {
        die("First and second argument to reaction should be functions");
      }
      if (!isPlainObject(opts)) {
        die("Third argument of reactions should be an object");
      }
    }
    var name = (_opts$name2 = opts.name) != null ? _opts$name2 : true ? "Reaction@" + getNextId() : "Reaction";
    var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
    var runSync = !opts.scheduler && !opts.delay;
    var scheduler = createSchedulerFromOptions(opts);
    var firstTime = true;
    var isScheduled = false;
    var value;
    var oldValue;
    var equals2 = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
    var r2 = new Reaction(name, function() {
      if (firstTime || runSync) {
        reactionRunner();
      } else if (!isScheduled) {
        isScheduled = true;
        scheduler(reactionRunner);
      }
    }, opts.onError, opts.requiresObservable);
    function reactionRunner() {
      isScheduled = false;
      if (r2.isDisposed_) {
        return;
      }
      var changed = false;
      r2.track(function() {
        var nextValue = allowStateChanges(false, function() {
          return expression(r2);
        });
        changed = firstTime || !equals2(value, nextValue);
        oldValue = value;
        value = nextValue;
      });
      if (firstTime && opts.fireImmediately) {
        effectAction(value, oldValue, r2);
      } else if (!firstTime && changed) {
        effectAction(value, oldValue, r2);
      }
      firstTime = false;
    }
    r2.schedule_();
    return r2.getDisposer_();
  }
  function wrapErrorHandler(errorHandler, baseFn) {
    return function() {
      try {
        return baseFn.apply(this, arguments);
      } catch (e) {
        errorHandler.call(this, e);
      }
    };
  }
  var ON_BECOME_OBSERVED = "onBO";
  var ON_BECOME_UNOBSERVED = "onBUO";
  function onBecomeObserved(thing, arg2, arg3) {
    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
  }
  function onBecomeUnobserved(thing, arg2, arg3) {
    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
  }
  function interceptHook(hook, thing, arg2, arg3) {
    var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
    var cb = isFunction(arg3) ? arg3 : arg2;
    var listenersKey = hook + "L";
    if (atom[listenersKey]) {
      atom[listenersKey].add(cb);
    } else {
      atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
    }
    return function() {
      var hookListeners = atom[listenersKey];
      if (hookListeners) {
        hookListeners["delete"](cb);
        if (hookListeners.size === 0) {
          delete atom[listenersKey];
        }
      }
    };
  }
  function extendObservable(target, properties, annotations, options) {
    if (true) {
      if (arguments.length > 4) {
        die("'extendObservable' expected 2-4 arguments");
      }
      if (typeof target !== "object") {
        die("'extendObservable' expects an object as first argument");
      }
      if (isObservableMap(target)) {
        die("'extendObservable' should not be used on maps, use map.merge instead");
      }
      if (!isPlainObject(properties)) {
        die("'extendObservable' only accepts plain objects as second argument");
      }
      if (isObservable(properties) || isObservable(annotations)) {
        die("Extending an object with another observable (object) is not supported");
      }
    }
    var descriptors = getOwnPropertyDescriptors(properties);
    var adm = asObservableObject(target, options)[$mobx];
    startBatch();
    try {
      ownKeys(descriptors).forEach(function(key) {
        adm.extend_(
          key,
          descriptors[key],
          // must pass "undefined" for { key: undefined }
          !annotations ? true : key in annotations ? annotations[key] : true
        );
      });
    } finally {
      endBatch();
    }
    return target;
  }
  function getDependencyTree(thing, property7) {
    return nodeToDependencyTree(getAtom(thing, property7));
  }
  function nodeToDependencyTree(node) {
    var result = {
      name: node.name_
    };
    if (node.observing_ && node.observing_.length > 0) {
      result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
    }
    return result;
  }
  function unique(list) {
    return Array.from(new Set(list));
  }
  var generatorId = 0;
  function FlowCancellationError() {
    this.message = "FLOW_CANCELLED";
  }
  FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
  var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
    bound: true
  });
  var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, flowAnnotation);
    }
    if (arguments.length !== 1) {
      die("Flow expects single argument with generator function");
    }
    var generator = arg1;
    var name = generator.name || "<unnamed flow>";
    var res = function res2() {
      var ctx = this;
      var args = arguments;
      var runId = ++generatorId;
      var gen2 = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
      var rejector;
      var pendingPromise = void 0;
      var promise = new Promise(function(resolve, reject) {
        var stepId = 0;
        rejector = reject;
        function onFulfilled(res3) {
          pendingPromise = void 0;
          var ret;
          try {
            ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen2.next).call(gen2, res3);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }
        function onRejected(err) {
          pendingPromise = void 0;
          var ret;
          try {
            ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen2["throw"]).call(gen2, err);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }
        function next(ret) {
          if (isFunction(ret == null ? void 0 : ret.then)) {
            ret.then(next, reject);
            return;
          }
          if (ret.done) {
            return resolve(ret.value);
          }
          pendingPromise = Promise.resolve(ret.value);
          return pendingPromise.then(onFulfilled, onRejected);
        }
        onFulfilled(void 0);
      });
      promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
        try {
          if (pendingPromise) {
            cancelPromise(pendingPromise);
          }
          var _res = gen2["return"](void 0);
          var yieldedPromise = Promise.resolve(_res.value);
          yieldedPromise.then(noop, noop);
          cancelPromise(yieldedPromise);
          rejector(new FlowCancellationError());
        } catch (e) {
          rejector(e);
        }
      });
      return promise;
    };
    res.isMobXFlow = true;
    return res;
  }, flowAnnotation);
  flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
  function cancelPromise(promise) {
    if (isFunction(promise.cancel)) {
      promise.cancel();
    }
  }
  function isFlow(fn) {
    return (fn == null ? void 0 : fn.isMobXFlow) === true;
  }
  function _isObservable(value, property7) {
    if (!value) {
      return false;
    }
    if (property7 !== void 0) {
      if (isObservableMap(value) || isObservableArray(value)) {
        return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
      }
      if (isObservableObject(value)) {
        return value[$mobx].values_.has(property7);
      }
      return false;
    }
    return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
  }
  function isObservable(value) {
    if (arguments.length !== 1) {
      die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
    }
    return _isObservable(value);
  }
  function apiOwnKeys(obj) {
    if (isObservableObject(obj)) {
      return obj[$mobx].ownKeys_();
    }
    die(38);
  }
  function cache(map3, key, value) {
    map3.set(key, value);
    return value;
  }
  function toJSHelper(source, __alreadySeen) {
    if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
      return source;
    }
    if (isObservableValue(source) || isComputedValue(source)) {
      return toJSHelper(source.get(), __alreadySeen);
    }
    if (__alreadySeen.has(source)) {
      return __alreadySeen.get(source);
    }
    if (isObservableArray(source)) {
      var res = cache(__alreadySeen, source, new Array(source.length));
      source.forEach(function(value, idx) {
        res[idx] = toJSHelper(value, __alreadySeen);
      });
      return res;
    }
    if (isObservableSet(source)) {
      var _res = cache(__alreadySeen, source, /* @__PURE__ */ new Set());
      source.forEach(function(value) {
        _res.add(toJSHelper(value, __alreadySeen));
      });
      return _res;
    }
    if (isObservableMap(source)) {
      var _res2 = cache(__alreadySeen, source, /* @__PURE__ */ new Map());
      source.forEach(function(value, key) {
        _res2.set(key, toJSHelper(value, __alreadySeen));
      });
      return _res2;
    } else {
      var _res3 = cache(__alreadySeen, source, {});
      apiOwnKeys(source).forEach(function(key) {
        if (objectPrototype.propertyIsEnumerable.call(source, key)) {
          _res3[key] = toJSHelper(source[key], __alreadySeen);
        }
      });
      return _res3;
    }
  }
  function toJS(source, options) {
    if (options) {
      die("toJS no longer supports options");
    }
    return toJSHelper(source, /* @__PURE__ */ new Map());
  }
  function trace() {
    if (false) {
      die("trace() is not available in production builds");
    }
    var enterBreakPoint = false;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[args.length - 1] === "boolean") {
      enterBreakPoint = args.pop();
    }
    var derivation = getAtomFromArgs(args);
    if (!derivation) {
      return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    }
    if (derivation.isTracing_ === TraceMode.NONE) {
      console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
    }
    derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
  }
  function getAtomFromArgs(args) {
    switch (args.length) {
      case 0:
        return globalState.trackingDerivation;
      case 1:
        return getAtom(args[0]);
      case 2:
        return getAtom(args[0], args[1]);
    }
  }
  function transaction(action2, thisArg) {
    if (thisArg === void 0) {
      thisArg = void 0;
    }
    startBatch();
    try {
      return action2.apply(thisArg);
    } finally {
      endBatch();
    }
  }
  function getAdm(target) {
    return target[$mobx];
  }
  var objectProxyTraps = {
    has: function has(target, name) {
      if (globalState.trackingDerivation) {
        warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
      }
      return getAdm(target).has_(name);
    },
    get: function get(target, name) {
      return getAdm(target).get_(name);
    },
    set: function set2(target, name, value) {
      var _getAdm$set_;
      if (!isStringish(name)) {
        return false;
      }
      if (!getAdm(target).values_.has(name)) {
        warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
      }
      return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
    },
    deleteProperty: function deleteProperty(target, name) {
      var _getAdm$delete_;
      if (true) {
        warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
      }
      if (!isStringish(name)) {
        return false;
      }
      return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
    },
    defineProperty: function defineProperty2(target, name, descriptor) {
      var _getAdm$definePropert;
      if (true) {
        warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
      }
      return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
    },
    ownKeys: function ownKeys2(target) {
      if (globalState.trackingDerivation) {
        warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
      }
      return getAdm(target).ownKeys_();
    },
    preventExtensions: function preventExtensions(target) {
      die(13);
    }
  };
  function asDynamicObservableObject(target, options) {
    var _target$$mobx, _target$$mobx$proxy_;
    assertProxies();
    target = asObservableObject(target, options);
    return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
  }
  function hasInterceptors(interceptable) {
    return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
  }
  function registerInterceptor(interceptable, handler) {
    var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
    interceptors.push(handler);
    return once(function() {
      var idx = interceptors.indexOf(handler);
      if (idx !== -1) {
        interceptors.splice(idx, 1);
      }
    });
  }
  function interceptChange(interceptable, change) {
    var prevU = untrackedStart();
    try {
      var interceptors = [].concat(interceptable.interceptors_ || []);
      for (var i4 = 0, l4 = interceptors.length; i4 < l4; i4++) {
        change = interceptors[i4](change);
        if (change && !change.type) {
          die(14);
        }
        if (!change) {
          break;
        }
      }
      return change;
    } finally {
      untrackedEnd(prevU);
    }
  }
  function hasListeners(listenable) {
    return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
  }
  function registerListener(listenable, handler) {
    var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
    listeners.push(handler);
    return once(function() {
      var idx = listeners.indexOf(handler);
      if (idx !== -1) {
        listeners.splice(idx, 1);
      }
    });
  }
  function notifyListeners(listenable, change) {
    var prevU = untrackedStart();
    var listeners = listenable.changeListeners_;
    if (!listeners) {
      return;
    }
    listeners = listeners.slice();
    for (var i4 = 0, l4 = listeners.length; i4 < l4; i4++) {
      listeners[i4](change);
    }
    untrackedEnd(prevU);
  }
  var SPLICE = "splice";
  var UPDATE = "update";
  var MAX_SPLICE_SIZE = 1e4;
  var arrayTraps = {
    get: function get2(target, name) {
      var adm = target[$mobx];
      if (name === $mobx) {
        return adm;
      }
      if (name === "length") {
        return adm.getArrayLength_();
      }
      if (typeof name === "string" && !isNaN(name)) {
        return adm.get_(parseInt(name));
      }
      if (hasProp(arrayExtensions, name)) {
        return arrayExtensions[name];
      }
      return target[name];
    },
    set: function set3(target, name, value) {
      var adm = target[$mobx];
      if (name === "length") {
        adm.setArrayLength_(value);
      }
      if (typeof name === "symbol" || isNaN(name)) {
        target[name] = value;
      } else {
        adm.set_(parseInt(name), value);
      }
      return true;
    },
    preventExtensions: function preventExtensions2() {
      die(15);
    }
  };
  var ObservableArrayAdministration = /* @__PURE__ */ function() {
    function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
      if (name === void 0) {
        name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
      }
      this.owned_ = void 0;
      this.legacyMode_ = void 0;
      this.atom_ = void 0;
      this.values_ = [];
      this.interceptors_ = void 0;
      this.changeListeners_ = void 0;
      this.enhancer_ = void 0;
      this.dehancer = void 0;
      this.proxy_ = void 0;
      this.lastKnownLength_ = 0;
      this.owned_ = owned_;
      this.legacyMode_ = legacyMode_;
      this.atom_ = new Atom(name);
      this.enhancer_ = function(newV, oldV) {
        return enhancer(newV, oldV, true ? name + "[..]" : "ObservableArray[..]");
      };
    }
    var _proto = ObservableArrayAdministration2.prototype;
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.dehanceValues_ = function dehanceValues_(values) {
      if (this.dehancer !== void 0 && values.length > 0) {
        return values.map(this.dehancer);
      }
      return values;
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === void 0) {
        fireImmediately = false;
      }
      if (fireImmediately) {
        listener({
          observableKind: "array",
          object: this.proxy_,
          debugObjectName: this.atom_.name_,
          type: "splice",
          index: 0,
          added: this.values_.slice(),
          addedCount: this.values_.length,
          removed: [],
          removedCount: 0
        });
      }
      return registerListener(this, listener);
    };
    _proto.getArrayLength_ = function getArrayLength_() {
      this.atom_.reportObserved();
      return this.values_.length;
    };
    _proto.setArrayLength_ = function setArrayLength_(newLength) {
      if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
        die("Out of range: " + newLength);
      }
      var currentLength = this.values_.length;
      if (newLength === currentLength) {
        return;
      } else if (newLength > currentLength) {
        var newItems = new Array(newLength - currentLength);
        for (var i4 = 0; i4 < newLength - currentLength; i4++) {
          newItems[i4] = void 0;
        }
        this.spliceWithArray_(currentLength, 0, newItems);
      } else {
        this.spliceWithArray_(newLength, currentLength - newLength);
      }
    };
    _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
      if (oldLength !== this.lastKnownLength_) {
        die(16);
      }
      this.lastKnownLength_ += delta;
      if (this.legacyMode_ && delta > 0) {
        reserveArrayBuffer(oldLength + delta + 1);
      }
    };
    _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this.atom_);
      var length = this.values_.length;
      if (index2 === void 0) {
        index2 = 0;
      } else if (index2 > length) {
        index2 = length;
      } else if (index2 < 0) {
        index2 = Math.max(0, length + index2);
      }
      if (arguments.length === 1) {
        deleteCount = length - index2;
      } else if (deleteCount === void 0 || deleteCount === null) {
        deleteCount = 0;
      } else {
        deleteCount = Math.max(0, Math.min(deleteCount, length - index2));
      }
      if (newItems === void 0) {
        newItems = EMPTY_ARRAY;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_,
          type: SPLICE,
          index: index2,
          removedCount: deleteCount,
          added: newItems
        });
        if (!change) {
          return EMPTY_ARRAY;
        }
        deleteCount = change.removedCount;
        newItems = change.added;
      }
      newItems = newItems.length === 0 ? newItems : newItems.map(function(v7) {
        return _this.enhancer_(v7, void 0);
      });
      if (this.legacyMode_ || true) {
        var lengthDelta = newItems.length - deleteCount;
        this.updateArrayLength_(length, lengthDelta);
      }
      var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
      if (deleteCount !== 0 || newItems.length !== 0) {
        this.notifyArraySplice_(index2, newItems, res);
      }
      return this.dehanceValues_(res);
    };
    _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
      if (newItems.length < MAX_SPLICE_SIZE) {
        var _this$values_;
        return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
      } else {
        var res = this.values_.slice(index2, index2 + deleteCount);
        var oldItems = this.values_.slice(index2 + deleteCount);
        this.values_.length += newItems.length - deleteCount;
        for (var i4 = 0; i4 < newItems.length; i4++) {
          this.values_[index2 + i4] = newItems[i4];
        }
        for (var _i = 0; _i < oldItems.length; _i++) {
          this.values_[index2 + newItems.length + _i] = oldItems[_i];
        }
        return res;
      }
    };
    _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
      var notifySpy = !this.owned_ && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "array",
        object: this.proxy_,
        type: UPDATE,
        debugObjectName: this.atom_.name_,
        index: index2,
        newValue,
        oldValue
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      this.atom_.reportChanged();
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    };
    _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
      var notifySpy = !this.owned_ && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: SPLICE,
        index: index2,
        removed,
        added,
        removedCount: removed.length,
        addedCount: added.length
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      this.atom_.reportChanged();
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    };
    _proto.get_ = function get_(index2) {
      if (this.legacyMode_ && index2 >= this.values_.length) {
        console.warn(true ? "[mobx.array] Attempt to read an array index (" + index2 + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX" : "[mobx] Out of bounds read: " + index2);
        return void 0;
      }
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index2]);
    };
    _proto.set_ = function set_(index2, newValue) {
      var values = this.values_;
      if (this.legacyMode_ && index2 > values.length) {
        die(17, index2, values.length);
      }
      if (index2 < values.length) {
        checkIfStateModificationsAreAllowed(this.atom_);
        var oldValue = values[index2];
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: UPDATE,
            object: this.proxy_,
            index: index2,
            newValue
          });
          if (!change) {
            return;
          }
          newValue = change.newValue;
        }
        newValue = this.enhancer_(newValue, oldValue);
        var changed = newValue !== oldValue;
        if (changed) {
          values[index2] = newValue;
          this.notifyArrayChildUpdate_(index2, newValue, oldValue);
        }
      } else {
        var newItems = new Array(index2 + 1 - values.length);
        for (var i4 = 0; i4 < newItems.length - 1; i4++) {
          newItems[i4] = void 0;
        }
        newItems[newItems.length - 1] = newValue;
        this.spliceWithArray_(values.length, 0, newItems);
      }
    };
    return ObservableArrayAdministration2;
  }();
  function createObservableArray(initialValues, enhancer, name, owned) {
    if (name === void 0) {
      name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    assertProxies();
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true);
      adm.spliceWithArray_(0, 0, initialValues);
      allowStateChangesEnd(prev);
    }
    return proxy;
  }
  var arrayExtensions = {
    clear: function clear() {
      return this.splice(0);
    },
    replace: function replace(newItems) {
      var adm = this[$mobx];
      return adm.spliceWithArray_(0, adm.values_.length, newItems);
    },
    // Used by JSON.stringify
    toJSON: function toJSON() {
      return this.slice();
    },
    /*
     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
     * since these functions alter the inner structure of the array, the have side effects.
     * Because the have side effects, they should not be used in computed function,
     * and for that reason the do not call dependencyState.notifyObserved
     */
    splice: function splice(index2, deleteCount) {
      for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        newItems[_key - 2] = arguments[_key];
      }
      var adm = this[$mobx];
      switch (arguments.length) {
        case 0:
          return [];
        case 1:
          return adm.spliceWithArray_(index2);
        case 2:
          return adm.spliceWithArray_(index2, deleteCount);
      }
      return adm.spliceWithArray_(index2, deleteCount, newItems);
    },
    spliceWithArray: function spliceWithArray(index2, deleteCount, newItems) {
      return this[$mobx].spliceWithArray_(index2, deleteCount, newItems);
    },
    push: function push() {
      var adm = this[$mobx];
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }
      adm.spliceWithArray_(adm.values_.length, 0, items);
      return adm.values_.length;
    },
    pop: function pop() {
      return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
    },
    shift: function shift() {
      return this.splice(0, 1)[0];
    },
    unshift: function unshift() {
      var adm = this[$mobx];
      for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        items[_key3] = arguments[_key3];
      }
      adm.spliceWithArray_(0, 0, items);
      return adm.values_.length;
    },
    reverse: function reverse() {
      if (globalState.trackingDerivation) {
        die(37, "reverse");
      }
      this.replace(this.slice().reverse());
      return this;
    },
    sort: function sort() {
      if (globalState.trackingDerivation) {
        die(37, "sort");
      }
      var copy = this.slice();
      copy.sort.apply(copy, arguments);
      this.replace(copy);
      return this;
    },
    remove: function remove(value) {
      var adm = this[$mobx];
      var idx = adm.dehanceValues_(adm.values_).indexOf(value);
      if (idx > -1) {
        this.splice(idx, 1);
        return true;
      }
      return false;
    }
  };
  addArrayExtension("concat", simpleFunc);
  addArrayExtension("flat", simpleFunc);
  addArrayExtension("includes", simpleFunc);
  addArrayExtension("indexOf", simpleFunc);
  addArrayExtension("join", simpleFunc);
  addArrayExtension("lastIndexOf", simpleFunc);
  addArrayExtension("slice", simpleFunc);
  addArrayExtension("toString", simpleFunc);
  addArrayExtension("toLocaleString", simpleFunc);
  addArrayExtension("every", mapLikeFunc);
  addArrayExtension("filter", mapLikeFunc);
  addArrayExtension("find", mapLikeFunc);
  addArrayExtension("findIndex", mapLikeFunc);
  addArrayExtension("flatMap", mapLikeFunc);
  addArrayExtension("forEach", mapLikeFunc);
  addArrayExtension("map", mapLikeFunc);
  addArrayExtension("some", mapLikeFunc);
  addArrayExtension("reduce", reduceLikeFunc);
  addArrayExtension("reduceRight", reduceLikeFunc);
  function addArrayExtension(funcName, funcFactory) {
    if (typeof Array.prototype[funcName] === "function") {
      arrayExtensions[funcName] = funcFactory(funcName);
    }
  }
  function simpleFunc(funcName) {
    return function() {
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      return dehancedValues[funcName].apply(dehancedValues, arguments);
    };
  }
  function mapLikeFunc(funcName) {
    return function(callback, thisArg) {
      var _this2 = this;
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      return dehancedValues[funcName](function(element, index2) {
        return callback.call(thisArg, element, index2, _this2);
      });
    };
  }
  function reduceLikeFunc(funcName) {
    return function() {
      var _this3 = this;
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      var callback = arguments[0];
      arguments[0] = function(accumulator, currentValue, index2) {
        return callback(accumulator, currentValue, index2, _this3);
      };
      return dehancedValues[funcName].apply(dehancedValues, arguments);
    };
  }
  var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
  function isObservableArray(thing) {
    return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
  }
  var _Symbol$iterator;
  var _Symbol$toStringTag;
  var ObservableMapMarker = {};
  var ADD = "add";
  var DELETE = "delete";
  _Symbol$iterator = Symbol.iterator;
  _Symbol$toStringTag = Symbol.toStringTag;
  var ObservableMap = /* @__PURE__ */ function() {
    function ObservableMap2(initialData, enhancer_, name_) {
      var _this = this;
      if (enhancer_ === void 0) {
        enhancer_ = deepEnhancer;
      }
      if (name_ === void 0) {
        name_ = true ? "ObservableMap@" + getNextId() : "ObservableMap";
      }
      this.enhancer_ = void 0;
      this.name_ = void 0;
      this[$mobx] = ObservableMapMarker;
      this.data_ = void 0;
      this.hasMap_ = void 0;
      this.keysAtom_ = void 0;
      this.interceptors_ = void 0;
      this.changeListeners_ = void 0;
      this.dehancer = void 0;
      this.enhancer_ = enhancer_;
      this.name_ = name_;
      if (!isFunction(Map)) {
        die(18);
      }
      this.keysAtom_ = createAtom(true ? this.name_ + ".keys()" : "ObservableMap.keys()");
      this.data_ = /* @__PURE__ */ new Map();
      this.hasMap_ = /* @__PURE__ */ new Map();
      allowStateChanges(true, function() {
        _this.merge(initialData);
      });
    }
    var _proto = ObservableMap2.prototype;
    _proto.has_ = function has_(key) {
      return this.data_.has(key);
    };
    _proto.has = function has2(key) {
      var _this2 = this;
      if (!globalState.trackingDerivation) {
        return this.has_(key);
      }
      var entry = this.hasMap_.get(key);
      if (!entry) {
        var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
        this.hasMap_.set(key, newEntry);
        onBecomeUnobserved(newEntry, function() {
          return _this2.hasMap_["delete"](key);
        });
      }
      return entry.get();
    };
    _proto.set = function set4(key, value) {
      var hasKey = this.has_(key);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: hasKey ? UPDATE : ADD,
          object: this,
          newValue: value,
          name: key
        });
        if (!change) {
          return this;
        }
        value = change.newValue;
      }
      if (hasKey) {
        this.updateValue_(key, value);
      } else {
        this.addValue_(key, value);
      }
      return this;
    };
    _proto["delete"] = function _delete(key) {
      var _this3 = this;
      checkIfStateModificationsAreAllowed(this.keysAtom_);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: DELETE,
          object: this,
          name: key
        });
        if (!change) {
          return false;
        }
      }
      if (this.has_(key)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: DELETE,
          object: this,
          oldValue: this.data_.get(key).value_,
          name: key
        } : null;
        if (notifySpy) {
          spyReportStart(_change);
        }
        transaction(function() {
          var _this3$hasMap_$get;
          _this3.keysAtom_.reportChanged();
          (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);
          var observable3 = _this3.data_.get(key);
          observable3.setNewValue_(void 0);
          _this3.data_["delete"](key);
        });
        if (notify) {
          notifyListeners(this, _change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
        return true;
      }
      return false;
    };
    _proto.updateValue_ = function updateValue_(key, newValue) {
      var observable3 = this.data_.get(key);
      newValue = observable3.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: UPDATE,
          object: this,
          oldValue: observable3.value_,
          name: key,
          newValue
        } : null;
        if (notifySpy) {
          spyReportStart(change);
        }
        observable3.setNewValue_(newValue);
        if (notify) {
          notifyListeners(this, change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      }
    };
    _proto.addValue_ = function addValue_(key, newValue) {
      var _this4 = this;
      checkIfStateModificationsAreAllowed(this.keysAtom_);
      transaction(function() {
        var _this4$hasMap_$get;
        var observable3 = new ObservableValue(newValue, _this4.enhancer_, true ? _this4.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
        _this4.data_.set(key, observable3);
        newValue = observable3.value_;
        (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);
        _this4.keysAtom_.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        name: key,
        newValue
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    };
    _proto.get = function get3(key) {
      if (this.has(key)) {
        return this.dehanceValue_(this.data_.get(key).get());
      }
      return this.dehanceValue_(void 0);
    };
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.keys = function keys() {
      this.keysAtom_.reportObserved();
      return this.data_.keys();
    };
    _proto.values = function values() {
      var self2 = this;
      var keys = this.keys();
      return makeIterable({
        next: function next() {
          var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;
          return {
            done,
            value: done ? void 0 : self2.get(value)
          };
        }
      });
    };
    _proto.entries = function entries() {
      var self2 = this;
      var keys = this.keys();
      return makeIterable({
        next: function next() {
          var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;
          return {
            done,
            value: done ? void 0 : [value, self2.get(value)]
          };
        }
      });
    };
    _proto[_Symbol$iterator] = function() {
      return this.entries();
    };
    _proto.forEach = function forEach(callback, thisArg) {
      for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
        var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
        callback.call(thisArg, value, key, this);
      }
    };
    _proto.merge = function merge(other) {
      var _this5 = this;
      if (isObservableMap(other)) {
        other = new Map(other);
      }
      transaction(function() {
        if (isPlainObject(other)) {
          getPlainObjectKeys(other).forEach(function(key) {
            return _this5.set(key, other[key]);
          });
        } else if (Array.isArray(other)) {
          other.forEach(function(_ref) {
            var key = _ref[0], value = _ref[1];
            return _this5.set(key, value);
          });
        } else if (isES6Map(other)) {
          if (other.constructor !== Map) {
            die(19, other);
          }
          other.forEach(function(value, key) {
            return _this5.set(key, value);
          });
        } else if (other !== null && other !== void 0) {
          die(20, other);
        }
      });
      return this;
    };
    _proto.clear = function clear2() {
      var _this6 = this;
      transaction(function() {
        untracked(function() {
          for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
            var key = _step2.value;
            _this6["delete"](key);
          }
        });
      });
    };
    _proto.replace = function replace2(values) {
      var _this7 = this;
      transaction(function() {
        var replacementMap = convertToMap(values);
        var orderedData = /* @__PURE__ */ new Map();
        var keysReportChangedCalled = false;
        for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
          var key = _step3.value;
          if (!replacementMap.has(key)) {
            var deleted = _this7["delete"](key);
            if (deleted) {
              keysReportChangedCalled = true;
            } else {
              var value = _this7.data_.get(key);
              orderedData.set(key, value);
            }
          }
        }
        for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
          var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
          var keyExisted = _this7.data_.has(_key);
          _this7.set(_key, _value);
          if (_this7.data_.has(_key)) {
            var _value2 = _this7.data_.get(_key);
            orderedData.set(_key, _value2);
            if (!keyExisted) {
              keysReportChangedCalled = true;
            }
          }
        }
        if (!keysReportChangedCalled) {
          if (_this7.data_.size !== orderedData.size) {
            _this7.keysAtom_.reportChanged();
          } else {
            var iter1 = _this7.data_.keys();
            var iter2 = orderedData.keys();
            var next1 = iter1.next();
            var next2 = iter2.next();
            while (!next1.done) {
              if (next1.value !== next2.value) {
                _this7.keysAtom_.reportChanged();
                break;
              }
              next1 = iter1.next();
              next2 = iter2.next();
            }
          }
        }
        _this7.data_ = orderedData;
      });
      return this;
    };
    _proto.toString = function toString3() {
      return "[object ObservableMap]";
    };
    _proto.toJSON = function toJSON2() {
      return Array.from(this);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === true) {
        die("`observe` doesn't support fireImmediately=true in combination with maps.");
      }
      return registerListener(this, listener);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _createClass(ObservableMap2, [{
      key: "size",
      get: function get3() {
        this.keysAtom_.reportObserved();
        return this.data_.size;
      }
    }, {
      key: _Symbol$toStringTag,
      get: function get3() {
        return "Map";
      }
    }]);
    return ObservableMap2;
  }();
  var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
  function convertToMap(dataStructure) {
    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
      return dataStructure;
    } else if (Array.isArray(dataStructure)) {
      return new Map(dataStructure);
    } else if (isPlainObject(dataStructure)) {
      var map3 = /* @__PURE__ */ new Map();
      for (var key in dataStructure) {
        map3.set(key, dataStructure[key]);
      }
      return map3;
    } else {
      return die(21, dataStructure);
    }
  }
  var _Symbol$iterator$1;
  var _Symbol$toStringTag$1;
  var ObservableSetMarker = {};
  _Symbol$iterator$1 = Symbol.iterator;
  _Symbol$toStringTag$1 = Symbol.toStringTag;
  var ObservableSet = /* @__PURE__ */ function() {
    function ObservableSet2(initialData, enhancer, name_) {
      if (enhancer === void 0) {
        enhancer = deepEnhancer;
      }
      if (name_ === void 0) {
        name_ = true ? "ObservableSet@" + getNextId() : "ObservableSet";
      }
      this.name_ = void 0;
      this[$mobx] = ObservableSetMarker;
      this.data_ = /* @__PURE__ */ new Set();
      this.atom_ = void 0;
      this.changeListeners_ = void 0;
      this.interceptors_ = void 0;
      this.dehancer = void 0;
      this.enhancer_ = void 0;
      this.name_ = name_;
      if (!isFunction(Set)) {
        die(22);
      }
      this.atom_ = createAtom(this.name_);
      this.enhancer_ = function(newV, oldV) {
        return enhancer(newV, oldV, name_);
      };
      if (initialData) {
        this.replace(initialData);
      }
    }
    var _proto = ObservableSet2.prototype;
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.clear = function clear2() {
      var _this = this;
      transaction(function() {
        untracked(function() {
          for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done; ) {
            var value = _step.value;
            _this["delete"](value);
          }
        });
      });
    };
    _proto.forEach = function forEach(callbackFn, thisArg) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
        var value = _step2.value;
        callbackFn.call(thisArg, value, value, this);
      }
    };
    _proto.add = function add3(value) {
      var _this2 = this;
      checkIfStateModificationsAreAllowed(this.atom_);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: ADD,
          object: this,
          newValue: value
        });
        if (!change) {
          return this;
        }
      }
      if (!this.has(value)) {
        transaction(function() {
          _this2.data_.add(_this2.enhancer_(value, void 0));
          _this2.atom_.reportChanged();
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change = notify || notifySpy ? {
          observableKind: "set",
          debugObjectName: this.name_,
          type: ADD,
          object: this,
          newValue: value
        } : null;
        if (notifySpy && true) {
          spyReportStart(_change);
        }
        if (notify) {
          notifyListeners(this, _change);
        }
        if (notifySpy && true) {
          spyReportEnd();
        }
      }
      return this;
    };
    _proto["delete"] = function _delete(value) {
      var _this3 = this;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: DELETE,
          object: this,
          oldValue: value
        });
        if (!change) {
          return false;
        }
      }
      if (this.has(value)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change2 = notify || notifySpy ? {
          observableKind: "set",
          debugObjectName: this.name_,
          type: DELETE,
          object: this,
          oldValue: value
        } : null;
        if (notifySpy && true) {
          spyReportStart(_change2);
        }
        transaction(function() {
          _this3.atom_.reportChanged();
          _this3.data_["delete"](value);
        });
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (notifySpy && true) {
          spyReportEnd();
        }
        return true;
      }
      return false;
    };
    _proto.has = function has2(value) {
      this.atom_.reportObserved();
      return this.data_.has(this.dehanceValue_(value));
    };
    _proto.entries = function entries() {
      var nextIndex = 0;
      var keys = Array.from(this.keys());
      var values = Array.from(this.values());
      return makeIterable({
        next: function next() {
          var index2 = nextIndex;
          nextIndex += 1;
          return index2 < values.length ? {
            value: [keys[index2], values[index2]],
            done: false
          } : {
            done: true
          };
        }
      });
    };
    _proto.keys = function keys() {
      return this.values();
    };
    _proto.values = function values() {
      this.atom_.reportObserved();
      var self2 = this;
      var nextIndex = 0;
      var observableValues = Array.from(this.data_.values());
      return makeIterable({
        next: function next() {
          return nextIndex < observableValues.length ? {
            value: self2.dehanceValue_(observableValues[nextIndex++]),
            done: false
          } : {
            done: true
          };
        }
      });
    };
    _proto.replace = function replace2(other) {
      var _this4 = this;
      if (isObservableSet(other)) {
        other = new Set(other);
      }
      transaction(function() {
        if (Array.isArray(other)) {
          _this4.clear();
          other.forEach(function(value) {
            return _this4.add(value);
          });
        } else if (isES6Set(other)) {
          _this4.clear();
          other.forEach(function(value) {
            return _this4.add(value);
          });
        } else if (other !== null && other !== void 0) {
          die("Cannot initialize set from " + other);
        }
      });
      return this;
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === true) {
        die("`observe` doesn't support fireImmediately=true in combination with sets.");
      }
      return registerListener(this, listener);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.toJSON = function toJSON2() {
      return Array.from(this);
    };
    _proto.toString = function toString3() {
      return "[object ObservableSet]";
    };
    _proto[_Symbol$iterator$1] = function() {
      return this.values();
    };
    _createClass(ObservableSet2, [{
      key: "size",
      get: function get3() {
        this.atom_.reportObserved();
        return this.data_.size;
      }
    }, {
      key: _Symbol$toStringTag$1,
      get: function get3() {
        return "Set";
      }
    }]);
    return ObservableSet2;
  }();
  var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
  var descriptorCache = /* @__PURE__ */ Object.create(null);
  var REMOVE = "remove";
  var ObservableObjectAdministration = /* @__PURE__ */ function() {
    function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
      if (values_ === void 0) {
        values_ = /* @__PURE__ */ new Map();
      }
      if (defaultAnnotation_ === void 0) {
        defaultAnnotation_ = autoAnnotation;
      }
      this.target_ = void 0;
      this.values_ = void 0;
      this.name_ = void 0;
      this.defaultAnnotation_ = void 0;
      this.keysAtom_ = void 0;
      this.changeListeners_ = void 0;
      this.interceptors_ = void 0;
      this.proxy_ = void 0;
      this.isPlainObject_ = void 0;
      this.appliedAnnotations_ = void 0;
      this.pendingKeys_ = void 0;
      this.target_ = target_;
      this.values_ = values_;
      this.name_ = name_;
      this.defaultAnnotation_ = defaultAnnotation_;
      this.keysAtom_ = new Atom(true ? this.name_ + ".keys" : "ObservableObject.keys");
      this.isPlainObject_ = isPlainObject(this.target_);
      if (!isAnnotation(this.defaultAnnotation_)) {
        die("defaultAnnotation must be valid annotation");
      }
      if (true) {
        this.appliedAnnotations_ = {};
      }
    }
    var _proto = ObservableObjectAdministration2.prototype;
    _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
      return this.values_.get(key).get();
    };
    _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
      var observable3 = this.values_.get(key);
      if (observable3 instanceof ComputedValue) {
        observable3.set(newValue);
        return true;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_ || this.target_,
          name: key,
          newValue
        });
        if (!change) {
          return null;
        }
        newValue = change.newValue;
      }
      newValue = observable3.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var _change = notify || notifySpy ? {
          type: UPDATE,
          observableKind: "object",
          debugObjectName: this.name_,
          object: this.proxy_ || this.target_,
          oldValue: observable3.value_,
          name: key,
          newValue
        } : null;
        if (notifySpy) {
          spyReportStart(_change);
        }
        observable3.setNewValue_(newValue);
        if (notify) {
          notifyListeners(this, _change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      }
      return true;
    };
    _proto.get_ = function get_(key) {
      if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
        this.has_(key);
      }
      return this.target_[key];
    };
    _proto.set_ = function set_(key, value, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (hasProp(this.target_, key)) {
        if (this.values_.has(key)) {
          return this.setObservablePropValue_(key, value);
        } else if (proxyTrap) {
          return Reflect.set(this.target_, key, value);
        } else {
          this.target_[key] = value;
          return true;
        }
      } else {
        return this.extend_(key, {
          value,
          enumerable: true,
          writable: true,
          configurable: true
        }, this.defaultAnnotation_, proxyTrap);
      }
    };
    _proto.has_ = function has_(key) {
      if (!globalState.trackingDerivation) {
        return key in this.target_;
      }
      this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
      var entry = this.pendingKeys_.get(key);
      if (!entry) {
        entry = new ObservableValue(key in this.target_, referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
        this.pendingKeys_.set(key, entry);
      }
      return entry.get();
    };
    _proto.make_ = function make_(key, annotation) {
      if (annotation === true) {
        annotation = this.defaultAnnotation_;
      }
      if (annotation === false) {
        return;
      }
      assertAnnotable(this, annotation, key);
      if (!(key in this.target_)) {
        var _this$target_$storedA;
        if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
          return;
        } else {
          die(1, annotation.annotationType_, this.name_ + "." + key.toString());
        }
      }
      var source = this.target_;
      while (source && source !== objectPrototype) {
        var descriptor = getDescriptor(source, key);
        if (descriptor) {
          var outcome = annotation.make_(this, key, descriptor, source);
          if (outcome === 0) {
            return;
          }
          if (outcome === 1) {
            break;
          }
        }
        source = Object.getPrototypeOf(source);
      }
      recordAnnotationApplied(this, annotation, key);
    };
    _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (annotation === true) {
        annotation = this.defaultAnnotation_;
      }
      if (annotation === false) {
        return this.defineProperty_(key, descriptor, proxyTrap);
      }
      assertAnnotable(this, annotation, key);
      var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
      if (outcome) {
        recordAnnotationApplied(this, annotation, key);
      }
      return outcome;
    };
    _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: descriptor.value
          });
          if (!change) {
            return null;
          }
          var newValue = change.newValue;
          if (descriptor.value !== newValue) {
            descriptor = _extends({}, descriptor, {
              value: newValue
            });
          }
        }
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        this.notifyPropertyAddition_(key, descriptor.value);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: value
          });
          if (!change) {
            return null;
          }
          value = change.newValue;
        }
        var cachedDescriptor = getCachedObservablePropDescriptor(key);
        var descriptor = {
          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
          enumerable: true,
          get: cachedDescriptor.get,
          set: cachedDescriptor.set
        };
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        var observable3 = new ObservableValue(value, enhancer, true ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
        this.values_.set(key, observable3);
        this.notifyPropertyAddition_(key, observable3.value_);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: void 0
          });
          if (!change) {
            return null;
          }
        }
        options.name || (options.name = true ? this.name_ + "." + key.toString() : "ObservableObject.key");
        options.context = this.proxy_ || this.target_;
        var cachedDescriptor = getCachedObservablePropDescriptor(key);
        var descriptor = {
          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
          enumerable: false,
          get: cachedDescriptor.get,
          set: cachedDescriptor.set
        };
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        this.values_.set(key, new ComputedValue(options));
        this.notifyPropertyAddition_(key, void 0);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.delete_ = function delete_(key, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (!hasProp(this.target_, key)) {
        return true;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: REMOVE
        });
        if (!change) {
          return null;
        }
      }
      try {
        var _this$pendingKeys_, _this$pendingKeys_$ge;
        startBatch();
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var observable3 = this.values_.get(key);
        var value = void 0;
        if (!observable3 && (notify || notifySpy)) {
          var _getDescriptor2;
          value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
        }
        if (proxyTrap) {
          if (!Reflect.deleteProperty(this.target_, key)) {
            return false;
          }
        } else {
          delete this.target_[key];
        }
        if (true) {
          delete this.appliedAnnotations_[key];
        }
        if (observable3) {
          this.values_["delete"](key);
          if (observable3 instanceof ObservableValue) {
            value = observable3.value_;
          }
          propagateChanged(observable3);
        }
        this.keysAtom_.reportChanged();
        (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
        if (notify || notifySpy) {
          var _change2 = {
            type: REMOVE,
            observableKind: "object",
            object: this.proxy_ || this.target_,
            debugObjectName: this.name_,
            oldValue: value,
            name: key
          };
          if (notifySpy) {
            spyReportStart(_change2);
          }
          if (notify) {
            notifyListeners(this, _change2);
          }
          if (notifySpy) {
            spyReportEnd();
          }
        }
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.observe_ = function observe_(callback, fireImmediately) {
      if (fireImmediately === true) {
        die("`observe` doesn't support the fire immediately property for observable objects.");
      }
      return registerListener(this, callback);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
      var _this$pendingKeys_2, _this$pendingKeys_2$g;
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      if (notify || notifySpy) {
        var change = notify || notifySpy ? {
          type: ADD,
          observableKind: "object",
          debugObjectName: this.name_,
          object: this.proxy_ || this.target_,
          name: key,
          newValue: value
        } : null;
        if (notifySpy) {
          spyReportStart(change);
        }
        if (notify) {
          notifyListeners(this, change);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      }
      (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
      this.keysAtom_.reportChanged();
    };
    _proto.ownKeys_ = function ownKeys_() {
      this.keysAtom_.reportObserved();
      return ownKeys(this.target_);
    };
    _proto.keys_ = function keys_() {
      this.keysAtom_.reportObserved();
      return Object.keys(this.target_);
    };
    return ObservableObjectAdministration2;
  }();
  function asObservableObject(target, options) {
    var _options$name;
    if (options && isObservableObject(target)) {
      die("Options can't be provided for already observable objects.");
    }
    if (hasProp(target, $mobx)) {
      if (!(getAdministration(target) instanceof ObservableObjectAdministration)) {
        die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
      }
      return target;
    }
    if (!Object.isExtensible(target)) {
      die("Cannot make the designated object observable; it is not extensible");
    }
    var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : true ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
    var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options));
    addHiddenProp(target, $mobx, adm);
    return target;
  }
  var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
  function getCachedObservablePropDescriptor(key) {
    return descriptorCache[key] || (descriptorCache[key] = {
      get: function get3() {
        return this[$mobx].getObservablePropValue_(key);
      },
      set: function set4(value) {
        return this[$mobx].setObservablePropValue_(key, value);
      }
    });
  }
  function isObservableObject(thing) {
    if (isObject(thing)) {
      return isObservableObjectAdministration(thing[$mobx]);
    }
    return false;
  }
  function recordAnnotationApplied(adm, annotation, key) {
    var _adm$target_$storedAn;
    if (true) {
      adm.appliedAnnotations_[key] = annotation;
    }
    (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
  }
  function assertAnnotable(adm, annotation, key) {
    if (!isAnnotation(annotation)) {
      die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
    }
    if (!isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
      var fieldName = adm.name_ + "." + key.toString();
      var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
      var requestedAnnotationType = annotation.annotationType_;
      die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overridden by subclass.");
    }
  }
  var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0);
  var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
  var StubArray = function StubArray2() {
  };
  function inherit(ctor, proto2) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ctor.prototype, proto2);
    } else if (ctor.prototype.__proto__ !== void 0) {
      ctor.prototype.__proto__ = proto2;
    } else {
      ctor.prototype = proto2;
    }
  }
  inherit(StubArray, Array.prototype);
  var LegacyObservableArray = /* @__PURE__ */ function(_StubArray, _Symbol$toStringTag2, _Symbol$iterator2) {
    _inheritsLoose(LegacyObservableArray2, _StubArray);
    function LegacyObservableArray2(initialValues, enhancer, name, owned) {
      var _this;
      if (name === void 0) {
        name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
      }
      if (owned === void 0) {
        owned = false;
      }
      _this = _StubArray.call(this) || this;
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _assertThisInitialized(_this);
      addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
      if (initialValues && initialValues.length) {
        var prev = allowStateChangesStart(true);
        _this.spliceWithArray(0, 0, initialValues);
        allowStateChangesEnd(prev);
      }
      {
        Object.defineProperty(_assertThisInitialized(_this), "0", ENTRY_0);
      }
      return _this;
    }
    var _proto = LegacyObservableArray2.prototype;
    _proto.concat = function concat6() {
      this[$mobx].atom_.reportObserved();
      for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
        arrays[_key] = arguments[_key];
      }
      return Array.prototype.concat.apply(
        this.slice(),
        //@ts-ignore
        arrays.map(function(a2) {
          return isObservableArray(a2) ? a2.slice() : a2;
        })
      );
    };
    _proto[_Symbol$iterator2] = function() {
      var self2 = this;
      var nextIndex = 0;
      return makeIterable({
        next: function next() {
          return nextIndex < self2.length ? {
            value: self2[nextIndex++],
            done: false
          } : {
            done: true,
            value: void 0
          };
        }
      });
    };
    _createClass(LegacyObservableArray2, [{
      key: "length",
      get: function get3() {
        return this[$mobx].getArrayLength_();
      },
      set: function set4(newLength) {
        this[$mobx].setArrayLength_(newLength);
      }
    }, {
      key: _Symbol$toStringTag2,
      get: function get3() {
        return "Array";
      }
    }]);
    return LegacyObservableArray2;
  }(StubArray, Symbol.toStringTag, Symbol.iterator);
  Object.entries(arrayExtensions).forEach(function(_ref) {
    var prop = _ref[0], fn = _ref[1];
    if (prop !== "concat") {
      addHiddenProp(LegacyObservableArray.prototype, prop, fn);
    }
  });
  function createArrayEntryDescriptor(index2) {
    return {
      enumerable: false,
      configurable: true,
      get: function get3() {
        return this[$mobx].get_(index2);
      },
      set: function set4(value) {
        this[$mobx].set_(index2, value);
      }
    };
  }
  function createArrayBufferItem(index2) {
    defineProperty(LegacyObservableArray.prototype, "" + index2, createArrayEntryDescriptor(index2));
  }
  function reserveArrayBuffer(max) {
    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
      for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE; index2 < max + 100; index2++) {
        createArrayBufferItem(index2);
      }
      OBSERVABLE_ARRAY_BUFFER_SIZE = max;
    }
  }
  reserveArrayBuffer(1e3);
  function createLegacyArray(initialValues, enhancer, name) {
    return new LegacyObservableArray(initialValues, enhancer, name);
  }
  function getAtom(thing, property7) {
    if (typeof thing === "object" && thing !== null) {
      if (isObservableArray(thing)) {
        if (property7 !== void 0) {
          die(23);
        }
        return thing[$mobx].atom_;
      }
      if (isObservableSet(thing)) {
        return thing.atom_;
      }
      if (isObservableMap(thing)) {
        if (property7 === void 0) {
          return thing.keysAtom_;
        }
        var observable3 = thing.data_.get(property7) || thing.hasMap_.get(property7);
        if (!observable3) {
          die(25, property7, getDebugName(thing));
        }
        return observable3;
      }
      if (isObservableObject(thing)) {
        if (!property7) {
          return die(26);
        }
        var _observable = thing[$mobx].values_.get(property7);
        if (!_observable) {
          die(27, property7, getDebugName(thing));
        }
        return _observable;
      }
      if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
        return thing;
      }
    } else if (isFunction(thing)) {
      if (isReaction(thing[$mobx])) {
        return thing[$mobx];
      }
    }
    die(28);
  }
  function getAdministration(thing, property7) {
    if (!thing) {
      die(29);
    }
    if (property7 !== void 0) {
      return getAdministration(getAtom(thing, property7));
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
    if (isObservableMap(thing) || isObservableSet(thing)) {
      return thing;
    }
    if (thing[$mobx]) {
      return thing[$mobx];
    }
    die(24, thing);
  }
  function getDebugName(thing, property7) {
    var named;
    if (property7 !== void 0) {
      named = getAtom(thing, property7);
    } else if (isAction(thing)) {
      return thing.name;
    } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
      named = getAdministration(thing);
    } else {
      named = getAtom(thing);
    }
    return named.name_;
  }
  var toString = objectPrototype.toString;
  function deepEqual(a2, b4, depth) {
    if (depth === void 0) {
      depth = -1;
    }
    return eq(a2, b4, depth);
  }
  function eq(a2, b4, depth, aStack, bStack) {
    if (a2 === b4) {
      return a2 !== 0 || 1 / a2 === 1 / b4;
    }
    if (a2 == null || b4 == null) {
      return false;
    }
    if (a2 !== a2) {
      return b4 !== b4;
    }
    var type = typeof a2;
    if (type !== "function" && type !== "object" && typeof b4 != "object") {
      return false;
    }
    var className = toString.call(a2);
    if (className !== toString.call(b4)) {
      return false;
    }
    switch (className) {
      case "[object RegExp]":
      case "[object String]":
        return "" + a2 === "" + b4;
      case "[object Number]":
        if (+a2 !== +a2) {
          return +b4 !== +b4;
        }
        return +a2 === 0 ? 1 / +a2 === 1 / b4 : +a2 === +b4;
      case "[object Date]":
      case "[object Boolean]":
        return +a2 === +b4;
      case "[object Symbol]":
        return typeof Symbol !== "undefined" && Symbol.valueOf.call(a2) === Symbol.valueOf.call(b4);
      case "[object Map]":
      case "[object Set]":
        if (depth >= 0) {
          depth++;
        }
        break;
    }
    a2 = unwrap(a2);
    b4 = unwrap(b4);
    var areArrays = className === "[object Array]";
    if (!areArrays) {
      if (typeof a2 != "object" || typeof b4 != "object") {
        return false;
      }
      var aCtor = a2.constructor, bCtor = b4.constructor;
      if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a2 && "constructor" in b4) {
        return false;
      }
    }
    if (depth === 0) {
      return false;
    } else if (depth < 0) {
      depth = -1;
    }
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      if (aStack[length] === a2) {
        return bStack[length] === b4;
      }
    }
    aStack.push(a2);
    bStack.push(b4);
    if (areArrays) {
      length = a2.length;
      if (length !== b4.length) {
        return false;
      }
      while (length--) {
        if (!eq(a2[length], b4[length], depth - 1, aStack, bStack)) {
          return false;
        }
      }
    } else {
      var keys = Object.keys(a2);
      var key;
      length = keys.length;
      if (Object.keys(b4).length !== length) {
        return false;
      }
      while (length--) {
        key = keys[length];
        if (!(hasProp(b4, key) && eq(a2[key], b4[key], depth - 1, aStack, bStack))) {
          return false;
        }
      }
    }
    aStack.pop();
    bStack.pop();
    return true;
  }
  function unwrap(a2) {
    if (isObservableArray(a2)) {
      return a2.slice();
    }
    if (isES6Map(a2) || isObservableMap(a2)) {
      return Array.from(a2.entries());
    }
    if (isES6Set(a2) || isObservableSet(a2)) {
      return Array.from(a2.entries());
    }
    return a2;
  }
  function makeIterable(iterator2) {
    iterator2[Symbol.iterator] = getSelf;
    return iterator2;
  }
  function getSelf() {
    return this;
  }
  function isAnnotation(thing) {
    return (
      // Can be function
      thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
    );
  }
  ["Symbol", "Map", "Set"].forEach(function(m5) {
    var g5 = getGlobal();
    if (typeof g5[m5] === "undefined") {
      die("MobX requires global '" + m5 + "' to be available or polyfilled");
    }
  });
  if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
      spy,
      extras: {
        getDebugName
      },
      $mobx
    });
  }

  // node_modules/@latticexyz/utils/dist/index.js
  var import_proxy_deep = __toESM(require_proxy_deep(), 1);

  // node_modules/tslib/tslib.es6.js
  var extendStatics = function(d6, b4) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d7, b5) {
      d7.__proto__ = b5;
    } || function(d7, b5) {
      for (var p2 in b5)
        if (Object.prototype.hasOwnProperty.call(b5, p2))
          d7[p2] = b5[p2];
    };
    return extendStatics(d6, b4);
  };
  function __extends(d6, b4) {
    if (typeof b4 !== "function" && b4 !== null)
      throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
    extendStatics(d6, b4);
    function __() {
      this.constructor = d6;
    }
    d6.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _18 = { label: 0, sent: function() {
      if (t3[0] & 1)
        throw t3[1];
      return t3[1];
    }, trys: [], ops: [] }, f5, y4, t3, g5;
    return g5 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
      return this;
    }), g5;
    function verb(n4) {
      return function(v7) {
        return step([n4, v7]);
      };
    }
    function step(op) {
      if (f5)
        throw new TypeError("Generator is already executing.");
      while (g5 && (g5 = 0, op[0] && (_18 = 0)), _18)
        try {
          if (f5 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done)
            return t3;
          if (y4 = 0, t3)
            op = [op[0] & 2, t3.value];
          switch (op[0]) {
            case 0:
            case 1:
              t3 = op;
              break;
            case 4:
              _18.label++;
              return { value: op[1], done: false };
            case 5:
              _18.label++;
              y4 = op[1];
              op = [0];
              continue;
            case 7:
              op = _18.ops.pop();
              _18.trys.pop();
              continue;
            default:
              if (!(t3 = _18.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _18 = 0;
                continue;
              }
              if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                _18.label = op[1];
                break;
              }
              if (op[0] === 6 && _18.label < t3[1]) {
                _18.label = t3[1];
                t3 = op;
                break;
              }
              if (t3 && _18.label < t3[2]) {
                _18.label = t3[2];
                _18.ops.push(op);
                break;
              }
              if (t3[2])
                _18.ops.pop();
              _18.trys.pop();
              continue;
          }
          op = body.call(thisArg, _18);
        } catch (e) {
          op = [6, e];
          y4 = 0;
        } finally {
          f5 = t3 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o3) {
    var s4 = typeof Symbol === "function" && Symbol.iterator, m5 = s4 && o3[s4], i4 = 0;
    if (m5)
      return m5.call(o3);
    if (o3 && typeof o3.length === "number")
      return {
        next: function() {
          if (o3 && i4 >= o3.length)
            o3 = void 0;
          return { value: o3 && o3[i4++], done: !o3 };
        }
      };
    throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o3, n4) {
    var m5 = typeof Symbol === "function" && o3[Symbol.iterator];
    if (!m5)
      return o3;
    var i4 = m5.call(o3), r2, ar = [], e;
    try {
      while ((n4 === void 0 || n4-- > 0) && !(r2 = i4.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m5 = i4["return"]))
          m5.call(i4);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i4 = 0, l4 = from2.length, ar; i4 < l4; i4++) {
        if (ar || !(i4 in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i4);
          ar[i4] = from2[i4];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await(v7) {
    return this instanceof __await ? (this.v = v7, this) : new __await(v7);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g5 = generator.apply(thisArg, _arguments || []), i4, q4 = [];
    return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
      return this;
    }, i4;
    function verb(n4) {
      if (g5[n4])
        i4[n4] = function(v7) {
          return new Promise(function(a2, b4) {
            q4.push([n4, v7, a2, b4]) > 1 || resume(n4, v7);
          });
        };
    }
    function resume(n4, v7) {
      try {
        step(g5[n4](v7));
      } catch (e) {
        settle(q4[0][3], e);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q4[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f5, v7) {
      if (f5(v7), q4.shift(), q4.length)
        resume(q4[0][0], q4[0][1]);
    }
  }
  function __asyncValues(o3) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m5 = o3[Symbol.asyncIterator], i4;
    return m5 ? m5.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
      return this;
    }, i4);
    function verb(n4) {
      i4[n4] = o3[n4] && function(v7) {
        return new Promise(function(resolve, reject) {
          v7 = o3[n4](v7), settle(resolve, reject, v7.done, v7.value);
        });
      };
    }
    function settle(resolve, reject, d6, v7) {
      Promise.resolve(v7).then(function(v8) {
        resolve({ value: v8, done: d6 });
      }, reject);
    }
  }

  // node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction2(value) {
    return typeof value === "function";
  }

  // node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors3) {
      _super(this);
      this.message = errors3 ? errors3.length + " errors occurred during unsubscription:\n" + errors3.map(function(err, i4) {
        return i4 + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors3;
    };
  });

  // node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove(arr, item) {
    if (arr) {
      var index2 = arr.indexOf(item);
      0 <= index2 && arr.splice(index2, 1);
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscription.js
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors3;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction2(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors3 = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors3 = errors3 !== null && errors3 !== void 0 ? errors3 : [];
                if (err instanceof UnsubscriptionError) {
                  errors3 = __spreadArray(__spreadArray([], __read(errors3)), __read(err.errors));
                } else {
                  errors3.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                _b.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors3) {
          throw new UnsubscriptionError(errors3);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction2(value.remove) && isFunction2(value.add) && isFunction2(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction2(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }

  // node_modules/rxjs/dist/esm5/internal/config.js
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  // node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop3() {
  }

  // node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  var COMPLETE_NOTIFICATION = function() {
    return createNotification("C", void 0, void 0);
  }();
  function errorNotification(error) {
    return createNotification("E", void 0, error);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }

  // node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  var context = null;
  function errorContext(cb) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error = _a.error;
        context = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }
  function captureError(err) {
    if (config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction2(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      captureError(error);
    } else {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop3,
    error: defaultErrorHandler,
    complete: noop3
  };

  // node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  var observable2 = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  // node_modules/rxjs/dist/esm5/internal/util/identity.js
  function identity(x8) {
    return x8;
  }

  // node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // node_modules/rxjs/dist/esm5/internal/Observable.js
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable3 = new Observable2();
      observable3.source = this;
      observable3.operator = operator;
      return observable3;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable2.prototype[observable2] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x8) {
          return value = x8;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction2(value.next) && isFunction2(value.error) && isFunction2(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  // node_modules/rxjs/dist/esm5/internal/util/lift.js
  function hasLift(source) {
    return isFunction2(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber);

  // node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  // node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable3 = new Observable();
      observable3.source = this;
      return observable3;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);

  // node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);

  // node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
  var dateTimestampProvider = {
    now: function() {
      return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === void 0) {
        _bufferSize = Infinity;
      }
      if (_windowTime === void 0) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === void 0) {
        _timestampProvider = dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
      var copy = _buffer.slice();
      for (var i4 = 0; i4 < copy.length && !subscriber.closed; i4 += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i4]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now2 = _timestampProvider.now();
        var last2 = 0;
        for (var i4 = 1; i4 < _buffer.length && _buffer[i4] <= now2; i4 += 2) {
          last2 = i4;
        }
        last2 && _buffer.splice(0, last2 + 1);
      }
    };
    return ReplaySubject2;
  }(Subject);

  // node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription);

  // node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
  var intervalProvider = {
    setInterval: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = intervalProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
    },
    clearInterval: function(handle) {
      var delegate = intervalProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay2) {
      var _a;
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id3 = this.id;
      var scheduler = this.scheduler;
      if (id3 != null) {
        this.id = this.recycleAsyncId(scheduler, id3, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id3, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 != null && this.delay === delay2 && this.pending === false) {
        return id3;
      }
      if (id3 != null) {
        intervalProvider.clearInterval(id3);
      }
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state, delay2);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a = this, id3 = _a.id, scheduler = _a.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove(actions, this);
        if (id3 != null) {
          this.id = this.recycleAsyncId(scheduler, id3, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action);

  // node_modules/rxjs/dist/esm5/internal/Scheduler.js
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now2) {
      if (now2 === void 0) {
        now2 = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now2;
    }
    Scheduler2.prototype.schedule = function(work, delay2, state) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay2);
    };
    Scheduler2.now = dateTimestampProvider.now;
    return Scheduler2;
  }();

  // node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now2) {
      if (now2 === void 0) {
        now2 = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now2) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action2) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action2);
        return;
      }
      var error;
      this._active = true;
      do {
        if (error = action2.execute(action2.state, action2.delay)) {
          break;
        }
      } while (action2 = actions.shift());
      this._active = false;
      if (error) {
        while (action2 = actions.shift()) {
          action2.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);

  // node_modules/rxjs/dist/esm5/internal/scheduler/async.js
  var asyncScheduler = new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;

  // node_modules/rxjs/dist/esm5/internal/observable/empty.js
  var EMPTY = new Observable(function(subscriber) {
    return subscriber.complete();
  });

  // node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
  function isScheduler(value) {
    return value && isFunction2(value.schedule);
  }

  // node_modules/rxjs/dist/esm5/internal/util/args.js
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args) {
    return isFunction2(last(args)) ? args.pop() : void 0;
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }

  // node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
  var isArrayLike = function(x8) {
    return x8 && typeof x8.length === "number" && typeof x8 !== "function";
  };

  // node_modules/rxjs/dist/esm5/internal/util/isPromise.js
  function isPromise(value) {
    return isFunction2(value === null || value === void 0 ? void 0 : value.then);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
  function isInteropObservable(input) {
    return isFunction2(input[observable2]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction2(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  // node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  // node_modules/rxjs/dist/esm5/internal/util/isIterable.js
  function isIterable(input) {
    return isFunction2(input === null || input === void 0 ? void 0 : input[iterator]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              return [3, 8];
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction2(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable2]();
      if (isFunction2(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array2) {
    return new Observable(function(subscriber) {
      for (var i4 = 0; i4 < array2.length && !subscriber.closed; i4++) {
        subscriber.next(array2[i4]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process2(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
  function executeSchedule(parentSubscription, scheduler, work, delay2, repeat) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay2));
      } else {
        this.unsubscribe();
      }
    }, delay2);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }

  // node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
  function observeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay2);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay2);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay2);
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
  function subscribeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay2));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i4 = 0;
      return scheduler.schedule(function() {
        if (i4 === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i4++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator2;
      executeSchedule(subscriber, scheduler, function() {
        iterator2 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator2.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction2(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/from.js
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/of.js
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }

  // node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
  var EmptyError = createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });

  // node_modules/rxjs/dist/esm5/internal/util/isDate.js
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/map.js
  function map2(project, thisArg) {
    return operate(function(source, subscriber) {
      var index2 = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index2++));
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map2(function(args) {
      return callOrApply(fn, args);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
  var isArray2 = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray2(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }

  // node_modules/rxjs/dist/esm5/internal/util/createObject.js
  function createObject(keys, values) {
    return keys.reduce(function(result, key, i4) {
      return result[key] = values[i4], result;
    }, {});
  }

  // node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
  function combineLatest() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    var resultSelector = popResultSelector(args);
    var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from([], scheduler);
    }
    var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject(keys, values);
    } : identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i5) {
          maybeSchedule(scheduler, function() {
            var source = from(observables[i5], scheduler);
            var hasFirstValue = false;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
              values[i5] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i4 = 0; i4 < length; i4++) {
          _loop_1(i4);
        }
      }, subscriber);
    };
  }
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer2 = [];
    var active = 0;
    var index2 = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer2.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer2.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index2++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer2.shift();
              if (innerSubScheduler) {
                executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer2.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction2(resultSelector)) {
      return mergeMap(function(a2, i4) {
        return map2(function(b4, ii) {
          return resultSelector(a2, b4, i4, ii);
        })(innerFrom(project(a2, i4)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source, subscriber) {
      return mergeInternals(source, subscriber, project, concurrent);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity, concurrent);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
  function concatAll() {
    return mergeAll(1);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/concat.js
  function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll()(from(args, popScheduler(args)));
  }

  // node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction2(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add3 = _a[0], remove2 = _a[1];
    if (!add3) {
      if (isArrayLike(target)) {
        return mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom(target));
      }
    }
    if (!add3) {
      throw new TypeError("Invalid event target");
    }
    return new Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add3(handler);
      return function() {
        return remove2(handler);
      };
    });
  }
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction2(target.addListener) && isFunction2(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction2(target.on) && isFunction2(target.off);
  }
  function isEventTarget(target) {
    return isFunction2(target.addEventListener) && isFunction2(target.removeEventListener);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/timer.js
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable(function(subscriber) {
      var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n4 = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n4++);
          if (0 <= intervalDuration) {
            this.schedule(void 0, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return operate(function(source, subscriber) {
      var index2 = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index2++) && subscriber.next(value);
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/observable/range.js
  function range(start, count, scheduler) {
    if (count == null) {
      count = start;
      start = 0;
    }
    if (count <= 0) {
      return EMPTY;
    }
    var end = count + start;
    return new Observable(scheduler ? function(subscriber) {
      var n4 = start;
      return scheduler.schedule(function() {
        if (n4 < end) {
          subscriber.next(n4++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n4 = start;
      while (n4 < end && !subscriber.closed) {
        subscriber.next(n4++);
      }
      subscriber.complete();
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js
  function bufferTime(bufferTimeSpan) {
    var _a, _b;
    var otherArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
    var maxBufferSize = otherArgs[1] || Infinity;
    return operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var buffer2 = record.buffer, subs = record.subs;
        subs.unsubscribe();
        arrRemove(bufferRecords, record);
        subscriber.next(buffer2);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription();
          subscriber.add(subs);
          var buffer2 = [];
          var record_1 = {
            buffer: buffer2,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer2 = record.buffer;
            buffer2.push(value);
            maxBufferSize <= buffer2.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
              _a2.call(recordsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, void 0, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index2 = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var i4 = index2++;
        state = hasState ? accumulator(state, value, i4) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
  function concatMap(project, resultSelector) {
    return isFunction2(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
  function defaultIfEmpty(defaultValue) {
    return operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/take.js
  function take(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
  function ignoreElements() {
    return operate(function(source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, noop3));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
  function mapTo(value) {
    return map2(function() {
      return value;
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
  function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
      };
    }
    return mergeMap(function(value, index2) {
      return innerFrom(delayDurationSelector(value, index2)).pipe(take(1), mapTo(value));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/delay.js
  function delay(due, scheduler) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    var duration = timer(due, scheduler);
    return delayWhen(function() {
      return duration;
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  function defaultErrorFactory() {
    return new EmptyError();
  }

  // node_modules/rxjs/dist/esm5/internal/operators/endWith.js
  function endWith() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return function(source) {
      return concat(source, of.apply(void 0, __spreadArray([], __read(values))));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/first.js
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter(function(v7, i4) {
        return predicate(v7, i4, source);
      }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/scan.js
  function scan(accumulator, seed) {
    return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
  }

  // node_modules/rxjs/dist/esm5/internal/operators/throttle.js
  function throttle(durationSelector, config2) {
    return operate(function(source, subscriber) {
      var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value) {
        return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send = function() {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
  function throttleTime(duration, scheduler, config2) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }
    var duration$ = timer(duration, scheduler);
    return throttle(function() {
      return duration$;
    }, config2);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/timestamp.js
  function timestamp(timestampProvider) {
    if (timestampProvider === void 0) {
      timestampProvider = dateTimestampProvider;
    }
    return map2(function(value) {
      return { value, timestamp: timestampProvider.now() };
    });
  }

  // node_modules/ethers/lib.esm/ethers.js
  var ethers_exports = {};
  __export(ethers_exports, {
    BaseContract: () => BaseContract,
    BigNumber: () => import_bignumber7.BigNumber,
    Contract: () => Contract,
    ContractFactory: () => ContractFactory,
    FixedNumber: () => import_bignumber7.FixedNumber,
    Signer: () => import_abstract_signer3.Signer,
    VoidSigner: () => import_abstract_signer3.VoidSigner,
    Wallet: () => import_wallet2.Wallet,
    Wordlist: () => import_wordlists.Wordlist,
    constants: () => constants,
    errors: () => import_logger20.ErrorCode,
    getDefaultProvider: () => getDefaultProvider,
    logger: () => logger18,
    providers: () => lib_exports,
    utils: () => utils_exports,
    version: () => version4,
    wordlists: () => import_wordlists.wordlists
  });

  // node_modules/@ethersproject/contracts/lib.esm/index.js
  var import_abi = __toESM(require_lib13());
  var import_abstract_provider = __toESM(require_lib14());
  var import_abstract_signer = __toESM(require_lib15());
  var import_address = __toESM(require_lib7());
  var import_bignumber = __toESM(require_lib3());
  var import_bytes = __toESM(require_lib2());
  var import_properties = __toESM(require_lib4());
  var import_transactions = __toESM(require_lib17());
  var import_logger = __toESM(require_lib());

  // node_modules/@ethersproject/contracts/lib.esm/_version.js
  var version = "contracts/5.7.0";

  // node_modules/@ethersproject/contracts/lib.esm/index.js
  var __awaiter2 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger = new import_logger.Logger(version);
  var allowedTransactionKeys = {
    chainId: true,
    data: true,
    from: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true,
    customData: true,
    ccipReadEnabled: true
  };
  function resolveName(resolver, nameOrPromise) {
    return __awaiter2(this, void 0, void 0, function* () {
      const name = yield nameOrPromise;
      if (typeof name !== "string") {
        logger.throwArgumentError("invalid address or ENS name", "name", name);
      }
      try {
        return (0, import_address.getAddress)(name);
      } catch (error) {
      }
      if (!resolver) {
        logger.throwError("a provider or signer is needed to resolve ENS names", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "resolveName"
        });
      }
      const address = yield resolver.resolveName(name);
      if (address == null) {
        logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
      }
      return address;
    });
  }
  function resolveAddresses(resolver, value, paramType) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (Array.isArray(paramType)) {
        return yield Promise.all(paramType.map((paramType2, index2) => {
          return resolveAddresses(resolver, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
        }));
      }
      if (paramType.type === "address") {
        return yield resolveName(resolver, value);
      }
      if (paramType.type === "tuple") {
        return yield resolveAddresses(resolver, value, paramType.components);
      }
      if (paramType.baseType === "array") {
        if (!Array.isArray(value)) {
          return Promise.reject(logger.makeError("invalid value for array", import_logger.Logger.errors.INVALID_ARGUMENT, {
            argument: "value",
            value
          }));
        }
        return yield Promise.all(value.map((v7) => resolveAddresses(resolver, v7, paramType.arrayChildren)));
      }
      return value;
    });
  }
  function populateTransaction(contract, fragment, args) {
    return __awaiter2(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        overrides = (0, import_properties.shallowCopy)(args.pop());
      }
      logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
      if (contract.signer) {
        if (overrides.from) {
          overrides.from = (0, import_properties.resolveProperties)({
            override: resolveName(contract.signer, overrides.from),
            signer: contract.signer.getAddress()
          }).then((check) => __awaiter2(this, void 0, void 0, function* () {
            if ((0, import_address.getAddress)(check.signer) !== check.override) {
              logger.throwError("Contract with a Signer cannot override from", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.from"
              });
            }
            return check.override;
          }));
        } else {
          overrides.from = contract.signer.getAddress();
        }
      } else if (overrides.from) {
        overrides.from = resolveName(contract.provider, overrides.from);
      }
      const resolved = yield (0, import_properties.resolveProperties)({
        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
        address: contract.resolvedAddress,
        overrides: (0, import_properties.resolveProperties)(overrides) || {}
      });
      const data = contract.interface.encodeFunctionData(fragment, resolved.args);
      const tx = {
        data,
        to: resolved.address
      };
      const ro = resolved.overrides;
      if (ro.nonce != null) {
        tx.nonce = import_bignumber.BigNumber.from(ro.nonce).toNumber();
      }
      if (ro.gasLimit != null) {
        tx.gasLimit = import_bignumber.BigNumber.from(ro.gasLimit);
      }
      if (ro.gasPrice != null) {
        tx.gasPrice = import_bignumber.BigNumber.from(ro.gasPrice);
      }
      if (ro.maxFeePerGas != null) {
        tx.maxFeePerGas = import_bignumber.BigNumber.from(ro.maxFeePerGas);
      }
      if (ro.maxPriorityFeePerGas != null) {
        tx.maxPriorityFeePerGas = import_bignumber.BigNumber.from(ro.maxPriorityFeePerGas);
      }
      if (ro.from != null) {
        tx.from = ro.from;
      }
      if (ro.type != null) {
        tx.type = ro.type;
      }
      if (ro.accessList != null) {
        tx.accessList = (0, import_transactions.accessListify)(ro.accessList);
      }
      if (tx.gasLimit == null && fragment.gas != null) {
        let intrinsic = 21e3;
        const bytes2 = (0, import_bytes.arrayify)(data);
        for (let i4 = 0; i4 < bytes2.length; i4++) {
          intrinsic += 4;
          if (bytes2[i4]) {
            intrinsic += 64;
          }
        }
        tx.gasLimit = import_bignumber.BigNumber.from(fragment.gas).add(intrinsic);
      }
      if (ro.value) {
        const roValue = import_bignumber.BigNumber.from(ro.value);
        if (!roValue.isZero() && !fragment.payable) {
          logger.throwError("non-payable method cannot override value", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides.value",
            value: overrides.value
          });
        }
        tx.value = roValue;
      }
      if (ro.customData) {
        tx.customData = (0, import_properties.shallowCopy)(ro.customData);
      }
      if (ro.ccipReadEnabled) {
        tx.ccipReadEnabled = !!ro.ccipReadEnabled;
      }
      delete overrides.nonce;
      delete overrides.gasLimit;
      delete overrides.gasPrice;
      delete overrides.from;
      delete overrides.value;
      delete overrides.type;
      delete overrides.accessList;
      delete overrides.maxFeePerGas;
      delete overrides.maxPriorityFeePerGas;
      delete overrides.customData;
      delete overrides.ccipReadEnabled;
      const leftovers = Object.keys(overrides).filter((key) => overrides[key] != null);
      if (leftovers.length) {
        logger.throwError(`cannot override ${leftovers.map((l4) => JSON.stringify(l4)).join(",")}`, import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides",
          overrides: leftovers
        });
      }
      return tx;
    });
  }
  function buildPopulate(contract, fragment) {
    return function(...args) {
      return populateTransaction(contract, fragment, args);
    };
  }
  function buildEstimate(contract, fragment) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (!signerOrProvider) {
          logger.throwError("estimate require a provider or signer", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "estimateGas"
          });
        }
        const tx = yield populateTransaction(contract, fragment, args);
        return yield signerOrProvider.estimateGas(tx);
      });
    };
  }
  function addContractWait(contract, tx) {
    const wait2 = tx.wait.bind(tx);
    tx.wait = (confirmations) => {
      return wait2(confirmations).then((receipt) => {
        receipt.events = receipt.logs.map((log) => {
          let event = (0, import_properties.deepCopy)(log);
          let parsed = null;
          try {
            parsed = contract.interface.parseLog(log);
          } catch (e) {
          }
          if (parsed) {
            event.args = parsed.args;
            event.decode = (data, topics) => {
              return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
            };
            event.event = parsed.name;
            event.eventSignature = parsed.signature;
          }
          event.removeListener = () => {
            return contract.provider;
          };
          event.getBlock = () => {
            return contract.provider.getBlock(receipt.blockHash);
          };
          event.getTransaction = () => {
            return contract.provider.getTransaction(receipt.transactionHash);
          };
          event.getTransactionReceipt = () => {
            return Promise.resolve(receipt);
          };
          return event;
        });
        return receipt;
      });
    };
  }
  function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
      return __awaiter2(this, void 0, void 0, function* () {
        let blockTag = void 0;
        if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          const overrides = (0, import_properties.shallowCopy)(args.pop());
          if (overrides.blockTag != null) {
            blockTag = yield overrides.blockTag;
          }
          delete overrides.blockTag;
          args.push(overrides);
        }
        if (contract.deployTransaction != null) {
          yield contract._deployed(blockTag);
        }
        const tx = yield populateTransaction(contract, fragment, args);
        const result = yield signerOrProvider.call(tx, blockTag);
        try {
          let value = contract.interface.decodeFunctionResult(fragment, result);
          if (collapseSimple && fragment.outputs.length === 1) {
            value = value[0];
          }
          return value;
        } catch (error) {
          if (error.code === import_logger.Logger.errors.CALL_EXCEPTION) {
            error.address = contract.address;
            error.args = args;
            error.transaction = tx;
          }
          throw error;
        }
      });
    };
  }
  function buildSend(contract, fragment) {
    return function(...args) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (!contract.signer) {
          logger.throwError("sending a transaction requires a signer", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "sendTransaction"
          });
        }
        if (contract.deployTransaction != null) {
          yield contract._deployed();
        }
        const txRequest = yield populateTransaction(contract, fragment, args);
        const tx = yield contract.signer.sendTransaction(txRequest);
        addContractWait(contract, tx);
        return tx;
      });
    };
  }
  function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) {
      return buildCall(contract, fragment, collapseSimple);
    }
    return buildSend(contract, fragment);
  }
  function getEventTag(filter2) {
    if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
      return "*";
    }
    return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
      if (Array.isArray(topic)) {
        return topic.join("|");
      }
      return topic;
    }).join(":") : "");
  }
  var RunningEvent = class {
    constructor(tag, filter2) {
      (0, import_properties.defineReadOnly)(this, "tag", tag);
      (0, import_properties.defineReadOnly)(this, "filter", filter2);
      this._listeners = [];
    }
    addListener(listener, once2) {
      this._listeners.push({ listener, once: once2 });
    }
    removeListener(listener) {
      let done = false;
      this._listeners = this._listeners.filter((item) => {
        if (done || item.listener !== listener) {
          return true;
        }
        done = true;
        return false;
      });
    }
    removeAllListeners() {
      this._listeners = [];
    }
    listeners() {
      return this._listeners.map((i4) => i4.listener);
    }
    listenerCount() {
      return this._listeners.length;
    }
    run(args) {
      const listenerCount = this.listenerCount();
      this._listeners = this._listeners.filter((item) => {
        const argsCopy = args.slice();
        setTimeout(() => {
          item.listener.apply(this, argsCopy);
        }, 0);
        return !item.once;
      });
      return listenerCount;
    }
    prepareEvent(event) {
    }
    // Returns the array that will be applied to an emit
    getEmit(event) {
      return [event];
    }
  };
  var ErrorRunningEvent = class extends RunningEvent {
    constructor() {
      super("error", null);
    }
  };
  var FragmentRunningEvent = class extends RunningEvent {
    constructor(address, contractInterface, fragment, topics) {
      const filter2 = {
        address
      };
      let topic = contractInterface.getEventTopic(fragment);
      if (topics) {
        if (topic !== topics[0]) {
          logger.throwArgumentError("topic mismatch", "topics", topics);
        }
        filter2.topics = topics.slice();
      } else {
        filter2.topics = [topic];
      }
      super(getEventTag(filter2), filter2);
      (0, import_properties.defineReadOnly)(this, "address", address);
      (0, import_properties.defineReadOnly)(this, "interface", contractInterface);
      (0, import_properties.defineReadOnly)(this, "fragment", fragment);
    }
    prepareEvent(event) {
      super.prepareEvent(event);
      event.event = this.fragment.name;
      event.eventSignature = this.fragment.format();
      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(this.fragment, data, topics);
      };
      try {
        event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
      } catch (error) {
        event.args = null;
        event.decodeError = error;
      }
    }
    getEmit(event) {
      const errors3 = (0, import_abi.checkResultErrors)(event.args);
      if (errors3.length) {
        throw errors3[0].error;
      }
      const args = (event.args || []).slice();
      args.push(event);
      return args;
    }
  };
  var WildcardRunningEvent = class extends RunningEvent {
    constructor(address, contractInterface) {
      super("*", { address });
      (0, import_properties.defineReadOnly)(this, "address", address);
      (0, import_properties.defineReadOnly)(this, "interface", contractInterface);
    }
    prepareEvent(event) {
      super.prepareEvent(event);
      try {
        const parsed = this.interface.parseLog(event);
        event.event = parsed.name;
        event.eventSignature = parsed.signature;
        event.decode = (data, topics) => {
          return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
        };
        event.args = parsed.args;
      } catch (error) {
      }
    }
  };
  var BaseContract = class {
    constructor(addressOrName, contractInterface, signerOrProvider) {
      (0, import_properties.defineReadOnly)(this, "interface", (0, import_properties.getStatic)(new.target, "getInterface")(contractInterface));
      if (signerOrProvider == null) {
        (0, import_properties.defineReadOnly)(this, "provider", null);
        (0, import_properties.defineReadOnly)(this, "signer", null);
      } else if (import_abstract_signer.Signer.isSigner(signerOrProvider)) {
        (0, import_properties.defineReadOnly)(this, "provider", signerOrProvider.provider || null);
        (0, import_properties.defineReadOnly)(this, "signer", signerOrProvider);
      } else if (import_abstract_provider.Provider.isProvider(signerOrProvider)) {
        (0, import_properties.defineReadOnly)(this, "provider", signerOrProvider);
        (0, import_properties.defineReadOnly)(this, "signer", null);
      } else {
        logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
      }
      (0, import_properties.defineReadOnly)(this, "callStatic", {});
      (0, import_properties.defineReadOnly)(this, "estimateGas", {});
      (0, import_properties.defineReadOnly)(this, "functions", {});
      (0, import_properties.defineReadOnly)(this, "populateTransaction", {});
      (0, import_properties.defineReadOnly)(this, "filters", {});
      {
        const uniqueFilters = {};
        Object.keys(this.interface.events).forEach((eventSignature) => {
          const event = this.interface.events[eventSignature];
          (0, import_properties.defineReadOnly)(this.filters, eventSignature, (...args) => {
            return {
              address: this.address,
              topics: this.interface.encodeFilterTopics(event, args)
            };
          });
          if (!uniqueFilters[event.name]) {
            uniqueFilters[event.name] = [];
          }
          uniqueFilters[event.name].push(eventSignature);
        });
        Object.keys(uniqueFilters).forEach((name) => {
          const filters = uniqueFilters[name];
          if (filters.length === 1) {
            (0, import_properties.defineReadOnly)(this.filters, name, this.filters[filters[0]]);
          } else {
            logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
          }
        });
      }
      (0, import_properties.defineReadOnly)(this, "_runningEvents", {});
      (0, import_properties.defineReadOnly)(this, "_wrappedEmits", {});
      if (addressOrName == null) {
        logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
      }
      (0, import_properties.defineReadOnly)(this, "address", addressOrName);
      if (this.provider) {
        (0, import_properties.defineReadOnly)(this, "resolvedAddress", resolveName(this.provider, addressOrName));
      } else {
        try {
          (0, import_properties.defineReadOnly)(this, "resolvedAddress", Promise.resolve((0, import_address.getAddress)(addressOrName)));
        } catch (error) {
          logger.throwError("provider is required to use ENS name as contract address", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Contract"
          });
        }
      }
      this.resolvedAddress.catch((e) => {
      });
      const uniqueNames = {};
      const uniqueSignatures = {};
      Object.keys(this.interface.functions).forEach((signature) => {
        const fragment = this.interface.functions[signature];
        if (uniqueSignatures[signature]) {
          logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
          return;
        }
        uniqueSignatures[signature] = true;
        {
          const name = fragment.name;
          if (!uniqueNames[`%${name}`]) {
            uniqueNames[`%${name}`] = [];
          }
          uniqueNames[`%${name}`].push(signature);
        }
        if (this[signature] == null) {
          (0, import_properties.defineReadOnly)(this, signature, buildDefault(this, fragment, true));
        }
        if (this.functions[signature] == null) {
          (0, import_properties.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));
        }
        if (this.callStatic[signature] == null) {
          (0, import_properties.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));
        }
        if (this.populateTransaction[signature] == null) {
          (0, import_properties.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));
        }
        if (this.estimateGas[signature] == null) {
          (0, import_properties.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));
        }
      });
      Object.keys(uniqueNames).forEach((name) => {
        const signatures = uniqueNames[name];
        if (signatures.length > 1) {
          return;
        }
        name = name.substring(1);
        const signature = signatures[0];
        try {
          if (this[name] == null) {
            (0, import_properties.defineReadOnly)(this, name, this[signature]);
          }
        } catch (e) {
        }
        if (this.functions[name] == null) {
          (0, import_properties.defineReadOnly)(this.functions, name, this.functions[signature]);
        }
        if (this.callStatic[name] == null) {
          (0, import_properties.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);
        }
        if (this.populateTransaction[name] == null) {
          (0, import_properties.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);
        }
        if (this.estimateGas[name] == null) {
          (0, import_properties.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);
        }
      });
    }
    static getContractAddress(transaction2) {
      return (0, import_address.getContractAddress)(transaction2);
    }
    static getInterface(contractInterface) {
      if (import_abi.Interface.isInterface(contractInterface)) {
        return contractInterface;
      }
      return new import_abi.Interface(contractInterface);
    }
    // @TODO: Allow timeout?
    deployed() {
      return this._deployed();
    }
    _deployed(blockTag) {
      if (!this._deployedPromise) {
        if (this.deployTransaction) {
          this._deployedPromise = this.deployTransaction.wait().then(() => {
            return this;
          });
        } else {
          this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
            if (code === "0x") {
              logger.throwError("contract not deployed", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
                contractAddress: this.address,
                operation: "getDeployed"
              });
            }
            return this;
          });
        }
      }
      return this._deployedPromise;
    }
    // @TODO:
    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
    // @TODO:
    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
    fallback(overrides) {
      if (!this.signer) {
        logger.throwError("sending a transactions require a signer", import_logger.Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
      }
      const tx = (0, import_properties.shallowCopy)(overrides || {});
      ["from", "to"].forEach(function(key) {
        if (tx[key] == null) {
          return;
        }
        logger.throwError("cannot override " + key, import_logger.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
      });
      tx.to = this.resolvedAddress;
      return this.deployed().then(() => {
        return this.signer.sendTransaction(tx);
      });
    }
    // Reconnect to a different signer or provider
    connect(signerOrProvider) {
      if (typeof signerOrProvider === "string") {
        signerOrProvider = new import_abstract_signer.VoidSigner(signerOrProvider, this.provider);
      }
      const contract = new this.constructor(this.address, this.interface, signerOrProvider);
      if (this.deployTransaction) {
        (0, import_properties.defineReadOnly)(contract, "deployTransaction", this.deployTransaction);
      }
      return contract;
    }
    // Re-attach to a different on-chain instance of this contract
    attach(addressOrName) {
      return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
      return import_abi.Indexed.isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
      if (this._runningEvents[runningEvent.tag]) {
        return this._runningEvents[runningEvent.tag];
      }
      return runningEvent;
    }
    _getRunningEvent(eventName) {
      if (typeof eventName === "string") {
        if (eventName === "error") {
          return this._normalizeRunningEvent(new ErrorRunningEvent());
        }
        if (eventName === "event") {
          return this._normalizeRunningEvent(new RunningEvent("event", null));
        }
        if (eventName === "*") {
          return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
        }
        const fragment = this.interface.getEvent(eventName);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
      }
      if (eventName.topics && eventName.topics.length > 0) {
        try {
          const topic = eventName.topics[0];
          if (typeof topic !== "string") {
            throw new Error("invalid topic");
          }
          const fragment = this.interface.getEvent(topic);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
        } catch (error) {
        }
        const filter2 = {
          address: this.address,
          topics: eventName.topics
        };
        return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter2), filter2));
      }
      return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
      if (runningEvent.listenerCount() === 0) {
        delete this._runningEvents[runningEvent.tag];
        const emit = this._wrappedEmits[runningEvent.tag];
        if (emit && runningEvent.filter) {
          this.provider.off(runningEvent.filter, emit);
          delete this._wrappedEmits[runningEvent.tag];
        }
      }
    }
    // Subclasses can override this to gracefully recover
    // from parse errors if they wish
    _wrapEvent(runningEvent, log, listener) {
      const event = (0, import_properties.deepCopy)(log);
      event.removeListener = () => {
        if (!listener) {
          return;
        }
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
      };
      event.getBlock = () => {
        return this.provider.getBlock(log.blockHash);
      };
      event.getTransaction = () => {
        return this.provider.getTransaction(log.transactionHash);
      };
      event.getTransactionReceipt = () => {
        return this.provider.getTransactionReceipt(log.transactionHash);
      };
      runningEvent.prepareEvent(event);
      return event;
    }
    _addEventListener(runningEvent, listener, once2) {
      if (!this.provider) {
        logger.throwError("events require a provider or a signer with a provider", import_logger.Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
      }
      runningEvent.addListener(listener, once2);
      this._runningEvents[runningEvent.tag] = runningEvent;
      if (!this._wrappedEmits[runningEvent.tag]) {
        const wrappedEmit = (log) => {
          let event = this._wrapEvent(runningEvent, log, listener);
          if (event.decodeError == null) {
            try {
              const args = runningEvent.getEmit(event);
              this.emit(runningEvent.filter, ...args);
            } catch (error) {
              event.decodeError = error.error;
            }
          }
          if (runningEvent.filter != null) {
            this.emit("event", event);
          }
          if (event.decodeError != null) {
            this.emit("error", event.decodeError, event);
          }
        };
        this._wrappedEmits[runningEvent.tag] = wrappedEmit;
        if (runningEvent.filter != null) {
          this.provider.on(runningEvent.filter, wrappedEmit);
        }
      }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
      const runningEvent = this._getRunningEvent(event);
      const filter2 = (0, import_properties.shallowCopy)(runningEvent.filter);
      if (typeof fromBlockOrBlockhash === "string" && (0, import_bytes.isHexString)(fromBlockOrBlockhash, 32)) {
        if (toBlock != null) {
          logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
        }
        filter2.blockHash = fromBlockOrBlockhash;
      } else {
        filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
        filter2.toBlock = toBlock != null ? toBlock : "latest";
      }
      return this.provider.getLogs(filter2).then((logs) => {
        return logs.map((log) => this._wrapEvent(runningEvent, log, null));
      });
    }
    on(event, listener) {
      this._addEventListener(this._getRunningEvent(event), listener, false);
      return this;
    }
    once(event, listener) {
      this._addEventListener(this._getRunningEvent(event), listener, true);
      return this;
    }
    emit(eventName, ...args) {
      if (!this.provider) {
        return false;
      }
      const runningEvent = this._getRunningEvent(eventName);
      const result = runningEvent.run(args) > 0;
      this._checkRunningEvents(runningEvent);
      return result;
    }
    listenerCount(eventName) {
      if (!this.provider) {
        return 0;
      }
      if (eventName == null) {
        return Object.keys(this._runningEvents).reduce((accum, key) => {
          return accum + this._runningEvents[key].listenerCount();
        }, 0);
      }
      return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
      if (!this.provider) {
        return [];
      }
      if (eventName == null) {
        const result = [];
        for (let tag in this._runningEvents) {
          this._runningEvents[tag].listeners().forEach((listener) => {
            result.push(listener);
          });
        }
        return result;
      }
      return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
      if (!this.provider) {
        return this;
      }
      if (eventName == null) {
        for (const tag in this._runningEvents) {
          const runningEvent2 = this._runningEvents[tag];
          runningEvent2.removeAllListeners();
          this._checkRunningEvents(runningEvent2);
        }
        return this;
      }
      const runningEvent = this._getRunningEvent(eventName);
      runningEvent.removeAllListeners();
      this._checkRunningEvents(runningEvent);
      return this;
    }
    off(eventName, listener) {
      if (!this.provider) {
        return this;
      }
      const runningEvent = this._getRunningEvent(eventName);
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
      return this;
    }
    removeListener(eventName, listener) {
      return this.off(eventName, listener);
    }
  };
  var Contract = class extends BaseContract {
  };
  var ContractFactory = class {
    constructor(contractInterface, bytecode, signer) {
      let bytecodeHex = null;
      if (typeof bytecode === "string") {
        bytecodeHex = bytecode;
      } else if ((0, import_bytes.isBytes)(bytecode)) {
        bytecodeHex = (0, import_bytes.hexlify)(bytecode);
      } else if (bytecode && typeof bytecode.object === "string") {
        bytecodeHex = bytecode.object;
      } else {
        bytecodeHex = "!";
      }
      if (bytecodeHex.substring(0, 2) !== "0x") {
        bytecodeHex = "0x" + bytecodeHex;
      }
      if (!(0, import_bytes.isHexString)(bytecodeHex) || bytecodeHex.length % 2) {
        logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
      }
      if (signer && !import_abstract_signer.Signer.isSigner(signer)) {
        logger.throwArgumentError("invalid signer", "signer", signer);
      }
      (0, import_properties.defineReadOnly)(this, "bytecode", bytecodeHex);
      (0, import_properties.defineReadOnly)(this, "interface", (0, import_properties.getStatic)(new.target, "getInterface")(contractInterface));
      (0, import_properties.defineReadOnly)(this, "signer", signer || null);
    }
    // @TODO: Future; rename to populateTransaction?
    getDeployTransaction(...args) {
      let tx = {};
      if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        tx = (0, import_properties.shallowCopy)(args.pop());
        for (const key in tx) {
          if (!allowedTransactionKeys[key]) {
            throw new Error("unknown transaction override " + key);
          }
        }
      }
      ["data", "from", "to"].forEach((key) => {
        if (tx[key] == null) {
          return;
        }
        logger.throwError("cannot override " + key, import_logger.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
      });
      if (tx.value) {
        const value = import_bignumber.BigNumber.from(tx.value);
        if (!value.isZero() && !this.interface.deploy.payable) {
          logger.throwError("non-payable constructor cannot override value", import_logger.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides.value",
            value: tx.value
          });
        }
      }
      logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      tx.data = (0, import_bytes.hexlify)((0, import_bytes.concat)([
        this.bytecode,
        this.interface.encodeDeploy(args)
      ]));
      return tx;
    }
    deploy(...args) {
      return __awaiter2(this, void 0, void 0, function* () {
        let overrides = {};
        if (args.length === this.interface.deploy.inputs.length + 1) {
          overrides = args.pop();
        }
        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
        params.push(overrides);
        const unsignedTx = this.getDeployTransaction(...params);
        const tx = yield this.signer.sendTransaction(unsignedTx);
        const address = (0, import_properties.getStatic)(this.constructor, "getContractAddress")(tx);
        const contract = (0, import_properties.getStatic)(this.constructor, "getContract")(address, this.interface, this.signer);
        addContractWait(contract, tx);
        (0, import_properties.defineReadOnly)(contract, "deployTransaction", tx);
        return contract;
      });
    }
    attach(address) {
      return this.constructor.getContract(address, this.interface, this.signer);
    }
    connect(signer) {
      return new this.constructor(this.interface, this.bytecode, signer);
    }
    static fromSolidity(compilerOutput, signer) {
      if (compilerOutput == null) {
        logger.throwError("missing compiler output", import_logger.Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
      }
      if (typeof compilerOutput === "string") {
        compilerOutput = JSON.parse(compilerOutput);
      }
      const abi = compilerOutput.abi;
      let bytecode = null;
      if (compilerOutput.bytecode) {
        bytecode = compilerOutput.bytecode;
      } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
        bytecode = compilerOutput.evm.bytecode;
      }
      return new this(abi, bytecode, signer);
    }
    static getInterface(contractInterface) {
      return Contract.getInterface(contractInterface);
    }
    static getContractAddress(tx) {
      return (0, import_address.getContractAddress)(tx);
    }
    static getContract(address, contractInterface, signer) {
      return new Contract(address, contractInterface, signer);
    }
  };

  // node_modules/ethers/lib.esm/ethers.js
  var import_bignumber7 = __toESM(require_lib3());
  var import_abstract_signer3 = __toESM(require_lib15());
  var import_wallet2 = __toESM(require_lib25());
  var constants = __toESM(require_lib8());

  // node_modules/@ethersproject/providers/lib.esm/index.js
  var lib_exports = {};
  __export(lib_exports, {
    AlchemyProvider: () => AlchemyProvider,
    AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
    AnkrProvider: () => AnkrProvider,
    BaseProvider: () => BaseProvider,
    CloudflareProvider: () => CloudflareProvider,
    EtherscanProvider: () => EtherscanProvider,
    FallbackProvider: () => FallbackProvider,
    Formatter: () => Formatter,
    InfuraProvider: () => InfuraProvider,
    InfuraWebSocketProvider: () => InfuraWebSocketProvider,
    IpcProvider: () => IpcProvider,
    JsonRpcBatchProvider: () => JsonRpcBatchProvider,
    JsonRpcProvider: () => JsonRpcProvider,
    JsonRpcSigner: () => JsonRpcSigner,
    NodesmithProvider: () => NodesmithProvider,
    PocketProvider: () => PocketProvider,
    Provider: () => import_abstract_provider4.Provider,
    Resolver: () => Resolver,
    StaticJsonRpcProvider: () => StaticJsonRpcProvider,
    UrlJsonRpcProvider: () => UrlJsonRpcProvider,
    Web3Provider: () => Web3Provider,
    WebSocketProvider: () => WebSocketProvider,
    getDefaultProvider: () => getDefaultProvider,
    getNetwork: () => getNetwork,
    isCommunityResourcable: () => isCommunityResourcable,
    isCommunityResource: () => isCommunityResource,
    showThrottleMessage: () => showThrottleMessage
  });
  var import_abstract_provider4 = __toESM(require_lib14());

  // node_modules/@ethersproject/networks/lib.esm/index.js
  var import_logger2 = __toESM(require_lib());

  // node_modules/@ethersproject/networks/lib.esm/_version.js
  var version2 = "networks/5.7.1";

  // node_modules/@ethersproject/networks/lib.esm/index.js
  var logger2 = new import_logger2.Logger(version2);
  function isRenetworkable(value) {
    return value && typeof value.renetwork === "function";
  }
  function ethDefaultProvider(network) {
    const func = function(providers, options) {
      if (options == null) {
        options = {};
      }
      const providerList = [];
      if (providers.InfuraProvider && options.infura !== "-") {
        try {
          providerList.push(new providers.InfuraProvider(network, options.infura));
        } catch (error) {
        }
      }
      if (providers.EtherscanProvider && options.etherscan !== "-") {
        try {
          providerList.push(new providers.EtherscanProvider(network, options.etherscan));
        } catch (error) {
        }
      }
      if (providers.AlchemyProvider && options.alchemy !== "-") {
        try {
          providerList.push(new providers.AlchemyProvider(network, options.alchemy));
        } catch (error) {
        }
      }
      if (providers.PocketProvider && options.pocket !== "-") {
        const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
        try {
          const provider = new providers.PocketProvider(network, options.pocket);
          if (provider.network && skip.indexOf(provider.network.name) === -1) {
            providerList.push(provider);
          }
        } catch (error) {
        }
      }
      if (providers.CloudflareProvider && options.cloudflare !== "-") {
        try {
          providerList.push(new providers.CloudflareProvider(network));
        } catch (error) {
        }
      }
      if (providers.AnkrProvider && options.ankr !== "-") {
        try {
          const skip = ["ropsten"];
          const provider = new providers.AnkrProvider(network, options.ankr);
          if (provider.network && skip.indexOf(provider.network.name) === -1) {
            providerList.push(provider);
          }
        } catch (error) {
        }
      }
      if (providerList.length === 0) {
        return null;
      }
      if (providers.FallbackProvider) {
        let quorum = 1;
        if (options.quorum != null) {
          quorum = options.quorum;
        } else if (network === "homestead") {
          quorum = 2;
        }
        return new providers.FallbackProvider(providerList, quorum);
      }
      return providerList[0];
    };
    func.renetwork = function(network2) {
      return ethDefaultProvider(network2);
    };
    return func;
  }
  function etcDefaultProvider(url, network) {
    const func = function(providers, options) {
      if (providers.JsonRpcProvider) {
        return new providers.JsonRpcProvider(url, network);
      }
      return null;
    };
    func.renetwork = function(network2) {
      return etcDefaultProvider(url, network2);
    };
    return func;
  }
  var homestead = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ethDefaultProvider("homestead")
  };
  var ropsten = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ethDefaultProvider("ropsten")
  };
  var classicMordor = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
  };
  var networks = {
    unspecified: { chainId: 0, name: "unspecified" },
    homestead,
    mainnet: homestead,
    morden: { chainId: 2, name: "morden" },
    ropsten,
    testnet: ropsten,
    rinkeby: {
      chainId: 4,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "rinkeby",
      _defaultProvider: ethDefaultProvider("rinkeby")
    },
    kovan: {
      chainId: 42,
      name: "kovan",
      _defaultProvider: ethDefaultProvider("kovan")
    },
    goerli: {
      chainId: 5,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "goerli",
      _defaultProvider: ethDefaultProvider("goerli")
    },
    kintsugi: { chainId: 1337702, name: "kintsugi" },
    sepolia: {
      chainId: 11155111,
      name: "sepolia",
      _defaultProvider: ethDefaultProvider("sepolia")
    },
    // ETC (See: #351)
    classic: {
      chainId: 61,
      name: "classic",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
    },
    classicMorden: { chainId: 62, name: "classicMorden" },
    classicMordor,
    classicTestnet: classicMordor,
    classicKotti: {
      chainId: 6,
      name: "classicKotti",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: { chainId: 100, name: "xdai" },
    matic: {
      chainId: 137,
      name: "matic",
      _defaultProvider: ethDefaultProvider("matic")
    },
    maticmum: { chainId: 80001, name: "maticmum" },
    optimism: {
      chainId: 10,
      name: "optimism",
      _defaultProvider: ethDefaultProvider("optimism")
    },
    "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
    "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
    arbitrum: { chainId: 42161, name: "arbitrum" },
    "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
    "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
    bnb: { chainId: 56, name: "bnb" },
    bnbt: { chainId: 97, name: "bnbt" }
  };
  function getNetwork(network) {
    if (network == null) {
      return null;
    }
    if (typeof network === "number") {
      for (const name in networks) {
        const standard2 = networks[name];
        if (standard2.chainId === network) {
          return {
            name: standard2.name,
            chainId: standard2.chainId,
            ensAddress: standard2.ensAddress || null,
            _defaultProvider: standard2._defaultProvider || null
          };
        }
      }
      return {
        chainId: network,
        name: "unknown"
      };
    }
    if (typeof network === "string") {
      const standard2 = networks[network];
      if (standard2 == null) {
        return null;
      }
      return {
        name: standard2.name,
        chainId: standard2.chainId,
        ensAddress: standard2.ensAddress,
        _defaultProvider: standard2._defaultProvider || null
      };
    }
    const standard = networks[network.name];
    if (!standard) {
      if (typeof network.chainId !== "number") {
        logger2.throwArgumentError("invalid network chainId", "network", network);
      }
      return network;
    }
    if (network.chainId !== 0 && network.chainId !== standard.chainId) {
      logger2.throwArgumentError("network chainId mismatch", "network", network);
    }
    let defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
      if (isRenetworkable(standard._defaultProvider)) {
        defaultProvider = standard._defaultProvider.renetwork(network);
      } else {
        defaultProvider = standard._defaultProvider;
      }
    }
    return {
      name: network.name,
      chainId: standard.chainId,
      ensAddress: network.ensAddress || standard.ensAddress || null,
      _defaultProvider: defaultProvider
    };
  }

  // node_modules/@ethersproject/providers/lib.esm/base-provider.js
  var import_abstract_provider2 = __toESM(require_lib14());
  var import_base64 = __toESM(require_lib10());
  var import_basex = __toESM(require_lib18());
  var import_bignumber3 = __toESM(require_lib3());
  var import_bytes3 = __toESM(require_lib2());
  var import_constants2 = __toESM(require_lib8());
  var import_hash = __toESM(require_lib12());
  var import_properties3 = __toESM(require_lib4());
  var import_sha2 = __toESM(require_lib19());
  var import_strings = __toESM(require_lib9());
  var import_web = __toESM(require_lib26());
  var import_bech32 = __toESM(require_bech32());
  var import_logger4 = __toESM(require_lib());

  // node_modules/@ethersproject/providers/lib.esm/_version.js
  var version3 = "providers/5.7.2";

  // node_modules/@ethersproject/providers/lib.esm/formatter.js
  var import_address2 = __toESM(require_lib7());
  var import_bignumber2 = __toESM(require_lib3());
  var import_bytes2 = __toESM(require_lib2());
  var import_constants = __toESM(require_lib8());
  var import_properties2 = __toESM(require_lib4());
  var import_transactions2 = __toESM(require_lib17());
  var import_logger3 = __toESM(require_lib());
  var logger3 = new import_logger3.Logger(version3);
  var Formatter = class {
    constructor() {
      this.formats = this.getDefaultFormats();
    }
    getDefaultFormats() {
      const formats = {};
      const address = this.address.bind(this);
      const bigNumber = this.bigNumber.bind(this);
      const blockTag = this.blockTag.bind(this);
      const data = this.data.bind(this);
      const hash3 = this.hash.bind(this);
      const hex2 = this.hex.bind(this);
      const number2 = this.number.bind(this);
      const type = this.type.bind(this);
      const strictData = (v7) => {
        return this.data(v7, true);
      };
      formats.transaction = {
        hash: hash3,
        type,
        accessList: Formatter.allowNull(this.accessList.bind(this), null),
        blockHash: Formatter.allowNull(hash3, null),
        blockNumber: Formatter.allowNull(number2, null),
        transactionIndex: Formatter.allowNull(number2, null),
        confirmations: Formatter.allowNull(number2, null),
        from: address,
        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
        // must be set
        gasPrice: Formatter.allowNull(bigNumber),
        maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
        maxFeePerGas: Formatter.allowNull(bigNumber),
        gasLimit: bigNumber,
        to: Formatter.allowNull(address, null),
        value: bigNumber,
        nonce: number2,
        data,
        r: Formatter.allowNull(this.uint256),
        s: Formatter.allowNull(this.uint256),
        v: Formatter.allowNull(number2),
        creates: Formatter.allowNull(address, null),
        raw: Formatter.allowNull(data)
      };
      formats.transactionRequest = {
        from: Formatter.allowNull(address),
        nonce: Formatter.allowNull(number2),
        gasLimit: Formatter.allowNull(bigNumber),
        gasPrice: Formatter.allowNull(bigNumber),
        maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
        maxFeePerGas: Formatter.allowNull(bigNumber),
        to: Formatter.allowNull(address),
        value: Formatter.allowNull(bigNumber),
        data: Formatter.allowNull(strictData),
        type: Formatter.allowNull(number2),
        accessList: Formatter.allowNull(this.accessList.bind(this), null)
      };
      formats.receiptLog = {
        transactionIndex: number2,
        blockNumber: number2,
        transactionHash: hash3,
        address,
        topics: Formatter.arrayOf(hash3),
        data,
        logIndex: number2,
        blockHash: hash3
      };
      formats.receipt = {
        to: Formatter.allowNull(this.address, null),
        from: Formatter.allowNull(this.address, null),
        contractAddress: Formatter.allowNull(address, null),
        transactionIndex: number2,
        // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
        root: Formatter.allowNull(hex2),
        gasUsed: bigNumber,
        logsBloom: Formatter.allowNull(data),
        blockHash: hash3,
        transactionHash: hash3,
        logs: Formatter.arrayOf(this.receiptLog.bind(this)),
        blockNumber: number2,
        confirmations: Formatter.allowNull(number2, null),
        cumulativeGasUsed: bigNumber,
        effectiveGasPrice: Formatter.allowNull(bigNumber),
        status: Formatter.allowNull(number2),
        type
      };
      formats.block = {
        hash: Formatter.allowNull(hash3),
        parentHash: hash3,
        number: number2,
        timestamp: number2,
        nonce: Formatter.allowNull(hex2),
        difficulty: this.difficulty.bind(this),
        gasLimit: bigNumber,
        gasUsed: bigNumber,
        miner: Formatter.allowNull(address),
        extraData: data,
        transactions: Formatter.allowNull(Formatter.arrayOf(hash3)),
        baseFeePerGas: Formatter.allowNull(bigNumber)
      };
      formats.blockWithTransactions = (0, import_properties2.shallowCopy)(formats.block);
      formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
      formats.filter = {
        fromBlock: Formatter.allowNull(blockTag, void 0),
        toBlock: Formatter.allowNull(blockTag, void 0),
        blockHash: Formatter.allowNull(hash3, void 0),
        address: Formatter.allowNull(address, void 0),
        topics: Formatter.allowNull(this.topics.bind(this), void 0)
      };
      formats.filterLog = {
        blockNumber: Formatter.allowNull(number2),
        blockHash: Formatter.allowNull(hash3),
        transactionIndex: number2,
        removed: Formatter.allowNull(this.boolean.bind(this)),
        address,
        data: Formatter.allowFalsish(data, "0x"),
        topics: Formatter.arrayOf(hash3),
        transactionHash: hash3,
        logIndex: number2
      };
      return formats;
    }
    accessList(accessList) {
      return (0, import_transactions2.accessListify)(accessList || []);
    }
    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
    // Strict! Used on input.
    number(number2) {
      if (number2 === "0x") {
        return 0;
      }
      return import_bignumber2.BigNumber.from(number2).toNumber();
    }
    type(number2) {
      if (number2 === "0x" || number2 == null) {
        return 0;
      }
      return import_bignumber2.BigNumber.from(number2).toNumber();
    }
    // Strict! Used on input.
    bigNumber(value) {
      return import_bignumber2.BigNumber.from(value);
    }
    // Requires a boolean, "true" or  "false"; returns a boolean
    boolean(value) {
      if (typeof value === "boolean") {
        return value;
      }
      if (typeof value === "string") {
        value = value.toLowerCase();
        if (value === "true") {
          return true;
        }
        if (value === "false") {
          return false;
        }
      }
      throw new Error("invalid boolean - " + value);
    }
    hex(value, strict) {
      if (typeof value === "string") {
        if (!strict && value.substring(0, 2) !== "0x") {
          value = "0x" + value;
        }
        if ((0, import_bytes2.isHexString)(value)) {
          return value.toLowerCase();
        }
      }
      return logger3.throwArgumentError("invalid hash", "value", value);
    }
    data(value, strict) {
      const result = this.hex(value, strict);
      if (result.length % 2 !== 0) {
        throw new Error("invalid data; odd-length - " + value);
      }
      return result;
    }
    // Requires an address
    // Strict! Used on input.
    address(value) {
      return (0, import_address2.getAddress)(value);
    }
    callAddress(value) {
      if (!(0, import_bytes2.isHexString)(value, 32)) {
        return null;
      }
      const address = (0, import_address2.getAddress)((0, import_bytes2.hexDataSlice)(value, 12));
      return address === import_constants.AddressZero ? null : address;
    }
    contractAddress(value) {
      return (0, import_address2.getContractAddress)(value);
    }
    // Strict! Used on input.
    blockTag(blockTag) {
      if (blockTag == null) {
        return "latest";
      }
      if (blockTag === "earliest") {
        return "0x0";
      }
      switch (blockTag) {
        case "earliest":
          return "0x0";
        case "latest":
        case "pending":
        case "safe":
        case "finalized":
          return blockTag;
      }
      if (typeof blockTag === "number" || (0, import_bytes2.isHexString)(blockTag)) {
        return (0, import_bytes2.hexValue)(blockTag);
      }
      throw new Error("invalid blockTag");
    }
    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
    hash(value, strict) {
      const result = this.hex(value, strict);
      if ((0, import_bytes2.hexDataLength)(result) !== 32) {
        return logger3.throwArgumentError("invalid hash", "value", value);
      }
      return result;
    }
    // Returns the difficulty as a number, or if too large (i.e. PoA network) null
    difficulty(value) {
      if (value == null) {
        return null;
      }
      const v7 = import_bignumber2.BigNumber.from(value);
      try {
        return v7.toNumber();
      } catch (error) {
      }
      return null;
    }
    uint256(value) {
      if (!(0, import_bytes2.isHexString)(value)) {
        throw new Error("invalid uint256");
      }
      return (0, import_bytes2.hexZeroPad)(value, 32);
    }
    _block(value, format3) {
      if (value.author != null && value.miner == null) {
        value.miner = value.author;
      }
      const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
      const result = Formatter.check(format3, value);
      result._difficulty = difficulty == null ? null : import_bignumber2.BigNumber.from(difficulty);
      return result;
    }
    block(value) {
      return this._block(value, this.formats.block);
    }
    blockWithTransactions(value) {
      return this._block(value, this.formats.blockWithTransactions);
    }
    // Strict! Used on input.
    transactionRequest(value) {
      return Formatter.check(this.formats.transactionRequest, value);
    }
    transactionResponse(transaction2) {
      if (transaction2.gas != null && transaction2.gasLimit == null) {
        transaction2.gasLimit = transaction2.gas;
      }
      if (transaction2.to && import_bignumber2.BigNumber.from(transaction2.to).isZero()) {
        transaction2.to = "0x0000000000000000000000000000000000000000";
      }
      if (transaction2.input != null && transaction2.data == null) {
        transaction2.data = transaction2.input;
      }
      if (transaction2.to == null && transaction2.creates == null) {
        transaction2.creates = this.contractAddress(transaction2);
      }
      if ((transaction2.type === 1 || transaction2.type === 2) && transaction2.accessList == null) {
        transaction2.accessList = [];
      }
      const result = Formatter.check(this.formats.transaction, transaction2);
      if (transaction2.chainId != null) {
        let chainId = transaction2.chainId;
        if ((0, import_bytes2.isHexString)(chainId)) {
          chainId = import_bignumber2.BigNumber.from(chainId).toNumber();
        }
        result.chainId = chainId;
      } else {
        let chainId = transaction2.networkId;
        if (chainId == null && result.v == null) {
          chainId = transaction2.chainId;
        }
        if ((0, import_bytes2.isHexString)(chainId)) {
          chainId = import_bignumber2.BigNumber.from(chainId).toNumber();
        }
        if (typeof chainId !== "number" && result.v != null) {
          chainId = (result.v - 35) / 2;
          if (chainId < 0) {
            chainId = 0;
          }
          chainId = parseInt(chainId);
        }
        if (typeof chainId !== "number") {
          chainId = 0;
        }
        result.chainId = chainId;
      }
      if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
        result.blockHash = null;
      }
      return result;
    }
    transaction(value) {
      return (0, import_transactions2.parse)(value);
    }
    receiptLog(value) {
      return Formatter.check(this.formats.receiptLog, value);
    }
    receipt(value) {
      const result = Formatter.check(this.formats.receipt, value);
      if (result.root != null) {
        if (result.root.length <= 4) {
          const value2 = import_bignumber2.BigNumber.from(result.root).toNumber();
          if (value2 === 0 || value2 === 1) {
            if (result.status != null && result.status !== value2) {
              logger3.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
            }
            result.status = value2;
            delete result.root;
          } else {
            logger3.throwArgumentError("invalid alt-root-status", "value.root", result.root);
          }
        } else if (result.root.length !== 66) {
          logger3.throwArgumentError("invalid root hash", "value.root", result.root);
        }
      }
      if (result.status != null) {
        result.byzantium = true;
      }
      return result;
    }
    topics(value) {
      if (Array.isArray(value)) {
        return value.map((v7) => this.topics(v7));
      } else if (value != null) {
        return this.hash(value, true);
      }
      return null;
    }
    filter(value) {
      return Formatter.check(this.formats.filter, value);
    }
    filterLog(value) {
      return Formatter.check(this.formats.filterLog, value);
    }
    static check(format3, object2) {
      const result = {};
      for (const key in format3) {
        try {
          const value = format3[key](object2[key]);
          if (value !== void 0) {
            result[key] = value;
          }
        } catch (error) {
          error.checkKey = key;
          error.checkValue = object2[key];
          throw error;
        }
      }
      return result;
    }
    // if value is null-ish, nullValue is returned
    static allowNull(format3, nullValue) {
      return function(value) {
        if (value == null) {
          return nullValue;
        }
        return format3(value);
      };
    }
    // If value is false-ish, replaceValue is returned
    static allowFalsish(format3, replaceValue) {
      return function(value) {
        if (!value) {
          return replaceValue;
        }
        return format3(value);
      };
    }
    // Requires an Array satisfying check
    static arrayOf(format3) {
      return function(array2) {
        if (!Array.isArray(array2)) {
          throw new Error("not an array");
        }
        const result = [];
        array2.forEach(function(value) {
          result.push(format3(value));
        });
        return result;
      };
    }
  };
  function isCommunityResourcable(value) {
    return value && typeof value.isCommunityResource === "function";
  }
  function isCommunityResource(value) {
    return isCommunityResourcable(value) && value.isCommunityResource();
  }
  var throttleMessage = false;
  function showThrottleMessage() {
    if (throttleMessage) {
      return;
    }
    throttleMessage = true;
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded  (this message will not be repeated)");
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https://docs.ethers.io/api-keys/");
    console.log("==========================");
  }

  // node_modules/@ethersproject/providers/lib.esm/base-provider.js
  var __awaiter3 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger4 = new import_logger4.Logger(version3);
  var MAX_CCIP_REDIRECTS = 10;
  function checkTopic(topic) {
    if (topic == null) {
      return "null";
    }
    if ((0, import_bytes3.hexDataLength)(topic) !== 32) {
      logger4.throwArgumentError("invalid topic", "topic", topic);
    }
    return topic.toLowerCase();
  }
  function serializeTopics(topics) {
    topics = topics.slice();
    while (topics.length > 0 && topics[topics.length - 1] == null) {
      topics.pop();
    }
    return topics.map((topic) => {
      if (Array.isArray(topic)) {
        const unique2 = {};
        topic.forEach((topic2) => {
          unique2[checkTopic(topic2)] = true;
        });
        const sorted = Object.keys(unique2);
        sorted.sort();
        return sorted.join("|");
      } else {
        return checkTopic(topic);
      }
    }).join("&");
  }
  function deserializeTopics(data) {
    if (data === "") {
      return [];
    }
    return data.split(/&/g).map((topic) => {
      if (topic === "") {
        return [];
      }
      const comps = topic.split("|").map((topic2) => {
        return topic2 === "null" ? null : topic2;
      });
      return comps.length === 1 ? comps[0] : comps;
    });
  }
  function getEventTag2(eventName) {
    if (typeof eventName === "string") {
      eventName = eventName.toLowerCase();
      if ((0, import_bytes3.hexDataLength)(eventName) === 32) {
        return "tx:" + eventName;
      }
      if (eventName.indexOf(":") === -1) {
        return eventName;
      }
    } else if (Array.isArray(eventName)) {
      return "filter:*:" + serializeTopics(eventName);
    } else if (import_abstract_provider2.ForkEvent.isForkEvent(eventName)) {
      logger4.warn("not implemented");
      throw new Error("not implemented");
    } else if (eventName && typeof eventName === "object") {
      return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
    }
    throw new Error("invalid event - " + eventName);
  }
  function getTime() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function stall(duration) {
    return new Promise((resolve) => {
      setTimeout(resolve, duration);
    });
  }
  var PollableEvents = ["block", "network", "pending", "poll"];
  var Event = class {
    constructor(tag, listener, once2) {
      (0, import_properties3.defineReadOnly)(this, "tag", tag);
      (0, import_properties3.defineReadOnly)(this, "listener", listener);
      (0, import_properties3.defineReadOnly)(this, "once", once2);
      this._lastBlockNumber = -2;
      this._inflight = false;
    }
    get event() {
      switch (this.type) {
        case "tx":
          return this.hash;
        case "filter":
          return this.filter;
      }
      return this.tag;
    }
    get type() {
      return this.tag.split(":")[0];
    }
    get hash() {
      const comps = this.tag.split(":");
      if (comps[0] !== "tx") {
        return null;
      }
      return comps[1];
    }
    get filter() {
      const comps = this.tag.split(":");
      if (comps[0] !== "filter") {
        return null;
      }
      const address = comps[1];
      const topics = deserializeTopics(comps[2]);
      const filter2 = {};
      if (topics.length > 0) {
        filter2.topics = topics;
      }
      if (address && address !== "*") {
        filter2.address = address;
      }
      return filter2;
    }
    pollable() {
      return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
    }
  };
  var coinInfos = {
    "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
    "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
    "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
    "60": { symbol: "eth", ilk: "eth" },
    "61": { symbol: "etc", ilk: "eth" },
    "700": { symbol: "xdai", ilk: "eth" }
  };
  function bytes32ify(value) {
    return (0, import_bytes3.hexZeroPad)(import_bignumber3.BigNumber.from(value).toHexString(), 32);
  }
  function base58Encode(data) {
    return import_basex.Base58.encode((0, import_bytes3.concat)([data, (0, import_bytes3.hexDataSlice)((0, import_sha2.sha256)((0, import_sha2.sha256)(data)), 0, 4)]));
  }
  var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
  var matchers = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
  ];
  function _parseString(result, start) {
    try {
      return (0, import_strings.toUtf8String)(_parseBytes(result, start));
    } catch (error) {
    }
    return null;
  }
  function _parseBytes(result, start) {
    if (result === "0x") {
      return null;
    }
    const offset = import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(result, start, start + 32)).toNumber();
    const length = import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(result, offset, offset + 32)).toNumber();
    return (0, import_bytes3.hexDataSlice)(result, offset + 32, offset + 32 + length);
  }
  function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
      link = link.substring(12);
    } else if (link.match(/^ipfs:\/\//i)) {
      link = link.substring(7);
    } else {
      logger4.throwArgumentError("unsupported IPFS format", "link", link);
    }
    return `https://gateway.ipfs.io/ipfs/${link}`;
  }
  function numPad(value) {
    const result = (0, import_bytes3.arrayify)(value);
    if (result.length > 32) {
      throw new Error("internal; should not happen");
    }
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
  }
  function bytesPad(value) {
    if (value.length % 32 === 0) {
      return value;
    }
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
  }
  function encodeBytes(datas) {
    const result = [];
    let byteCount = 0;
    for (let i4 = 0; i4 < datas.length; i4++) {
      result.push(null);
      byteCount += 32;
    }
    for (let i4 = 0; i4 < datas.length; i4++) {
      const data = (0, import_bytes3.arrayify)(datas[i4]);
      result[i4] = numPad(byteCount);
      result.push(numPad(data.length));
      result.push(bytesPad(data));
      byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return (0, import_bytes3.hexConcat)(result);
  }
  var Resolver = class {
    // The resolvedAddress is only for creating a ReverseLookup resolver
    constructor(provider, address, name, resolvedAddress) {
      (0, import_properties3.defineReadOnly)(this, "provider", provider);
      (0, import_properties3.defineReadOnly)(this, "name", name);
      (0, import_properties3.defineReadOnly)(this, "address", provider.formatter.address(address));
      (0, import_properties3.defineReadOnly)(this, "_resolvedAddress", resolvedAddress);
    }
    supportsWildcard() {
      if (!this._supportsEip2544) {
        this._supportsEip2544 = this.provider.call({
          to: this.address,
          data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
        }).then((result) => {
          return import_bignumber3.BigNumber.from(result).eq(1);
        }).catch((error) => {
          if (error.code === import_logger4.Logger.errors.CALL_EXCEPTION) {
            return false;
          }
          this._supportsEip2544 = null;
          throw error;
        });
      }
      return this._supportsEip2544;
    }
    _fetch(selector, parameters) {
      return __awaiter3(this, void 0, void 0, function* () {
        const tx = {
          to: this.address,
          ccipReadEnabled: true,
          data: (0, import_bytes3.hexConcat)([selector, (0, import_hash.namehash)(this.name), parameters || "0x"])
        };
        let parseBytes = false;
        if (yield this.supportsWildcard()) {
          parseBytes = true;
          tx.data = (0, import_bytes3.hexConcat)(["0x9061b923", encodeBytes([(0, import_hash.dnsEncode)(this.name), tx.data])]);
        }
        try {
          let result = yield this.provider.call(tx);
          if ((0, import_bytes3.arrayify)(result).length % 32 === 4) {
            logger4.throwError("resolver threw error", import_logger4.Logger.errors.CALL_EXCEPTION, {
              transaction: tx,
              data: result
            });
          }
          if (parseBytes) {
            result = _parseBytes(result, 0);
          }
          return result;
        } catch (error) {
          if (error.code === import_logger4.Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      });
    }
    _fetchBytes(selector, parameters) {
      return __awaiter3(this, void 0, void 0, function* () {
        const result = yield this._fetch(selector, parameters);
        if (result != null) {
          return _parseBytes(result, 0);
        }
        return null;
      });
    }
    _getAddress(coinType, hexBytes) {
      const coinInfo = coinInfos[String(coinType)];
      if (coinInfo == null) {
        logger4.throwError(`unsupported coin type: ${coinType}`, import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`
        });
      }
      if (coinInfo.ilk === "eth") {
        return this.provider.formatter.address(hexBytes);
      }
      const bytes2 = (0, import_bytes3.arrayify)(hexBytes);
      if (coinInfo.p2pkh != null) {
        const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
        if (p2pkh) {
          const length = parseInt(p2pkh[1], 16);
          if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
            return base58Encode((0, import_bytes3.concat)([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
          }
        }
      }
      if (coinInfo.p2sh != null) {
        const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
        if (p2sh) {
          const length = parseInt(p2sh[1], 16);
          if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
            return base58Encode((0, import_bytes3.concat)([[coinInfo.p2sh], "0x" + p2sh[2]]));
          }
        }
      }
      if (coinInfo.prefix != null) {
        const length = bytes2[1];
        let version7 = bytes2[0];
        if (version7 === 0) {
          if (length !== 20 && length !== 32) {
            version7 = -1;
          }
        } else {
          version7 = -1;
        }
        if (version7 >= 0 && bytes2.length === 2 + length && length >= 1 && length <= 75) {
          const words = import_bech32.default.toWords(bytes2.slice(2));
          words.unshift(version7);
          return import_bech32.default.encode(coinInfo.prefix, words);
        }
      }
      return null;
    }
    getAddress(coinType) {
      return __awaiter3(this, void 0, void 0, function* () {
        if (coinType == null) {
          coinType = 60;
        }
        if (coinType === 60) {
          try {
            const result = yield this._fetch("0x3b3b57de");
            if (result === "0x" || result === import_constants2.HashZero) {
              return null;
            }
            return this.provider.formatter.callAddress(result);
          } catch (error) {
            if (error.code === import_logger4.Logger.errors.CALL_EXCEPTION) {
              return null;
            }
            throw error;
          }
        }
        const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        const address = this._getAddress(coinType, hexBytes);
        if (address == null) {
          logger4.throwError(`invalid or unsupported coin data`, import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${coinType})`,
            coinType,
            data: hexBytes
          });
        }
        return address;
      });
    }
    getAvatar() {
      return __awaiter3(this, void 0, void 0, function* () {
        const linkage = [{ type: "name", content: this.name }];
        try {
          const avatar = yield this.getText("avatar");
          if (avatar == null) {
            return null;
          }
          for (let i4 = 0; i4 < matchers.length; i4++) {
            const match = avatar.match(matchers[i4]);
            if (match == null) {
              continue;
            }
            const scheme = match[1].toLowerCase();
            switch (scheme) {
              case "https":
                linkage.push({ type: "url", content: avatar });
                return { linkage, url: avatar };
              case "data":
                linkage.push({ type: "data", content: avatar });
                return { linkage, url: avatar };
              case "ipfs":
                linkage.push({ type: "ipfs", content: avatar });
                return { linkage, url: getIpfsLink(avatar) };
              case "erc721":
              case "erc1155": {
                const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                linkage.push({ type: scheme, content: avatar });
                const owner = this._resolvedAddress || (yield this.getAddress());
                const comps = (match[2] || "").split("/");
                if (comps.length !== 2) {
                  return null;
                }
                const addr = yield this.provider.formatter.address(comps[0]);
                const tokenId = (0, import_bytes3.hexZeroPad)(import_bignumber3.BigNumber.from(comps[1]).toHexString(), 32);
                if (scheme === "erc721") {
                  const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                    to: addr,
                    data: (0, import_bytes3.hexConcat)(["0x6352211e", tokenId])
                  }));
                  if (owner !== tokenOwner) {
                    return null;
                  }
                  linkage.push({ type: "owner", content: tokenOwner });
                } else if (scheme === "erc1155") {
                  const balance = import_bignumber3.BigNumber.from(yield this.provider.call({
                    to: addr,
                    data: (0, import_bytes3.hexConcat)(["0x00fdd58e", (0, import_bytes3.hexZeroPad)(owner, 32), tokenId])
                  }));
                  if (balance.isZero()) {
                    return null;
                  }
                  linkage.push({ type: "balance", content: balance.toString() });
                }
                const tx = {
                  to: this.provider.formatter.address(comps[0]),
                  data: (0, import_bytes3.hexConcat)([selector, tokenId])
                };
                let metadataUrl = _parseString(yield this.provider.call(tx), 0);
                if (metadataUrl == null) {
                  return null;
                }
                linkage.push({ type: "metadata-url-base", content: metadataUrl });
                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                  linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
                }
                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }
                linkage.push({ type: "metadata-url", content: metadataUrl });
                const metadata = yield (0, import_web.fetchJson)(metadataUrl);
                if (!metadata) {
                  return null;
                }
                linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                let imageUrl = metadata.image;
                if (typeof imageUrl !== "string") {
                  return null;
                }
                if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                } else {
                  const ipfs = imageUrl.match(matcherIpfs);
                  if (ipfs == null) {
                    return null;
                  }
                  linkage.push({ type: "url-ipfs", content: imageUrl });
                  imageUrl = getIpfsLink(imageUrl);
                }
                linkage.push({ type: "url", content: imageUrl });
                return { linkage, url: imageUrl };
              }
            }
          }
        } catch (error) {
        }
        return null;
      });
    }
    getContentHash() {
      return __awaiter3(this, void 0, void 0, function* () {
        const hexBytes = yield this._fetchBytes("0xbc1c58d1");
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipfs) {
          const length = parseInt(ipfs[3], 16);
          if (ipfs[4].length === length * 2) {
            return "ipfs://" + import_basex.Base58.encode("0x" + ipfs[1]);
          }
        }
        const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipns) {
          const length = parseInt(ipns[3], 16);
          if (ipns[4].length === length * 2) {
            return "ipns://" + import_basex.Base58.encode("0x" + ipns[1]);
          }
        }
        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (swarm) {
          if (swarm[1].length === 32 * 2) {
            return "bzz://" + swarm[1];
          }
        }
        const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
        if (skynet) {
          if (skynet[1].length === 34 * 2) {
            const urlSafe = { "=": "", "+": "-", "/": "_" };
            const hash3 = (0, import_base64.encode)("0x" + skynet[1]).replace(/[=+\/]/g, (a2) => urlSafe[a2]);
            return "sia://" + hash3;
          }
        }
        return logger4.throwError(`invalid or unsupported content hash data`, import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getContentHash()",
          data: hexBytes
        });
      });
    }
    getText(key) {
      return __awaiter3(this, void 0, void 0, function* () {
        let keyBytes = (0, import_strings.toUtf8Bytes)(key);
        keyBytes = (0, import_bytes3.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
        if (keyBytes.length % 32 !== 0) {
          keyBytes = (0, import_bytes3.concat)([keyBytes, (0, import_bytes3.hexZeroPad)("0x", 32 - key.length % 32)]);
        }
        const hexBytes = yield this._fetchBytes("0x59d1d43c", (0, import_bytes3.hexlify)(keyBytes));
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        return (0, import_strings.toUtf8String)(hexBytes);
      });
    }
  };
  var defaultFormatter = null;
  var nextPollId = 1;
  var BaseProvider = class extends import_abstract_provider2.Provider {
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */
    constructor(network) {
      super();
      this._events = [];
      this._emitted = { block: -2 };
      this.disableCcipRead = false;
      this.formatter = new.target.getFormatter();
      (0, import_properties3.defineReadOnly)(this, "anyNetwork", network === "any");
      if (this.anyNetwork) {
        network = this.detectNetwork();
      }
      if (network instanceof Promise) {
        this._networkPromise = network;
        network.catch((error) => {
        });
        this._ready().catch((error) => {
        });
      } else {
        const knownNetwork = (0, import_properties3.getStatic)(new.target, "getNetwork")(network);
        if (knownNetwork) {
          (0, import_properties3.defineReadOnly)(this, "_network", knownNetwork);
          this.emit("network", knownNetwork, null);
        } else {
          logger4.throwArgumentError("invalid network", "network", network);
        }
      }
      this._maxInternalBlockNumber = -1024;
      this._lastBlockNumber = -2;
      this._maxFilterBlockRange = 10;
      this._pollingInterval = 4e3;
      this._fastQueryDate = 0;
    }
    _ready() {
      return __awaiter3(this, void 0, void 0, function* () {
        if (this._network == null) {
          let network = null;
          if (this._networkPromise) {
            try {
              network = yield this._networkPromise;
            } catch (error) {
            }
          }
          if (network == null) {
            network = yield this.detectNetwork();
          }
          if (!network) {
            logger4.throwError("no network detected", import_logger4.Logger.errors.UNKNOWN_ERROR, {});
          }
          if (this._network == null) {
            if (this.anyNetwork) {
              this._network = network;
            } else {
              (0, import_properties3.defineReadOnly)(this, "_network", network);
            }
            this.emit("network", network, null);
          }
        }
        return this._network;
      });
    }
    // This will always return the most recently established network.
    // For "any", this can change (a "network" event is emitted before
    // any change is reflected); otherwise this cannot change
    get ready() {
      return (0, import_web.poll)(() => {
        return this._ready().then((network) => {
          return network;
        }, (error) => {
          if (error.code === import_logger4.Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
            return void 0;
          }
          throw error;
        });
      });
    }
    // @TODO: Remove this and just create a singleton formatter
    static getFormatter() {
      if (defaultFormatter == null) {
        defaultFormatter = new Formatter();
      }
      return defaultFormatter;
    }
    // @TODO: Remove this and just use getNetwork
    static getNetwork(network) {
      return getNetwork(network == null ? "homestead" : network);
    }
    ccipReadFetch(tx, calldata, urls) {
      return __awaiter3(this, void 0, void 0, function* () {
        if (this.disableCcipRead || urls.length === 0) {
          return null;
        }
        const sender = tx.to.toLowerCase();
        const data = calldata.toLowerCase();
        const errorMessages = [];
        for (let i4 = 0; i4 < urls.length; i4++) {
          const url = urls[i4];
          const href = url.replace("{sender}", sender).replace("{data}", data);
          const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
          const result = yield (0, import_web.fetchJson)({ url: href, errorPassThrough: true }, json, (value, response) => {
            value.status = response.statusCode;
            return value;
          });
          if (result.data) {
            return result.data;
          }
          const errorMessage = result.message || "unknown error";
          if (result.status >= 400 && result.status < 500) {
            return logger4.throwError(`response not found during CCIP fetch: ${errorMessage}`, import_logger4.Logger.errors.SERVER_ERROR, { url, errorMessage });
          }
          errorMessages.push(errorMessage);
        }
        return logger4.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m5) => JSON.stringify(m5)).join(", ")}`, import_logger4.Logger.errors.SERVER_ERROR, {
          urls,
          errorMessages
        });
      });
    }
    // Fetches the blockNumber, but will reuse any result that is less
    // than maxAge old or has been requested since the last request
    _getInternalBlockNumber(maxAge) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this._ready();
        if (maxAge > 0) {
          while (this._internalBlockNumber) {
            const internalBlockNumber = this._internalBlockNumber;
            try {
              const result = yield internalBlockNumber;
              if (getTime() - result.respTime <= maxAge) {
                return result.blockNumber;
              }
              break;
            } catch (error) {
              if (this._internalBlockNumber === internalBlockNumber) {
                break;
              }
            }
          }
        }
        const reqTime = getTime();
        const checkInternalBlockNumber = (0, import_properties3.resolveProperties)({
          blockNumber: this.perform("getBlockNumber", {}),
          networkError: this.getNetwork().then((network) => null, (error) => error)
        }).then(({ blockNumber, networkError }) => {
          if (networkError) {
            if (this._internalBlockNumber === checkInternalBlockNumber) {
              this._internalBlockNumber = null;
            }
            throw networkError;
          }
          const respTime = getTime();
          blockNumber = import_bignumber3.BigNumber.from(blockNumber).toNumber();
          if (blockNumber < this._maxInternalBlockNumber) {
            blockNumber = this._maxInternalBlockNumber;
          }
          this._maxInternalBlockNumber = blockNumber;
          this._setFastBlockNumber(blockNumber);
          return { blockNumber, reqTime, respTime };
        });
        this._internalBlockNumber = checkInternalBlockNumber;
        checkInternalBlockNumber.catch((error) => {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
        });
        return (yield checkInternalBlockNumber).blockNumber;
      });
    }
    poll() {
      return __awaiter3(this, void 0, void 0, function* () {
        const pollId = nextPollId++;
        const runners = [];
        let blockNumber = null;
        try {
          blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
        } catch (error) {
          this.emit("error", error);
          return;
        }
        this._setFastBlockNumber(blockNumber);
        this.emit("poll", pollId, blockNumber);
        if (blockNumber === this._lastBlockNumber) {
          this.emit("didPoll", pollId);
          return;
        }
        if (this._emitted.block === -2) {
          this._emitted.block = blockNumber - 1;
        }
        if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
          logger4.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
          this.emit("error", logger4.makeError("network block skew detected", import_logger4.Logger.errors.NETWORK_ERROR, {
            blockNumber,
            event: "blockSkew",
            previousBlockNumber: this._emitted.block
          }));
          this.emit("block", blockNumber);
        } else {
          for (let i4 = this._emitted.block + 1; i4 <= blockNumber; i4++) {
            this.emit("block", i4);
          }
        }
        if (this._emitted.block !== blockNumber) {
          this._emitted.block = blockNumber;
          Object.keys(this._emitted).forEach((key) => {
            if (key === "block") {
              return;
            }
            const eventBlockNumber = this._emitted[key];
            if (eventBlockNumber === "pending") {
              return;
            }
            if (blockNumber - eventBlockNumber > 12) {
              delete this._emitted[key];
            }
          });
        }
        if (this._lastBlockNumber === -2) {
          this._lastBlockNumber = blockNumber - 1;
        }
        this._events.forEach((event) => {
          switch (event.type) {
            case "tx": {
              const hash3 = event.hash;
              let runner = this.getTransactionReceipt(hash3).then((receipt) => {
                if (!receipt || receipt.blockNumber == null) {
                  return null;
                }
                this._emitted["t:" + hash3] = receipt.blockNumber;
                this.emit(hash3, receipt);
                return null;
              }).catch((error) => {
                this.emit("error", error);
              });
              runners.push(runner);
              break;
            }
            case "filter": {
              if (!event._inflight) {
                event._inflight = true;
                if (event._lastBlockNumber === -2) {
                  event._lastBlockNumber = blockNumber - 1;
                }
                const filter2 = event.filter;
                filter2.fromBlock = event._lastBlockNumber + 1;
                filter2.toBlock = blockNumber;
                const minFromBlock = filter2.toBlock - this._maxFilterBlockRange;
                if (minFromBlock > filter2.fromBlock) {
                  filter2.fromBlock = minFromBlock;
                }
                if (filter2.fromBlock < 0) {
                  filter2.fromBlock = 0;
                }
                const runner = this.getLogs(filter2).then((logs) => {
                  event._inflight = false;
                  if (logs.length === 0) {
                    return;
                  }
                  logs.forEach((log) => {
                    if (log.blockNumber > event._lastBlockNumber) {
                      event._lastBlockNumber = log.blockNumber;
                    }
                    this._emitted["b:" + log.blockHash] = log.blockNumber;
                    this._emitted["t:" + log.transactionHash] = log.blockNumber;
                    this.emit(filter2, log);
                  });
                }).catch((error) => {
                  this.emit("error", error);
                  event._inflight = false;
                });
                runners.push(runner);
              }
              break;
            }
          }
        });
        this._lastBlockNumber = blockNumber;
        Promise.all(runners).then(() => {
          this.emit("didPoll", pollId);
        }).catch((error) => {
          this.emit("error", error);
        });
        return;
      });
    }
    // Deprecated; do not use this
    resetEventsBlock(blockNumber) {
      this._lastBlockNumber = blockNumber - 1;
      if (this.polling) {
        this.poll();
      }
    }
    get network() {
      return this._network;
    }
    // This method should query the network if the underlying network
    // can change, such as when connected to a JSON-RPC backend
    detectNetwork() {
      return __awaiter3(this, void 0, void 0, function* () {
        return logger4.throwError("provider does not support network detection", import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "provider.detectNetwork"
        });
      });
    }
    getNetwork() {
      return __awaiter3(this, void 0, void 0, function* () {
        const network = yield this._ready();
        const currentNetwork = yield this.detectNetwork();
        if (network.chainId !== currentNetwork.chainId) {
          if (this.anyNetwork) {
            this._network = currentNetwork;
            this._lastBlockNumber = -2;
            this._fastBlockNumber = null;
            this._fastBlockNumberPromise = null;
            this._fastQueryDate = 0;
            this._emitted.block = -2;
            this._maxInternalBlockNumber = -1024;
            this._internalBlockNumber = null;
            this.emit("network", currentNetwork, network);
            yield stall(0);
            return this._network;
          }
          const error = logger4.makeError("underlying network changed", import_logger4.Logger.errors.NETWORK_ERROR, {
            event: "changed",
            network,
            detectedNetwork: currentNetwork
          });
          this.emit("error", error);
          throw error;
        }
        return network;
      });
    }
    get blockNumber() {
      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
        this._setFastBlockNumber(blockNumber);
      }, (error) => {
      });
      return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
    }
    get polling() {
      return this._poller != null;
    }
    set polling(value) {
      if (value && !this._poller) {
        this._poller = setInterval(() => {
          this.poll();
        }, this.pollingInterval);
        if (!this._bootstrapPoll) {
          this._bootstrapPoll = setTimeout(() => {
            this.poll();
            this._bootstrapPoll = setTimeout(() => {
              if (!this._poller) {
                this.poll();
              }
              this._bootstrapPoll = null;
            }, this.pollingInterval);
          }, 0);
        }
      } else if (!value && this._poller) {
        clearInterval(this._poller);
        this._poller = null;
      }
    }
    get pollingInterval() {
      return this._pollingInterval;
    }
    set pollingInterval(value) {
      if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
        throw new Error("invalid polling interval");
      }
      this._pollingInterval = value;
      if (this._poller) {
        clearInterval(this._poller);
        this._poller = setInterval(() => {
          this.poll();
        }, this._pollingInterval);
      }
    }
    _getFastBlockNumber() {
      const now2 = getTime();
      if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
        this._fastQueryDate = now2;
        this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
          if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
            this._fastBlockNumber = blockNumber;
          }
          return this._fastBlockNumber;
        });
      }
      return this._fastBlockNumberPromise;
    }
    _setFastBlockNumber(blockNumber) {
      if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
        return;
      }
      this._fastQueryDate = getTime();
      if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
        this._fastBlockNumber = blockNumber;
        this._fastBlockNumberPromise = Promise.resolve(blockNumber);
      }
    }
    waitForTransaction(transactionHash, confirmations, timeout) {
      return __awaiter3(this, void 0, void 0, function* () {
        return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
      });
    }
    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
      return __awaiter3(this, void 0, void 0, function* () {
        const receipt = yield this.getTransactionReceipt(transactionHash);
        if ((receipt ? receipt.confirmations : 0) >= confirmations) {
          return receipt;
        }
        return new Promise((resolve, reject) => {
          const cancelFuncs = [];
          let done = false;
          const alreadyDone = function() {
            if (done) {
              return true;
            }
            done = true;
            cancelFuncs.forEach((func) => {
              func();
            });
            return false;
          };
          const minedHandler = (receipt2) => {
            if (receipt2.confirmations < confirmations) {
              return;
            }
            if (alreadyDone()) {
              return;
            }
            resolve(receipt2);
          };
          this.on(transactionHash, minedHandler);
          cancelFuncs.push(() => {
            this.removeListener(transactionHash, minedHandler);
          });
          if (replaceable) {
            let lastBlockNumber = replaceable.startBlock;
            let scannedBlock = null;
            const replaceHandler = (blockNumber) => __awaiter3(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              yield stall(1e3);
              this.getTransactionCount(replaceable.from).then((nonce) => __awaiter3(this, void 0, void 0, function* () {
                if (done) {
                  return;
                }
                if (nonce <= replaceable.nonce) {
                  lastBlockNumber = blockNumber;
                } else {
                  {
                    const mined = yield this.getTransaction(transactionHash);
                    if (mined && mined.blockNumber != null) {
                      return;
                    }
                  }
                  if (scannedBlock == null) {
                    scannedBlock = lastBlockNumber - 3;
                    if (scannedBlock < replaceable.startBlock) {
                      scannedBlock = replaceable.startBlock;
                    }
                  }
                  while (scannedBlock <= blockNumber) {
                    if (done) {
                      return;
                    }
                    const block = yield this.getBlockWithTransactions(scannedBlock);
                    for (let ti = 0; ti < block.transactions.length; ti++) {
                      const tx = block.transactions[ti];
                      if (tx.hash === transactionHash) {
                        return;
                      }
                      if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                        if (done) {
                          return;
                        }
                        const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                        if (alreadyDone()) {
                          return;
                        }
                        let reason = "replaced";
                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                          reason = "repriced";
                        } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                          reason = "cancelled";
                        }
                        reject(logger4.makeError("transaction was replaced", import_logger4.Logger.errors.TRANSACTION_REPLACED, {
                          cancelled: reason === "replaced" || reason === "cancelled",
                          reason,
                          replacement: this._wrapTransaction(tx),
                          hash: transactionHash,
                          receipt: receipt2
                        }));
                        return;
                      }
                    }
                    scannedBlock++;
                  }
                }
                if (done) {
                  return;
                }
                this.once("block", replaceHandler);
              }), (error) => {
                if (done) {
                  return;
                }
                this.once("block", replaceHandler);
              });
            });
            if (done) {
              return;
            }
            this.once("block", replaceHandler);
            cancelFuncs.push(() => {
              this.removeListener("block", replaceHandler);
            });
          }
          if (typeof timeout === "number" && timeout > 0) {
            const timer3 = setTimeout(() => {
              if (alreadyDone()) {
                return;
              }
              reject(logger4.makeError("timeout exceeded", import_logger4.Logger.errors.TIMEOUT, { timeout }));
            }, timeout);
            if (timer3.unref) {
              timer3.unref();
            }
            cancelFuncs.push(() => {
              clearTimeout(timer3);
            });
          }
        });
      });
    }
    getBlockNumber() {
      return __awaiter3(this, void 0, void 0, function* () {
        return this._getInternalBlockNumber(0);
      });
    }
    getGasPrice() {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const result = yield this.perform("getGasPrice", {});
        try {
          return import_bignumber3.BigNumber.from(result);
        } catch (error) {
          return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
            method: "getGasPrice",
            result,
            error
          });
        }
      });
    }
    getBalance(addressOrName, blockTag) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield (0, import_properties3.resolveProperties)({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getBalance", params);
        try {
          return import_bignumber3.BigNumber.from(result);
        } catch (error) {
          return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
            method: "getBalance",
            params,
            result,
            error
          });
        }
      });
    }
    getTransactionCount(addressOrName, blockTag) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield (0, import_properties3.resolveProperties)({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getTransactionCount", params);
        try {
          return import_bignumber3.BigNumber.from(result).toNumber();
        } catch (error) {
          return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
            method: "getTransactionCount",
            params,
            result,
            error
          });
        }
      });
    }
    getCode(addressOrName, blockTag) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield (0, import_properties3.resolveProperties)({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getCode", params);
        try {
          return (0, import_bytes3.hexlify)(result);
        } catch (error) {
          return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
            method: "getCode",
            params,
            result,
            error
          });
        }
      });
    }
    getStorageAt(addressOrName, position, blockTag) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield (0, import_properties3.resolveProperties)({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag),
          position: Promise.resolve(position).then((p2) => (0, import_bytes3.hexValue)(p2))
        });
        const result = yield this.perform("getStorageAt", params);
        try {
          return (0, import_bytes3.hexlify)(result);
        } catch (error) {
          return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
            method: "getStorageAt",
            params,
            result,
            error
          });
        }
      });
    }
    // This should be called by any subclass wrapping a TransactionResponse
    _wrapTransaction(tx, hash3, startBlock) {
      if (hash3 != null && (0, import_bytes3.hexDataLength)(hash3) !== 32) {
        throw new Error("invalid response - sendTransaction");
      }
      const result = tx;
      if (hash3 != null && tx.hash !== hash3) {
        logger4.throwError("Transaction hash mismatch from Provider.sendTransaction.", import_logger4.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
      }
      result.wait = (confirms, timeout) => __awaiter3(this, void 0, void 0, function* () {
        if (confirms == null) {
          confirms = 1;
        }
        if (timeout == null) {
          timeout = 0;
        }
        let replacement = void 0;
        if (confirms !== 0 && startBlock != null) {
          replacement = {
            data: tx.data,
            from: tx.from,
            nonce: tx.nonce,
            to: tx.to,
            value: tx.value,
            startBlock
          };
        }
        const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
        if (receipt == null && confirms === 0) {
          return null;
        }
        this._emitted["t:" + tx.hash] = receipt.blockNumber;
        if (receipt.status === 0) {
          logger4.throwError("transaction failed", import_logger4.Logger.errors.CALL_EXCEPTION, {
            transactionHash: tx.hash,
            transaction: tx,
            receipt
          });
        }
        return receipt;
      });
      return result;
    }
    sendTransaction(signedTransaction) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const hexTx = yield Promise.resolve(signedTransaction).then((t3) => (0, import_bytes3.hexlify)(t3));
        const tx = this.formatter.transaction(signedTransaction);
        if (tx.confirmations == null) {
          tx.confirmations = 0;
        }
        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        try {
          const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
          return this._wrapTransaction(tx, hash3, blockNumber);
        } catch (error) {
          error.transaction = tx;
          error.transactionHash = tx.hash;
          throw error;
        }
      });
    }
    _getTransactionRequest(transaction2) {
      return __awaiter3(this, void 0, void 0, function* () {
        const values = yield transaction2;
        const tx = {};
        ["from", "to"].forEach((key) => {
          if (values[key] == null) {
            return;
          }
          tx[key] = Promise.resolve(values[key]).then((v7) => v7 ? this._getAddress(v7) : null);
        });
        ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key) => {
          if (values[key] == null) {
            return;
          }
          tx[key] = Promise.resolve(values[key]).then((v7) => v7 ? import_bignumber3.BigNumber.from(v7) : null);
        });
        ["type"].forEach((key) => {
          if (values[key] == null) {
            return;
          }
          tx[key] = Promise.resolve(values[key]).then((v7) => v7 != null ? v7 : null);
        });
        if (values.accessList) {
          tx.accessList = this.formatter.accessList(values.accessList);
        }
        ["data"].forEach((key) => {
          if (values[key] == null) {
            return;
          }
          tx[key] = Promise.resolve(values[key]).then((v7) => v7 ? (0, import_bytes3.hexlify)(v7) : null);
        });
        return this.formatter.transactionRequest(yield (0, import_properties3.resolveProperties)(tx));
      });
    }
    _getFilter(filter2) {
      return __awaiter3(this, void 0, void 0, function* () {
        filter2 = yield filter2;
        const result = {};
        if (filter2.address != null) {
          result.address = this._getAddress(filter2.address);
        }
        ["blockHash", "topics"].forEach((key) => {
          if (filter2[key] == null) {
            return;
          }
          result[key] = filter2[key];
        });
        ["fromBlock", "toBlock"].forEach((key) => {
          if (filter2[key] == null) {
            return;
          }
          result[key] = this._getBlockTag(filter2[key]);
        });
        return this.formatter.filter(yield (0, import_properties3.resolveProperties)(result));
      });
    }
    _call(transaction2, blockTag, attempt) {
      return __awaiter3(this, void 0, void 0, function* () {
        if (attempt >= MAX_CCIP_REDIRECTS) {
          logger4.throwError("CCIP read exceeded maximum redirections", import_logger4.Logger.errors.SERVER_ERROR, {
            redirects: attempt,
            transaction: transaction2
          });
        }
        const txSender = transaction2.to;
        const result = yield this.perform("call", { transaction: transaction2, blockTag });
        if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && (0, import_bytes3.hexDataLength)(result) % 32 === 4) {
          try {
            const data = (0, import_bytes3.hexDataSlice)(result, 4);
            const sender = (0, import_bytes3.hexDataSlice)(data, 0, 32);
            if (!import_bignumber3.BigNumber.from(sender).eq(txSender)) {
              logger4.throwError("CCIP Read sender did not match", import_logger4.Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: transaction2,
                data: result
              });
            }
            const urls = [];
            const urlsOffset = import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(data, 32, 64)).toNumber();
            const urlsLength = import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();
            const urlsData = (0, import_bytes3.hexDataSlice)(data, urlsOffset + 32);
            for (let u3 = 0; u3 < urlsLength; u3++) {
              const url = _parseString(urlsData, u3 * 32);
              if (url == null) {
                logger4.throwError("CCIP Read contained corrupt URL string", import_logger4.Logger.errors.CALL_EXCEPTION, {
                  name: "OffchainLookup",
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction: transaction2,
                  data: result
                });
              }
              urls.push(url);
            }
            const calldata = _parseBytes(data, 64);
            if (!import_bignumber3.BigNumber.from((0, import_bytes3.hexDataSlice)(data, 100, 128)).isZero()) {
              logger4.throwError("CCIP Read callback selector included junk", import_logger4.Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: transaction2,
                data: result
              });
            }
            const callbackSelector = (0, import_bytes3.hexDataSlice)(data, 96, 100);
            const extraData = _parseBytes(data, 128);
            const ccipResult = yield this.ccipReadFetch(transaction2, calldata, urls);
            if (ccipResult == null) {
              logger4.throwError("CCIP Read disabled or provided no URLs", import_logger4.Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: transaction2,
                data: result
              });
            }
            const tx = {
              to: txSender,
              data: (0, import_bytes3.hexConcat)([callbackSelector, encodeBytes([ccipResult, extraData])])
            };
            return this._call(tx, blockTag, attempt + 1);
          } catch (error) {
            if (error.code === import_logger4.Logger.errors.SERVER_ERROR) {
              throw error;
            }
          }
        }
        try {
          return (0, import_bytes3.hexlify)(result);
        } catch (error) {
          return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
            method: "call",
            params: { transaction: transaction2, blockTag },
            result,
            error
          });
        }
      });
    }
    call(transaction2, blockTag) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const resolved = yield (0, import_properties3.resolveProperties)({
          transaction: this._getTransactionRequest(transaction2),
          blockTag: this._getBlockTag(blockTag),
          ccipReadEnabled: Promise.resolve(transaction2.ccipReadEnabled)
        });
        return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
      });
    }
    estimateGas(transaction2) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield (0, import_properties3.resolveProperties)({
          transaction: this._getTransactionRequest(transaction2)
        });
        const result = yield this.perform("estimateGas", params);
        try {
          return import_bignumber3.BigNumber.from(result);
        } catch (error) {
          return logger4.throwError("bad result from backend", import_logger4.Logger.errors.SERVER_ERROR, {
            method: "estimateGas",
            params,
            result,
            error
          });
        }
      });
    }
    _getAddress(addressOrName) {
      return __awaiter3(this, void 0, void 0, function* () {
        addressOrName = yield addressOrName;
        if (typeof addressOrName !== "string") {
          logger4.throwArgumentError("invalid address or ENS name", "name", addressOrName);
        }
        const address = yield this.resolveName(addressOrName);
        if (address == null) {
          logger4.throwError("ENS name not configured", import_logger4.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: `resolveName(${JSON.stringify(addressOrName)})`
          });
        }
        return address;
      });
    }
    _getBlock(blockHashOrBlockTag, includeTransactions) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        blockHashOrBlockTag = yield blockHashOrBlockTag;
        let blockNumber = -128;
        const params = {
          includeTransactions: !!includeTransactions
        };
        if ((0, import_bytes3.isHexString)(blockHashOrBlockTag, 32)) {
          params.blockHash = blockHashOrBlockTag;
        } else {
          try {
            params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
            if ((0, import_bytes3.isHexString)(params.blockTag)) {
              blockNumber = parseInt(params.blockTag.substring(2), 16);
            }
          } catch (error) {
            logger4.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
          }
        }
        return (0, import_web.poll)(() => __awaiter3(this, void 0, void 0, function* () {
          const block = yield this.perform("getBlock", params);
          if (block == null) {
            if (params.blockHash != null) {
              if (this._emitted["b:" + params.blockHash] == null) {
                return null;
              }
            }
            if (params.blockTag != null) {
              if (blockNumber > this._emitted.block) {
                return null;
              }
            }
            return void 0;
          }
          if (includeTransactions) {
            let blockNumber2 = null;
            for (let i4 = 0; i4 < block.transactions.length; i4++) {
              const tx = block.transactions[i4];
              if (tx.blockNumber == null) {
                tx.confirmations = 0;
              } else if (tx.confirmations == null) {
                if (blockNumber2 == null) {
                  blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                }
                let confirmations = blockNumber2 - tx.blockNumber + 1;
                if (confirmations <= 0) {
                  confirmations = 1;
                }
                tx.confirmations = confirmations;
              }
            }
            const blockWithTxs = this.formatter.blockWithTransactions(block);
            blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
            return blockWithTxs;
          }
          return this.formatter.block(block);
        }), { oncePoll: this });
      });
    }
    getBlock(blockHashOrBlockTag) {
      return this._getBlock(blockHashOrBlockTag, false);
    }
    getBlockWithTransactions(blockHashOrBlockTag) {
      return this._getBlock(blockHashOrBlockTag, true);
    }
    getTransaction(transactionHash) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        transactionHash = yield transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return (0, import_web.poll)(() => __awaiter3(this, void 0, void 0, function* () {
          const result = yield this.perform("getTransaction", params);
          if (result == null) {
            if (this._emitted["t:" + transactionHash] == null) {
              return null;
            }
            return void 0;
          }
          const tx = this.formatter.transactionResponse(result);
          if (tx.blockNumber == null) {
            tx.confirmations = 0;
          } else if (tx.confirmations == null) {
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            let confirmations = blockNumber - tx.blockNumber + 1;
            if (confirmations <= 0) {
              confirmations = 1;
            }
            tx.confirmations = confirmations;
          }
          return this._wrapTransaction(tx);
        }), { oncePoll: this });
      });
    }
    getTransactionReceipt(transactionHash) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        transactionHash = yield transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return (0, import_web.poll)(() => __awaiter3(this, void 0, void 0, function* () {
          const result = yield this.perform("getTransactionReceipt", params);
          if (result == null) {
            if (this._emitted["t:" + transactionHash] == null) {
              return null;
            }
            return void 0;
          }
          if (result.blockHash == null) {
            return void 0;
          }
          const receipt = this.formatter.receipt(result);
          if (receipt.blockNumber == null) {
            receipt.confirmations = 0;
          } else if (receipt.confirmations == null) {
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            let confirmations = blockNumber - receipt.blockNumber + 1;
            if (confirmations <= 0) {
              confirmations = 1;
            }
            receipt.confirmations = confirmations;
          }
          return receipt;
        }), { oncePoll: this });
      });
    }
    getLogs(filter2) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield (0, import_properties3.resolveProperties)({ filter: this._getFilter(filter2) });
        const logs = yield this.perform("getLogs", params);
        logs.forEach((log) => {
          if (log.removed == null) {
            log.removed = false;
          }
        });
        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
      });
    }
    getEtherPrice() {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.getNetwork();
        return this.perform("getEtherPrice", {});
      });
    }
    _getBlockTag(blockTag) {
      return __awaiter3(this, void 0, void 0, function* () {
        blockTag = yield blockTag;
        if (typeof blockTag === "number" && blockTag < 0) {
          if (blockTag % 1) {
            logger4.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
          }
          let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          blockNumber += blockTag;
          if (blockNumber < 0) {
            blockNumber = 0;
          }
          return this.formatter.blockTag(blockNumber);
        }
        return this.formatter.blockTag(blockTag);
      });
    }
    getResolver(name) {
      return __awaiter3(this, void 0, void 0, function* () {
        let currentName = name;
        while (true) {
          if (currentName === "" || currentName === ".") {
            return null;
          }
          if (name !== "eth" && currentName === "eth") {
            return null;
          }
          const addr = yield this._getResolver(currentName, "getResolver");
          if (addr != null) {
            const resolver = new Resolver(this, addr, name);
            if (currentName !== name && !(yield resolver.supportsWildcard())) {
              return null;
            }
            return resolver;
          }
          currentName = currentName.split(".").slice(1).join(".");
        }
      });
    }
    _getResolver(name, operation) {
      return __awaiter3(this, void 0, void 0, function* () {
        if (operation == null) {
          operation = "ENS";
        }
        const network = yield this.getNetwork();
        if (!network.ensAddress) {
          logger4.throwError("network does not support ENS", import_logger4.Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
        }
        try {
          const addrData = yield this.call({
            to: network.ensAddress,
            data: "0x0178b8bf" + (0, import_hash.namehash)(name).substring(2)
          });
          return this.formatter.callAddress(addrData);
        } catch (error) {
        }
        return null;
      });
    }
    resolveName(name) {
      return __awaiter3(this, void 0, void 0, function* () {
        name = yield name;
        try {
          return Promise.resolve(this.formatter.address(name));
        } catch (error) {
          if ((0, import_bytes3.isHexString)(name)) {
            throw error;
          }
        }
        if (typeof name !== "string") {
          logger4.throwArgumentError("invalid ENS name", "name", name);
        }
        const resolver = yield this.getResolver(name);
        if (!resolver) {
          return null;
        }
        return yield resolver.getAddress();
      });
    }
    lookupAddress(address) {
      return __awaiter3(this, void 0, void 0, function* () {
        address = yield address;
        address = this.formatter.address(address);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddr = yield this._getResolver(node, "lookupAddress");
        if (resolverAddr == null) {
          return null;
        }
        const name = _parseString(yield this.call({
          to: resolverAddr,
          data: "0x691f3431" + (0, import_hash.namehash)(node).substring(2)
        }), 0);
        const addr = yield this.resolveName(name);
        if (addr != address) {
          return null;
        }
        return name;
      });
    }
    getAvatar(nameOrAddress) {
      return __awaiter3(this, void 0, void 0, function* () {
        let resolver = null;
        if ((0, import_bytes3.isHexString)(nameOrAddress)) {
          const address = this.formatter.address(nameOrAddress);
          const node = address.substring(2).toLowerCase() + ".addr.reverse";
          const resolverAddress = yield this._getResolver(node, "getAvatar");
          if (!resolverAddress) {
            return null;
          }
          resolver = new Resolver(this, resolverAddress, node);
          try {
            const avatar2 = yield resolver.getAvatar();
            if (avatar2) {
              return avatar2.url;
            }
          } catch (error) {
            if (error.code !== import_logger4.Logger.errors.CALL_EXCEPTION) {
              throw error;
            }
          }
          try {
            const name = _parseString(yield this.call({
              to: resolverAddress,
              data: "0x691f3431" + (0, import_hash.namehash)(node).substring(2)
            }), 0);
            resolver = yield this.getResolver(name);
          } catch (error) {
            if (error.code !== import_logger4.Logger.errors.CALL_EXCEPTION) {
              throw error;
            }
            return null;
          }
        } else {
          resolver = yield this.getResolver(nameOrAddress);
          if (!resolver) {
            return null;
          }
        }
        const avatar = yield resolver.getAvatar();
        if (avatar == null) {
          return null;
        }
        return avatar.url;
      });
    }
    perform(method, params) {
      return logger4.throwError(method + " not implemented", import_logger4.Logger.errors.NOT_IMPLEMENTED, { operation: method });
    }
    _startEvent(event) {
      this.polling = this._events.filter((e) => e.pollable()).length > 0;
    }
    _stopEvent(event) {
      this.polling = this._events.filter((e) => e.pollable()).length > 0;
    }
    _addEventListener(eventName, listener, once2) {
      const event = new Event(getEventTag2(eventName), listener, once2);
      this._events.push(event);
      this._startEvent(event);
      return this;
    }
    on(eventName, listener) {
      return this._addEventListener(eventName, listener, false);
    }
    once(eventName, listener) {
      return this._addEventListener(eventName, listener, true);
    }
    emit(eventName, ...args) {
      let result = false;
      let stopped = [];
      let eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        setTimeout(() => {
          event.listener.apply(this, args);
        }, 0);
        result = true;
        if (event.once) {
          stopped.push(event);
          return false;
        }
        return true;
      });
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return result;
    }
    listenerCount(eventName) {
      if (!eventName) {
        return this._events.length;
      }
      let eventTag = getEventTag2(eventName);
      return this._events.filter((event) => {
        return event.tag === eventTag;
      }).length;
    }
    listeners(eventName) {
      if (eventName == null) {
        return this._events.map((event) => event.listener);
      }
      let eventTag = getEventTag2(eventName);
      return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
    }
    off(eventName, listener) {
      if (listener == null) {
        return this.removeAllListeners(eventName);
      }
      const stopped = [];
      let found = false;
      let eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag || event.listener != listener) {
          return true;
        }
        if (found) {
          return true;
        }
        found = true;
        stopped.push(event);
        return false;
      });
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return this;
    }
    removeAllListeners(eventName) {
      let stopped = [];
      if (eventName == null) {
        stopped = this._events;
        this._events = [];
      } else {
        const eventTag = getEventTag2(eventName);
        this._events = this._events.filter((event) => {
          if (event.tag !== eventTag) {
            return true;
          }
          stopped.push(event);
          return false;
        });
      }
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return this;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
  var import_properties7 = __toESM(require_lib4());

  // node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
  var import_bignumber5 = __toESM(require_lib3());
  var import_properties5 = __toESM(require_lib4());

  // node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
  var import_abstract_signer2 = __toESM(require_lib15());
  var import_bignumber4 = __toESM(require_lib3());
  var import_bytes4 = __toESM(require_lib2());
  var import_hash2 = __toESM(require_lib12());
  var import_properties4 = __toESM(require_lib4());
  var import_strings2 = __toESM(require_lib9());
  var import_transactions3 = __toESM(require_lib17());
  var import_web2 = __toESM(require_lib26());
  var import_logger5 = __toESM(require_lib());
  var __awaiter4 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger5 = new import_logger5.Logger(version3);
  var errorGas = ["call", "estimateGas"];
  function spelunk(value, requireData) {
    if (value == null) {
      return null;
    }
    if (typeof value.message === "string" && value.message.match("reverted")) {
      const data = (0, import_bytes4.isHexString)(value.data) ? value.data : null;
      if (!requireData || data) {
        return { message: value.message, data };
      }
    }
    if (typeof value === "object") {
      for (const key in value) {
        const result = spelunk(value[key], requireData);
        if (result) {
          return result;
        }
      }
      return null;
    }
    if (typeof value === "string") {
      try {
        return spelunk(JSON.parse(value), requireData);
      } catch (error) {
      }
    }
    return null;
  }
  function checkError(method, error, params) {
    const transaction2 = params.transaction || params.signedTransaction;
    if (method === "call") {
      const result = spelunk(error, true);
      if (result) {
        return result.data;
      }
      logger5.throwError("missing revert data in call exception; Transaction reverted without a reason string", import_logger5.Logger.errors.CALL_EXCEPTION, {
        data: "0x",
        transaction: transaction2,
        error
      });
    }
    if (method === "estimateGas") {
      let result = spelunk(error.body, false);
      if (result == null) {
        result = spelunk(error, false);
      }
      if (result) {
        logger5.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", import_logger5.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          reason: result.message,
          method,
          transaction: transaction2,
          error
        });
      }
    }
    let message = error.message;
    if (error.code === import_logger5.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
    message = (message || "").toLowerCase();
    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
      logger5.throwError("insufficient funds for intrinsic transaction cost", import_logger5.Logger.errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction: transaction2
      });
    }
    if (message.match(/nonce (is )?too low/i)) {
      logger5.throwError("nonce has already been used", import_logger5.Logger.errors.NONCE_EXPIRED, {
        error,
        method,
        transaction: transaction2
      });
    }
    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
      logger5.throwError("replacement fee too low", import_logger5.Logger.errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction: transaction2
      });
    }
    if (message.match(/only replay-protected/i)) {
      logger5.throwError("legacy pre-eip-155 transactions not supported", import_logger5.Logger.errors.UNSUPPORTED_OPERATION, {
        error,
        method,
        transaction: transaction2
      });
    }
    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
      logger5.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", import_logger5.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction: transaction2
      });
    }
    throw error;
  }
  function timer2(timeout) {
    return new Promise(function(resolve) {
      setTimeout(resolve, timeout);
    });
  }
  function getResult(payload) {
    if (payload.error) {
      const error = new Error(payload.error.message);
      error.code = payload.error.code;
      error.data = payload.error.data;
      throw error;
    }
    return payload.result;
  }
  function getLowerCase(value) {
    if (value) {
      return value.toLowerCase();
    }
    return value;
  }
  var _constructorGuard = {};
  var JsonRpcSigner = class extends import_abstract_signer2.Signer {
    constructor(constructorGuard, provider, addressOrIndex) {
      super();
      if (constructorGuard !== _constructorGuard) {
        throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
      }
      (0, import_properties4.defineReadOnly)(this, "provider", provider);
      if (addressOrIndex == null) {
        addressOrIndex = 0;
      }
      if (typeof addressOrIndex === "string") {
        (0, import_properties4.defineReadOnly)(this, "_address", this.provider.formatter.address(addressOrIndex));
        (0, import_properties4.defineReadOnly)(this, "_index", null);
      } else if (typeof addressOrIndex === "number") {
        (0, import_properties4.defineReadOnly)(this, "_index", addressOrIndex);
        (0, import_properties4.defineReadOnly)(this, "_address", null);
      } else {
        logger5.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
      }
    }
    connect(provider) {
      return logger5.throwError("cannot alter JSON-RPC Signer connection", import_logger5.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "connect"
      });
    }
    connectUnchecked() {
      return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
    }
    getAddress() {
      if (this._address) {
        return Promise.resolve(this._address);
      }
      return this.provider.send("eth_accounts", []).then((accounts) => {
        if (accounts.length <= this._index) {
          logger5.throwError("unknown account #" + this._index, import_logger5.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress"
          });
        }
        return this.provider.formatter.address(accounts[this._index]);
      });
    }
    sendUncheckedTransaction(transaction2) {
      transaction2 = (0, import_properties4.shallowCopy)(transaction2);
      const fromAddress = this.getAddress().then((address) => {
        if (address) {
          address = address.toLowerCase();
        }
        return address;
      });
      if (transaction2.gasLimit == null) {
        const estimate = (0, import_properties4.shallowCopy)(transaction2);
        estimate.from = fromAddress;
        transaction2.gasLimit = this.provider.estimateGas(estimate);
      }
      if (transaction2.to != null) {
        transaction2.to = Promise.resolve(transaction2.to).then((to) => __awaiter4(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.provider.resolveName(to);
          if (address == null) {
            logger5.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
      }
      return (0, import_properties4.resolveProperties)({
        tx: (0, import_properties4.resolveProperties)(transaction2),
        sender: fromAddress
      }).then(({ tx, sender }) => {
        if (tx.from != null) {
          if (tx.from.toLowerCase() !== sender) {
            logger5.throwArgumentError("from address mismatch", "transaction", transaction2);
          }
        } else {
          tx.from = sender;
        }
        const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
        return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
          return hash3;
        }, (error) => {
          if (typeof error.message === "string" && error.message.match(/user denied/i)) {
            logger5.throwError("user rejected transaction", import_logger5.Logger.errors.ACTION_REJECTED, {
              action: "sendTransaction",
              transaction: tx
            });
          }
          return checkError("sendTransaction", error, hexTx);
        });
      });
    }
    signTransaction(transaction2) {
      return logger5.throwError("signing transactions is unsupported", import_logger5.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "signTransaction"
      });
    }
    sendTransaction(transaction2) {
      return __awaiter4(this, void 0, void 0, function* () {
        const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
        const hash3 = yield this.sendUncheckedTransaction(transaction2);
        try {
          return yield (0, import_web2.poll)(() => __awaiter4(this, void 0, void 0, function* () {
            const tx = yield this.provider.getTransaction(hash3);
            if (tx === null) {
              return void 0;
            }
            return this.provider._wrapTransaction(tx, hash3, blockNumber);
          }), { oncePoll: this.provider });
        } catch (error) {
          error.transactionHash = hash3;
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter4(this, void 0, void 0, function* () {
        const data = typeof message === "string" ? (0, import_strings2.toUtf8Bytes)(message) : message;
        const address = yield this.getAddress();
        try {
          return yield this.provider.send("personal_sign", [(0, import_bytes4.hexlify)(data), address.toLowerCase()]);
        } catch (error) {
          if (typeof error.message === "string" && error.message.match(/user denied/i)) {
            logger5.throwError("user rejected signing", import_logger5.Logger.errors.ACTION_REJECTED, {
              action: "signMessage",
              from: address,
              messageData: message
            });
          }
          throw error;
        }
      });
    }
    _legacySignMessage(message) {
      return __awaiter4(this, void 0, void 0, function* () {
        const data = typeof message === "string" ? (0, import_strings2.toUtf8Bytes)(message) : message;
        const address = yield this.getAddress();
        try {
          return yield this.provider.send("eth_sign", [address.toLowerCase(), (0, import_bytes4.hexlify)(data)]);
        } catch (error) {
          if (typeof error.message === "string" && error.message.match(/user denied/i)) {
            logger5.throwError("user rejected signing", import_logger5.Logger.errors.ACTION_REJECTED, {
              action: "_legacySignMessage",
              from: address,
              messageData: message
            });
          }
          throw error;
        }
      });
    }
    _signTypedData(domain, types, value) {
      return __awaiter4(this, void 0, void 0, function* () {
        const populated = yield import_hash2._TypedDataEncoder.resolveNames(domain, types, value, (name) => {
          return this.provider.resolveName(name);
        });
        const address = yield this.getAddress();
        try {
          return yield this.provider.send("eth_signTypedData_v4", [
            address.toLowerCase(),
            JSON.stringify(import_hash2._TypedDataEncoder.getPayload(populated.domain, types, populated.value))
          ]);
        } catch (error) {
          if (typeof error.message === "string" && error.message.match(/user denied/i)) {
            logger5.throwError("user rejected signing", import_logger5.Logger.errors.ACTION_REJECTED, {
              action: "_signTypedData",
              from: address,
              messageData: { domain: populated.domain, types, value: populated.value }
            });
          }
          throw error;
        }
      });
    }
    unlock(password) {
      return __awaiter4(this, void 0, void 0, function* () {
        const provider = this.provider;
        const address = yield this.getAddress();
        return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
      });
    }
  };
  var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
    sendTransaction(transaction2) {
      return this.sendUncheckedTransaction(transaction2).then((hash3) => {
        return {
          hash: hash3,
          nonce: null,
          gasLimit: null,
          gasPrice: null,
          data: null,
          value: null,
          chainId: null,
          confirmations: 0,
          from: null,
          wait: (confirmations) => {
            return this.provider.waitForTransaction(hash3, confirmations);
          }
        };
      });
    }
  };
  var allowedTransactionKeys2 = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true
  };
  var JsonRpcProvider = class extends BaseProvider {
    constructor(url, network) {
      let networkOrReady = network;
      if (networkOrReady == null) {
        networkOrReady = new Promise((resolve, reject) => {
          setTimeout(() => {
            this.detectNetwork().then((network2) => {
              resolve(network2);
            }, (error) => {
              reject(error);
            });
          }, 0);
        });
      }
      super(networkOrReady);
      if (!url) {
        url = (0, import_properties4.getStatic)(this.constructor, "defaultUrl")();
      }
      if (typeof url === "string") {
        (0, import_properties4.defineReadOnly)(this, "connection", Object.freeze({
          url
        }));
      } else {
        (0, import_properties4.defineReadOnly)(this, "connection", Object.freeze((0, import_properties4.shallowCopy)(url)));
      }
      this._nextId = 42;
    }
    get _cache() {
      if (this._eventLoopCache == null) {
        this._eventLoopCache = {};
      }
      return this._eventLoopCache;
    }
    static defaultUrl() {
      return "http://localhost:8545";
    }
    detectNetwork() {
      if (!this._cache["detectNetwork"]) {
        this._cache["detectNetwork"] = this._uncachedDetectNetwork();
        setTimeout(() => {
          this._cache["detectNetwork"] = null;
        }, 0);
      }
      return this._cache["detectNetwork"];
    }
    _uncachedDetectNetwork() {
      return __awaiter4(this, void 0, void 0, function* () {
        yield timer2(0);
        let chainId = null;
        try {
          chainId = yield this.send("eth_chainId", []);
        } catch (error) {
          try {
            chainId = yield this.send("net_version", []);
          } catch (error2) {
          }
        }
        if (chainId != null) {
          const getNetwork2 = (0, import_properties4.getStatic)(this.constructor, "getNetwork");
          try {
            return getNetwork2(import_bignumber4.BigNumber.from(chainId).toNumber());
          } catch (error) {
            return logger5.throwError("could not detect network", import_logger5.Logger.errors.NETWORK_ERROR, {
              chainId,
              event: "invalidNetwork",
              serverError: error
            });
          }
        }
        return logger5.throwError("could not detect network", import_logger5.Logger.errors.NETWORK_ERROR, {
          event: "noNetwork"
        });
      });
    }
    getSigner(addressOrIndex) {
      return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
    }
    getUncheckedSigner(addressOrIndex) {
      return this.getSigner(addressOrIndex).connectUnchecked();
    }
    listAccounts() {
      return this.send("eth_accounts", []).then((accounts) => {
        return accounts.map((a2) => this.formatter.address(a2));
      });
    }
    send(method, params) {
      const request = {
        method,
        params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      this.emit("debug", {
        action: "request",
        request: (0, import_properties4.deepCopy)(request),
        provider: this
      });
      const cache2 = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
      if (cache2 && this._cache[method]) {
        return this._cache[method];
      }
      const result = (0, import_web2.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result2) => {
        this.emit("debug", {
          action: "response",
          request,
          response: result2,
          provider: this
        });
        return result2;
      }, (error) => {
        this.emit("debug", {
          action: "response",
          error,
          request,
          provider: this
        });
        throw error;
      });
      if (cache2) {
        this._cache[method] = result;
        setTimeout(() => {
          this._cache[method] = null;
        }, 0);
      }
      return result;
    }
    prepareRequest(method, params) {
      switch (method) {
        case "getBlockNumber":
          return ["eth_blockNumber", []];
        case "getGasPrice":
          return ["eth_gasPrice", []];
        case "getBalance":
          return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
        case "getTransactionCount":
          return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
        case "getCode":
          return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
        case "getStorageAt":
          return ["eth_getStorageAt", [getLowerCase(params.address), (0, import_bytes4.hexZeroPad)(params.position, 32), params.blockTag]];
        case "sendTransaction":
          return ["eth_sendRawTransaction", [params.signedTransaction]];
        case "getBlock":
          if (params.blockTag) {
            return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
          } else if (params.blockHash) {
            return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
          }
          return null;
        case "getTransaction":
          return ["eth_getTransactionByHash", [params.transactionHash]];
        case "getTransactionReceipt":
          return ["eth_getTransactionReceipt", [params.transactionHash]];
        case "call": {
          const hexlifyTransaction = (0, import_properties4.getStatic)(this.constructor, "hexlifyTransaction");
          return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
        }
        case "estimateGas": {
          const hexlifyTransaction = (0, import_properties4.getStatic)(this.constructor, "hexlifyTransaction");
          return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
        }
        case "getLogs":
          if (params.filter && params.filter.address != null) {
            params.filter.address = getLowerCase(params.filter.address);
          }
          return ["eth_getLogs", [params.filter]];
        default:
          break;
      }
      return null;
    }
    perform(method, params) {
      return __awaiter4(this, void 0, void 0, function* () {
        if (method === "call" || method === "estimateGas") {
          const tx = params.transaction;
          if (tx && tx.type != null && import_bignumber4.BigNumber.from(tx.type).isZero()) {
            if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
              const feeData = yield this.getFeeData();
              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                params = (0, import_properties4.shallowCopy)(params);
                params.transaction = (0, import_properties4.shallowCopy)(tx);
                delete params.transaction.type;
              }
            }
          }
        }
        const args = this.prepareRequest(method, params);
        if (args == null) {
          logger5.throwError(method + " not implemented", import_logger5.Logger.errors.NOT_IMPLEMENTED, { operation: method });
        }
        try {
          return yield this.send(args[0], args[1]);
        } catch (error) {
          return checkError(method, error, params);
        }
      });
    }
    _startEvent(event) {
      if (event.tag === "pending") {
        this._startPending();
      }
      super._startEvent(event);
    }
    _startPending() {
      if (this._pendingFilter != null) {
        return;
      }
      const self2 = this;
      const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
      this._pendingFilter = pendingFilter;
      pendingFilter.then(function(filterId) {
        function poll6() {
          self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
            if (self2._pendingFilter != pendingFilter) {
              return null;
            }
            let seq = Promise.resolve();
            hashes.forEach(function(hash3) {
              self2._emitted["t:" + hash3.toLowerCase()] = "pending";
              seq = seq.then(function() {
                return self2.getTransaction(hash3).then(function(tx) {
                  self2.emit("pending", tx);
                  return null;
                });
              });
            });
            return seq.then(function() {
              return timer2(1e3);
            });
          }).then(function() {
            if (self2._pendingFilter != pendingFilter) {
              self2.send("eth_uninstallFilter", [filterId]);
              return;
            }
            setTimeout(function() {
              poll6();
            }, 0);
            return null;
          }).catch((error) => {
          });
        }
        poll6();
        return filterId;
      }).catch((error) => {
      });
    }
    _stopEvent(event) {
      if (event.tag === "pending" && this.listenerCount("pending") === 0) {
        this._pendingFilter = null;
      }
      super._stopEvent(event);
    }
    // Convert an ethers.js transaction into a JSON-RPC transaction
    //  - gasLimit => gas
    //  - All values hexlified
    //  - All numeric values zero-striped
    //  - All addresses are lowercased
    // NOTE: This allows a TransactionRequest, but all values should be resolved
    //       before this is called
    // @TODO: This will likely be removed in future versions and prepareRequest
    //        will be the preferred method for this.
    static hexlifyTransaction(transaction2, allowExtra) {
      const allowed = (0, import_properties4.shallowCopy)(allowedTransactionKeys2);
      if (allowExtra) {
        for (const key in allowExtra) {
          if (allowExtra[key]) {
            allowed[key] = true;
          }
        }
      }
      (0, import_properties4.checkProperties)(transaction2, allowed);
      const result = {};
      ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key) {
        if (transaction2[key] == null) {
          return;
        }
        const value = (0, import_bytes4.hexValue)(import_bignumber4.BigNumber.from(transaction2[key]));
        if (key === "gasLimit") {
          key = "gas";
        }
        result[key] = value;
      });
      ["from", "to", "data"].forEach(function(key) {
        if (transaction2[key] == null) {
          return;
        }
        result[key] = (0, import_bytes4.hexlify)(transaction2[key]);
      });
      if (transaction2.accessList) {
        result["accessList"] = (0, import_transactions3.accessListify)(transaction2.accessList);
      }
      return result;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/ws.js
  var import_logger6 = __toESM(require_lib());
  var WS = null;
  try {
    WS = WebSocket;
    if (WS == null) {
      throw new Error("inject please");
    }
  } catch (error) {
    const logger19 = new import_logger6.Logger(version3);
    WS = function() {
      logger19.throwError("WebSockets not supported in this environment", import_logger6.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new WebSocket()"
      });
    };
  }

  // node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
  var import_logger7 = __toESM(require_lib());
  var __awaiter5 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger6 = new import_logger7.Logger(version3);
  var NextId = 1;
  var WebSocketProvider = class extends JsonRpcProvider {
    constructor(url, network) {
      if (network === "any") {
        logger6.throwError("WebSocketProvider does not support 'any' network yet", import_logger7.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "network:any"
        });
      }
      if (typeof url === "string") {
        super(url, network);
      } else {
        super("_websocket", network);
      }
      this._pollingInterval = -1;
      this._wsReady = false;
      if (typeof url === "string") {
        (0, import_properties5.defineReadOnly)(this, "_websocket", new WS(this.connection.url));
      } else {
        (0, import_properties5.defineReadOnly)(this, "_websocket", url);
      }
      (0, import_properties5.defineReadOnly)(this, "_requests", {});
      (0, import_properties5.defineReadOnly)(this, "_subs", {});
      (0, import_properties5.defineReadOnly)(this, "_subIds", {});
      (0, import_properties5.defineReadOnly)(this, "_detectNetwork", super.detectNetwork());
      this.websocket.onopen = () => {
        this._wsReady = true;
        Object.keys(this._requests).forEach((id3) => {
          this.websocket.send(this._requests[id3].payload);
        });
      };
      this.websocket.onmessage = (messageEvent) => {
        const data = messageEvent.data;
        const result = JSON.parse(data);
        if (result.id != null) {
          const id3 = String(result.id);
          const request = this._requests[id3];
          delete this._requests[id3];
          if (result.result !== void 0) {
            request.callback(null, result.result);
            this.emit("debug", {
              action: "response",
              request: JSON.parse(request.payload),
              response: result.result,
              provider: this
            });
          } else {
            let error = null;
            if (result.error) {
              error = new Error(result.error.message || "unknown error");
              (0, import_properties5.defineReadOnly)(error, "code", result.error.code || null);
              (0, import_properties5.defineReadOnly)(error, "response", data);
            } else {
              error = new Error("unknown error");
            }
            request.callback(error, void 0);
            this.emit("debug", {
              action: "response",
              error,
              request: JSON.parse(request.payload),
              provider: this
            });
          }
        } else if (result.method === "eth_subscription") {
          const sub = this._subs[result.params.subscription];
          if (sub) {
            sub.processFunc(result.params.result);
          }
        } else {
          console.warn("this should not happen");
        }
      };
      const fauxPoll = setInterval(() => {
        this.emit("poll");
      }, 1e3);
      if (fauxPoll.unref) {
        fauxPoll.unref();
      }
    }
    // Cannot narrow the type of _websocket, as that is not backwards compatible
    // so we add a getter and let the WebSocket be a public API.
    get websocket() {
      return this._websocket;
    }
    detectNetwork() {
      return this._detectNetwork;
    }
    get pollingInterval() {
      return 0;
    }
    resetEventsBlock(blockNumber) {
      logger6.throwError("cannot reset events block on WebSocketProvider", import_logger7.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resetEventBlock"
      });
    }
    set pollingInterval(value) {
      logger6.throwError("cannot set polling interval on WebSocketProvider", import_logger7.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setPollingInterval"
      });
    }
    poll() {
      return __awaiter5(this, void 0, void 0, function* () {
        return null;
      });
    }
    set polling(value) {
      if (!value) {
        return;
      }
      logger6.throwError("cannot set polling on WebSocketProvider", import_logger7.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setPolling"
      });
    }
    send(method, params) {
      const rid = NextId++;
      return new Promise((resolve, reject) => {
        function callback(error, result) {
          if (error) {
            return reject(error);
          }
          return resolve(result);
        }
        const payload = JSON.stringify({
          method,
          params,
          id: rid,
          jsonrpc: "2.0"
        });
        this.emit("debug", {
          action: "request",
          request: JSON.parse(payload),
          provider: this
        });
        this._requests[String(rid)] = { callback, payload };
        if (this._wsReady) {
          this.websocket.send(payload);
        }
      });
    }
    static defaultUrl() {
      return "ws://localhost:8546";
    }
    _subscribe(tag, param, processFunc) {
      return __awaiter5(this, void 0, void 0, function* () {
        let subIdPromise = this._subIds[tag];
        if (subIdPromise == null) {
          subIdPromise = Promise.all(param).then((param2) => {
            return this.send("eth_subscribe", param2);
          });
          this._subIds[tag] = subIdPromise;
        }
        const subId = yield subIdPromise;
        this._subs[subId] = { tag, processFunc };
      });
    }
    _startEvent(event) {
      switch (event.type) {
        case "block":
          this._subscribe("block", ["newHeads"], (result) => {
            const blockNumber = import_bignumber5.BigNumber.from(result.number).toNumber();
            this._emitted.block = blockNumber;
            this.emit("block", blockNumber);
          });
          break;
        case "pending":
          this._subscribe("pending", ["newPendingTransactions"], (result) => {
            this.emit("pending", result);
          });
          break;
        case "filter":
          this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
            if (result.removed == null) {
              result.removed = false;
            }
            this.emit(event.filter, this.formatter.filterLog(result));
          });
          break;
        case "tx": {
          const emitReceipt = (event2) => {
            const hash3 = event2.hash;
            this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt) {
                return;
              }
              this.emit(hash3, receipt);
            });
          };
          emitReceipt(event);
          this._subscribe("tx", ["newHeads"], (result) => {
            this._events.filter((e) => e.type === "tx").forEach(emitReceipt);
          });
          break;
        }
        case "debug":
        case "poll":
        case "willPoll":
        case "didPoll":
        case "error":
          break;
        default:
          console.log("unhandled:", event);
          break;
      }
    }
    _stopEvent(event) {
      let tag = event.tag;
      if (event.type === "tx") {
        if (this._events.filter((e) => e.type === "tx").length) {
          return;
        }
        tag = "tx";
      } else if (this.listenerCount(event.event)) {
        return;
      }
      const subId = this._subIds[tag];
      if (!subId) {
        return;
      }
      delete this._subIds[tag];
      subId.then((subId2) => {
        if (!this._subs[subId2]) {
          return;
        }
        delete this._subs[subId2];
        this.send("eth_unsubscribe", [subId2]);
      });
    }
    destroy() {
      return __awaiter5(this, void 0, void 0, function* () {
        if (this.websocket.readyState === WS.CONNECTING) {
          yield new Promise((resolve) => {
            this.websocket.onopen = function() {
              resolve(true);
            };
            this.websocket.onerror = function() {
              resolve(false);
            };
          });
        }
        this.websocket.close(1e3);
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
  var import_logger9 = __toESM(require_lib());

  // node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
  var import_properties6 = __toESM(require_lib4());
  var import_logger8 = __toESM(require_lib());
  var __awaiter6 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger7 = new import_logger8.Logger(version3);
  var StaticJsonRpcProvider = class extends JsonRpcProvider {
    detectNetwork() {
      const _super = Object.create(null, {
        detectNetwork: { get: () => super.detectNetwork }
      });
      return __awaiter6(this, void 0, void 0, function* () {
        let network = this.network;
        if (network == null) {
          network = yield _super.detectNetwork.call(this);
          if (!network) {
            logger7.throwError("no network detected", import_logger8.Logger.errors.UNKNOWN_ERROR, {});
          }
          if (this._network == null) {
            (0, import_properties6.defineReadOnly)(this, "_network", network);
            this.emit("network", network, null);
          }
        }
        return network;
      });
    }
  };
  var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
    constructor(network, apiKey) {
      logger7.checkAbstract(new.target, UrlJsonRpcProvider);
      network = (0, import_properties6.getStatic)(new.target, "getNetwork")(network);
      apiKey = (0, import_properties6.getStatic)(new.target, "getApiKey")(apiKey);
      const connection = (0, import_properties6.getStatic)(new.target, "getUrl")(network, apiKey);
      super(connection, network);
      if (typeof apiKey === "string") {
        (0, import_properties6.defineReadOnly)(this, "apiKey", apiKey);
      } else if (apiKey != null) {
        Object.keys(apiKey).forEach((key) => {
          (0, import_properties6.defineReadOnly)(this, key, apiKey[key]);
        });
      }
    }
    _startPending() {
      logger7.warn("WARNING: API provider does not support pending filters");
    }
    isCommunityResource() {
      return false;
    }
    getSigner(address) {
      return logger7.throwError("API provider does not support signing", import_logger8.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
    }
    listAccounts() {
      return Promise.resolve([]);
    }
    // Return a defaultApiKey if null, otherwise validate the API key
    static getApiKey(apiKey) {
      return apiKey;
    }
    // Returns the url or connection for the given network and API key. The
    // API key will have been sanitized by the getApiKey first, so any validation
    // or transformations can be done there.
    static getUrl(network, apiKey) {
      return logger7.throwError("not implemented; sub-classes must override getUrl", import_logger8.Logger.errors.NOT_IMPLEMENTED, {
        operation: "getUrl"
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
  var logger8 = new import_logger9.Logger(version3);
  var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
  var AlchemyWebSocketProvider = class extends WebSocketProvider {
    constructor(network, apiKey) {
      const provider = new AlchemyProvider(network, apiKey);
      const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
      super(url, provider.network);
      (0, import_properties7.defineReadOnly)(this, "apiKey", provider.apiKey);
    }
    isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  };
  var AlchemyProvider = class extends UrlJsonRpcProvider {
    static getWebSocketProvider(network, apiKey) {
      return new AlchemyWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
      if (apiKey == null) {
        return defaultApiKey;
      }
      if (apiKey && typeof apiKey !== "string") {
        logger8.throwArgumentError("invalid apiKey", "apiKey", apiKey);
      }
      return apiKey;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "eth-mainnet.alchemyapi.io/v2/";
          break;
        case "goerli":
          host = "eth-goerli.g.alchemy.com/v2/";
          break;
        case "matic":
          host = "polygon-mainnet.g.alchemy.com/v2/";
          break;
        case "maticmum":
          host = "polygon-mumbai.g.alchemy.com/v2/";
          break;
        case "arbitrum":
          host = "arb-mainnet.g.alchemy.com/v2/";
          break;
        case "arbitrum-goerli":
          host = "arb-goerli.g.alchemy.com/v2/";
          break;
        case "optimism":
          host = "opt-mainnet.g.alchemy.com/v2/";
          break;
        case "optimism-goerli":
          host = "opt-goerli.g.alchemy.com/v2/";
          break;
        default:
          logger8.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return {
        allowGzip: true,
        url: "https://" + host + apiKey,
        throttleCallback: (attempt, url) => {
          if (apiKey === defaultApiKey) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
    }
    isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
  var import_logger10 = __toESM(require_lib());
  var logger9 = new import_logger10.Logger(version3);
  var defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
  function getHost(name) {
    switch (name) {
      case "homestead":
        return "rpc.ankr.com/eth/";
      case "ropsten":
        return "rpc.ankr.com/eth_ropsten/";
      case "rinkeby":
        return "rpc.ankr.com/eth_rinkeby/";
      case "goerli":
        return "rpc.ankr.com/eth_goerli/";
      case "matic":
        return "rpc.ankr.com/polygon/";
      case "arbitrum":
        return "rpc.ankr.com/arbitrum/";
    }
    return logger9.throwArgumentError("unsupported network", "name", name);
  }
  var AnkrProvider = class extends UrlJsonRpcProvider {
    isCommunityResource() {
      return this.apiKey === defaultApiKey2;
    }
    static getApiKey(apiKey) {
      if (apiKey == null) {
        return defaultApiKey2;
      }
      return apiKey;
    }
    static getUrl(network, apiKey) {
      if (apiKey == null) {
        apiKey = defaultApiKey2;
      }
      const connection = {
        allowGzip: true,
        url: "https://" + getHost(network.name) + apiKey,
        throttleCallback: (attempt, url) => {
          if (apiKey.apiKey === defaultApiKey2) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      if (apiKey.projectSecret != null) {
        connection.user = "";
        connection.password = apiKey.projectSecret;
      }
      return connection;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
  var import_logger11 = __toESM(require_lib());
  var __awaiter7 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger10 = new import_logger11.Logger(version3);
  var CloudflareProvider = class extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
      if (apiKey != null) {
        logger10.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
      }
      return null;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "https://cloudflare-eth.com/";
          break;
        default:
          logger10.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return host;
    }
    perform(method, params) {
      const _super = Object.create(null, {
        perform: { get: () => super.perform }
      });
      return __awaiter7(this, void 0, void 0, function* () {
        if (method === "getBlockNumber") {
          const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
          return block.number;
        }
        return _super.perform.call(this, method, params);
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
  var import_bytes5 = __toESM(require_lib2());
  var import_properties8 = __toESM(require_lib4());
  var import_transactions4 = __toESM(require_lib17());
  var import_web3 = __toESM(require_lib26());
  var import_logger12 = __toESM(require_lib());
  var __awaiter8 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger11 = new import_logger12.Logger(version3);
  function getTransactionPostData(transaction2) {
    const result = {};
    for (let key in transaction2) {
      if (transaction2[key] == null) {
        continue;
      }
      let value = transaction2[key];
      if (key === "type" && value === 0) {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value = (0, import_bytes5.hexValue)((0, import_bytes5.hexlify)(value));
      } else if (key === "accessList") {
        value = "[" + (0, import_transactions4.accessListify)(value).map((set4) => {
          return `{address:"${set4.address}",storageKeys:["${set4.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else {
        value = (0, import_bytes5.hexlify)(value);
      }
      result[key] = value;
    }
    return result;
  }
  function getResult2(result) {
    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
      return result.result;
    }
    if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
      const error = new Error("invalid response");
      error.result = JSON.stringify(result);
      if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        error.throttleRetry = true;
      }
      throw error;
    }
    return result.result;
  }
  function getJsonResult(result) {
    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      const error = new Error("throttled response");
      error.result = JSON.stringify(result);
      error.throttleRetry = true;
      throw error;
    }
    if (result.jsonrpc != "2.0") {
      const error = new Error("invalid response");
      error.result = JSON.stringify(result);
      throw error;
    }
    if (result.error) {
      const error = new Error(result.error.message || "unknown error");
      if (result.error.code) {
        error.code = result.error.code;
      }
      if (result.error.data) {
        error.data = result.error.data;
      }
      throw error;
    }
    return result.result;
  }
  function checkLogTag(blockTag) {
    if (blockTag === "pending") {
      throw new Error("pending not supported");
    }
    if (blockTag === "latest") {
      return blockTag;
    }
    return parseInt(blockTag.substring(2), 16);
  }
  function checkError2(method, error, transaction2) {
    if (method === "call" && error.code === import_logger12.Logger.errors.SERVER_ERROR) {
      const e = error.error;
      if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
        let data = e.data;
        if (data) {
          data = "0x" + data.replace(/^.*0x/i, "");
        }
        if ((0, import_bytes5.isHexString)(data)) {
          return data;
        }
        logger11.throwError("missing revert data in call exception", import_logger12.Logger.errors.CALL_EXCEPTION, {
          error,
          data: "0x"
        });
      }
    }
    let message = error.message;
    if (error.code === import_logger12.Logger.errors.SERVER_ERROR) {
      if (error.error && typeof error.error.message === "string") {
        message = error.error.message;
      } else if (typeof error.body === "string") {
        message = error.body;
      } else if (typeof error.responseText === "string") {
        message = error.responseText;
      }
    }
    message = (message || "").toLowerCase();
    if (message.match(/insufficient funds/)) {
      logger11.throwError("insufficient funds for intrinsic transaction cost", import_logger12.Logger.errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction: transaction2
      });
    }
    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
      logger11.throwError("nonce has already been used", import_logger12.Logger.errors.NONCE_EXPIRED, {
        error,
        method,
        transaction: transaction2
      });
    }
    if (message.match(/another transaction with same nonce/)) {
      logger11.throwError("replacement fee too low", import_logger12.Logger.errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction: transaction2
      });
    }
    if (message.match(/execution failed due to an exception|execution reverted/)) {
      logger11.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", import_logger12.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction: transaction2
      });
    }
    throw error;
  }
  var EtherscanProvider = class extends BaseProvider {
    constructor(network, apiKey) {
      super(network);
      (0, import_properties8.defineReadOnly)(this, "baseUrl", this.getBaseUrl());
      (0, import_properties8.defineReadOnly)(this, "apiKey", apiKey || null);
    }
    getBaseUrl() {
      switch (this.network ? this.network.name : "invalid") {
        case "homestead":
          return "https://api.etherscan.io";
        case "goerli":
          return "https://api-goerli.etherscan.io";
        case "sepolia":
          return "https://api-sepolia.etherscan.io";
        case "matic":
          return "https://api.polygonscan.com";
        case "maticmum":
          return "https://api-testnet.polygonscan.com";
        case "arbitrum":
          return "https://api.arbiscan.io";
        case "arbitrum-goerli":
          return "https://api-goerli.arbiscan.io";
        case "optimism":
          return "https://api-optimistic.etherscan.io";
        case "optimism-goerli":
          return "https://api-goerli-optimistic.etherscan.io";
        default:
      }
      return logger11.throwArgumentError("unsupported network", "network", this.network.name);
    }
    getUrl(module2, params) {
      const query = Object.keys(params).reduce((accum, key) => {
        const value = params[key];
        if (value != null) {
          accum += `&${key}=${value}`;
        }
        return accum;
      }, "");
      const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
      return `${this.baseUrl}/api?module=${module2}${query}${apiKey}`;
    }
    getPostUrl() {
      return `${this.baseUrl}/api`;
    }
    getPostData(module2, params) {
      params.module = module2;
      params.apikey = this.apiKey;
      return params;
    }
    fetch(module2, params, post) {
      return __awaiter8(this, void 0, void 0, function* () {
        const url = post ? this.getPostUrl() : this.getUrl(module2, params);
        const payload = post ? this.getPostData(module2, params) : null;
        const procFunc = module2 === "proxy" ? getJsonResult : getResult2;
        this.emit("debug", {
          action: "request",
          request: url,
          provider: this
        });
        const connection = {
          url,
          throttleSlotInterval: 1e3,
          throttleCallback: (attempt, url2) => {
            if (this.isCommunityResource()) {
              showThrottleMessage();
            }
            return Promise.resolve(true);
          }
        };
        let payloadStr = null;
        if (payload) {
          connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
          payloadStr = Object.keys(payload).map((key) => {
            return `${key}=${payload[key]}`;
          }).join("&");
        }
        const result = yield (0, import_web3.fetchJson)(connection, payloadStr, procFunc || getJsonResult);
        this.emit("debug", {
          action: "response",
          request: url,
          response: (0, import_properties8.deepCopy)(result),
          provider: this
        });
        return result;
      });
    }
    detectNetwork() {
      return __awaiter8(this, void 0, void 0, function* () {
        return this.network;
      });
    }
    perform(method, params) {
      const _super = Object.create(null, {
        perform: { get: () => super.perform }
      });
      return __awaiter8(this, void 0, void 0, function* () {
        switch (method) {
          case "getBlockNumber":
            return this.fetch("proxy", { action: "eth_blockNumber" });
          case "getGasPrice":
            return this.fetch("proxy", { action: "eth_gasPrice" });
          case "getBalance":
            return this.fetch("account", {
              action: "balance",
              address: params.address,
              tag: params.blockTag
            });
          case "getTransactionCount":
            return this.fetch("proxy", {
              action: "eth_getTransactionCount",
              address: params.address,
              tag: params.blockTag
            });
          case "getCode":
            return this.fetch("proxy", {
              action: "eth_getCode",
              address: params.address,
              tag: params.blockTag
            });
          case "getStorageAt":
            return this.fetch("proxy", {
              action: "eth_getStorageAt",
              address: params.address,
              position: params.position,
              tag: params.blockTag
            });
          case "sendTransaction":
            return this.fetch("proxy", {
              action: "eth_sendRawTransaction",
              hex: params.signedTransaction
            }, true).catch((error) => {
              return checkError2("sendTransaction", error, params.signedTransaction);
            });
          case "getBlock":
            if (params.blockTag) {
              return this.fetch("proxy", {
                action: "eth_getBlockByNumber",
                tag: params.blockTag,
                boolean: params.includeTransactions ? "true" : "false"
              });
            }
            throw new Error("getBlock by blockHash not implemented");
          case "getTransaction":
            return this.fetch("proxy", {
              action: "eth_getTransactionByHash",
              txhash: params.transactionHash
            });
          case "getTransactionReceipt":
            return this.fetch("proxy", {
              action: "eth_getTransactionReceipt",
              txhash: params.transactionHash
            });
          case "call": {
            if (params.blockTag !== "latest") {
              throw new Error("EtherscanProvider does not support blockTag for call");
            }
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_call";
            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError2("call", error, params.transaction);
            }
          }
          case "estimateGas": {
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_estimateGas";
            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError2("estimateGas", error, params.transaction);
            }
          }
          case "getLogs": {
            const args = { action: "getLogs" };
            if (params.filter.fromBlock) {
              args.fromBlock = checkLogTag(params.filter.fromBlock);
            }
            if (params.filter.toBlock) {
              args.toBlock = checkLogTag(params.filter.toBlock);
            }
            if (params.filter.address) {
              args.address = params.filter.address;
            }
            if (params.filter.topics && params.filter.topics.length > 0) {
              if (params.filter.topics.length > 1) {
                logger11.throwError("unsupported topic count", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
              }
              if (params.filter.topics.length === 1) {
                const topic0 = params.filter.topics[0];
                if (typeof topic0 !== "string" || topic0.length !== 66) {
                  logger11.throwError("unsupported topic format", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
                }
                args.topic0 = topic0;
              }
            }
            const logs = yield this.fetch("logs", args);
            let blocks = {};
            for (let i4 = 0; i4 < logs.length; i4++) {
              const log = logs[i4];
              if (log.blockHash != null) {
                continue;
              }
              if (blocks[log.blockNumber] == null) {
                const block = yield this.getBlock(log.blockNumber);
                if (block) {
                  blocks[log.blockNumber] = block.hash;
                }
              }
              log.blockHash = blocks[log.blockNumber];
            }
            return logs;
          }
          case "getEtherPrice":
            if (this.network.name !== "homestead") {
              return 0;
            }
            return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
          default:
            break;
        }
        return _super.perform.call(this, method, params);
      });
    }
    // Note: The `page` page parameter only allows pagination within the
    //       10,000 window available without a page and offset parameter
    //       Error: Result window is too large, PageNo x Offset size must
    //              be less than or equal to 10000
    getHistory(addressOrName, startBlock, endBlock) {
      return __awaiter8(this, void 0, void 0, function* () {
        const params = {
          action: "txlist",
          address: yield this.resolveName(addressOrName),
          startblock: startBlock == null ? 0 : startBlock,
          endblock: endBlock == null ? 99999999 : endBlock,
          sort: "asc"
        };
        const result = yield this.fetch("account", params);
        return result.map((tx) => {
          ["contractAddress", "to"].forEach(function(key) {
            if (tx[key] == "") {
              delete tx[key];
            }
          });
          if (tx.creates == null && tx.contractAddress != null) {
            tx.creates = tx.contractAddress;
          }
          const item = this.formatter.transactionResponse(tx);
          if (tx.timeStamp) {
            item.timestamp = parseInt(tx.timeStamp);
          }
          return item;
        });
      });
    }
    isCommunityResource() {
      return this.apiKey == null;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
  var import_abstract_provider3 = __toESM(require_lib14());
  var import_bignumber6 = __toESM(require_lib3());
  var import_bytes6 = __toESM(require_lib2());
  var import_properties9 = __toESM(require_lib4());
  var import_random = __toESM(require_lib23());
  var import_web4 = __toESM(require_lib26());
  var import_logger13 = __toESM(require_lib());
  var __awaiter9 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger12 = new import_logger13.Logger(version3);
  function now() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function checkNetworks(networks2) {
    let result = null;
    for (let i4 = 0; i4 < networks2.length; i4++) {
      const network = networks2[i4];
      if (network == null) {
        return null;
      }
      if (result) {
        if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
          logger12.throwArgumentError("provider mismatch", "networks", networks2);
        }
      } else {
        result = network;
      }
    }
    return result;
  }
  function median(values, maxDelta) {
    values = values.slice().sort();
    const middle = Math.floor(values.length / 2);
    if (values.length % 2) {
      return values[middle];
    }
    const a2 = values[middle - 1], b4 = values[middle];
    if (maxDelta != null && Math.abs(a2 - b4) > maxDelta) {
      return null;
    }
    return (a2 + b4) / 2;
  }
  function serialize(value) {
    if (value === null) {
      return "null";
    } else if (typeof value === "number" || typeof value === "boolean") {
      return JSON.stringify(value);
    } else if (typeof value === "string") {
      return value;
    } else if (import_bignumber6.BigNumber.isBigNumber(value)) {
      return value.toString();
    } else if (Array.isArray(value)) {
      return JSON.stringify(value.map((i4) => serialize(i4)));
    } else if (typeof value === "object") {
      const keys = Object.keys(value);
      keys.sort();
      return "{" + keys.map((key) => {
        let v7 = value[key];
        if (typeof v7 === "function") {
          v7 = "[function]";
        } else {
          v7 = serialize(v7);
        }
        return JSON.stringify(key) + ":" + v7;
      }).join(",") + "}";
    }
    throw new Error("unknown value type: " + typeof value);
  }
  var nextRid = 1;
  function stall2(duration) {
    let cancel = null;
    let timer3 = null;
    let promise = new Promise((resolve) => {
      cancel = function() {
        if (timer3) {
          clearTimeout(timer3);
          timer3 = null;
        }
        resolve();
      };
      timer3 = setTimeout(cancel, duration);
    });
    const wait2 = (func) => {
      promise = promise.then(func);
      return promise;
    };
    function getPromise() {
      return promise;
    }
    return { cancel, getPromise, wait: wait2 };
  }
  var ForwardErrors = [
    import_logger13.Logger.errors.CALL_EXCEPTION,
    import_logger13.Logger.errors.INSUFFICIENT_FUNDS,
    import_logger13.Logger.errors.NONCE_EXPIRED,
    import_logger13.Logger.errors.REPLACEMENT_UNDERPRICED,
    import_logger13.Logger.errors.UNPREDICTABLE_GAS_LIMIT
  ];
  var ForwardProperties = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction"
  ];
  function exposeDebugConfig(config2, now2) {
    const result = {
      weight: config2.weight
    };
    Object.defineProperty(result, "provider", { get: () => config2.provider });
    if (config2.start) {
      result.start = config2.start;
    }
    if (now2) {
      result.duration = now2 - config2.start;
    }
    if (config2.done) {
      if (config2.error) {
        result.error = config2.error;
      } else {
        result.result = config2.result || null;
      }
    }
    return result;
  }
  function normalizedTally(normalize2, quorum) {
    return function(configs) {
      const tally = {};
      configs.forEach((c3) => {
        const value = normalize2(c3.result);
        if (!tally[value]) {
          tally[value] = { count: 0, result: c3.result };
        }
        tally[value].count++;
      });
      const keys = Object.keys(tally);
      for (let i4 = 0; i4 < keys.length; i4++) {
        const check = tally[keys[i4]];
        if (check.count >= quorum) {
          return check.result;
        }
      }
      return void 0;
    };
  }
  function getProcessFunc(provider, method, params) {
    let normalize2 = serialize;
    switch (method) {
      case "getBlockNumber":
        return function(configs) {
          const values = configs.map((c3) => c3.result);
          let blockNumber = median(configs.map((c3) => c3.result), 2);
          if (blockNumber == null) {
            return void 0;
          }
          blockNumber = Math.ceil(blockNumber);
          if (values.indexOf(blockNumber + 1) >= 0) {
            blockNumber++;
          }
          if (blockNumber >= provider._highestBlockNumber) {
            provider._highestBlockNumber = blockNumber;
          }
          return provider._highestBlockNumber;
        };
      case "getGasPrice":
        return function(configs) {
          const values = configs.map((c3) => c3.result);
          values.sort();
          return values[Math.floor(values.length / 2)];
        };
      case "getEtherPrice":
        return function(configs) {
          return median(configs.map((c3) => c3.result));
        };
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorageAt":
      case "call":
      case "estimateGas":
      case "getLogs":
        break;
      case "getTransaction":
      case "getTransactionReceipt":
        normalize2 = function(tx) {
          if (tx == null) {
            return null;
          }
          tx = (0, import_properties9.shallowCopy)(tx);
          tx.confirmations = -1;
          return serialize(tx);
        };
        break;
      case "getBlock":
        if (params.includeTransactions) {
          normalize2 = function(block) {
            if (block == null) {
              return null;
            }
            block = (0, import_properties9.shallowCopy)(block);
            block.transactions = block.transactions.map((tx) => {
              tx = (0, import_properties9.shallowCopy)(tx);
              tx.confirmations = -1;
              return tx;
            });
            return serialize(block);
          };
        } else {
          normalize2 = function(block) {
            if (block == null) {
              return null;
            }
            return serialize(block);
          };
        }
        break;
      default:
        throw new Error("unknown method: " + method);
    }
    return normalizedTally(normalize2, provider.quorum);
  }
  function waitForSync(config2, blockNumber) {
    return __awaiter9(this, void 0, void 0, function* () {
      const provider = config2.provider;
      if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
        return provider;
      }
      return (0, import_web4.poll)(() => {
        return new Promise((resolve, reject) => {
          setTimeout(function() {
            if (provider.blockNumber >= blockNumber) {
              return resolve(provider);
            }
            if (config2.cancelled) {
              return resolve(null);
            }
            return resolve(void 0);
          }, 0);
        });
      }, { oncePoll: provider });
    });
  }
  function getRunner(config2, currentBlockNumber, method, params) {
    return __awaiter9(this, void 0, void 0, function* () {
      let provider = config2.provider;
      switch (method) {
        case "getBlockNumber":
        case "getGasPrice":
          return provider[method]();
        case "getEtherPrice":
          if (provider.getEtherPrice) {
            return provider.getEtherPrice();
          }
          break;
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
          if (params.blockTag && (0, import_bytes6.isHexString)(params.blockTag)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          return provider[method](params.address, params.blockTag || "latest");
        case "getStorageAt":
          if (params.blockTag && (0, import_bytes6.isHexString)(params.blockTag)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
        case "getBlock":
          if (params.blockTag && (0, import_bytes6.isHexString)(params.blockTag)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
        case "call":
        case "estimateGas":
          if (params.blockTag && (0, import_bytes6.isHexString)(params.blockTag)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          if (method === "call" && params.blockTag) {
            return provider[method](params.transaction, params.blockTag);
          }
          return provider[method](params.transaction);
        case "getTransaction":
        case "getTransactionReceipt":
          return provider[method](params.transactionHash);
        case "getLogs": {
          let filter2 = params.filter;
          if (filter2.fromBlock && (0, import_bytes6.isHexString)(filter2.fromBlock) || filter2.toBlock && (0, import_bytes6.isHexString)(filter2.toBlock)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          return provider.getLogs(filter2);
        }
      }
      return logger12.throwError("unknown method error", import_logger13.Logger.errors.UNKNOWN_ERROR, {
        method,
        params
      });
    });
  }
  var FallbackProvider = class extends BaseProvider {
    constructor(providers, quorum) {
      if (providers.length === 0) {
        logger12.throwArgumentError("missing providers", "providers", providers);
      }
      const providerConfigs = providers.map((configOrProvider, index2) => {
        if (import_abstract_provider3.Provider.isProvider(configOrProvider)) {
          const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
          const priority = 1;
          return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
        }
        const config2 = (0, import_properties9.shallowCopy)(configOrProvider);
        if (config2.priority == null) {
          config2.priority = 1;
        }
        if (config2.stallTimeout == null) {
          config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        }
        if (config2.weight == null) {
          config2.weight = 1;
        }
        const weight = config2.weight;
        if (weight % 1 || weight > 512 || weight < 1) {
          logger12.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index2}].weight`, weight);
        }
        return Object.freeze(config2);
      });
      const total = providerConfigs.reduce((accum, c3) => accum + c3.weight, 0);
      if (quorum == null) {
        quorum = total / 2;
      } else if (quorum > total) {
        logger12.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
      }
      let networkOrReady = checkNetworks(providerConfigs.map((c3) => c3.provider.network));
      if (networkOrReady == null) {
        networkOrReady = new Promise((resolve, reject) => {
          setTimeout(() => {
            this.detectNetwork().then(resolve, reject);
          }, 0);
        });
      }
      super(networkOrReady);
      (0, import_properties9.defineReadOnly)(this, "providerConfigs", Object.freeze(providerConfigs));
      (0, import_properties9.defineReadOnly)(this, "quorum", quorum);
      this._highestBlockNumber = -1;
    }
    detectNetwork() {
      return __awaiter9(this, void 0, void 0, function* () {
        const networks2 = yield Promise.all(this.providerConfigs.map((c3) => c3.provider.getNetwork()));
        return checkNetworks(networks2);
      });
    }
    perform(method, params) {
      return __awaiter9(this, void 0, void 0, function* () {
        if (method === "sendTransaction") {
          const results = yield Promise.all(this.providerConfigs.map((c3) => {
            return c3.provider.sendTransaction(params.signedTransaction).then((result) => {
              return result.hash;
            }, (error) => {
              return error;
            });
          }));
          for (let i5 = 0; i5 < results.length; i5++) {
            const result = results[i5];
            if (typeof result === "string") {
              return result;
            }
          }
          throw results[0];
        }
        if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
          yield this.getBlockNumber();
        }
        const processFunc = getProcessFunc(this, method, params);
        const configs = (0, import_random.shuffled)(this.providerConfigs.map(import_properties9.shallowCopy));
        configs.sort((a2, b4) => a2.priority - b4.priority);
        const currentBlockNumber = this._highestBlockNumber;
        let i4 = 0;
        let first2 = true;
        while (true) {
          const t0 = now();
          let inflightWeight = configs.filter((c3) => c3.runner && t0 - c3.start < c3.stallTimeout).reduce((accum, c3) => accum + c3.weight, 0);
          while (inflightWeight < this.quorum && i4 < configs.length) {
            const config2 = configs[i4++];
            const rid = nextRid++;
            config2.start = now();
            config2.staller = stall2(config2.stallTimeout);
            config2.staller.wait(() => {
              config2.staller = null;
            });
            config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
              config2.done = true;
              config2.result = result;
              if (this.listenerCount("debug")) {
                this.emit("debug", {
                  action: "request",
                  rid,
                  backend: exposeDebugConfig(config2, now()),
                  request: { method, params: (0, import_properties9.deepCopy)(params) },
                  provider: this
                });
              }
            }, (error) => {
              config2.done = true;
              config2.error = error;
              if (this.listenerCount("debug")) {
                this.emit("debug", {
                  action: "request",
                  rid,
                  backend: exposeDebugConfig(config2, now()),
                  request: { method, params: (0, import_properties9.deepCopy)(params) },
                  provider: this
                });
              }
            });
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, null),
                request: { method, params: (0, import_properties9.deepCopy)(params) },
                provider: this
              });
            }
            inflightWeight += config2.weight;
          }
          const waiting = [];
          configs.forEach((c3) => {
            if (c3.done || !c3.runner) {
              return;
            }
            waiting.push(c3.runner);
            if (c3.staller) {
              waiting.push(c3.staller.getPromise());
            }
          });
          if (waiting.length) {
            yield Promise.race(waiting);
          }
          const results = configs.filter((c3) => c3.done && c3.error == null);
          if (results.length >= this.quorum) {
            const result = processFunc(results);
            if (result !== void 0) {
              configs.forEach((c3) => {
                if (c3.staller) {
                  c3.staller.cancel();
                }
                c3.cancelled = true;
              });
              return result;
            }
            if (!first2) {
              yield stall2(100).getPromise();
            }
            first2 = false;
          }
          const errors3 = configs.reduce((accum, c3) => {
            if (!c3.done || c3.error == null) {
              return accum;
            }
            const code = c3.error.code;
            if (ForwardErrors.indexOf(code) >= 0) {
              if (!accum[code]) {
                accum[code] = { error: c3.error, weight: 0 };
              }
              accum[code].weight += c3.weight;
            }
            return accum;
          }, {});
          Object.keys(errors3).forEach((errorCode) => {
            const tally = errors3[errorCode];
            if (tally.weight < this.quorum) {
              return;
            }
            configs.forEach((c3) => {
              if (c3.staller) {
                c3.staller.cancel();
              }
              c3.cancelled = true;
            });
            const e = tally.error;
            const props = {};
            ForwardProperties.forEach((name) => {
              if (e[name] == null) {
                return;
              }
              props[name] = e[name];
            });
            logger12.throwError(e.reason || e.message, errorCode, props);
          });
          if (configs.filter((c3) => !c3.done).length === 0) {
            break;
          }
        }
        configs.forEach((c3) => {
          if (c3.staller) {
            c3.staller.cancel();
          }
          c3.cancelled = true;
        });
        return logger12.throwError("failed to meet quorum", import_logger13.Logger.errors.SERVER_ERROR, {
          method,
          params,
          //results: configs.map((c) => c.result),
          //errors: configs.map((c) => c.error),
          results: configs.map((c3) => exposeDebugConfig(c3)),
          provider: this
        });
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
  var IpcProvider = null;

  // node_modules/@ethersproject/providers/lib.esm/infura-provider.js
  var import_properties10 = __toESM(require_lib4());
  var import_logger14 = __toESM(require_lib());
  var logger13 = new import_logger14.Logger(version3);
  var defaultProjectId = "84842078b09946638c03157f83405213";
  var InfuraWebSocketProvider = class extends WebSocketProvider {
    constructor(network, apiKey) {
      const provider = new InfuraProvider(network, apiKey);
      const connection = provider.connection;
      if (connection.password) {
        logger13.throwError("INFURA WebSocket project secrets unsupported", import_logger14.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "InfuraProvider.getWebSocketProvider()"
        });
      }
      const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
      super(url, network);
      (0, import_properties10.defineReadOnly)(this, "apiKey", provider.projectId);
      (0, import_properties10.defineReadOnly)(this, "projectId", provider.projectId);
      (0, import_properties10.defineReadOnly)(this, "projectSecret", provider.projectSecret);
    }
    isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
  };
  var InfuraProvider = class extends UrlJsonRpcProvider {
    static getWebSocketProvider(network, apiKey) {
      return new InfuraWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
      const apiKeyObj = {
        apiKey: defaultProjectId,
        projectId: defaultProjectId,
        projectSecret: null
      };
      if (apiKey == null) {
        return apiKeyObj;
      }
      if (typeof apiKey === "string") {
        apiKeyObj.projectId = apiKey;
      } else if (apiKey.projectSecret != null) {
        logger13.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
        logger13.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
        apiKeyObj.projectId = apiKey.projectId;
        apiKeyObj.projectSecret = apiKey.projectSecret;
      } else if (apiKey.projectId) {
        apiKeyObj.projectId = apiKey.projectId;
      }
      apiKeyObj.apiKey = apiKeyObj.projectId;
      return apiKeyObj;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network ? network.name : "unknown") {
        case "homestead":
          host = "mainnet.infura.io";
          break;
        case "goerli":
          host = "goerli.infura.io";
          break;
        case "sepolia":
          host = "sepolia.infura.io";
          break;
        case "matic":
          host = "polygon-mainnet.infura.io";
          break;
        case "maticmum":
          host = "polygon-mumbai.infura.io";
          break;
        case "optimism":
          host = "optimism-mainnet.infura.io";
          break;
        case "optimism-goerli":
          host = "optimism-goerli.infura.io";
          break;
        case "arbitrum":
          host = "arbitrum-mainnet.infura.io";
          break;
        case "arbitrum-goerli":
          host = "arbitrum-goerli.infura.io";
          break;
        default:
          logger13.throwError("unsupported network", import_logger14.Logger.errors.INVALID_ARGUMENT, {
            argument: "network",
            value: network
          });
      }
      const connection = {
        allowGzip: true,
        url: "https://" + host + "/v3/" + apiKey.projectId,
        throttleCallback: (attempt, url) => {
          if (apiKey.projectId === defaultProjectId) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      if (apiKey.projectSecret != null) {
        connection.user = "";
        connection.password = apiKey.projectSecret;
      }
      return connection;
    }
    isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
  var import_properties11 = __toESM(require_lib4());
  var import_web5 = __toESM(require_lib26());
  var JsonRpcBatchProvider = class extends JsonRpcProvider {
    send(method, params) {
      const request = {
        method,
        params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      if (this._pendingBatch == null) {
        this._pendingBatch = [];
      }
      const inflightRequest = { request, resolve: null, reject: null };
      const promise = new Promise((resolve, reject) => {
        inflightRequest.resolve = resolve;
        inflightRequest.reject = reject;
      });
      this._pendingBatch.push(inflightRequest);
      if (!this._pendingBatchAggregator) {
        this._pendingBatchAggregator = setTimeout(() => {
          const batch = this._pendingBatch;
          this._pendingBatch = null;
          this._pendingBatchAggregator = null;
          const request2 = batch.map((inflight) => inflight.request);
          this.emit("debug", {
            action: "requestBatch",
            request: (0, import_properties11.deepCopy)(request2),
            provider: this
          });
          return (0, import_web5.fetchJson)(this.connection, JSON.stringify(request2)).then((result) => {
            this.emit("debug", {
              action: "response",
              request: request2,
              response: result,
              provider: this
            });
            batch.forEach((inflightRequest2, index2) => {
              const payload = result[index2];
              if (payload.error) {
                const error = new Error(payload.error.message);
                error.code = payload.error.code;
                error.data = payload.error.data;
                inflightRequest2.reject(error);
              } else {
                inflightRequest2.resolve(payload.result);
              }
            });
          }, (error) => {
            this.emit("debug", {
              action: "response",
              error,
              request: request2,
              provider: this
            });
            batch.forEach((inflightRequest2) => {
              inflightRequest2.reject(error);
            });
          });
        }, 10);
      }
      return promise;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
  var import_logger15 = __toESM(require_lib());
  var logger14 = new import_logger15.Logger(version3);
  var defaultApiKey3 = "ETHERS_JS_SHARED";
  var NodesmithProvider = class extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
      if (apiKey && typeof apiKey !== "string") {
        logger14.throwArgumentError("invalid apiKey", "apiKey", apiKey);
      }
      return apiKey || defaultApiKey3;
    }
    static getUrl(network, apiKey) {
      logger14.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
          break;
        case "ropsten":
          host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
          break;
        case "rinkeby":
          host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
          break;
        case "goerli":
          host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
          break;
        case "kovan":
          host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
          break;
        default:
          logger14.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return host + "?apiKey=" + apiKey;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
  var import_logger16 = __toESM(require_lib());
  var logger15 = new import_logger16.Logger(version3);
  var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
  var PocketProvider = class extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
      const apiKeyObj = {
        applicationId: null,
        loadBalancer: true,
        applicationSecretKey: null
      };
      if (apiKey == null) {
        apiKeyObj.applicationId = defaultApplicationId;
      } else if (typeof apiKey === "string") {
        apiKeyObj.applicationId = apiKey;
      } else if (apiKey.applicationSecretKey != null) {
        apiKeyObj.applicationId = apiKey.applicationId;
        apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
      } else if (apiKey.applicationId) {
        apiKeyObj.applicationId = apiKey.applicationId;
      } else {
        logger15.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
      }
      return apiKeyObj;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network ? network.name : "unknown") {
        case "goerli":
          host = "eth-goerli.gateway.pokt.network";
          break;
        case "homestead":
          host = "eth-mainnet.gateway.pokt.network";
          break;
        case "kovan":
          host = "poa-kovan.gateway.pokt.network";
          break;
        case "matic":
          host = "poly-mainnet.gateway.pokt.network";
          break;
        case "maticmum":
          host = "polygon-mumbai-rpc.gateway.pokt.network";
          break;
        case "rinkeby":
          host = "eth-rinkeby.gateway.pokt.network";
          break;
        case "ropsten":
          host = "eth-ropsten.gateway.pokt.network";
          break;
        default:
          logger15.throwError("unsupported network", import_logger16.Logger.errors.INVALID_ARGUMENT, {
            argument: "network",
            value: network
          });
      }
      const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
      const connection = { headers: {}, url };
      if (apiKey.applicationSecretKey != null) {
        connection.user = "";
        connection.password = apiKey.applicationSecretKey;
      }
      return connection;
    }
    isCommunityResource() {
      return this.applicationId === defaultApplicationId;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/web3-provider.js
  var import_properties12 = __toESM(require_lib4());
  var import_logger17 = __toESM(require_lib());
  var logger16 = new import_logger17.Logger(version3);
  var _nextId = 1;
  function buildWeb3LegacyFetcher(provider, sendFunc) {
    const fetcher = "Web3LegacyFetcher";
    return function(method, params) {
      const request = {
        method,
        params,
        id: _nextId++,
        jsonrpc: "2.0"
      };
      return new Promise((resolve, reject) => {
        this.emit("debug", {
          action: "request",
          fetcher,
          request: (0, import_properties12.deepCopy)(request),
          provider: this
        });
        sendFunc(request, (error, response) => {
          if (error) {
            this.emit("debug", {
              action: "response",
              fetcher,
              error,
              request,
              provider: this
            });
            return reject(error);
          }
          this.emit("debug", {
            action: "response",
            fetcher,
            request,
            response,
            provider: this
          });
          if (response.error) {
            const error2 = new Error(response.error.message);
            error2.code = response.error.code;
            error2.data = response.error.data;
            return reject(error2);
          }
          resolve(response.result);
        });
      });
    };
  }
  function buildEip1193Fetcher(provider) {
    return function(method, params) {
      if (params == null) {
        params = [];
      }
      const request = { method, params };
      this.emit("debug", {
        action: "request",
        fetcher: "Eip1193Fetcher",
        request: (0, import_properties12.deepCopy)(request),
        provider: this
      });
      return provider.request(request).then((response) => {
        this.emit("debug", {
          action: "response",
          fetcher: "Eip1193Fetcher",
          request,
          response,
          provider: this
        });
        return response;
      }, (error) => {
        this.emit("debug", {
          action: "response",
          fetcher: "Eip1193Fetcher",
          request,
          error,
          provider: this
        });
        throw error;
      });
    };
  }
  var Web3Provider = class extends JsonRpcProvider {
    constructor(provider, network) {
      if (provider == null) {
        logger16.throwArgumentError("missing provider", "provider", provider);
      }
      let path = null;
      let jsonRpcFetchFunc = null;
      let subprovider = null;
      if (typeof provider === "function") {
        path = "unknown:";
        jsonRpcFetchFunc = provider;
      } else {
        path = provider.host || provider.path || "";
        if (!path && provider.isMetaMask) {
          path = "metamask";
        }
        subprovider = provider;
        if (provider.request) {
          if (path === "") {
            path = "eip-1193:";
          }
          jsonRpcFetchFunc = buildEip1193Fetcher(provider);
        } else if (provider.sendAsync) {
          jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
        } else if (provider.send) {
          jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
        } else {
          logger16.throwArgumentError("unsupported provider", "provider", provider);
        }
        if (!path) {
          path = "unknown:";
        }
      }
      super(path, network);
      (0, import_properties12.defineReadOnly)(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
      (0, import_properties12.defineReadOnly)(this, "provider", subprovider);
    }
    send(method, params) {
      return this.jsonRpcFetchFunc(method, params);
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/index.js
  var import_logger18 = __toESM(require_lib());
  var logger17 = new import_logger18.Logger(version3);
  function getDefaultProvider(network, options) {
    if (network == null) {
      network = "homestead";
    }
    if (typeof network === "string") {
      const match = network.match(/^(ws|http)s?:/i);
      if (match) {
        switch (match[1].toLowerCase()) {
          case "http":
          case "https":
            return new JsonRpcProvider(network);
          case "ws":
          case "wss":
            return new WebSocketProvider(network);
          default:
            logger17.throwArgumentError("unsupported URL scheme", "network", network);
        }
      }
    }
    const n4 = getNetwork(network);
    if (!n4 || !n4._defaultProvider) {
      logger17.throwError("unsupported getDefaultProvider network", import_logger18.Logger.errors.NETWORK_ERROR, {
        operation: "getDefaultProvider",
        network
      });
    }
    return n4._defaultProvider({
      FallbackProvider,
      AlchemyProvider,
      AnkrProvider,
      CloudflareProvider,
      EtherscanProvider,
      InfuraProvider,
      JsonRpcProvider,
      NodesmithProvider,
      PocketProvider,
      Web3Provider,
      IpcProvider
    }, options);
  }

  // node_modules/ethers/lib.esm/ethers.js
  var import_wordlists = __toESM(require_lib21());

  // node_modules/ethers/lib.esm/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    AbiCoder: () => import_abi2.AbiCoder,
    ConstructorFragment: () => import_abi2.ConstructorFragment,
    ErrorFragment: () => import_abi2.ErrorFragment,
    EventFragment: () => import_abi2.EventFragment,
    FormatTypes: () => import_abi2.FormatTypes,
    Fragment: () => import_abi2.Fragment,
    FunctionFragment: () => import_abi2.FunctionFragment,
    HDNode: () => import_hdnode.HDNode,
    Indexed: () => import_abi2.Indexed,
    Interface: () => import_abi2.Interface,
    LogDescription: () => import_abi2.LogDescription,
    Logger: () => import_logger19.Logger,
    ParamType: () => import_abi2.ParamType,
    RLP: () => RLP,
    SigningKey: () => import_signing_key.SigningKey,
    SupportedAlgorithm: () => import_sha23.SupportedAlgorithm,
    TransactionDescription: () => import_abi2.TransactionDescription,
    TransactionTypes: () => import_transactions5.TransactionTypes,
    UnicodeNormalizationForm: () => import_strings4.UnicodeNormalizationForm,
    Utf8ErrorFuncs: () => import_strings3.Utf8ErrorFuncs,
    Utf8ErrorReason: () => import_strings4.Utf8ErrorReason,
    _TypedDataEncoder: () => import_hash3._TypedDataEncoder,
    _fetchData: () => import_web6._fetchData,
    _toEscapedUtf8String: () => import_strings3._toEscapedUtf8String,
    accessListify: () => import_transactions5.accessListify,
    arrayify: () => import_bytes7.arrayify,
    base58: () => import_basex2.Base58,
    base64: () => base64,
    checkProperties: () => import_properties13.checkProperties,
    checkResultErrors: () => import_abi2.checkResultErrors,
    commify: () => import_units.commify,
    computeAddress: () => import_transactions5.computeAddress,
    computeHmac: () => import_sha22.computeHmac,
    computePublicKey: () => import_signing_key.computePublicKey,
    concat: () => import_bytes7.concat,
    deepCopy: () => import_properties13.deepCopy,
    defaultAbiCoder: () => import_abi2.defaultAbiCoder,
    defaultPath: () => import_hdnode.defaultPath,
    defineReadOnly: () => import_properties13.defineReadOnly,
    dnsEncode: () => import_hash3.dnsEncode,
    entropyToMnemonic: () => import_hdnode.entropyToMnemonic,
    fetchJson: () => import_web6.fetchJson,
    formatBytes32String: () => import_strings3.formatBytes32String,
    formatEther: () => import_units.formatEther,
    formatUnits: () => import_units.formatUnits,
    getAccountPath: () => import_hdnode.getAccountPath,
    getAddress: () => import_address3.getAddress,
    getContractAddress: () => import_address3.getContractAddress,
    getCreate2Address: () => import_address3.getCreate2Address,
    getIcapAddress: () => import_address3.getIcapAddress,
    getJsonWalletAddress: () => import_json_wallets.getJsonWalletAddress,
    getStatic: () => import_properties13.getStatic,
    hashMessage: () => import_hash3.hashMessage,
    hexConcat: () => import_bytes7.hexConcat,
    hexDataLength: () => import_bytes7.hexDataLength,
    hexDataSlice: () => import_bytes7.hexDataSlice,
    hexStripZeros: () => import_bytes7.hexStripZeros,
    hexValue: () => import_bytes7.hexValue,
    hexZeroPad: () => import_bytes7.hexZeroPad,
    hexlify: () => import_bytes7.hexlify,
    id: () => import_hash3.id,
    isAddress: () => import_address3.isAddress,
    isBytes: () => import_bytes7.isBytes,
    isBytesLike: () => import_bytes7.isBytesLike,
    isHexString: () => import_bytes7.isHexString,
    isValidMnemonic: () => import_hdnode.isValidMnemonic,
    isValidName: () => import_hash3.isValidName,
    joinSignature: () => import_bytes7.joinSignature,
    keccak256: () => import_keccak256.keccak256,
    mnemonicToEntropy: () => import_hdnode.mnemonicToEntropy,
    mnemonicToSeed: () => import_hdnode.mnemonicToSeed,
    namehash: () => import_hash3.namehash,
    nameprep: () => import_strings3.nameprep,
    parseBytes32String: () => import_strings3.parseBytes32String,
    parseEther: () => import_units.parseEther,
    parseTransaction: () => import_transactions5.parse,
    parseUnits: () => import_units.parseUnits,
    poll: () => import_web6.poll,
    randomBytes: () => import_random2.randomBytes,
    recoverAddress: () => import_transactions5.recoverAddress,
    recoverPublicKey: () => import_signing_key.recoverPublicKey,
    resolveProperties: () => import_properties13.resolveProperties,
    ripemd160: () => import_sha22.ripemd160,
    serializeTransaction: () => import_transactions5.serialize,
    sha256: () => import_sha22.sha256,
    sha512: () => import_sha22.sha512,
    shallowCopy: () => import_properties13.shallowCopy,
    shuffled: () => import_random2.shuffled,
    solidityKeccak256: () => import_solidity.keccak256,
    solidityPack: () => import_solidity.pack,
    soliditySha256: () => import_solidity.sha256,
    splitSignature: () => import_bytes7.splitSignature,
    stripZeros: () => import_bytes7.stripZeros,
    toUtf8Bytes: () => import_strings3.toUtf8Bytes,
    toUtf8CodePoints: () => import_strings3.toUtf8CodePoints,
    toUtf8String: () => import_strings3.toUtf8String,
    verifyMessage: () => import_wallet.verifyMessage,
    verifyTypedData: () => import_wallet.verifyTypedData,
    zeroPad: () => import_bytes7.zeroPad
  });
  var import_abi2 = __toESM(require_lib13());
  var import_address3 = __toESM(require_lib7());
  var base64 = __toESM(require_lib10());
  var import_basex2 = __toESM(require_lib18());
  var import_bytes7 = __toESM(require_lib2());
  var import_hash3 = __toESM(require_lib12());
  var import_hdnode = __toESM(require_lib22());
  var import_json_wallets = __toESM(require_lib24());
  var import_keccak256 = __toESM(require_lib5());
  var import_logger19 = __toESM(require_lib());
  var import_sha22 = __toESM(require_lib19());
  var import_solidity = __toESM(require_lib27());
  var import_random2 = __toESM(require_lib23());
  var import_properties13 = __toESM(require_lib4());
  var RLP = __toESM(require_lib6());
  var import_signing_key = __toESM(require_lib16());
  var import_strings3 = __toESM(require_lib9());
  var import_transactions5 = __toESM(require_lib17());
  var import_units = __toESM(require_lib28());
  var import_wallet = __toESM(require_lib25());
  var import_web6 = __toESM(require_lib26());
  var import_sha23 = __toESM(require_lib19());
  var import_strings4 = __toESM(require_lib9());

  // node_modules/ethers/lib.esm/ethers.js
  var import_logger20 = __toESM(require_lib());

  // node_modules/ethers/lib.esm/_version.js
  var version4 = "ethers/5.7.2";

  // node_modules/ethers/lib.esm/ethers.js
  var logger18 = new import_logger20.Logger(version4);

  // node_modules/ethers/lib.esm/index.js
  try {
    const anyGlobal = window;
    if (anyGlobal._ethers == null) {
      anyGlobal._ethers = ethers_exports;
    }
  } catch (error) {
  }

  // node_modules/@latticexyz/utils/dist/index.js
  var import_utils = __toESM(require_utils5(), 1);
  function d() {
    let e = null, r2 = null, t3 = new Promise((n4, o3) => {
      e = (i4) => n4(i4), r2 = (i4) => o3(i4);
    });
    return [e, r2, t3];
  }
  async function P(e) {
    let [r2, , t3] = d(), n4 = reaction(() => e.get(), (i4) => {
      i4 && r2(i4);
    }, { fireImmediately: true }), o3 = await t3;
    return n4(), o3;
  }
  function _14(e) {
    return typeof e == "object" && !Array.isArray(e) && e !== null;
  }
  function E(e) {
    return e instanceof Function;
  }
  function U(e, r2) {
    if (r2.length === 0)
      return e;
    if (r2.length === 1)
      return e[r2[0]];
    let [t3, ...n4] = r2, o3 = e[t3];
    if (!_14(o3))
      throw new Error("Path does not exist on the target");
    return U(o3, n4);
  }
  function Je(e) {
    let r2 = [], t3 = new import_proxy_deep.default({}, { get(n4, o3) {
      let i4 = e.get();
      return i4 ? o3 === "proxied" ? false : Reflect.get(i4, o3) : o3 === "proxied" ? true : o3 === "name" ? "ProxiedTarget" : o3 === "toJSON" ? () => ({ proxied: true }) : this.nest(() => {
      });
    }, apply(n4, o3, i4) {
      let a2 = e.get();
      if (a2) {
        let s4 = U(a2, this.path);
        if (!E(s4))
          throw new Error("Target is not callable");
        return Reflect.apply(s4, o3, i4);
      } else {
        let [s4, l4, u3] = d();
        return r2.push({ path: this.path, args: i4, resolve: s4, reject: l4 }), u3;
      }
    } });
    return reaction(() => e.get(), (n4) => {
      if (!n4)
        return;
      let o3 = r2.splice(0);
      for (let { path: i4, args: a2, resolve: s4, reject: l4 } of o3) {
        let u3 = U(n4, i4);
        a2 && E(u3) ? (async () => {
          try {
            s4(await u3(...a2));
          } catch (p2) {
            l4(p2);
          }
        })() : s4(u3);
      }
    }), t3;
  }
  function Ge(e, r2) {
    let t3 = {};
    for (let n4 in e)
      t3[n4] = r2(e[n4], n4);
    return t3;
  }
  function de() {
    return pipe(filter((e) => e != null));
  }
  function ur() {
    return pipe(concatMap((e) => e));
  }
  function lr(e) {
    return pipe(timestamp(), scan((r2, t3) => {
      let n4 = 0;
      if (r2 !== null) {
        let o3 = t3.timestamp - r2.timestamp;
        n4 = o3 > e ? 0 : e - o3;
      }
      return { timestamp: t3.timestamp, delay: n4, value: t3.value };
    }, null), de(), mergeMap((r2) => of(r2.value).pipe(delay(r2.delay)), 1));
  }
  function mr(e) {
    return computed(() => e.get());
  }
  function cr(e) {
    let r2 = new ReplaySubject(1);
    return reaction(() => e.get(), (t3) => {
      t3 != null && r2.next(t3);
    }, { fireImmediately: true }), r2;
  }
  async function dr(e) {
    let r2 = observable.box();
    e.subscribe((n4) => runInAction(() => r2.set(n4)));
    let t3 = computed(() => r2.get());
    return await P(t3), t3;
  }
  async function xe(e, r2 = (t3) => t3 != null) {
    let [t3, , n4] = d();
    return e.pipe(first(r2)).subscribe(t3), n4;
  }
  var br = function() {
    let e = Te, r2 = be;
    return r2(e(32), 8) + "-" + r2(e(16), 4) + "-" + r2(16384 | e(12), 4) + "-" + r2(32768 | e(14), 4) + "-" + r2(e(48), 12);
  };
  var Te = function(e) {
    if (e < 0 || e > 53)
      return NaN;
    let r2 = 0 | Math.random() * 1073741824;
    return e > 30 ? r2 + (0 | Math.random() * (1 << e - 30)) * 1073741824 : r2 >>> 30 - e;
  };
  var be = function(e, r2) {
    let t3 = e.toString(16), n4 = r2 - t3.length, o3 = "0";
    for (; n4 > 0; n4 >>>= 1, o3 += o3)
      n4 & 1 && (t3 = o3 + t3);
    return t3;
  };
  function R(e, r2) {
    return new Promise((t3) => setTimeout(() => t3(r2), e));
  }
  var wr = function* (e = 0, r2 = 1, t3 = 0) {
    for (let n4 = 0; n4 < e; yield t3 + n4++ * r2)
      ;
  };
  async function ge(e, r2) {
    throw await R(e), new Error(r2);
  }
  var Cr = async (e, r2, t3) => Promise.race([e, ge(r2, t3)]);
  var Ir = (e, r2 = [], t3 = 10, n4 = 1e3) => {
    let [o3, i4, a2] = d();
    return (async () => {
      let l4;
      for (let u3 = 0; u3 < t3; u3++)
        try {
          l4 = await e(...r2), o3(l4);
          break;
        } catch (p2) {
          u3 < t3 - 1 ? (console.info("[CallWithRetry Failed] attempt number=" + u3, e), console.error(p2), await R(Math.min(n4 * 2 ** u3 + Math.random() * 100, 15e3))) : i4(p2);
        }
    })(), a2;
  };
  function h(e) {
    return { ...e, [Symbol.iterator]() {
      return this;
    } };
  }
  function kr(e, r2) {
    return h({ next() {
      let n4 = e.next(), o3 = r2.next();
      return n4.done && o3.done ? { done: true, value: null } : { value: [n4.value, o3.value] };
    } });
  }
  function v(e, r2) {
    return h({ next() {
      let { done: t3, value: n4 } = e.next();
      return { done: t3, value: t3 ? n4 : r2(n4) };
    } });
  }
  function Or(e) {
    let r2 = 0;
    return h({ next() {
      let n4 = r2 >= e.length;
      return n4 ? { done: n4, value: null } : { value: e[r2++] };
    } });
  }
  function Fr(e) {
    return import_bignumber7.BigNumber.from((0, import_utils.keccak256)((0, import_utils.toUtf8Bytes)(e))).toHexString();
  }
  function Hr(e, r2) {
    return r2.subscribe((t3) => e.postMessage(t3)), fromEvent(e, "message").pipe(map2((t3) => t3.data));
  }
  function we(e, r2) {
    return e & 2 ** r2 - 1;
  }
  function Ce(e, r2) {
    if (r2.reduce((n4, o3) => n4 + o3, 0) > 32)
      throw new Error("JS pretends integers are 32 bit when bitshifts are involved");
    if (e.length !== r2.length)
      throw new Error("Arrays' lengths must match");
    for (let n4 = 0; n4 < e.length; n4++) {
      if (e[n4] < 0)
        throw new Error("Underflow: can only pack unsigned integer");
      if (e[n4] > 2 ** r2[n4] - 1) {
        let o3 = `Overflow: ${e[n4]} does not fit in ${r2[n4]} bits`;
        throw new Error(o3);
      }
    }
    let t3 = 0;
    for (let n4 = 0; n4 < e.length; n4++)
      t3 = t3 << r2[n4] | e[n4];
    return t3;
  }
  function Ie(e, r2) {
    let t3 = [], n4 = e;
    for (let o3 = r2.length - 1; o3 >= 0; o3--)
      t3.unshift(we(n4, r2[o3])), n4 = n4 >>> r2[o3];
    return t3;
  }
  function Wr(e) {
    return Ce(e, [8, 24]);
  }
  function Jr(e) {
    return Ie(e, [8, 24]);
  }
  var ve = 2 ** 16 - 1;
  var A = 2 ** 15 - 1;
  function G(e, r2) {
    e.substring(0, 2) == "0x" && (e = e.substring(2));
    let t3 = r2 / 4;
    return e = e.padStart(t3, "0"), e = e.substring(e.length - t3), `0x${e}`;
  }
  function K(e) {
    return G(e, 160);
  }
  function Zr(e) {
    if (e[0] !== "0" && e[1] !== "x")
      throw new Error("Invalid hex string");
    return "0x" + e.substring(10);
  }
  var q = (e) => `0x${[...new Uint8Array(e)].map((r2) => r2.toString(16).padStart(2, "0")).join("")}`;
  var F = (e) => [...e].map((r2) => String.fromCharCode(r2)).join("");
  function Q(e) {
    return /^(0x)?([\da-f]{2})*$/i.test(e);
  }
  var V = (e) => {
    if (!Q(e))
      throw console.error("Invalid hex string", e), new Error("Invalid hex string");
    let r2 = e.match(/[\da-f]{2}/gi);
    return r2 ? new Uint8Array(r2.map((t3) => parseInt(t3, 16))) : new Uint8Array([]);
  };
  function Tt(e) {
    return e !== void 0;
  }
  var $ = (e) => {
    if (e.length > 16)
      throw new Error("string too long");
    return new Uint8Array(16).map((r2, t3) => e.charCodeAt(t3));
  };
  var f = class {
    namespace;
    name;
    constructor(r2, t3) {
      this.namespace = r2, this.name = t3;
    }
    toString() {
      return `TableId<${this.namespace || "[empty]"}:${this.name || "[empty]"}>`;
    }
    toHexString() {
      return f.toHexString(this.namespace, this.name);
    }
    static toHexString(r2, t3) {
      let n4 = new Uint8Array(32);
      return n4.set($(r2), 0), n4.set($(t3), 16), q(n4);
    }
    static fromHexString(r2) {
      return f.fromBytes32(V(r2));
    }
    static fromBytes32(r2) {
      let t3 = new Uint8Array(32);
      t3.set(r2);
      let n4 = F(t3.slice(0, 16)).replace(/\0+$/, ""), o3 = F(t3.slice(16, 32)).replace(/\0+$/, "");
      return new f(n4, o3);
    }
    static parse(r2) {
      let t3 = r2.match(/^TableId<(.+?):(.+?)>$/);
      if (!t3)
        return null;
      let [, n4, o3] = t3;
      return new f(n4 === "[empty]" ? "" : n4, o3 === "[empty]" ? "" : o3);
    }
  };
  var Z = 16;
  function Ot(e) {
    return Object.keys(e.tables).map((r2) => new f(e.namespace.slice(0, Z), r2.slice(0, Z)));
  }
  function Oe(e) {
    if (e < 2)
      throw new Error("Minimum size is 2");
    if (e > 64)
      throw new Error("Maximum size is 64");
    let r2 = 2 ** (e - 1) - 1, t3 = -r2 - 1;
    return (n4) => {
      if (n4 = n4 << 0, n4 > r2 || n4 < t3)
        throw console.log("value", n4, r2, t3, n4 > r2, n4 < t3), new Error(`Int${e} overflow`);
      return n4 < 0 ? 2 ** e + n4 : n4;
    };
  }
  var Lt = Oe(32);

  // node_modules/@latticexyz/recs/dist/index.js
  var U2 = ((d6) => (d6[d6.Boolean = 0] = "Boolean", d6[d6.Number = 1] = "Number", d6[d6.OptionalNumber = 2] = "OptionalNumber", d6[d6.BigInt = 3] = "BigInt", d6[d6.OptionalBigInt = 4] = "OptionalBigInt", d6[d6.String = 5] = "String", d6[d6.OptionalString = 6] = "OptionalString", d6[d6.NumberArray = 7] = "NumberArray", d6[d6.OptionalNumberArray = 8] = "OptionalNumberArray", d6[d6.BigIntArray = 9] = "BigIntArray", d6[d6.OptionalBigIntArray = 10] = "OptionalBigIntArray", d6[d6.StringArray = 11] = "StringArray", d6[d6.OptionalStringArray = 12] = "OptionalStringArray", d6[d6.Entity = 13] = "Entity", d6[d6.OptionalEntity = 14] = "OptionalEntity", d6[d6.EntityArray = 15] = "EntityArray", d6[d6.OptionalEntityArray = 16] = "OptionalEntityArray", d6[d6.T = 17] = "T", d6[d6.OptionalT = 18] = "OptionalT", d6))(U2 || {});
  var F2 = ((r2) => (r2[r2.Enter = 0] = "Enter", r2[r2.Exit = 1] = "Exit", r2[r2.Update = 2] = "Update", r2[r2.Noop = 3] = "Noop", r2))(F2 || {});
  var W2 = [14, 16, 2, 8, 4, 10, 6, 12, 18];
  function S(e) {
    return Symbol.for(e);
  }
  function b(e) {
    return Symbol.keyFor(e);
  }
  function H(e) {
    let t3 = /* @__PURE__ */ new Map();
    function n4(y4) {
      let m5 = t3.get(o3(y4));
      return m5 ? new Set([...m5].map(b)) : /* @__PURE__ */ new Set();
    }
    function o3(y4) {
      return Object.values(y4).join("/");
    }
    function r2(y4, m5) {
      if (!m5)
        return;
      let g5 = o3(m5), i4 = t3.get(g5);
      i4 || (i4 = /* @__PURE__ */ new Set(), t3.set(g5, i4)), i4.add(y4);
    }
    function p2(y4, m5) {
      if (!m5)
        return;
      let g5 = o3(m5), i4 = t3.get(g5);
      i4 && i4.delete(y4);
    }
    for (let y4 of T(e)) {
      let m5 = x(e, y4);
      r2(S(y4), m5);
    }
    let a2 = e.update$.subscribe(({ entity: y4, value: m5 }) => {
      p2(S(y4), m5[1]), r2(S(y4), m5[0]);
    });
    return e.world.registerDisposer(() => a2?.unsubscribe()), { ...e, getEntitiesWithValue: n4 };
  }
  function Be(e, t3, n4) {
    if (Object.keys(t3).length === 0)
      throw new Error("Component schema must have at least one key");
    let o3 = n4?.id ?? br(), r2 = Ge(t3, () => /* @__PURE__ */ new Map()), p2 = new Subject(), a2 = n4?.metadata, m5 = { values: r2, schema: t3, id: o3, update$: p2, metadata: a2, entities: () => v(Object.values(r2)[0].keys(), b), world: e };
    return n4?.indexed && (m5 = H(m5)), e.registerComponent(m5), m5;
  }
  function C(e, t3, n4) {
    let o3 = S(t3), r2 = x(e, t3);
    for (let [p2, a2] of Object.entries(n4))
      e.values[p2] ? e.values[p2].set(o3, a2) : e.metadata?.tableId && /^\d+$/.test(p2) || console.warn("Component definition for", e.metadata?.tableId ?? e.metadata?.contractId ?? e.id, "is missing key", p2, ", ignoring value", a2, "for entity", t3, ". Existing keys: ", Object.keys(e.values));
    e.update$.next({ entity: t3, value: [n4, r2], component: e });
  }
  function Re(e, t3, n4, o3) {
    let r2 = x(e, t3);
    if (r2 === void 0) {
      if (o3 === void 0)
        throw new Error("Can't update component without a current value or initial value");
      C(e, t3, { ...o3, ...n4 });
    } else
      C(e, t3, { ...r2, ...n4 });
  }
  function I(e, t3) {
    let n4 = S(t3), o3 = x(e, t3);
    for (let r2 of Object.keys(e.values))
      e.values[r2].delete(n4);
    e.update$.next({ entity: t3, value: [void 0, o3], component: e });
  }
  function v2(e, t3) {
    let n4 = S(t3);
    return Object.values(e.values)[0].has(n4);
  }
  function x(e, t3) {
    let n4 = {}, o3 = S(t3), r2 = Object.keys(e.schema);
    for (let p2 of r2) {
      let a2 = e.values[p2].get(o3);
      if (a2 === void 0 && !W2.includes(e.schema[p2]))
        return;
      n4[p2] = a2;
    }
    return n4;
  }
  function je(e, t3) {
    let n4 = x(e, t3);
    if (!n4)
      throw new Error(`No value for component ${e.id} on entity ${t3}`);
    return n4;
  }
  function T(e) {
    return e.entities();
  }
  var L = ((a2) => (a2[a2.Has = 0] = "Has", a2[a2.HasValue = 1] = "HasValue", a2[a2.Not = 2] = "Not", a2[a2.NotValue = 3] = "NotValue", a2[a2.ProxyRead = 4] = "ProxyRead", a2[a2.ProxyExpand = 5] = "ProxyExpand", a2))(L || {});
  function Jt() {
    let e = /* @__PURE__ */ new Set(), t3 = [], n4 = [];
    function o3({ id: i4, idSuffix: l4 } = {}) {
      let c3 = i4 || e.size + (l4 ? "-" + l4 : ""), u3 = S(c3);
      return e.add(u3), c3;
    }
    function r2() {
      return v(e.values(), b);
    }
    function p2(i4) {
      t3.push(i4);
    }
    function a2(i4) {
      for (let [, l4] of n4.filter((c3) => !i4 || c3[0] === i4))
        l4();
      n4 = n4.filter((l4) => i4 && l4[0] !== i4);
    }
    function y4(i4, l4 = "") {
      n4.push([l4, i4]);
    }
    function m5(i4) {
      let l4 = S(i4);
      return e.has(l4);
    }
    function g5(i4) {
      for (let l4 of t3)
        v2(l4, i4) && I(l4, i4);
      e.delete(S(i4));
    }
    return { registerEntity: o3, components: t3, registerComponent: p2, dispose: a2, registerDisposer: y4, hasEntity: m5, getEntities: r2, entitySymbols: e, deleteEntity: g5 };
  }

  // src/common/NetMgr.ts
  var _NetMgr = class {
    mud = void 0;
    constructor() {
    }
    static getInstance() {
      if (_NetMgr.instance === void 0) {
        _NetMgr.instance = new _NetMgr();
      }
      return _NetMgr.instance;
    }
    SetMud(mud) {
      this.mud = mud;
    }
    GetMud() {
      return this.mud;
    }
  };
  var NetMgr = _NetMgr;
  __publicField(NetMgr, "instance");

  // src/mud/createClientComponents.ts
  function createClientComponents({ components }) {
    return {
      ...components
      // add your client components or overrides here
    };
  }

  // src/mud/createSystemCalls.ts
  function createSystemCalls({ worldSend, txReduced$, singletonEntity }, {}) {
    const verifyGamePlay = async (entity, index2, opArray) => {
      try {
        const tx = await worldSend("verifyGamePlay", [entity, index2, opArray]);
        await xe(txReduced$, (txHash) => txHash === tx.hash);
        return true;
      } catch {
        return false;
      }
    };
    const joinGame = async () => {
      try {
        const tx = await worldSend("joinGame", []);
        await xe(txReduced$, (txHash) => txHash === tx.hash);
        return true;
      } catch {
        return false;
      }
    };
    return {
      joinGame,
      verifyGamePlay
    };
  }

  // node_modules/@latticexyz/std-client/dist/chunk-64VNNNML.js
  var i = new BehaviorSubject(null);

  // node_modules/@latticexyz/network/dist/chunk-GFCVK7S2.js
  function f2(r2) {
    if (r2 === "")
      throw new Error("Can't normalize an empty entity ID");
    return import_bignumber7.BigNumber.isBigNumber(r2) ? r2.toHexString() : Q(r2) ? import_bignumber7.BigNumber.from(r2).toHexString() : r2;
  }

  // node_modules/@latticexyz/network/dist/chunk-34B3FIL2.js
  var import_utils21 = __toESM(require_utils5(), 1);
  var import_debug = __toESM(require_browser(), 1);
  var import_orderBy = __toESM(require_orderBy(), 1);

  // node_modules/@latticexyz/schema-type/dist/typescript/index.js
  var I2 = ((t3) => (t3[t3.UINT8 = 0] = "UINT8", t3[t3.UINT16 = 1] = "UINT16", t3[t3.UINT24 = 2] = "UINT24", t3[t3.UINT32 = 3] = "UINT32", t3[t3.UINT40 = 4] = "UINT40", t3[t3.UINT48 = 5] = "UINT48", t3[t3.UINT56 = 6] = "UINT56", t3[t3.UINT64 = 7] = "UINT64", t3[t3.UINT72 = 8] = "UINT72", t3[t3.UINT80 = 9] = "UINT80", t3[t3.UINT88 = 10] = "UINT88", t3[t3.UINT96 = 11] = "UINT96", t3[t3.UINT104 = 12] = "UINT104", t3[t3.UINT112 = 13] = "UINT112", t3[t3.UINT120 = 14] = "UINT120", t3[t3.UINT128 = 15] = "UINT128", t3[t3.UINT136 = 16] = "UINT136", t3[t3.UINT144 = 17] = "UINT144", t3[t3.UINT152 = 18] = "UINT152", t3[t3.UINT160 = 19] = "UINT160", t3[t3.UINT168 = 20] = "UINT168", t3[t3.UINT176 = 21] = "UINT176", t3[t3.UINT184 = 22] = "UINT184", t3[t3.UINT192 = 23] = "UINT192", t3[t3.UINT200 = 24] = "UINT200", t3[t3.UINT208 = 25] = "UINT208", t3[t3.UINT216 = 26] = "UINT216", t3[t3.UINT224 = 27] = "UINT224", t3[t3.UINT232 = 28] = "UINT232", t3[t3.UINT240 = 29] = "UINT240", t3[t3.UINT248 = 30] = "UINT248", t3[t3.UINT256 = 31] = "UINT256", t3[t3.INT8 = 32] = "INT8", t3[t3.INT16 = 33] = "INT16", t3[t3.INT24 = 34] = "INT24", t3[t3.INT32 = 35] = "INT32", t3[t3.INT40 = 36] = "INT40", t3[t3.INT48 = 37] = "INT48", t3[t3.INT56 = 38] = "INT56", t3[t3.INT64 = 39] = "INT64", t3[t3.INT72 = 40] = "INT72", t3[t3.INT80 = 41] = "INT80", t3[t3.INT88 = 42] = "INT88", t3[t3.INT96 = 43] = "INT96", t3[t3.INT104 = 44] = "INT104", t3[t3.INT112 = 45] = "INT112", t3[t3.INT120 = 46] = "INT120", t3[t3.INT128 = 47] = "INT128", t3[t3.INT136 = 48] = "INT136", t3[t3.INT144 = 49] = "INT144", t3[t3.INT152 = 50] = "INT152", t3[t3.INT160 = 51] = "INT160", t3[t3.INT168 = 52] = "INT168", t3[t3.INT176 = 53] = "INT176", t3[t3.INT184 = 54] = "INT184", t3[t3.INT192 = 55] = "INT192", t3[t3.INT200 = 56] = "INT200", t3[t3.INT208 = 57] = "INT208", t3[t3.INT216 = 58] = "INT216", t3[t3.INT224 = 59] = "INT224", t3[t3.INT232 = 60] = "INT232", t3[t3.INT240 = 61] = "INT240", t3[t3.INT248 = 62] = "INT248", t3[t3.INT256 = 63] = "INT256", t3[t3.BYTES1 = 64] = "BYTES1", t3[t3.BYTES2 = 65] = "BYTES2", t3[t3.BYTES3 = 66] = "BYTES3", t3[t3.BYTES4 = 67] = "BYTES4", t3[t3.BYTES5 = 68] = "BYTES5", t3[t3.BYTES6 = 69] = "BYTES6", t3[t3.BYTES7 = 70] = "BYTES7", t3[t3.BYTES8 = 71] = "BYTES8", t3[t3.BYTES9 = 72] = "BYTES9", t3[t3.BYTES10 = 73] = "BYTES10", t3[t3.BYTES11 = 74] = "BYTES11", t3[t3.BYTES12 = 75] = "BYTES12", t3[t3.BYTES13 = 76] = "BYTES13", t3[t3.BYTES14 = 77] = "BYTES14", t3[t3.BYTES15 = 78] = "BYTES15", t3[t3.BYTES16 = 79] = "BYTES16", t3[t3.BYTES17 = 80] = "BYTES17", t3[t3.BYTES18 = 81] = "BYTES18", t3[t3.BYTES19 = 82] = "BYTES19", t3[t3.BYTES20 = 83] = "BYTES20", t3[t3.BYTES21 = 84] = "BYTES21", t3[t3.BYTES22 = 85] = "BYTES22", t3[t3.BYTES23 = 86] = "BYTES23", t3[t3.BYTES24 = 87] = "BYTES24", t3[t3.BYTES25 = 88] = "BYTES25", t3[t3.BYTES26 = 89] = "BYTES26", t3[t3.BYTES27 = 90] = "BYTES27", t3[t3.BYTES28 = 91] = "BYTES28", t3[t3.BYTES29 = 92] = "BYTES29", t3[t3.BYTES30 = 93] = "BYTES30", t3[t3.BYTES31 = 94] = "BYTES31", t3[t3.BYTES32 = 95] = "BYTES32", t3[t3.BOOL = 96] = "BOOL", t3[t3.ADDRESS = 97] = "ADDRESS", t3[t3.UINT8_ARRAY = 98] = "UINT8_ARRAY", t3[t3.UINT16_ARRAY = 99] = "UINT16_ARRAY", t3[t3.UINT24_ARRAY = 100] = "UINT24_ARRAY", t3[t3.UINT32_ARRAY = 101] = "UINT32_ARRAY", t3[t3.UINT40_ARRAY = 102] = "UINT40_ARRAY", t3[t3.UINT48_ARRAY = 103] = "UINT48_ARRAY", t3[t3.UINT56_ARRAY = 104] = "UINT56_ARRAY", t3[t3.UINT64_ARRAY = 105] = "UINT64_ARRAY", t3[t3.UINT72_ARRAY = 106] = "UINT72_ARRAY", t3[t3.UINT80_ARRAY = 107] = "UINT80_ARRAY", t3[t3.UINT88_ARRAY = 108] = "UINT88_ARRAY", t3[t3.UINT96_ARRAY = 109] = "UINT96_ARRAY", t3[t3.UINT104_ARRAY = 110] = "UINT104_ARRAY", t3[t3.UINT112_ARRAY = 111] = "UINT112_ARRAY", t3[t3.UINT120_ARRAY = 112] = "UINT120_ARRAY", t3[t3.UINT128_ARRAY = 113] = "UINT128_ARRAY", t3[t3.UINT136_ARRAY = 114] = "UINT136_ARRAY", t3[t3.UINT144_ARRAY = 115] = "UINT144_ARRAY", t3[t3.UINT152_ARRAY = 116] = "UINT152_ARRAY", t3[t3.UINT160_ARRAY = 117] = "UINT160_ARRAY", t3[t3.UINT168_ARRAY = 118] = "UINT168_ARRAY", t3[t3.UINT176_ARRAY = 119] = "UINT176_ARRAY", t3[t3.UINT184_ARRAY = 120] = "UINT184_ARRAY", t3[t3.UINT192_ARRAY = 121] = "UINT192_ARRAY", t3[t3.UINT200_ARRAY = 122] = "UINT200_ARRAY", t3[t3.UINT208_ARRAY = 123] = "UINT208_ARRAY", t3[t3.UINT216_ARRAY = 124] = "UINT216_ARRAY", t3[t3.UINT224_ARRAY = 125] = "UINT224_ARRAY", t3[t3.UINT232_ARRAY = 126] = "UINT232_ARRAY", t3[t3.UINT240_ARRAY = 127] = "UINT240_ARRAY", t3[t3.UINT248_ARRAY = 128] = "UINT248_ARRAY", t3[t3.UINT256_ARRAY = 129] = "UINT256_ARRAY", t3[t3.INT8_ARRAY = 130] = "INT8_ARRAY", t3[t3.INT16_ARRAY = 131] = "INT16_ARRAY", t3[t3.INT24_ARRAY = 132] = "INT24_ARRAY", t3[t3.INT32_ARRAY = 133] = "INT32_ARRAY", t3[t3.INT40_ARRAY = 134] = "INT40_ARRAY", t3[t3.INT48_ARRAY = 135] = "INT48_ARRAY", t3[t3.INT56_ARRAY = 136] = "INT56_ARRAY", t3[t3.INT64_ARRAY = 137] = "INT64_ARRAY", t3[t3.INT72_ARRAY = 138] = "INT72_ARRAY", t3[t3.INT80_ARRAY = 139] = "INT80_ARRAY", t3[t3.INT88_ARRAY = 140] = "INT88_ARRAY", t3[t3.INT96_ARRAY = 141] = "INT96_ARRAY", t3[t3.INT104_ARRAY = 142] = "INT104_ARRAY", t3[t3.INT112_ARRAY = 143] = "INT112_ARRAY", t3[t3.INT120_ARRAY = 144] = "INT120_ARRAY", t3[t3.INT128_ARRAY = 145] = "INT128_ARRAY", t3[t3.INT136_ARRAY = 146] = "INT136_ARRAY", t3[t3.INT144_ARRAY = 147] = "INT144_ARRAY", t3[t3.INT152_ARRAY = 148] = "INT152_ARRAY", t3[t3.INT160_ARRAY = 149] = "INT160_ARRAY", t3[t3.INT168_ARRAY = 150] = "INT168_ARRAY", t3[t3.INT176_ARRAY = 151] = "INT176_ARRAY", t3[t3.INT184_ARRAY = 152] = "INT184_ARRAY", t3[t3.INT192_ARRAY = 153] = "INT192_ARRAY", t3[t3.INT200_ARRAY = 154] = "INT200_ARRAY", t3[t3.INT208_ARRAY = 155] = "INT208_ARRAY", t3[t3.INT216_ARRAY = 156] = "INT216_ARRAY", t3[t3.INT224_ARRAY = 157] = "INT224_ARRAY", t3[t3.INT232_ARRAY = 158] = "INT232_ARRAY", t3[t3.INT240_ARRAY = 159] = "INT240_ARRAY", t3[t3.INT248_ARRAY = 160] = "INT248_ARRAY", t3[t3.INT256_ARRAY = 161] = "INT256_ARRAY", t3[t3.BYTES1_ARRAY = 162] = "BYTES1_ARRAY", t3[t3.BYTES2_ARRAY = 163] = "BYTES2_ARRAY", t3[t3.BYTES3_ARRAY = 164] = "BYTES3_ARRAY", t3[t3.BYTES4_ARRAY = 165] = "BYTES4_ARRAY", t3[t3.BYTES5_ARRAY = 166] = "BYTES5_ARRAY", t3[t3.BYTES6_ARRAY = 167] = "BYTES6_ARRAY", t3[t3.BYTES7_ARRAY = 168] = "BYTES7_ARRAY", t3[t3.BYTES8_ARRAY = 169] = "BYTES8_ARRAY", t3[t3.BYTES9_ARRAY = 170] = "BYTES9_ARRAY", t3[t3.BYTES10_ARRAY = 171] = "BYTES10_ARRAY", t3[t3.BYTES11_ARRAY = 172] = "BYTES11_ARRAY", t3[t3.BYTES12_ARRAY = 173] = "BYTES12_ARRAY", t3[t3.BYTES13_ARRAY = 174] = "BYTES13_ARRAY", t3[t3.BYTES14_ARRAY = 175] = "BYTES14_ARRAY", t3[t3.BYTES15_ARRAY = 176] = "BYTES15_ARRAY", t3[t3.BYTES16_ARRAY = 177] = "BYTES16_ARRAY", t3[t3.BYTES17_ARRAY = 178] = "BYTES17_ARRAY", t3[t3.BYTES18_ARRAY = 179] = "BYTES18_ARRAY", t3[t3.BYTES19_ARRAY = 180] = "BYTES19_ARRAY", t3[t3.BYTES20_ARRAY = 181] = "BYTES20_ARRAY", t3[t3.BYTES21_ARRAY = 182] = "BYTES21_ARRAY", t3[t3.BYTES22_ARRAY = 183] = "BYTES22_ARRAY", t3[t3.BYTES23_ARRAY = 184] = "BYTES23_ARRAY", t3[t3.BYTES24_ARRAY = 185] = "BYTES24_ARRAY", t3[t3.BYTES25_ARRAY = 186] = "BYTES25_ARRAY", t3[t3.BYTES26_ARRAY = 187] = "BYTES26_ARRAY", t3[t3.BYTES27_ARRAY = 188] = "BYTES27_ARRAY", t3[t3.BYTES28_ARRAY = 189] = "BYTES28_ARRAY", t3[t3.BYTES29_ARRAY = 190] = "BYTES29_ARRAY", t3[t3.BYTES30_ARRAY = 191] = "BYTES30_ARRAY", t3[t3.BYTES31_ARRAY = 192] = "BYTES31_ARRAY", t3[t3.BYTES32_ARRAY = 193] = "BYTES32_ARRAY", t3[t3.BOOL_ARRAY = 194] = "BOOL_ARRAY", t3[t3.ADDRESS_ARRAY = 195] = "ADDRESS_ARRAY", t3[t3.BYTES = 196] = "BYTES", t3[t3.STRING = 197] = "STRING", t3))(I2 || {});
  var Y = { [0]: "uint8", [1]: "uint16", [2]: "uint24", [3]: "uint32", [4]: "uint40", [5]: "uint48", [6]: "uint56", [7]: "uint64", [8]: "uint72", [9]: "uint80", [10]: "uint88", [11]: "uint96", [12]: "uint104", [13]: "uint112", [14]: "uint120", [15]: "uint128", [16]: "uint136", [17]: "uint144", [18]: "uint152", [19]: "uint160", [20]: "uint168", [21]: "uint176", [22]: "uint184", [23]: "uint192", [24]: "uint200", [25]: "uint208", [26]: "uint216", [27]: "uint224", [28]: "uint232", [29]: "uint240", [30]: "uint248", [31]: "uint256", [32]: "int8", [33]: "int16", [34]: "int24", [35]: "int32", [36]: "int40", [37]: "int48", [38]: "int56", [39]: "int64", [40]: "int72", [41]: "int80", [42]: "int88", [43]: "int96", [44]: "int104", [45]: "int112", [46]: "int120", [47]: "int128", [48]: "int136", [49]: "int144", [50]: "int152", [51]: "int160", [52]: "int168", [53]: "int176", [54]: "int184", [55]: "int192", [56]: "int200", [57]: "int208", [58]: "int216", [59]: "int224", [60]: "int232", [61]: "int240", [62]: "int248", [63]: "int256", [64]: "bytes1", [65]: "bytes2", [66]: "bytes3", [67]: "bytes4", [68]: "bytes5", [69]: "bytes6", [70]: "bytes7", [71]: "bytes8", [72]: "bytes9", [73]: "bytes10", [74]: "bytes11", [75]: "bytes12", [76]: "bytes13", [77]: "bytes14", [78]: "bytes15", [79]: "bytes16", [80]: "bytes17", [81]: "bytes18", [82]: "bytes19", [83]: "bytes20", [84]: "bytes21", [85]: "bytes22", [86]: "bytes23", [87]: "bytes24", [88]: "bytes25", [89]: "bytes26", [90]: "bytes27", [91]: "bytes28", [92]: "bytes29", [93]: "bytes30", [94]: "bytes31", [95]: "bytes32", [96]: "bool", [97]: "address", [98]: "uint8[]", [99]: "uint16[]", [100]: "uint24[]", [101]: "uint32[]", [102]: "uint40[]", [103]: "uint48[]", [104]: "uint56[]", [105]: "uint64[]", [106]: "uint72[]", [107]: "uint80[]", [108]: "uint88[]", [109]: "uint96[]", [110]: "uint104[]", [111]: "uint112[]", [112]: "uint120[]", [113]: "uint128[]", [114]: "uint136[]", [115]: "uint144[]", [116]: "uint152[]", [117]: "uint160[]", [118]: "uint168[]", [119]: "uint176[]", [120]: "uint184[]", [121]: "uint192[]", [122]: "uint200[]", [123]: "uint208[]", [124]: "uint216[]", [125]: "uint224[]", [126]: "uint232[]", [127]: "uint240[]", [128]: "uint248[]", [129]: "uint256[]", [130]: "int8[]", [131]: "int16[]", [132]: "int24[]", [133]: "int32[]", [134]: "int40[]", [135]: "int48[]", [136]: "int56[]", [137]: "int64[]", [138]: "int72[]", [139]: "int80[]", [140]: "int88[]", [141]: "int96[]", [142]: "int104[]", [143]: "int112[]", [144]: "int120[]", [145]: "int128[]", [146]: "int136[]", [147]: "int144[]", [148]: "int152[]", [149]: "int160[]", [150]: "int168[]", [151]: "int176[]", [152]: "int184[]", [153]: "int192[]", [154]: "int200[]", [155]: "int208[]", [156]: "int216[]", [157]: "int224[]", [158]: "int232[]", [159]: "int240[]", [160]: "int248[]", [161]: "int256[]", [162]: "bytes1[]", [163]: "bytes2[]", [164]: "bytes3[]", [165]: "bytes4[]", [166]: "bytes5[]", [167]: "bytes6[]", [168]: "bytes7[]", [169]: "bytes8[]", [170]: "bytes9[]", [171]: "bytes10[]", [172]: "bytes11[]", [173]: "bytes12[]", [174]: "bytes13[]", [175]: "bytes14[]", [176]: "bytes15[]", [177]: "bytes16[]", [178]: "bytes17[]", [179]: "bytes18[]", [180]: "bytes19[]", [181]: "bytes20[]", [182]: "bytes21[]", [183]: "bytes22[]", [184]: "bytes23[]", [185]: "bytes24[]", [186]: "bytes25[]", [187]: "bytes26[]", [188]: "bytes27[]", [189]: "bytes28[]", [190]: "bytes29[]", [191]: "bytes30[]", [192]: "bytes31[]", [193]: "bytes32[]", [194]: "bool[]", [195]: "address[]", [196]: "bytes", [197]: "string" };
  var s = Object.values(Y);
  var _15 = Object.fromEntries(Object.entries(Y).map(([R4, A3]) => [A3, parseInt(R4)]));
  function n(R4) {
    let A3 = R4.valueOf();
    return A3 < 32 ? A3 + 1 : A3 < 64 ? A3 + 1 - 32 : A3 < 96 ? A3 + 1 - 64 : R4 == 96 ? 1 : R4 == 97 ? 20 : 0;
  }
  var U3 = s.filter((R4) => n(_15[R4]) > 0);
  var u = { [98]: 0, [99]: 1, [100]: 2, [101]: 3, [102]: 4, [103]: 5, [104]: 6, [105]: 7, [106]: 8, [107]: 9, [108]: 10, [109]: 11, [110]: 12, [111]: 13, [112]: 14, [113]: 15, [114]: 16, [115]: 17, [116]: 18, [117]: 19, [118]: 20, [119]: 21, [120]: 22, [121]: 23, [122]: 24, [123]: 25, [124]: 26, [125]: 27, [126]: 28, [127]: 29, [128]: 30, [129]: 31, [130]: 32, [131]: 33, [132]: 34, [133]: 35, [134]: 36, [135]: 37, [136]: 38, [137]: 39, [138]: 40, [139]: 41, [140]: 42, [141]: 43, [142]: 44, [143]: 45, [144]: 46, [145]: 47, [146]: 48, [147]: 49, [148]: 50, [149]: 51, [150]: 52, [151]: 53, [152]: 54, [153]: 55, [154]: 56, [155]: 57, [156]: 58, [157]: 59, [158]: 60, [159]: 61, [160]: 62, [161]: 63, [162]: 64, [163]: 65, [164]: 66, [165]: 67, [166]: 68, [167]: 69, [168]: 70, [169]: 71, [170]: 72, [171]: 73, [172]: 74, [173]: 75, [174]: 76, [175]: 77, [176]: 78, [177]: 79, [178]: 80, [179]: 81, [180]: 82, [181]: 83, [182]: 84, [183]: 85, [184]: 86, [185]: 87, [186]: 88, [187]: 89, [188]: 90, [189]: 91, [190]: 92, [191]: 93, [192]: 94, [193]: 95, [194]: 96, [195]: 97 };
  function o(R4) {
    if (R4.length > 28)
      throw new Error("Schema can only have up to 28 fields");
    let A3 = new Uint8Array(32), T4 = 0, N2 = 0, b4 = false;
    for (let i4 = 0; i4 < R4.length; i4++) {
      let E4 = n(R4[i4]);
      if (E4 > 0) {
        if (b4)
          throw new Error("Static fields must come before dynamic fields in the schema");
        N2++;
      } else
        b4 = true;
      T4 += E4, A3[i4 + 4] = R4[i4];
    }
    let r2 = R4.length - N2;
    if (r2 > 14)
      throw new Error("Schema can only have up to 14 dynamic fields");
    return new DataView(A3.buffer).setUint16(0, T4), A3[2] = N2, A3[3] = r2, A3;
  }
  var B = { uint8: 0, uint16: 0, uint24: 0, uint32: 0, uint40: 0, uint48: 0, uint56: 0n, uint64: 0n, uint72: 0n, uint80: 0n, uint88: 0n, uint96: 0n, uint104: 0n, uint112: 0n, uint120: 0n, uint128: 0n, uint136: 0n, uint144: 0n, uint152: 0n, uint160: 0n, uint168: 0n, uint176: 0n, uint184: 0n, uint192: 0n, uint200: 0n, uint208: 0n, uint216: 0n, uint224: 0n, uint232: 0n, uint240: 0n, uint248: 0n, uint256: 0n, int8: 0, int16: 0, int24: 0, int32: 0, int40: 0, int48: 0, int56: 0n, int64: 0n, int72: 0n, int80: 0n, int88: 0n, int96: 0n, int104: 0n, int112: 0n, int120: 0n, int128: 0n, int136: 0n, int144: 0n, int152: 0n, int160: 0n, int168: 0n, int176: 0n, int184: 0n, int192: 0n, int200: 0n, int208: 0n, int216: 0n, int224: 0n, int232: 0n, int240: 0n, int248: 0n, int256: 0n, bytes1: "0x00", bytes2: "0x0000", bytes3: "0x000000", bytes4: "0x00000000", bytes5: "0x0000000000", bytes6: "0x000000000000", bytes7: "0x00000000000000", bytes8: "0x0000000000000000", bytes9: "0x000000000000000000", bytes10: "0x00000000000000000000", bytes11: "0x0000000000000000000000", bytes12: "0x000000000000000000000000", bytes13: "0x00000000000000000000000000", bytes14: "0x0000000000000000000000000000", bytes15: "0x000000000000000000000000000000", bytes16: "0x00000000000000000000000000000000", bytes17: "0x0000000000000000000000000000000000", bytes18: "0x000000000000000000000000000000000000", bytes19: "0x00000000000000000000000000000000000000", bytes20: "0x0000000000000000000000000000000000000000", bytes21: "0x000000000000000000000000000000000000000000", bytes22: "0x00000000000000000000000000000000000000000000", bytes23: "0x0000000000000000000000000000000000000000000000", bytes24: "0x000000000000000000000000000000000000000000000000", bytes25: "0x00000000000000000000000000000000000000000000000000", bytes26: "0x0000000000000000000000000000000000000000000000000000", bytes27: "0x000000000000000000000000000000000000000000000000000000", bytes28: "0x00000000000000000000000000000000000000000000000000000000", bytes29: "0x0000000000000000000000000000000000000000000000000000000000", bytes30: "0x000000000000000000000000000000000000000000000000000000000000", bytes31: "0x00000000000000000000000000000000000000000000000000000000000000", bytes32: "0x0000000000000000000000000000000000000000000000000000000000000000", bool: false, address: "0x0000000000000000000000000000000000000000", "uint8[]": [], "uint16[]": [], "uint24[]": [], "uint32[]": [], "uint40[]": [], "uint48[]": [], "uint56[]": [], "uint64[]": [], "uint72[]": [], "uint80[]": [], "uint88[]": [], "uint96[]": [], "uint104[]": [], "uint112[]": [], "uint120[]": [], "uint128[]": [], "uint136[]": [], "uint144[]": [], "uint152[]": [], "uint160[]": [], "uint168[]": [], "uint176[]": [], "uint184[]": [], "uint192[]": [], "uint200[]": [], "uint208[]": [], "uint216[]": [], "uint224[]": [], "uint232[]": [], "uint240[]": [], "uint248[]": [], "uint256[]": [], "int8[]": [], "int16[]": [], "int24[]": [], "int32[]": [], "int40[]": [], "int48[]": [], "int56[]": [], "int64[]": [], "int72[]": [], "int80[]": [], "int88[]": [], "int96[]": [], "int104[]": [], "int112[]": [], "int120[]": [], "int128[]": [], "int136[]": [], "int144[]": [], "int152[]": [], "int160[]": [], "int168[]": [], "int176[]": [], "int184[]": [], "int192[]": [], "int200[]": [], "int208[]": [], "int216[]": [], "int224[]": [], "int232[]": [], "int240[]": [], "int248[]": [], "int256[]": [], "bytes1[]": [], "bytes2[]": [], "bytes3[]": [], "bytes4[]": [], "bytes5[]": [], "bytes6[]": [], "bytes7[]": [], "bytes8[]": [], "bytes9[]": [], "bytes10[]": [], "bytes11[]": [], "bytes12[]": [], "bytes13[]": [], "bytes14[]": [], "bytes15[]": [], "bytes16[]": [], "bytes17[]": [], "bytes18[]": [], "bytes19[]": [], "bytes20[]": [], "bytes21[]": [], "bytes22[]": [], "bytes23[]": [], "bytes24[]": [], "bytes25[]": [], "bytes26[]": [], "bytes27[]": [], "bytes28[]": [], "bytes29[]": [], "bytes30[]": [], "bytes31[]": [], "bytes32[]": [], "bool[]": [], "address[]": [], bytes: "0x", string: "" };
  function g(R4) {
    let A3 = R4.replace(/(\w+)\[\d+\]/g, "$1[]");
    return B[A3];
  }

  // node_modules/viem/dist/esm/utils/abi/encodeEventTopics.js
  init_abi();

  // node_modules/viem/dist/esm/errors/log.js
  init_base();
  var FilterTypeNotSupportedError = class extends BaseError {
    constructor(type) {
      super(`Filter type "${type}" is not supported.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FilterTypeNotSupportedError"
      });
    }
  };

  // node_modules/viem/dist/esm/utils/abi/encodeEventTopics.js
  init_toBytes();

  // node_modules/viem/dist/esm/utils/hash/getEventSelector.js
  init_hashFunction();
  var getEventSelector = (event) => hashFunction(event);

  // node_modules/viem/dist/esm/utils/abi/encodeEventTopics.js
  init_keccak256();
  init_encodeAbiParameters();
  init_formatAbiItem();
  init_getAbiItem();
  function encodeEventTopics({ abi, eventName, args }) {
    let abiItem = abi[0];
    if (eventName) {
      abiItem = getAbiItem({
        abi,
        args,
        name: eventName
      });
      if (!abiItem)
        throw new AbiEventNotFoundError(eventName, {
          docsPath: "/docs/contract/encodeEventTopics"
        });
    }
    if (abiItem.type !== "event")
      throw new AbiEventNotFoundError(void 0, {
        docsPath: "/docs/contract/encodeEventTopics"
      });
    const definition = formatAbiItem(abiItem);
    const signature = getEventSelector(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
      const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
      const args_ = Array.isArray(args) ? args : indexedInputs?.map((x8) => args[x8.name]) ?? [];
      topics = indexedInputs?.map((param, i4) => Array.isArray(args_[i4]) ? args_[i4].map((_18, j3) => encodeArg({ param, value: args_[i4][j3] })) : args_[i4] ? encodeArg({ param, value: args_[i4] }) : null) ?? [];
    }
    return [signature, ...topics];
  }
  function encodeArg({ param, value }) {
    if (param.type === "string" || param.type === "bytes")
      return keccak2562(toBytes(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      throw new FilterTypeNotSupportedError(param.type);
    return encodeAbiParameters([param], [value]);
  }

  // node_modules/viem/dist/esm/actions/public/createContractEventFilter.js
  init_toHex();

  // node_modules/viem/dist/esm/utils/filters/createFilterRequestScope.js
  function createFilterRequestScope(client, { method }) {
    const requestMap = {};
    if (client.transport.type === "fallback")
      client.transport.onResponse?.(({ method: method_, response: id3, status, transport }) => {
        if (status === "success" && method === method_)
          requestMap[id3] = transport.request;
      });
    return (id3) => requestMap[id3] || client.request;
  }

  // node_modules/viem/dist/esm/actions/public/createContractEventFilter.js
  async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, toBlock }) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newFilter"
    });
    const topics = eventName ? encodeEventTopics({
      abi,
      args,
      eventName
    }) : void 0;
    const id3 = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
          topics
        }
      ]
    });
    return {
      abi,
      args,
      eventName,
      id: id3,
      request: getRequest(id3),
      type: "event"
    };
  }

  // node_modules/viem/dist/esm/actions/public/estimateContractGas.js
  init_parseAccount();
  init_encodeFunctionData();

  // node_modules/viem/dist/esm/utils/errors/getContractError.js
  init_abi();
  init_base();
  init_contract();
  var EXECUTION_REVERTED_ERROR_CODE = 3;
  function getContractError(err, { abi, address, args, docsPath: docsPath4, functionName, sender }) {
    const { code, data, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => "data" in err2) : {};
    let cause = err;
    if (err instanceof AbiDecodingZeroDataError) {
      cause = new ContractFunctionZeroDataError({ functionName });
    } else if (code === EXECUTION_REVERTED_ERROR_CODE && (data || message || shortMessage)) {
      cause = new ContractFunctionRevertedError({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
      });
    }
    return new ContractFunctionExecutionError(cause, {
      abi,
      args,
      contractAddress: address,
      docsPath: docsPath4,
      functionName,
      sender
    });
  }

  // node_modules/viem/dist/esm/actions/public/estimateGas.js
  init_parseAccount();

  // node_modules/viem/dist/esm/errors/account.js
  init_base();
  var AccountNotFoundError = class extends BaseError {
    constructor({ docsPath: docsPath4 } = {}) {
      super([
        "Could not find an Account to execute with this Action.",
        "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
      ].join("\n"), {
        docsPath: docsPath4,
        docsSlug: "account"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AccountNotFoundError"
      });
    }
  };

  // node_modules/viem/dist/esm/actions/public/estimateGas.js
  init_toHex();

  // node_modules/viem/dist/esm/errors/estimateGas.js
  init_formatEther();
  init_formatGwei();
  init_base();
  init_transaction();
  var EstimateGasExecutionError = class extends BaseError {
    constructor(cause, { account, docsPath: docsPath4, chain: chain2, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
      const prettyArgs = prettyPrint({
        from: account?.address,
        to,
        value: typeof value !== "undefined" && `${formatEther2(value)} ${chain2?.nativeCurrency.symbol || "ETH"}`,
        data,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath4,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Estimate Gas Arguments:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EstimateGasExecutionError"
      });
      this.cause = cause;
    }
  };

  // node_modules/viem/dist/esm/utils/errors/getEstimateGasError.js
  init_getNodeError();
  function getEstimateGasError(err, { docsPath: docsPath4, ...args }) {
    let cause = err;
    if (containsNodeError(err))
      cause = getNodeError(err, args);
    return new EstimateGasExecutionError(cause, {
      docsPath: docsPath4,
      ...args
    });
  }

  // node_modules/viem/dist/esm/actions/public/estimateGas.js
  init_extract();
  init_format();
  init_transactionRequest();
  init_assertRequest();

  // node_modules/viem/dist/esm/utils/transaction/prepareRequest.js
  init_parseAccount();

  // node_modules/viem/dist/esm/errors/block.js
  init_base();
  var BlockNotFoundError = class extends BaseError {
    constructor({ blockHash, blockNumber }) {
      let identifier = "Block";
      if (blockHash)
        identifier = `Block at hash "${blockHash}"`;
      if (blockNumber)
        identifier = `Block at number "${blockNumber}"`;
      super(`${identifier} could not be found.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BlockNotFoundError"
      });
    }
  };

  // node_modules/viem/dist/esm/actions/public/getBlock.js
  init_toHex();

  // node_modules/viem/dist/esm/utils/formatters/block.js
  init_format();

  // node_modules/viem/dist/esm/utils/formatters/transaction.js
  init_fromHex();
  init_format();
  var transactionType = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559"
  };
  function formatTransaction(transaction2) {
    const transaction_ = {
      ...transaction2,
      blockHash: transaction2.blockHash ? transaction2.blockHash : null,
      blockNumber: transaction2.blockNumber ? BigInt(transaction2.blockNumber) : null,
      chainId: transaction2.chainId ? hexToNumber(transaction2.chainId) : void 0,
      gas: transaction2.gas ? BigInt(transaction2.gas) : void 0,
      gasPrice: transaction2.gasPrice ? BigInt(transaction2.gasPrice) : void 0,
      maxFeePerGas: transaction2.maxFeePerGas ? BigInt(transaction2.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: transaction2.maxPriorityFeePerGas ? BigInt(transaction2.maxPriorityFeePerGas) : void 0,
      nonce: transaction2.nonce ? hexToNumber(transaction2.nonce) : void 0,
      to: transaction2.to ? transaction2.to : null,
      transactionIndex: transaction2.transactionIndex ? Number(transaction2.transactionIndex) : null,
      type: transaction2.type ? transactionType[transaction2.type] : void 0,
      value: transaction2.value ? BigInt(transaction2.value) : void 0,
      v: transaction2.v ? BigInt(transaction2.v) : void 0
    };
    if (transaction_.type === "legacy") {
      delete transaction_["accessList"];
      delete transaction_["maxFeePerGas"];
      delete transaction_["maxPriorityFeePerGas"];
    }
    if (transaction_.type === "eip2930") {
      delete transaction_["maxFeePerGas"];
      delete transaction_["maxPriorityFeePerGas"];
    }
    return transaction_;
  }
  var defineTransaction = defineFormatter({ format: formatTransaction });

  // node_modules/viem/dist/esm/utils/formatters/block.js
  function formatBlock(block) {
    const transactions = block.transactions?.map((transaction2) => {
      if (typeof transaction2 === "string")
        return transaction2;
      return formatTransaction(transaction2);
    });
    return {
      ...block,
      baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
      difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
      gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
      gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
      hash: block.hash ? block.hash : null,
      logsBloom: block.logsBloom ? block.logsBloom : null,
      nonce: block.nonce ? block.nonce : null,
      number: block.number ? BigInt(block.number) : null,
      size: block.size ? BigInt(block.size) : void 0,
      timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
      transactions,
      totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
    };
  }
  var defineBlock = defineFormatter({ format: formatBlock });

  // node_modules/viem/dist/esm/actions/public/getBlock.js
  init_format();
  async function getBlock(client, { blockHash, blockNumber, blockTag = "latest", includeTransactions = false } = {}) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let block = null;
    if (blockHash) {
      block = await client.request({
        method: "eth_getBlockByHash",
        params: [blockHash, includeTransactions]
      });
    } else {
      block = await client.request({
        method: "eth_getBlockByNumber",
        params: [blockNumberHex || blockTag, includeTransactions]
      });
    }
    if (!block)
      throw new BlockNotFoundError({ blockHash, blockNumber });
    return format(block, {
      formatter: client.chain?.formatters?.block || formatBlock
    });
  }

  // node_modules/viem/dist/esm/actions/public/getGasPrice.js
  async function getGasPrice(client) {
    const gasPrice = await client.request({
      method: "eth_gasPrice"
    });
    return BigInt(gasPrice);
  }

  // node_modules/viem/dist/esm/actions/public/getTransactionCount.js
  init_fromHex();
  init_toHex();
  async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
    const count = await client.request({
      method: "eth_getTransactionCount",
      params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
    });
    return hexToNumber(count);
  }

  // node_modules/viem/dist/esm/utils/transaction/prepareRequest.js
  init_base();
  init_assertRequest();
  var defaultTip = 1500000000n;
  async function prepareRequest(client, args) {
    const { account: account_, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce } = args;
    if (!account_)
      throw new AccountNotFoundError();
    const account = parseAccount(account_);
    const block = await getBlock(client, { blockTag: "latest" });
    const request = { ...args, from: account.address };
    if (typeof nonce === "undefined")
      request.nonce = await getTransactionCount(client, {
        address: account.address,
        blockTag: "pending"
      });
    if (block.baseFeePerGas) {
      if (typeof gasPrice !== "undefined")
        throw new BaseError("Chain does not support legacy `gasPrice`.");
      if (typeof maxFeePerGas === "undefined") {
        request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip;
        request.maxFeePerGas = block.baseFeePerGas * 120n / 100n + request.maxPriorityFeePerGas;
      } else {
        if (typeof maxPriorityFeePerGas === "undefined" && maxFeePerGas < defaultTip)
          throw new BaseError("`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).");
        request.maxFeePerGas = maxFeePerGas;
        request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip;
      }
    } else {
      if (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined")
        throw new BaseError("Chain does not support EIP-1559 fees.");
      if (typeof gasPrice === "undefined")
        request.gasPrice = await getGasPrice(client) * 120n / 100n;
    }
    if (typeof gas === "undefined")
      request.gas = await estimateGas(client, {
        ...request,
        account: { address: account.address, type: "json-rpc" }
      });
    assertRequest(request);
    return request;
  }

  // node_modules/viem/dist/esm/actions/public/estimateGas.js
  async function estimateGas(client, args) {
    const account_ = args.account ?? client.account;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/public/estimateGas"
      });
    const account = parseAccount(account_);
    try {
      const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await prepareRequest(client, args) : args;
      const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      assertRequest(args);
      const formatter = client.chain?.formatters?.transactionRequest;
      const request = format({
        from: account.address,
        accessList,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...extract(rest, { formatter })
      }, {
        formatter: formatter || formatTransactionRequest
      });
      const balance = await client.request({
        method: "eth_estimateGas",
        params: block ? [request, block] : [request]
      });
      return BigInt(balance);
    } catch (err) {
      throw getEstimateGasError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }

  // node_modules/viem/dist/esm/actions/public/estimateContractGas.js
  async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
    const data = encodeFunctionData({
      abi,
      args,
      functionName
    });
    try {
      const gas = await estimateGas(client, {
        data,
        to: address,
        ...request
      });
      return gas;
    } catch (err) {
      const account = request.account ? parseAccount(request.account) : void 0;
      throw getContractError(err, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/simulateContract",
        functionName,
        sender: account?.address
      });
    }
  }

  // node_modules/viem/dist/esm/actions/public/readContract.js
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_call();
  async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
    const calldata = encodeFunctionData({
      abi,
      args,
      functionName
    });
    try {
      const { data } = await call(client, {
        data: calldata,
        to: address,
        ...callRequest
      });
      return decodeFunctionResult({
        abi,
        args,
        functionName,
        data: data || "0x"
      });
    } catch (err) {
      throw getContractError(err, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/readContract",
        functionName
      });
    }
  }

  // node_modules/viem/dist/esm/actions/public/simulateContract.js
  init_parseAccount();
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_call();
  async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
    const account = callRequest.account ? parseAccount(callRequest.account) : void 0;
    const calldata = encodeFunctionData({
      abi,
      args,
      functionName
    });
    try {
      const { data } = await call(client, {
        batch: false,
        data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...callRequest
      });
      const result = decodeFunctionResult({
        abi,
        args,
        functionName,
        data: data || "0x"
      });
      return {
        result,
        request: {
          abi,
          address,
          args,
          functionName,
          ...callRequest
        }
      };
    } catch (err) {
      throw getContractError(err, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/simulateContract",
        functionName,
        sender: account?.address
      });
    }
  }

  // node_modules/viem/dist/esm/actions/public/watchContractEvent.js
  init_getAbiItem();

  // node_modules/viem/dist/esm/utils/observe.js
  var listenersCache = /* @__PURE__ */ new Map();
  var cleanupCache = /* @__PURE__ */ new Map();
  var callbackCount = 0;
  function observe(observerId, callbacks, fn) {
    const callbackId = ++callbackCount;
    const getListeners = () => listenersCache.get(observerId) || [];
    const unsubscribe = () => {
      const listeners2 = getListeners();
      listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
    };
    const unwatch = () => {
      const cleanup2 = cleanupCache.get(observerId);
      if (getListeners().length === 1 && cleanup2)
        cleanup2();
      unsubscribe();
    };
    const listeners = getListeners();
    listenersCache.set(observerId, [
      ...listeners,
      { id: callbackId, fns: callbacks }
    ]);
    if (listeners && listeners.length > 0)
      return unwatch;
    const emit = {};
    for (const key in callbacks) {
      emit[key] = (...args) => {
        const listeners2 = getListeners();
        if (listeners2.length === 0)
          return;
        listeners2.forEach((listener) => listener.fns[key]?.(...args));
      };
    }
    const cleanup = fn(emit);
    if (typeof cleanup === "function")
      cleanupCache.set(observerId, cleanup);
    return unwatch;
  }

  // node_modules/viem/dist/esm/utils/wait.js
  async function wait(time) {
    return new Promise((res) => setTimeout(res, time));
  }

  // node_modules/viem/dist/esm/utils/poll.js
  function poll5(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = () => active = false;
    const watch = async () => {
      let data;
      if (emitOnBegin)
        data = await fn({ unpoll: unwatch });
      const initialWait = await initialWaitTime?.(data) ?? interval;
      await wait(initialWait);
      const poll6 = async () => {
        if (!active)
          return;
        await fn({ unpoll: unwatch });
        await wait(interval);
        poll6();
      };
      poll6();
    };
    watch();
    return unwatch;
  }

  // node_modules/viem/dist/esm/actions/public/watchContractEvent.js
  init_stringify();

  // node_modules/viem/dist/esm/utils/promise/withCache.js
  var promiseCache = /* @__PURE__ */ new Map();
  var responseCache = /* @__PURE__ */ new Map();
  function getCache(cacheKey2) {
    const buildCache = (cacheKey3, cache2) => ({
      clear: () => cache2.delete(cacheKey3),
      get: () => cache2.get(cacheKey3),
      set: (data) => cache2.set(cacheKey3, data)
    });
    const promise = buildCache(cacheKey2, promiseCache);
    const response = buildCache(cacheKey2, responseCache);
    return {
      clear: () => {
        promise.clear();
        response.clear();
      },
      promise,
      response
    };
  }
  async function withCache(fn, { cacheKey: cacheKey2, maxAge = Infinity }) {
    const cache2 = getCache(cacheKey2);
    const response = cache2.response.get();
    if (response && maxAge > 0) {
      const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
      if (age < maxAge)
        return response.data;
    }
    let promise = cache2.promise.get();
    if (!promise) {
      promise = fn();
      cache2.promise.set(promise);
    }
    const data = await promise;
    cache2.promise.clear();
    cache2.response.set({ created: /* @__PURE__ */ new Date(), data });
    return data;
  }

  // node_modules/viem/dist/esm/actions/public/getBlockNumber.js
  var cacheKey = (id3) => `blockNumber.${id3}`;
  async function getBlockNumber(client, { maxAge = client.pollingInterval } = {}) {
    const blockNumberHex = await withCache(() => client.request({
      method: "eth_blockNumber"
    }), { cacheKey: cacheKey(client.uid), maxAge });
    return BigInt(blockNumberHex);
  }

  // node_modules/viem/dist/esm/utils/abi/decodeEventLog.js
  init_abi();
  init_decodeAbiParameters();
  init_formatAbiItem();
  var docsPath2 = "/docs/contract/decodeEventLog";
  function decodeEventLog({ abi, data, topics }) {
    const [signature, ...argTopics] = topics;
    if (!signature)
      throw new AbiEventSignatureEmptyTopicsError({
        docsPath: docsPath2
      });
    const abiItem = abi.find((x8) => x8.type === "event" && signature === getEventSelector(formatAbiItem(x8)));
    if (!(abiItem && "name" in abiItem))
      throw new AbiEventSignatureNotFoundError(signature, {
        docsPath: docsPath2
      });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x8) => !("name" in x8 && x8.name));
    let args = isUnnamed ? [] : {};
    const indexedInputs = inputs.filter((x8) => "indexed" in x8 && x8.indexed);
    if (argTopics.length > 0) {
      for (let i4 = 0; i4 < indexedInputs.length; i4++) {
        const param = indexedInputs[i4];
        const topic = argTopics[i4];
        if (!topic)
          throw new DecodeLogTopicsMismatch({
            abiItem,
            param
          });
        args[param.name || i4] = decodeTopic({ param, value: topic });
      }
    }
    const nonIndexedInputs = inputs.filter((x8) => !("indexed" in x8 && x8.indexed));
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i4 = 0; i4 < nonIndexedInputs.length; i4++) {
              args[nonIndexedInputs[i4].name] = decodedData[i4];
            }
          }
        }
      } catch (err) {
        if (err instanceof AbiDecodingDataSizeTooSmallError)
          throw new DecodeLogDataMismatch({
            data: err.data,
            params: err.params,
            size: err.size
          });
        throw err;
      }
    }
    return {
      eventName: name,
      args: Object.values(args).length > 0 ? args : void 0
    };
  }
  function decodeTopic({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      return value;
    const decodedArg = decodeAbiParameters([param], value) || [];
    return decodedArg[0];
  }

  // node_modules/viem/dist/esm/utils/formatters/log.js
  function formatLog(log, { args, eventName } = {}) {
    return {
      ...log,
      blockHash: log.blockHash ? log.blockHash : null,
      blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
      logIndex: log.logIndex ? BigInt(log.logIndex) : null,
      transactionHash: log.transactionHash ? log.transactionHash : null,
      transactionIndex: log.transactionIndex ? BigInt(log.transactionIndex) : null,
      ...eventName ? { args, eventName } : {}
    };
  }

  // node_modules/viem/dist/esm/actions/public/getFilterChanges.js
  async function getFilterChanges(_client, { filter: filter2 }) {
    const logs = await filter2.request({
      method: "eth_getFilterChanges",
      params: [filter2.id]
    });
    return logs.map((log) => {
      if (typeof log === "string")
        return log;
      try {
        const { eventName, args } = "abi" in filter2 && filter2.abi ? decodeEventLog({
          abi: filter2.abi,
          data: log.data,
          topics: log.topics
        }) : { eventName: void 0, args: void 0 };
        return formatLog(log, { args, eventName });
      } catch {
        return;
      }
    }).filter(Boolean);
  }

  // node_modules/viem/dist/esm/actions/public/getLogs.js
  init_toHex();
  async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, args } = {}) {
    let topics = [];
    if (event)
      topics = encodeEventTopics({
        abi: [event],
        eventName: event.name,
        args
      });
    let logs;
    if (blockHash) {
      logs = await client.request({
        method: "eth_getLogs",
        params: [{ address, topics, blockHash }]
      });
    } else {
      logs = await client.request({
        method: "eth_getLogs",
        params: [
          {
            address,
            topics,
            fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
          }
        ]
      });
    }
    return logs.map((log) => {
      try {
        const { eventName, args: args2 } = event ? decodeEventLog({
          abi: [event],
          data: log.data,
          topics: log.topics
        }) : { eventName: void 0, args: void 0 };
        return formatLog(log, { args: args2, eventName });
      } catch {
        return;
      }
    }).filter(Boolean);
  }

  // node_modules/viem/dist/esm/actions/public/uninstallFilter.js
  async function uninstallFilter(_client, { filter: filter2 }) {
    return filter2.request({
      method: "eth_uninstallFilter",
      params: [filter2.id]
    });
  }

  // node_modules/viem/dist/esm/actions/public/watchContractEvent.js
  function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, pollingInterval = client.pollingInterval }) {
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = poll5(async () => {
        if (!initialized) {
          try {
            filter2 = await createContractEventFilter(client, {
              abi,
              address,
              args,
              eventName
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getFilterChanges(client, { filter: filter2 });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getLogs(client, {
                address,
                args,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                event: getAbiItem({
                  abi,
                  name: eventName
                })
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await uninstallFilter(client, { filter: filter2 });
        unwatch();
      };
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/writeContract.js
  init_encodeFunctionData();

  // node_modules/viem/dist/esm/actions/wallet/sendTransaction.js
  init_parseAccount();
  init_chain2();

  // node_modules/viem/dist/esm/utils/errors/getTransactionError.js
  init_transaction();
  init_getNodeError();
  function getTransactionError(err, { docsPath: docsPath4, ...args }) {
    let cause = err;
    if (containsNodeError(err))
      cause = getNodeError(err, args);
    return new TransactionExecutionError(cause, {
      docsPath: docsPath4,
      ...args
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/sendTransaction.js
  init_extract();
  init_format();
  init_transactionRequest();
  init_assertRequest();

  // node_modules/viem/dist/esm/actions/public/getChainId.js
  init_fromHex();
  async function getChainId(client) {
    const chainIdHex = await client.request({ method: "eth_chainId" });
    return hexToNumber(chainIdHex);
  }

  // node_modules/viem/dist/esm/actions/wallet/sendTransaction.js
  async function sendTransaction(client, args) {
    const { account: account_ = client.account, chain: chain2 = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/sendTransaction"
      });
    const account = parseAccount(account_);
    try {
      assertRequest(args);
      let chainId;
      if (chain2 !== null) {
        chainId = await getChainId(client);
        assertCurrentChain({
          currentChainId: chainId,
          chain: chain2
        });
      }
      if (account.type === "local") {
        const request2 = await prepareRequest(client, {
          account,
          accessList,
          chain: chain2,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value,
          ...rest
        });
        if (!chainId)
          chainId = await getChainId(client);
        const signedRequest = await account.signTransaction({
          chainId,
          ...request2
        });
        return await client.request({
          method: "eth_sendRawTransaction",
          params: [signedRequest]
        });
      }
      const formatter = chain2?.formatters?.transactionRequest;
      const request = format({
        accessList,
        data,
        from: account.address,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...extract(rest, { formatter })
      }, {
        formatter: formatter || formatTransactionRequest
      });
      return await client.request({
        method: "eth_sendTransaction",
        params: [request]
      });
    } catch (err) {
      throw getTransactionError(err, {
        ...args,
        account,
        chain: args.chain || void 0
      });
    }
  }

  // node_modules/viem/dist/esm/actions/wallet/writeContract.js
  async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
    const data = encodeFunctionData({
      abi,
      args,
      functionName
    });
    const hash3 = await sendTransaction(client, {
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...request
    });
    return hash3;
  }

  // node_modules/viem/dist/esm/index.js
  init_call();

  // node_modules/viem/dist/esm/actions/public/createEventFilter.js
  init_toHex();
  async function createEventFilter(client, { address, args, event, fromBlock, toBlock } = {}) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newFilter"
    });
    let topics = [];
    if (event)
      topics = encodeEventTopics({
        abi: [event],
        eventName: event.name,
        args
      });
    const id3 = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
          ...topics.length ? { topics } : {}
        }
      ]
    });
    return {
      abi: event ? [event] : void 0,
      args,
      eventName: event ? event.name : void 0,
      id: id3,
      request: getRequest(id3),
      type: "event"
    };
  }

  // node_modules/viem/dist/esm/utils/abi/encodeDeployData.js
  init_abi();
  init_concat();
  init_encodeAbiParameters();
  var docsPath3 = "/docs/contract/encodeDeployData";
  function encodeDeployData({ abi, args, bytecode }) {
    if (!args || args.length === 0)
      return bytecode;
    const description = abi.find((x8) => "type" in x8 && x8.type === "constructor");
    if (!description)
      throw new AbiConstructorNotFoundError({ docsPath: docsPath3 });
    if (!("inputs" in description))
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
    if (!description.inputs || description.inputs.length === 0)
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
    const data = encodeAbiParameters(description.inputs, args);
    return concatHex([bytecode, data]);
  }

  // node_modules/viem/dist/esm/actions/wallet/deployContract.js
  function deployContract(walletClient, { abi, args, bytecode, ...request }) {
    const calldata = encodeDeployData({
      abi,
      args,
      bytecode
    });
    return sendTransaction(walletClient, {
      ...request,
      data: calldata
    });
  }

  // node_modules/viem/dist/esm/actions/public/getBalance.js
  init_toHex();
  async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const balance = await client.request({
      method: "eth_getBalance",
      params: [address, blockNumberHex || blockTag]
    });
    return BigInt(balance);
  }

  // node_modules/viem/dist/esm/actions/public/getBlockTransactionCount.js
  init_fromHex();
  init_toHex();
  async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let count = null;
    if (blockHash) {
      count = await client.request({
        method: "eth_getBlockTransactionCountByHash",
        params: [blockHash]
      });
    } else {
      count = await client.request({
        method: "eth_getBlockTransactionCountByNumber",
        params: [blockNumberHex || blockTag]
      });
    }
    return hexToNumber(count);
  }

  // node_modules/viem/dist/esm/actions/public/getBytecode.js
  init_toHex();
  async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const hex2 = await client.request({
      method: "eth_getCode",
      params: [address, blockNumberHex || blockTag]
    });
    if (hex2 === "0x")
      return void 0;
    return hex2;
  }

  // node_modules/viem/dist/esm/actions/ens/getEnsAddress.js
  init_abis();
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_chain2();
  init_trim();
  init_toHex();

  // node_modules/viem/dist/esm/utils/ens/namehash.js
  init_concat();
  init_toBytes();
  init_toHex();
  init_keccak256();
  function namehash3(name) {
    let result = new Uint8Array(32).fill(0);
    if (!name)
      return bytesToHex(result);
    const labels = name.split(".");
    for (let i4 = labels.length - 1; i4 >= 0; i4 -= 1) {
      const hashed = keccak2562(stringToBytes(labels[i4]), "bytes");
      result = keccak2562(concat5([result, hashed]), "bytes");
    }
    return bytesToHex(result);
  }

  // node_modules/viem/dist/esm/utils/ens/packetToBytes.js
  init_toBytes();
  function packetToBytes(packet) {
    function length(value2) {
      if (value2 === "." || value2 === "..")
        return 1;
      return stringToBytes(value2.replace(/^\.|\.$/gm, "")).length + 2;
    }
    const bytes2 = new Uint8Array(length(packet));
    const value = packet.replace(/^\.|\.$/gm, "");
    if (!value.length)
      return bytes2;
    let offset = 0;
    const list = value.split(".");
    for (let i4 = 0; i4 < list.length; i4++) {
      const encoded = stringToBytes(list[i4]);
      bytes2[offset] = encoded.length;
      bytes2.set(encoded, offset + 1);
      offset += encoded.length + 1;
    }
    return bytes2;
  }

  // node_modules/viem/dist/esm/actions/ens/getEnsAddress.js
  async function getEnsAddress(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: singleAddressResolverAbi,
          functionName: "addr",
          args: [namehash3(name)]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: singleAddressResolverAbi,
      functionName: "addr",
      data: res[0]
    });
    return trim(address) === "0x00" ? null : address;
  }

  // node_modules/viem/dist/esm/actions/ens/getEnsName.js
  init_solidity();
  init_contract();
  init_chain2();
  init_toHex();
  async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
    try {
      const res = await readContract(client, {
        address: universalResolverAddress,
        abi: [
          {
            name: "reverse",
            type: "function",
            stateMutability: "view",
            inputs: [{ type: "bytes", name: "reverseName" }],
            outputs: [
              { type: "string", name: "resolvedName" },
              { type: "address", name: "resolvedAddress" },
              { type: "address", name: "reverseResolver" },
              { type: "address", name: "resolver" }
            ]
          }
        ],
        functionName: "reverse",
        args: [toHex(packetToBytes(reverseNode))],
        blockNumber,
        blockTag
      });
      return res[0];
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError && error.cause.reason === panicReasons[50])
        return null;
      throw error;
    }
  }

  // node_modules/viem/dist/esm/actions/ens/getEnsResolver.js
  init_chain2();
  init_toHex();
  async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const [resolverAddress] = await readContract(client, {
      address: universalResolverAddress,
      abi: [
        {
          inputs: [{ type: "bytes" }],
          name: "findResolver",
          outputs: [{ type: "address" }, { type: "bytes32" }],
          stateMutability: "view",
          type: "function"
        }
      ],
      functionName: "findResolver",
      args: [toHex(packetToBytes(name))],
      blockNumber,
      blockTag
    });
    return resolverAddress;
  }

  // node_modules/viem/dist/esm/actions/public/getFeeHistory.js
  init_toHex();

  // node_modules/viem/dist/esm/utils/formatters/feeHistory.js
  function formatFeeHistory(feeHistory) {
    return {
      baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
      gasUsedRatio: feeHistory.gasUsedRatio,
      oldestBlock: BigInt(feeHistory.oldestBlock),
      reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
    };
  }

  // node_modules/viem/dist/esm/actions/public/getFeeHistory.js
  async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const feeHistory = await client.request({
      method: "eth_feeHistory",
      params: [
        numberToHex(blockCount),
        blockNumberHex || blockTag,
        rewardPercentiles
      ]
    });
    return formatFeeHistory(feeHistory);
  }

  // node_modules/viem/dist/esm/actions/public/getFilterLogs.js
  async function getFilterLogs(_client, { filter: filter2 }) {
    const logs = await filter2.request({
      method: "eth_getFilterLogs",
      params: [filter2.id]
    });
    return logs.map((log) => {
      try {
        const { eventName, args } = "abi" in filter2 && filter2.abi ? decodeEventLog({
          abi: filter2.abi,
          data: log.data,
          topics: log.topics
        }) : { eventName: void 0, args: void 0 };
        return formatLog(log, { args, eventName });
      } catch {
        return;
      }
    }).filter(Boolean);
  }

  // node_modules/viem/dist/esm/actions/public/getStorageAt.js
  init_toHex();
  async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const data = await client.request({
      method: "eth_getStorageAt",
      params: [address, slot, blockNumberHex || blockTag]
    });
    return data;
  }

  // node_modules/viem/dist/esm/actions/public/getTransaction.js
  init_transaction();
  init_toHex();
  init_format();
  async function getTransaction(client, { blockHash, blockNumber, blockTag = "latest", hash: hash3, index: index2 }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let transaction2 = null;
    if (hash3) {
      transaction2 = await client.request({
        method: "eth_getTransactionByHash",
        params: [hash3]
      });
    } else if (blockHash) {
      transaction2 = await client.request({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [blockHash, numberToHex(index2)]
      });
    } else if (blockNumberHex || blockTag) {
      transaction2 = await client.request({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [blockNumberHex || blockTag, numberToHex(index2)]
      });
    }
    if (!transaction2)
      throw new TransactionNotFoundError({
        blockHash,
        blockNumber,
        blockTag,
        hash: hash3,
        index: index2
      });
    return format(transaction2, {
      formatter: client.chain?.formatters?.transaction || formatTransaction
    });
  }

  // node_modules/viem/dist/esm/actions/public/getTransactionConfirmations.js
  async function getTransactionConfirmations(client, { hash: hash3, transactionReceipt }) {
    const [blockNumber, transaction2] = await Promise.all([
      getBlockNumber(client),
      hash3 ? getTransaction(client, { hash: hash3 }) : void 0
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction2?.blockNumber;
    if (!transactionBlockNumber)
      return 0n;
    return blockNumber - transactionBlockNumber + 1n;
  }

  // node_modules/viem/dist/esm/actions/public/getTransactionReceipt.js
  init_transaction();
  init_format();

  // node_modules/viem/dist/esm/utils/formatters/transactionReceipt.js
  init_fromHex();
  init_format();
  var statuses = {
    "0x0": "reverted",
    "0x1": "success"
  };
  function formatTransactionReceipt(transactionReceipt) {
    return {
      ...transactionReceipt,
      blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
      contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
      cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
      effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
      gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
      logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
      to: transactionReceipt.to ? transactionReceipt.to : null,
      transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
      status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
      type: transactionReceipt.type ? transactionType[transactionReceipt.type] : null
    };
  }
  var defineTransactionReceipt = defineFormatter({
    format: formatTransactionReceipt
  });

  // node_modules/viem/dist/esm/actions/public/getTransactionReceipt.js
  async function getTransactionReceipt(client, { hash: hash3 }) {
    const receipt = await client.request({
      method: "eth_getTransactionReceipt",
      params: [hash3]
    });
    if (!receipt)
      throw new TransactionReceiptNotFoundError({ hash: hash3 });
    return format(receipt, {
      formatter: client.chain?.formatters?.transactionReceipt || formatTransactionReceipt
    });
  }

  // node_modules/viem/dist/esm/actions/public/multicall.js
  init_abis();
  init_abi();
  init_contract();
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_chain2();
  async function multicall(client, args) {
    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts_, multicallAddress: multicallAddress_ } = args;
    const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
    const contracts = contracts_;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. multicallAddress is required.");
      multicallAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const chunkedCalls = [[]];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for (let i4 = 0; i4 < contracts.length; i4++) {
      const { abi, address, args: args2, functionName } = contracts[i4];
      try {
        const callData = encodeFunctionData({
          abi,
          args: args2,
          functionName
        });
        currentChunkSize += callData.length;
        if (batchSize > 0 && currentChunkSize > batchSize) {
          currentChunk++;
          currentChunkSize = (callData.length - 2) / 2;
          chunkedCalls[currentChunk] = [];
        }
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData,
            target: address
          }
        ];
      } catch (err) {
        const error = getContractError(err, {
          abi,
          address,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData: "0x",
            target: address
          }
        ];
      }
    }
    const results = await Promise.all(chunkedCalls.map((calls) => readContract(client, {
      abi: multicall3Abi,
      address: multicallAddress,
      args: [calls],
      blockNumber,
      blockTag,
      functionName: "aggregate3"
    })));
    return results.flat().map(({ returnData, success }, i4) => {
      const calls = chunkedCalls.flat();
      const { callData } = calls[i4];
      const { abi, address, functionName, args: args2 } = contracts[i4];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result = decodeFunctionResult({
          abi,
          data: returnData,
          functionName
        });
        return allowFailure ? { result, status: "success" } : result;
      } catch (err) {
        const error = getContractError(err, {
          abi,
          address,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        return { error, result: void 0, status: "failure" };
      }
    });
  }

  // node_modules/viem/dist/esm/actions/public/watchBlocks.js
  init_stringify();
  function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions = false, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    let prevBlock;
    const pollBlocks = () => {
      const observerId = stringify([
        "watchBlocks",
        client.uid,
        emitMissed,
        emitOnBegin,
        includeTransactions,
        pollingInterval
      ]);
      return observe(observerId, { onBlock, onError }, (emit) => poll5(async () => {
        try {
          const block = await getBlock(client, {
            blockTag,
            includeTransactions
          });
          if (block.number && prevBlock?.number) {
            if (block.number === prevBlock.number)
              return;
            if (block.number - prevBlock.number > 1 && emitMissed) {
              for (let i4 = prevBlock?.number + 1n; i4 < block.number; i4++) {
                const block2 = await getBlock(client, {
                  blockNumber: i4,
                  includeTransactions
                });
                emit.onBlock(block2, prevBlock);
                prevBlock = block2;
              }
            }
          }
          if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
            emit.onBlock(block, prevBlock);
            prevBlock = block;
          }
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlocks = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              if (!active)
                return;
              const block = data.result;
              onBlock(block, prevBlock);
              prevBlock = block;
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return unsubscribe;
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
  }

  // node_modules/viem/dist/esm/actions/public/watchBlockNumber.js
  init_fromHex();
  init_stringify();
  function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    let prevBlockNumber;
    const pollBlockNumber = () => {
      const observerId = stringify([
        "watchBlockNumber",
        client.uid,
        emitOnBegin,
        emitMissed,
        pollingInterval
      ]);
      return observe(observerId, { onBlockNumber, onError }, (emit) => poll5(async () => {
        try {
          const blockNumber = await getBlockNumber(client, { maxAge: 0 });
          if (prevBlockNumber) {
            if (blockNumber === prevBlockNumber)
              return;
            if (blockNumber - prevBlockNumber > 1 && emitMissed) {
              for (let i4 = prevBlockNumber + 1n; i4 < blockNumber; i4++) {
                emit.onBlockNumber(i4, prevBlockNumber);
                prevBlockNumber = i4;
              }
            }
          }
          if (!prevBlockNumber || blockNumber > prevBlockNumber) {
            emit.onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          }
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlockNumber = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              if (!active)
                return;
              const blockNumber = hexToBigInt(data.result?.number);
              onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return unsubscribe;
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
  }

  // node_modules/viem/dist/esm/actions/public/watchEvent.js
  init_stringify();
  function watchEvent(client, { address, args, batch = true, event, onError, onLogs, pollingInterval = client.pollingInterval }) {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = poll5(async () => {
        if (!initialized) {
          try {
            filter2 = await createEventFilter(client, {
              address,
              args,
              event
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getFilterChanges(client, { filter: filter2 });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getLogs(client, {
                address,
                args,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                event
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await uninstallFilter(client, { filter: filter2 });
        unwatch();
      };
    });
  }

  // node_modules/viem/dist/esm/actions/public/watchPendingTransactions.js
  init_stringify();

  // node_modules/viem/dist/esm/actions/public/createPendingTransactionFilter.js
  async function createPendingTransactionFilter(client) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newPendingTransactionFilter"
    });
    const id3 = await client.request({
      method: "eth_newPendingTransactionFilter"
    });
    return { id: id3, request: getRequest(id3), type: "transaction" };
  }

  // node_modules/viem/dist/esm/actions/public/watchPendingTransactions.js
  function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    const pollPendingTransactions = () => {
      const observerId = stringify([
        "watchPendingTransactions",
        client.uid,
        batch,
        pollingInterval
      ]);
      return observe(observerId, { onTransactions, onError }, (emit) => {
        let filter2;
        const unwatch = poll5(async () => {
          try {
            if (!filter2) {
              try {
                filter2 = await createPendingTransactionFilter(client);
                return;
              } catch (err) {
                unwatch();
                throw err;
              }
            }
            const hashes = await getFilterChanges(client, { filter: filter2 });
            if (hashes.length === 0)
              return;
            if (batch)
              emit.onTransactions(hashes);
            else
              hashes.forEach((hash3) => emit.onTransactions([hash3]));
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter2)
            await uninstallFilter(client, { filter: filter2 });
          unwatch();
        };
      });
    };
    const subscribePendingTransactions = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newPendingTransactions"],
            onData(data) {
              if (!active)
                return;
              const transaction2 = data.result;
              onTransactions([transaction2]);
            },
            onError(error) {
              onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return unsubscribe;
    };
    return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
  }

  // node_modules/viem/dist/esm/actions/public/waitForTransactionReceipt.js
  init_transaction();

  // node_modules/viem/dist/esm/utils/promise/withRetry.js
  function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
    return new Promise((resolve, reject) => {
      const attemptRetry = async ({ count = 0 } = {}) => {
        const retry = async ({ error }) => {
          const delay2 = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
          if (delay2)
            await wait(delay2);
          attemptRetry({ count: count + 1 });
        };
        try {
          const data = await fn();
          resolve(data);
        } catch (err) {
          if (count < retryCount && await shouldRetry({ count, error: err }))
            return retry({ error: err });
          reject(err);
        }
      };
      attemptRetry();
    });
  }

  // node_modules/viem/dist/esm/actions/public/waitForTransactionReceipt.js
  init_stringify();
  async function waitForTransactionReceipt(client, { confirmations = 1, hash: hash3, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
    const observerId = stringify(["waitForTransactionReceipt", client.uid, hash3]);
    let transaction2;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    return new Promise((resolve, reject) => {
      if (timeout)
        setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash3 })), timeout);
      const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
        const unwatch = watchBlockNumber(client, {
          emitMissed: true,
          emitOnBegin: true,
          poll: true,
          pollingInterval,
          async onBlockNumber(blockNumber_) {
            if (retrying)
              return;
            let blockNumber = blockNumber_;
            const done = async (fn) => {
              unwatch();
              fn();
              _unobserve();
            };
            try {
              if (receipt) {
                if (blockNumber - receipt.blockNumber + 1n < confirmations)
                  return;
                done(() => emit.resolve(receipt));
                return;
              }
              if (!transaction2) {
                retrying = true;
                await withRetry(async () => {
                  transaction2 = await getTransaction(client, { hash: hash3 });
                  if (transaction2.blockNumber)
                    blockNumber = transaction2.blockNumber;
                }, {
                  delay: ({ count }) => ~~(1 << count) * 200,
                  retryCount: 6
                });
                retrying = false;
              }
              receipt = await getTransactionReceipt(client, { hash: hash3 });
              if (confirmations > 0 && blockNumber - receipt.blockNumber + 1n < confirmations)
                return;
              done(() => emit.resolve(receipt));
            } catch (err) {
              if (transaction2 && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {
                replacedTransaction = transaction2;
                const block = await getBlock(client, {
                  blockNumber,
                  includeTransactions: true
                });
                const replacementTransaction = block.transactions.find(({ from: from2, nonce }) => from2 === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getTransactionReceipt(client, {
                  hash: replacementTransaction.hash
                });
                if (blockNumber - receipt.blockNumber + 1n < confirmations)
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit.resolve(receipt);
                });
              } else {
                done(() => emit.reject(err));
              }
            }
          }
        });
        return unwatch;
      });
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/requestPermissions.js
  async function requestPermissions(client, permissions) {
    return client.request({
      method: "wallet_requestPermissions",
      params: [permissions]
    });
  }

  // node_modules/viem/dist/esm/actions/test/sendUnsignedTransaction.js
  init_transactionRequest();

  // node_modules/viem/dist/esm/actions/wallet/signMessage.js
  init_parseAccount();
  init_toHex();
  async function signMessage(client, { account: account_ = client.account, message }) {
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signMessage"
      });
    const account = parseAccount(account_);
    if (account.type === "local")
      return account.signMessage({ message });
    return client.request({
      method: "personal_sign",
      params: [toHex(message), account.address]
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/signTypedData.js
  init_parseAccount();
  init_isHex();
  init_stringify();

  // node_modules/viem/dist/esm/utils/typedData.js
  init_abi();
  init_address();
  init_isAddress();
  init_size();
  init_toHex();

  // node_modules/viem/dist/esm/utils/regex.js
  var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  var integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

  // node_modules/viem/dist/esm/utils/typedData.js
  function validateTypedData({ domain, message, primaryType, types: types_ }) {
    const types = types_;
    const validateData = (struct, value_) => {
      for (const param of struct) {
        const { name, type: type_ } = param;
        const type = type_;
        const value = value_[name];
        const integerMatch = type.match(integerRegex);
        if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
          const [_type, base, size_] = integerMatch;
          numberToHex(value, {
            signed: base === "int",
            size: parseInt(size_) / 8
          });
        }
        if (type === "address" && typeof value === "string" && !isAddress2(value))
          throw new InvalidAddressError({ address: value });
        const bytesMatch = type.match(bytesRegex);
        if (bytesMatch) {
          const [_type, size_] = bytesMatch;
          if (size_ && size(value) !== parseInt(size_))
            throw new BytesSizeMismatchError({
              expectedSize: parseInt(size_),
              givenSize: size(value)
            });
        }
        const struct2 = types[type];
        if (struct2)
          validateData(struct2, value);
      }
    };
    if (types["EIP712Domain"] && domain)
      validateData(types["EIP712Domain"], domain);
    if (primaryType !== "EIP712Domain") {
      const type = types[primaryType];
      validateData(type, message);
    }
  }

  // node_modules/viem/dist/esm/actions/wallet/signTypedData.js
  async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTypedData"
      });
    const account = parseAccount(account_);
    const types = {
      EIP712Domain: [
        domain?.name && { name: "name", type: "string" },
        domain?.version && { name: "version", type: "string" },
        domain?.chainId && { name: "chainId", type: "uint256" },
        domain?.verifyingContract && {
          name: "verifyingContract",
          type: "address"
        },
        domain?.salt && { name: "salt", type: "bytes32" }
      ].filter(Boolean),
      ...types_
    };
    validateTypedData({
      domain,
      message,
      primaryType,
      types
    });
    if (account.type === "local")
      return account.signTypedData({
        domain,
        primaryType,
        types,
        message
      });
    const typedData = stringify({ domain: domain ?? {}, primaryType, types, message }, (_18, value) => isHex(value) ? value.toLowerCase() : value);
    return client.request({
      method: "eth_signTypedData_v4",
      params: [account.address, typedData]
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/watchAsset.js
  async function watchAsset(client, params) {
    const added = await client.request({
      method: "wallet_watchAsset",
      params
    });
    return added;
  }

  // node_modules/viem/dist/esm/utils/uid.js
  var size2 = 256;
  var index = size2;
  var buffer;
  function uid(length = 11) {
    if (!buffer || index + length > size2 * 2) {
      buffer = "";
      index = 0;
      for (let i4 = 0; i4 < size2; i4++) {
        buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
      }
    }
    return buffer.substring(index, index++ + length);
  }

  // node_modules/viem/dist/esm/clients/createClient.js
  function createClient({ chain: chain2, key = "base", name = "Base Client", pollingInterval = 4e3, transport, type = "base" }) {
    const { config: config2, request, value } = transport({ chain: chain2, pollingInterval });
    return {
      chain: chain2,
      key,
      name,
      pollingInterval,
      request,
      transport: { ...config2, ...value },
      type,
      uid: uid()
    };
  }

  // node_modules/viem/dist/esm/utils/buildRequest.js
  init_base();
  init_request();
  init_rpc();
  var isDeterministicError = (error) => {
    if ("code" in error)
      return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
    if (error instanceof HttpRequestError && error.status)
      return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
    return false;
  };
  function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
    return async (args) => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        if (err.code === -32700)
          throw new ParseRpcError(err);
        if (err.code === -32600)
          throw new InvalidRequestRpcError(err);
        if (err.code === -32601)
          throw new MethodNotFoundRpcError(err);
        if (err.code === -32602)
          throw new InvalidParamsRpcError(err);
        if (err.code === -32603)
          throw new InternalRpcError(err);
        if (err.code === -32e3)
          throw new InvalidInputRpcError(err);
        if (err.code === -32001)
          throw new ResourceNotFoundRpcError(err);
        if (err.code === -32002)
          throw new ResourceUnavailableRpcError(err);
        if (err.code === -32003)
          throw new TransactionRejectedRpcError(err);
        if (err.code === -32004)
          throw new MethodNotSupportedRpcError(err);
        if (err.code === -32005)
          throw new LimitExceededRpcError(err);
        if (err.code === -32006)
          throw new JsonRpcVersionUnsupportedError(err);
        if (err.code === -32042)
          throw new MethodNotSupportedRpcError(err);
        if (err.code === 4001)
          throw new UserRejectedRequestError(err);
        if (err.code === 4100)
          throw new UnauthorizedProviderError(err);
        if (err.code === 4200)
          throw new UnsupportedProviderMethodError(err);
        if (err.code === 4900)
          throw new ProviderDisconnectedError(err);
        if (err.code === 4901)
          throw new ChainDisconnectedError(err);
        if (err.code === 4902)
          throw new SwitchChainError(err);
        if (err_ instanceof BaseError)
          throw err_;
        throw new UnknownRpcError(err);
      }
    }, {
      delay: ({ count, error }) => {
        if (error && error instanceof HttpRequestError) {
          const retryAfter = error?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => !isDeterministicError(error)
    });
  }

  // node_modules/viem/dist/esm/clients/transports/createTransport.js
  function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
    return {
      config: { key, name, request, retryCount, retryDelay, timeout, type },
      request: buildRequest(request, { retryCount, retryDelay }),
      value
    };
  }

  // node_modules/viem/dist/esm/clients/transports/fallback.js
  function fallback(transports_, config2 = {}) {
    const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config2;
    return ({ chain: chain2, pollingInterval = 4e3, timeout }) => {
      let transports = transports_;
      let onResponse = () => {
      };
      const transport = createTransport({
        key,
        name,
        async request({ method, params }) {
          const fetch2 = async (i4 = 0) => {
            const transport2 = transports[i4]({ chain: chain2, retryCount: 0, timeout });
            try {
              const response = await transport2.request({
                method,
                params
              });
              onResponse({
                method,
                params,
                response,
                transport: transport2,
                status: "success"
              });
              return response;
            } catch (err) {
              onResponse({
                error: err,
                method,
                params,
                transport: transport2,
                status: "error"
              });
              if (isDeterministicError(err))
                throw err;
              if (i4 === transports.length - 1)
                throw err;
              return fetch2(i4 + 1);
            }
          };
          return fetch2();
        },
        retryCount,
        retryDelay,
        type: "fallback"
      }, {
        onResponse: (fn) => onResponse = fn,
        transports: transports.map((fn) => fn({ chain: chain2, retryCount: 0 }))
      });
      if (rank) {
        const rankOptions = typeof rank === "object" ? rank : {};
        rankTransports({
          chain: chain2,
          interval: rankOptions.interval ?? pollingInterval,
          onTransports: (transports_2) => transports = transports_2,
          sampleCount: rankOptions.sampleCount,
          timeout: rankOptions.timeout,
          transports,
          weights: rankOptions.weights
        });
      }
      return transport;
    };
  }
  function rankTransports({ chain: chain2, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async () => {
      const sample = await Promise.all(transports.map(async (transport) => {
        const transport_ = transport({ chain: chain2, retryCount: 0, timeout });
        const start = Date.now();
        let end;
        let success;
        try {
          await transport_.request({ method: "net_listening" });
          success = 1;
        } catch {
          success = 0;
        } finally {
          end = Date.now();
        }
        const latency = end - start;
        return { latency, success };
      }));
      samples.push(sample);
      if (samples.length > sampleCount)
        samples.shift();
      const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
      const scores = transports.map((_18, i4) => {
        const latencies = samples.map((sample2) => sample2[i4].latency);
        const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
        const latencyScore = 1 - meanLatency / maxLatency;
        const successes = samples.map((sample2) => sample2[i4].success);
        const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
        if (stabilityScore === 0)
          return [0, i4];
        return [
          latencyWeight * latencyScore + stabilityWeight * stabilityScore,
          i4
        ];
      }).sort((a2, b4) => b4[0] - a2[0]);
      onTransports(scores.map(([, i4]) => transports[i4]));
      await wait(interval);
      rankTransports_();
    };
    rankTransports_();
  }

  // node_modules/viem/dist/esm/errors/transport.js
  init_base();
  var UrlRequiredError = class extends BaseError {
    constructor() {
      super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
        docsPath: "/docs/clients/intro"
      });
    }
  };

  // node_modules/viem/dist/esm/utils/rpc.js
  init_request();
  init_createBatchScheduler();

  // node_modules/viem/dist/esm/utils/promise/withTimeout.js
  function withTimeout(fn, { errorInstance, timeout, signal }) {
    return new Promise((resolve, reject) => {
      ;
      (async () => {
        let timeoutId;
        try {
          const controller = new AbortController();
          if (timeout > 0) {
            timeoutId = setTimeout(() => {
              if (signal) {
                controller.abort();
              } else {
                reject(errorInstance);
              }
            }, timeout);
          }
          resolve(await fn({ signal: controller?.signal }));
        } catch (err) {
          if (err.name === "AbortError")
            reject(errorInstance);
          reject(err);
        } finally {
          clearTimeout(timeoutId);
        }
      })();
    });
  }

  // node_modules/viem/dist/esm/utils/rpc.js
  init_stringify();
  var id2 = 0;
  async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
    const { headers, method, signal: signal_ } = fetchOptions;
    try {
      const response = await withTimeout(async ({ signal }) => {
        const response2 = await fetch(url, {
          ...fetchOptions,
          body: stringify({ jsonrpc: "2.0", id: id2++, ...body }),
          headers: {
            ...headers,
            "Content-Type": "application/json"
          },
          method: method || "POST",
          signal: signal_ || (timeout > 0 ? signal : void 0)
        });
        return response2;
      }, {
        errorInstance: new TimeoutError({ body, url }),
        timeout,
        signal: true
      });
      let data;
      if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        data = await response.json();
      } else {
        data = await response.text();
      }
      if (!response.ok) {
        throw new HttpRequestError({
          body,
          details: stringify(data.error) || response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
      }
      if (data.error) {
        throw new RpcRequestError({ body, error: data.error, url });
      }
      return data;
    } catch (err) {
      if (err instanceof HttpRequestError)
        throw err;
      if (err instanceof RpcRequestError)
        throw err;
      if (err instanceof TimeoutError)
        throw err;
      throw new HttpRequestError({
        body,
        details: err.message,
        url
      });
    }
  }
  var sockets = /* @__PURE__ */ new Map();
  async function getSocket(url_) {
    const url = new URL(url_);
    const urlKey = url.toString();
    let socket = sockets.get(urlKey);
    if (socket)
      return socket;
    const { schedule } = createBatchScheduler({
      id: urlKey,
      fn: async () => {
        let WebSocket2 = await Promise.resolve().then(() => (init_browser(), browser_exports));
        if (WebSocket2.default?.constructor)
          WebSocket2 = WebSocket2.default;
        else
          WebSocket2 = WebSocket2.WebSocket;
        const webSocket3 = new WebSocket2(url);
        const requests = /* @__PURE__ */ new Map();
        const subscriptions = /* @__PURE__ */ new Map();
        const onMessage = ({ data }) => {
          const message = JSON.parse(data);
          const isSubscription2 = message.method === "eth_subscription";
          const id3 = isSubscription2 ? message.params.subscription : message.id;
          const cache2 = isSubscription2 ? subscriptions : requests;
          const callback = cache2.get(id3);
          if (callback)
            callback({ data });
          if (!isSubscription2)
            cache2.delete(id3);
        };
        const onClose = () => {
          sockets.delete(urlKey);
          webSocket3.removeEventListener("close", onClose);
          webSocket3.removeEventListener("message", onMessage);
        };
        webSocket3.addEventListener("close", onClose);
        webSocket3.addEventListener("message", onMessage);
        if (webSocket3.readyState === WebSocket2.CONNECTING) {
          await new Promise((resolve, reject) => {
            if (!webSocket3)
              return;
            webSocket3.onopen = resolve;
            webSocket3.onerror = reject;
          });
        }
        socket = Object.assign(webSocket3, {
          requests,
          subscriptions
        });
        sockets.set(urlKey, socket);
        return [socket];
      }
    });
    const [_18, [socket_]] = await schedule();
    return socket_;
  }
  function webSocket(socket, { body, onData, onError }) {
    if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
      throw new WebSocketRequestError({
        body,
        url: socket.url,
        details: "Socket is closed."
      });
    const id_ = id2++;
    const callback = ({ data }) => {
      const message = JSON.parse(data);
      if (typeof message.id === "number" && id_ !== message.id)
        return;
      if (message.error) {
        onError?.(new RpcRequestError({ body, error: message.error, url: socket.url }));
      } else {
        onData?.(message);
      }
      if (body.method === "eth_subscribe" && typeof message.result === "string") {
        socket.subscriptions.set(message.result, callback);
      }
      if (body.method === "eth_unsubscribe") {
        socket.subscriptions.delete(body.params?.[0]);
      }
    };
    socket.requests.set(id_, callback);
    socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
    return socket;
  }
  async function webSocketAsync(socket, { body, timeout = 1e4 }) {
    return withTimeout(() => new Promise((onData, onError) => rpc.webSocket(socket, {
      body,
      onData,
      onError
    })), {
      errorInstance: new TimeoutError({ body, url: socket.url }),
      timeout
    });
  }
  var rpc = {
    http,
    webSocket,
    webSocketAsync
  };

  // node_modules/viem/dist/esm/clients/transports/http.js
  function http2(url, config2 = {}) {
    const { fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config2;
    return ({ chain: chain2, retryCount: retryCount_, timeout: timeout_ }) => {
      const retryCount = config2.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config2.timeout ?? 1e4;
      const url_ = url || chain2?.rpcUrls.default.http[0];
      if (!url_)
        throw new UrlRequiredError();
      return createTransport({
        key,
        name,
        async request({ method, params }) {
          const { result } = await rpc.http(url_, {
            body: {
              method,
              params
            },
            fetchOptions,
            timeout
          });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "http"
      }, {
        url
      });
    };
  }

  // node_modules/viem/dist/esm/errors/ens.js
  init_base();
  var EnsAvatarInvalidMetadataError = class extends BaseError {
    constructor({ data }) {
      super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
        metaMessages: [
          "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
          "",
          `Provided data: ${JSON.stringify(data)}`
        ]
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EnsAvatarInvalidMetadataError"
      });
    }
  };
  var EnsAvatarInvalidNftUriError = class extends BaseError {
    constructor({ reason }) {
      super(`ENS NFT avatar URI is invalid. ${reason}`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EnsAvatarInvalidNftUriError"
      });
    }
  };
  var EnsAvatarUriResolutionError = class extends BaseError {
    constructor({ uri }) {
      super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EnsAvatarUriResolutionError"
      });
    }
  };
  var EnsAvatarUnsupportedNamespaceError = class extends BaseError {
    constructor({ namespace }) {
      super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EnsAvatarUnsupportedNamespaceError"
      });
    }
  };

  // node_modules/viem/dist/esm/utils/ens/avatar/utils.js
  var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
  var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
  var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
  var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
  async function isImageUri(uri) {
    try {
      const res = await fetch(uri, { method: "HEAD" });
      if (res.status === 200) {
        const contentType = res.headers.get("content-type");
        return contentType?.startsWith("image/");
      }
      return false;
    } catch (error) {
      if (typeof error === "object" && typeof error.response !== "undefined") {
        return false;
      }
      if (!globalThis.hasOwnProperty("Image"))
        return false;
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          resolve(true);
        };
        img.onerror = () => {
          resolve(false);
        };
        img.src = uri;
      });
    }
  }
  function getGateway(custom3, defaultGateway) {
    if (!custom3)
      return defaultGateway;
    if (custom3.endsWith("/"))
      return custom3.slice(0, -1);
    return custom3;
  }
  function resolveAvatarUri({ uri, gatewayUrls }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded)
      return { uri, isOnChain: true, isEncoded };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
    const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
    const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
    const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
    if (uri.startsWith("http") && !isIPNS && !isIPFS) {
      let replacedUri = uri;
      if (gatewayUrls?.arweave)
        replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
      return { uri: replacedUri, isOnChain: false, isEncoded: false };
    }
    if ((isIPNS || isIPFS) && target) {
      return {
        uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
        isOnChain: false,
        isEncoded: false
      };
    } else if (protocol === "ar:/" && target) {
      return {
        uri: `${arweaveGateway}/${target}${subtarget || ""}`,
        isOnChain: false,
        isEncoded: false
      };
    }
    let parsedUri = uri.replace(dataURIRegex, "");
    if (parsedUri.startsWith("<svg")) {
      parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    }
    if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
      return {
        uri: parsedUri,
        isOnChain: true,
        isEncoded: false
      };
    }
    throw new EnsAvatarUriResolutionError({ uri });
  }
  function getJsonImage(data) {
    if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
      throw new EnsAvatarInvalidMetadataError({ data });
    }
    return data.image || data.image_url || data.image_data;
  }
  async function getMetadataAvatarUri({ gatewayUrls, uri }) {
    try {
      const res = await fetch(uri).then((res2) => res2.json());
      const image = await parseAvatarUri({
        gatewayUrls,
        uri: getJsonImage(res)
      });
      return image;
    } catch {
      throw new EnsAvatarUriResolutionError({ uri });
    }
  }
  async function parseAvatarUri({ gatewayUrls, uri }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
    if (isOnChain)
      return resolvedURI;
    const isImage = await isImageUri(resolvedURI);
    if (isImage)
      return resolvedURI;
    throw new EnsAvatarUriResolutionError({ uri });
  }
  function parseNftUri(uri) {
    if (uri.startsWith("did:nft:")) {
      uri = uri.replace("did:nft:", "").replace(/_/g, "/");
    }
    const [reference, asset_namespace, tokenID] = uri.split("/");
    const [eip_namespace, chainID] = reference.split(":");
    const [erc_namespace, contractAddress] = asset_namespace.split(":");
    if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
      throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
    if (!chainID)
      throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
    if (!contractAddress)
      throw new EnsAvatarInvalidNftUriError({
        reason: "Contract address not found"
      });
    if (!tokenID)
      throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
    if (!erc_namespace)
      throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
    return {
      chainID: parseInt(chainID),
      namespace: erc_namespace.toLowerCase(),
      contractAddress,
      tokenID
    };
  }
  async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === "erc721") {
      return readContract(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "tokenURI",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "tokenId", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "tokenURI",
        args: [BigInt(nft.tokenID)]
      });
    }
    if (nft.namespace === "erc1155") {
      return readContract(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "uri",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "_id", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "uri",
        args: [BigInt(nft.tokenID)]
      });
    }
    throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
  }

  // node_modules/viem/dist/esm/utils/ens/avatar/parseAvatarRecord.js
  async function parseAvatarRecord(client, { gatewayUrls, record }) {
    if (/eip155:/i.test(record))
      return parseNftAvatarUri(client, { gatewayUrls, record });
    return parseAvatarUri({ uri: record, gatewayUrls });
  }
  async function parseNftAvatarUri(client, { gatewayUrls, record }) {
    const nft = parseNftUri(record);
    const nftUri = await getNftTokenUri(client, { nft });
    const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
    if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
      const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
      const decoded = JSON.parse(encodedJson);
      return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === "erc1155")
      uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
    return getMetadataAvatarUri({
      gatewayUrls,
      uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
    });
  }

  // node_modules/viem/dist/esm/actions/ens/getEnsText.js
  init_abis();
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_chain2();
  init_toHex();
  async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash3(name), key]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  }

  // node_modules/viem/dist/esm/actions/ens/getEnsAvatar.js
  async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
    const record = await getEnsText(client, {
      blockNumber,
      blockTag,
      key: "avatar",
      name,
      universalResolverAddress
    });
    if (!record)
      return null;
    try {
      return await parseAvatarRecord(client, { record, gatewayUrls });
    } catch {
      return null;
    }
  }

  // node_modules/viem/dist/esm/clients/decorators/public.js
  init_call();

  // node_modules/viem/dist/esm/actions/public/createBlockFilter.js
  async function createBlockFilter(client) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newBlockFilter"
    });
    const id3 = await client.request({
      method: "eth_newBlockFilter"
    });
    return { id: id3, request: getRequest(id3), type: "block" };
  }

  // node_modules/viem/dist/esm/utils/index.js
  init_ccip2();
  init_chain2();
  init_stringify();
  init_decodeAbiParameters();
  init_decodeErrorResult();

  // node_modules/viem/dist/esm/utils/abi/decodeFunctionData.js
  init_abi();
  init_slice();
  init_getFunctionSelector();
  init_decodeAbiParameters();
  init_formatAbiItem();

  // node_modules/viem/dist/esm/utils/index.js
  init_decodeFunctionResult();
  init_encodeAbiParameters();

  // node_modules/viem/dist/esm/utils/abi/encodeErrorResult.js
  init_abi();
  init_concat();
  init_getFunctionSelector();
  init_encodeAbiParameters();
  init_formatAbiItem();
  init_getAbiItem();

  // node_modules/viem/dist/esm/utils/index.js
  init_encodeFunctionData();

  // node_modules/viem/dist/esm/utils/abi/encodeFunctionResult.js
  init_abi();
  init_encodeAbiParameters();
  init_getAbiItem();

  // node_modules/viem/dist/esm/utils/index.js
  init_getAbiItem();

  // node_modules/viem/dist/esm/utils/abi/encodePacked.js
  init_abi();
  init_address();
  init_isAddress();
  init_concat();
  init_pad();
  init_toHex();

  // node_modules/viem/dist/esm/utils/index.js
  init_formatAbiItemWithArgs();
  init_formatAbiItem();
  init_parseAccount();

  // node_modules/viem/dist/esm/accounts/utils/publicKeyToAddress.js
  init_getAddress();
  init_keccak256();
  function publicKeyToAddress(publicKey) {
    const address = keccak2562(`0x${publicKey.substring(4)}`).substring(26);
    return checksumAddress(`0x${address}`);
  }

  // node_modules/viem/dist/esm/utils/address/getContractAddress.js
  init_concat();
  init_pad();
  init_slice();
  init_toBytes();

  // node_modules/viem/dist/esm/utils/encoding/toRlp.js
  init_concat();
  init_toBytes();
  init_toHex();
  function toRlp(hexOrBytes, to_) {
    const to = to_ || "hex";
    return format2(bytesToRlp(parse(hexOrBytes)), to);
  }
  function parse(hexOrBytes) {
    if (Array.isArray(hexOrBytes))
      return hexOrBytes.map(parse);
    return typeof hexOrBytes === "string" ? toBytes(hexOrBytes) : hexOrBytes;
  }
  function format2(bytes2, type = "bytes") {
    return type === "hex" ? bytesToHex(bytes2) : bytes2;
  }
  function bytesToRlp(bytes2) {
    if (Array.isArray(bytes2)) {
      const encoded = concat5(bytes2.map(bytesToRlp));
      return new Uint8Array([...encodeLength(encoded.length, 192), ...encoded]);
    }
    if (bytes2.length === 1 && bytes2[0] < 128)
      return bytes2;
    return new Uint8Array([...encodeLength(bytes2.length, 128), ...bytes2]);
  }
  function encodeLength(length, offset) {
    if (length < 56)
      return [offset + length];
    return [toBytes(length).length + offset + 55, ...toBytes(length)];
  }

  // node_modules/viem/dist/esm/utils/address/getContractAddress.js
  init_keccak256();
  init_getAddress();

  // node_modules/viem/dist/esm/utils/index.js
  init_getAddress();
  init_isAddress();
  init_isAddressEqual();
  init_extractFunctionParts();
  init_concat();
  init_isHex();
  init_pad();
  init_size();
  init_slice();
  init_trim();
  init_format();
  init_transactionRequest();
  init_extract();
  init_toBytes();
  init_toHex();

  // node_modules/viem/dist/esm/utils/encoding/fromBytes.js
  init_encoding();
  init_trim();
  init_fromHex();
  init_toHex();
  function bytesToString(bytes_, opts = {}) {
    let bytes2 = bytes_;
    if (typeof opts.size !== "undefined") {
      assertSize(bytes2, { size: opts.size });
      bytes2 = trim(bytes2, { dir: "right" });
    }
    return new TextDecoder().decode(bytes2);
  }

  // node_modules/viem/dist/esm/utils/index.js
  init_fromHex();

  // node_modules/viem/dist/esm/utils/encoding/fromRlp.js
  init_encoding();
  init_toBytes();
  init_toHex();

  // node_modules/viem/dist/esm/utils/index.js
  init_getNodeError();
  init_getCallError();
  init_getFunctionSelector();

  // node_modules/viem/dist/esm/utils/hash/isHash.js
  init_isHex();
  init_size();

  // node_modules/viem/dist/esm/utils/index.js
  init_keccak256();

  // node_modules/viem/dist/esm/utils/signature/hashTypedData.js
  init_encodeAbiParameters();
  init_concat();
  init_toHex();
  init_keccak256();
  function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
    const domain = typeof domain_ === "undefined" ? {} : domain_;
    const types = {
      EIP712Domain: [
        domain?.name && { name: "name", type: "string" },
        domain?.version && { name: "version", type: "string" },
        domain?.chainId && { name: "chainId", type: "uint256" },
        domain?.verifyingContract && {
          name: "verifyingContract",
          type: "address"
        },
        domain?.salt && { name: "salt", type: "bytes32" }
      ].filter(Boolean),
      ...types_
    };
    validateTypedData({
      domain,
      message,
      primaryType,
      types
    });
    const parts = ["0x1901"];
    if (domain)
      parts.push(hashDomain({
        domain,
        types
      }));
    if (primaryType !== "EIP712Domain") {
      parts.push(hashStruct({
        data: message,
        primaryType,
        types
      }));
    }
    return keccak2562(concat5(parts));
  }
  function hashDomain({ domain, types }) {
    return hashStruct({
      data: domain,
      primaryType: "EIP712Domain",
      types
    });
  }
  function hashStruct({ data, primaryType, types }) {
    const encoded = encodeData({
      data,
      primaryType,
      types
    });
    return keccak2562(encoded);
  }
  function encodeData({ data, primaryType, types }) {
    const encodedTypes = [{ type: "bytes32" }];
    const encodedValues = [hashType({ primaryType, types })];
    for (const field of types[primaryType]) {
      const [type, value] = encodeField({
        types,
        name: field.name,
        type: field.type,
        value: data[field.name]
      });
      encodedTypes.push(type);
      encodedValues.push(value);
    }
    return encodeAbiParameters(encodedTypes, encodedValues);
  }
  function hashType({ primaryType, types }) {
    const encodedHashType = toHex(encodeType({ primaryType, types }));
    return keccak2562(encodedHashType);
  }
  function encodeType({ primaryType, types }) {
    let result = "";
    const unsortedDeps = findTypeDependencies({ primaryType, types });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
      result += `${type}(${types[type].map(({ name, type: t3 }) => `${t3} ${name}`).join(",")})`;
    }
    return result;
  }
  function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === void 0) {
      return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
      findTypeDependencies({ primaryType: field.type, types }, results);
    }
    return results;
  }
  function encodeField({ types, name, type, value }) {
    if (types[type] !== void 0) {
      return [
        { type: "bytes32" },
        keccak2562(encodeData({ data: value, primaryType: type, types }))
      ];
    }
    if (type === "bytes") {
      const prepend = value.length % 2 ? "0" : "";
      value = `0x${prepend + value.slice(2)}`;
      return [{ type: "bytes32" }, keccak2562(value)];
    }
    if (type === "string")
      return [{ type: "bytes32" }, keccak2562(toHex(value))];
    if (type.lastIndexOf("]") === type.length - 1) {
      const parsedType = type.slice(0, type.lastIndexOf("["));
      const typeValuePairs = value.map((item) => encodeField({
        name,
        type: parsedType,
        types,
        value: item
      }));
      return [
        { type: "bytes32" },
        keccak2562(encodeAbiParameters(typeValuePairs.map(([t3]) => t3), typeValuePairs.map(([, v7]) => v7)))
      ];
    }
    return [{ type }, value];
  }

  // node_modules/viem/dist/esm/utils/signature/recoverPublicKey.js
  init_isHex();
  init_fromHex();
  init_toHex();

  // node_modules/viem/dist/esm/utils/signature/hashMessage.js
  init_concat();
  init_toBytes();
  init_keccak256();
  function hashMessage2(message, to_) {
    const messageBytes = stringToBytes(message);
    const prefixBytes = stringToBytes(`Ethereum Signed Message:
${messageBytes.length}`);
    return keccak2562(concat5([prefixBytes, messageBytes]), to_);
  }

  // node_modules/viem/dist/esm/utils/signature/verifyMessage.js
  init_getAddress();
  init_isAddressEqual();

  // node_modules/viem/dist/esm/utils/signature/verifyTypedData.js
  init_getAddress();
  init_isAddressEqual();

  // node_modules/viem/dist/esm/utils/transaction/getSerializedTransactionType.js
  init_transaction();
  init_slice();
  init_fromHex();

  // node_modules/viem/dist/esm/utils/transaction/getTransactionType.js
  init_transaction();
  function getTransactionType(transaction2) {
    if (transaction2.type)
      return transaction2.type;
    if (typeof transaction2.maxFeePerGas !== "undefined" || typeof transaction2.maxPriorityFeePerGas !== "undefined")
      return "eip1559";
    if (typeof transaction2.gasPrice !== "undefined") {
      if (typeof transaction2.accessList !== "undefined")
        return "eip2930";
      return "legacy";
    }
    throw new InvalidSerializableTransactionError({ transaction: transaction2 });
  }

  // node_modules/viem/dist/esm/utils/index.js
  init_assertRequest();

  // node_modules/viem/dist/esm/utils/transaction/assertTransaction.js
  init_address();
  init_base();
  init_chain();
  init_node();
  init_isAddress();
  function assertTransactionEIP1559(transaction2) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction2;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
    if (gasPrice)
      throw new BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  function assertTransactionEIP2930(transaction2) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction2;
    if (chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
    if (gasPrice && gasPrice > 2n ** 256n - 1n)
      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
  }
  function assertTransactionLegacy(transaction2) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction2;
    if (to && !isAddress2(to))
      throw new InvalidAddressError({ address: to });
    if (typeof chainId !== "undefined" && chainId <= 0)
      throw new InvalidChainIdError({ chainId });
    if (maxPriorityFeePerGas || maxFeePerGas)
      throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
    if (gasPrice && gasPrice > 2n ** 256n - 1n)
      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
    if (accessList)
      throw new BaseError("`accessList` is not a valid Legacy Transaction attribute.");
  }

  // node_modules/viem/dist/esm/utils/transaction/parseTransaction.js
  init_address();
  init_transaction();
  init_isAddress();
  init_isHex();
  init_pad();
  init_trim();
  init_fromHex();

  // node_modules/viem/dist/esm/utils/transaction/serializeTransaction.js
  init_address();
  init_transaction();
  init_isAddress();
  init_concat();
  init_trim();
  init_toHex();
  function serializeTransaction2(transaction2, signature) {
    const type = getTransactionType(transaction2);
    if (type === "eip1559")
      return serializeTransactionEIP1559(transaction2, signature);
    if (type === "eip2930")
      return serializeTransactionEIP2930(transaction2, signature);
    return serializeTransactionLegacy(transaction2, signature);
  }
  function serializeTransactionEIP1559(transaction2, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction2;
    assertTransactionEIP1559(transaction2);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? toHex(maxFeePerGas) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializedAccessList
    ];
    if (signature)
      serializedTransaction.push(signature.v === 27n ? "0x" : toHex(1), trim(signature.r), trim(signature.s));
    return concatHex([
      "0x02",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionEIP2930(transaction2, signature) {
    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction2;
    assertTransactionEIP2930(transaction2);
    const serializedAccessList = serializeAccessList(accessList);
    const serializedTransaction = [
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      gasPrice ? toHex(gasPrice) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializedAccessList
    ];
    if (signature)
      serializedTransaction.push(signature.v === 27n ? "0x" : toHex(1), signature.r, signature.s);
    return concatHex([
      "0x01",
      toRlp(serializedTransaction)
    ]);
  }
  function serializeTransactionLegacy(transaction2, signature) {
    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction2;
    assertTransactionLegacy(transaction2);
    let serializedTransaction = [
      nonce ? toHex(nonce) : "0x",
      gasPrice ? toHex(gasPrice) : "0x",
      gas ? toHex(gas) : "0x",
      to ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x"
    ];
    if (signature) {
      let v7 = 27n + (signature.v === 27n ? 0n : 1n);
      if (chainId > 0)
        v7 = BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      else if (signature.v !== v7)
        throw new InvalidLegacyVError({ v: signature.v });
      serializedTransaction = [
        ...serializedTransaction,
        toHex(v7),
        signature.r,
        signature.s
      ];
    } else if (chainId > 0) {
      serializedTransaction = [
        ...serializedTransaction,
        toHex(chainId),
        "0x",
        "0x"
      ];
    }
    return toRlp(serializedTransaction);
  }
  function serializeAccessList(accessList) {
    if (!accessList || accessList.length === 0)
      return [];
    const serializedAccessList = [];
    for (let i4 = 0; i4 < accessList.length; i4++) {
      const { address, storageKeys } = accessList[i4];
      for (let j3 = 0; j3 < storageKeys.length; j3++) {
        if (storageKeys[j3].length - 2 !== 64) {
          throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j3] });
        }
      }
      if (!isAddress2(address)) {
        throw new InvalidAddressError({ address });
      }
      serializedAccessList.push([address, storageKeys]);
    }
    return serializedAccessList;
  }

  // node_modules/viem/dist/esm/utils/index.js
  init_formatEther();
  init_formatGwei();
  init_formatUnits();

  // node_modules/viem/dist/esm/utils/unit/parseEther.js
  init_unit();

  // node_modules/viem/dist/esm/utils/unit/parseGwei.js
  init_unit();

  // node_modules/viem/dist/esm/actions/public/verifyHash.js
  init_abis();

  // node_modules/viem/dist/esm/constants/contracts.js
  var universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

  // node_modules/viem/dist/esm/actions/public/verifyHash.js
  init_contract();

  // node_modules/viem/dist/esm/utils/data/isBytesEqual.js
  init_utils3();
  function isBytesEqual(a_, b_) {
    const a2 = isHex(a_) ? toBytes(a_) : a_;
    const b4 = isHex(b_) ? toBytes(b_) : b_;
    return equalBytes(a2, b4);
  }

  // node_modules/viem/dist/esm/actions/public/verifyHash.js
  init_call();
  async function verifyHash(client, { address, hash: hash3, signature, ...callRequest }) {
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    try {
      const { data } = await call(client, {
        data: encodeDeployData({
          abi: universalSignatureValidatorAbi,
          args: [address, hash3, signatureHex],
          bytecode: universalSignatureValidatorByteCode
        }),
        ...callRequest
      });
      return isBytesEqual(data ?? "0x0", "0x1");
    } catch (error) {
      if (error instanceof CallExecutionError) {
        return false;
      }
      throw error;
    }
  }

  // node_modules/viem/dist/esm/actions/public/verifyMessage.js
  async function verifyMessage3(client, { address, message, signature, ...callRequest }) {
    const hash3 = hashMessage2(message);
    return verifyHash(client, {
      address,
      hash: hash3,
      signature,
      ...callRequest
    });
  }

  // node_modules/viem/dist/esm/actions/public/verifyTypedData.js
  async function verifyTypedData3(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
    const hash3 = hashTypedData({ message, primaryType, types, domain });
    return verifyHash(client, {
      address,
      hash: hash3,
      signature,
      ...callRequest
    });
  }

  // node_modules/viem/dist/esm/clients/decorators/public.js
  var publicActions = (client) => ({
    call: (args) => call(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getBytecode(client, args),
    getChainId: () => getChainId(client),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    readContract: (args) => readContract(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage3(client, args),
    verifyTypedData: (args) => verifyTypedData3(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  });

  // node_modules/viem/dist/esm/clients/createPublicClient.js
  function createPublicClient({ batch, chain: chain2, key = "public", name = "Public Client", transport, pollingInterval }) {
    const client = {
      batch,
      ...createClient({
        chain: chain2,
        key,
        name,
        pollingInterval,
        transport,
        type: "publicClient"
      })
    };
    return {
      ...client,
      ...publicActions(client)
    };
  }

  // node_modules/viem/dist/esm/actions/test/getTxpoolStatus.js
  init_fromHex();

  // node_modules/viem/dist/esm/actions/test/increaseTime.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/mine.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setBalance.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setBlockGasLimit.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setMinGasPrice.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setNextBlockBaseFeePerGas.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setNextBlockTimestamp.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setNonce.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setStorageAt.js
  init_toHex();

  // node_modules/viem/dist/esm/clients/createWalletClient.js
  init_parseAccount();

  // node_modules/viem/dist/esm/actions/wallet/addChain.js
  init_toHex();
  async function addChain(client, { chain: chain2 }) {
    const { id: id3, name, nativeCurrency, rpcUrls, blockExplorers } = chain2;
    await client.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: numberToHex(id3),
          chainName: name,
          nativeCurrency,
          rpcUrls: rpcUrls.default.http,
          blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
        }
      ]
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/getAddresses.js
  init_getAddress();
  async function getAddresses(client) {
    const addresses = await client.request({ method: "eth_accounts" });
    return addresses.map((address) => checksumAddress(address));
  }

  // node_modules/viem/dist/esm/actions/wallet/getPermissions.js
  async function getPermissions(client) {
    const permissions = await client.request({ method: "wallet_getPermissions" });
    return permissions;
  }

  // node_modules/viem/dist/esm/actions/wallet/requestAddresses.js
  init_getAddress();
  async function requestAddresses(client) {
    const addresses = await client.request({ method: "eth_requestAccounts" });
    return addresses.map((address) => getAddress4(address));
  }

  // node_modules/viem/dist/esm/actions/wallet/switchChain.js
  init_toHex();
  async function switchChain(client, { id: id3 }) {
    await client.request({
      method: "wallet_switchEthereumChain",
      params: [
        {
          chainId: numberToHex(id3)
        }
      ]
    });
  }

  // node_modules/viem/dist/esm/clients/decorators/wallet.js
  var walletActions = (client) => ({
    addChain: (args) => addChain(client, args),
    deployContract: (args) => deployContract(client, args),
    getAddresses: () => getAddresses(client),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (args) => requestPermissions(client, args),
    sendTransaction: (args) => sendTransaction(client, args),
    signMessage: (args) => signMessage(client, args),
    signTypedData: (args) => signTypedData(client, args),
    switchChain: (args) => switchChain(client, args),
    watchAsset: (args) => watchAsset(client, args),
    writeContract: (args) => writeContract(client, args)
  });

  // node_modules/viem/dist/esm/clients/createWalletClient.js
  function createWalletClient({ account, chain: chain2, transport, key = "wallet", name = "Wallet Client", pollingInterval }) {
    const client = {
      ...createClient({
        chain: chain2,
        key,
        name,
        pollingInterval,
        transport: (opts) => transport({ ...opts, retryCount: 0 }),
        type: "walletClient"
      }),
      account: account ? parseAccount(account) : void 0
    };
    return {
      ...client,
      ...walletActions(client)
    };
  }

  // node_modules/viem/dist/esm/clients/transports/webSocket.js
  function webSocket2(url, config2 = {}) {
    const { key = "webSocket", name = "WebSocket JSON-RPC", retryDelay } = config2;
    return ({ chain: chain2, retryCount: retryCount_, timeout: timeout_ }) => {
      const retryCount = config2.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config2.timeout ?? 1e4;
      const url_ = url || chain2?.rpcUrls.default.webSocket?.[0];
      if (!url_)
        throw new UrlRequiredError();
      return createTransport({
        key,
        name,
        async request({ method, params }) {
          const socket = await getSocket(url_);
          const { result } = await rpc.webSocketAsync(socket, {
            body: { method, params },
            timeout
          });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "webSocket"
      }, {
        getSocket() {
          return getSocket(url_);
        },
        async subscribe({ params, onData, onError }) {
          const socket = await getSocket(url_);
          const { result: subscriptionId } = await new Promise((resolve, reject) => rpc.webSocket(socket, {
            body: {
              method: "eth_subscribe",
              params
            },
            onData: (data) => {
              if (typeof data.id === "number") {
                resolve(data);
                return;
              }
              if (data.method !== "eth_subscription")
                return;
              onData(data.params);
            },
            onError: (error) => {
              reject(error);
              onError?.(error);
            }
          }));
          return {
            subscriptionId,
            async unsubscribe() {
              return new Promise((resolve, reject) => rpc.webSocket(socket, {
                body: {
                  method: "eth_unsubscribe",
                  params: [subscriptionId]
                },
                onData: resolve,
                onError: reject
              }));
            }
          };
        }
      });
    };
  }

  // node_modules/viem/dist/esm/index.js
  init_abis();
  init_unit();
  init_abi();
  init_base();
  init_contract();
  init_rpc();
  init_chain();
  init_encoding();
  init_node();
  init_request();
  init_address();
  init_transaction();
  init_data();

  // node_modules/viem/dist/esm/utils/ens/labelhash.js
  init_toBytes();
  init_toHex();
  init_keccak256();

  // node_modules/viem/dist/esm/index.js
  init_decodeAbiParameters();
  init_decodeErrorResult();
  init_decodeFunctionResult();
  init_encodeAbiParameters();
  init_encodeFunctionData();
  init_format();
  init_transactionRequest();
  init_getAbiItem();
  init_assertRequest();
  init_toBytes();
  init_toHex();
  init_ccip2();
  init_concat();
  init_chain2();
  init_formatEther();
  init_formatGwei();
  init_formatUnits();
  init_fromHex();
  init_getAddress();
  init_getFunctionSelector();
  init_isAddress();
  init_isAddressEqual();
  init_isHex();
  init_keccak256();
  init_pad();
  init_size();
  init_slice();
  init_stringify();
  init_trim();

  // node_modules/@latticexyz/store/abi/IStore.sol/IStore.abi.json
  var IStore_abi_default = [
    {
      inputs: [
        {
          internalType: "uint256",
          name: "length",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "received",
          type: "uint256"
        }
      ],
      name: "StoreCore_DataIndexOverflow",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "expected",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "received",
          type: "uint256"
        }
      ],
      name: "StoreCore_InvalidDataLength",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "expected",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "received",
          type: "uint256"
        }
      ],
      name: "StoreCore_InvalidFieldNamesLength",
      type: "error"
    },
    {
      inputs: [],
      name: "StoreCore_NotDynamicField",
      type: "error"
    },
    {
      inputs: [],
      name: "StoreCore_NotImplemented",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "tableId",
          type: "bytes32"
        },
        {
          internalType: "string",
          name: "tableIdString",
          type: "string"
        }
      ],
      name: "StoreCore_TableAlreadyExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "tableId",
          type: "bytes32"
        },
        {
          internalType: "string",
          name: "tableIdString",
          type: "string"
        }
      ],
      name: "StoreCore_TableNotFound",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          indexed: false,
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        }
      ],
      name: "StoreDeleteRecord",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          indexed: false,
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "StoreEphemeralRecord",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          indexed: false,
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          indexed: false,
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "StoreSetField",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          indexed: false,
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "StoreSetRecord",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        }
      ],
      name: "deleteRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "emitEphemeralRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        }
      ],
      name: "getField",
      outputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        }
      ],
      name: "getFieldLength",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        },
        {
          internalType: "uint256",
          name: "start",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "end",
          type: "uint256"
        }
      ],
      name: "getFieldSlice",
      outputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        }
      ],
      name: "getKeySchema",
      outputs: [
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        }
      ],
      name: "getRecord",
      outputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        }
      ],
      name: "getRecord",
      outputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        }
      ],
      name: "getSchema",
      outputs: [
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "isStore",
      outputs: [],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "byteLengthToPop",
          type: "uint256"
        }
      ],
      name: "popFromField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "dataToPush",
          type: "bytes"
        }
      ],
      name: "pushToField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        },
        {
          internalType: "Schema",
          name: "keySchema",
          type: "bytes32"
        }
      ],
      name: "registerSchema",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "contract IStoreHook",
          name: "hook",
          type: "address"
        }
      ],
      name: "registerStoreHook",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "setField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "string",
          name: "tableName",
          type: "string"
        },
        {
          internalType: "string[]",
          name: "fieldNames",
          type: "string[]"
        }
      ],
      name: "setMetadata",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "setRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "startByteIndex",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "dataToSet",
          type: "bytes"
        }
      ],
      name: "updateInField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ];

  // node_modules/@latticexyz/services/dist/mode.js
  var import_minimal = __toESM(require_minimal2(), 1);
  function createBaseRow() {
    return { values: [] };
  }
  var Row = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      for (const v7 of message.values) {
        writer.uint32(18).bytes(v7);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseRow();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 2:
            if (tag != 18) {
              break;
            }
            message.values.push(reader.bytes());
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return Row.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseRow();
      message.values = object2.values?.map((e) => e) || [];
      return message;
    }
  };
  function createBaseGenericTable() {
    return { cols: [], rows: [], types: [] };
  }
  var GenericTable = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      for (const v7 of message.cols) {
        writer.uint32(10).string(v7);
      }
      for (const v7 of message.rows) {
        Row.encode(v7, writer.uint32(18).fork()).ldelim();
      }
      for (const v7 of message.types) {
        writer.uint32(26).string(v7);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGenericTable();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.cols.push(reader.string());
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.rows.push(Row.decode(reader, reader.uint32()));
            continue;
          case 3:
            if (tag != 26) {
              break;
            }
            message.types.push(reader.string());
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return GenericTable.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseGenericTable();
      message.cols = object2.cols?.map((e) => e) || [];
      message.rows = object2.rows?.map((e) => Row.fromPartial(e)) || [];
      message.types = object2.types?.map((e) => e) || [];
      return message;
    }
  };
  function createBaseQueryLayerStateResponse() {
    return { chainTables: {}, worldTables: {} };
  }
  var QueryLayerStateResponse = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      Object.entries(message.chainTables).forEach(([key, value]) => {
        QueryLayerStateResponse_ChainTablesEntry.encode({ key, value }, writer.uint32(10).fork()).ldelim();
      });
      Object.entries(message.worldTables).forEach(([key, value]) => {
        QueryLayerStateResponse_WorldTablesEntry.encode({ key, value }, writer.uint32(18).fork()).ldelim();
      });
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseQueryLayerStateResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            const entry1 = QueryLayerStateResponse_ChainTablesEntry.decode(reader, reader.uint32());
            if (entry1.value !== void 0) {
              message.chainTables[entry1.key] = entry1.value;
            }
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            const entry2 = QueryLayerStateResponse_WorldTablesEntry.decode(reader, reader.uint32());
            if (entry2.value !== void 0) {
              message.worldTables[entry2.key] = entry2.value;
            }
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return QueryLayerStateResponse.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseQueryLayerStateResponse();
      message.chainTables = Object.entries(object2.chainTables ?? {}).reduce(
        (acc, [key, value]) => {
          if (value !== void 0) {
            acc[key] = GenericTable.fromPartial(value);
          }
          return acc;
        },
        {}
      );
      message.worldTables = Object.entries(object2.worldTables ?? {}).reduce(
        (acc, [key, value]) => {
          if (value !== void 0) {
            acc[key] = GenericTable.fromPartial(value);
          }
          return acc;
        },
        {}
      );
      return message;
    }
  };
  function createBaseQueryLayerStateResponse_ChainTablesEntry() {
    return { key: "", value: void 0 };
  }
  var QueryLayerStateResponse_ChainTablesEntry = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== void 0) {
        GenericTable.encode(message.value, writer.uint32(18).fork()).ldelim();
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseQueryLayerStateResponse_ChainTablesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.key = reader.string();
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.value = GenericTable.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return QueryLayerStateResponse_ChainTablesEntry.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseQueryLayerStateResponse_ChainTablesEntry();
      message.key = object2.key ?? "";
      message.value = object2.value !== void 0 && object2.value !== null ? GenericTable.fromPartial(object2.value) : void 0;
      return message;
    }
  };
  function createBaseQueryLayerStateResponse_WorldTablesEntry() {
    return { key: "", value: void 0 };
  }
  var QueryLayerStateResponse_WorldTablesEntry = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== void 0) {
        GenericTable.encode(message.value, writer.uint32(18).fork()).ldelim();
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseQueryLayerStateResponse_WorldTablesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.key = reader.string();
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.value = GenericTable.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return QueryLayerStateResponse_WorldTablesEntry.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseQueryLayerStateResponse_WorldTablesEntry();
      message.key = object2.key ?? "";
      message.value = object2.value !== void 0 && object2.value !== null ? GenericTable.fromPartial(object2.value) : void 0;
      return message;
    }
  };
  function createBaseQueryLayerStateStreamResponse() {
    return { inserted: void 0, updated: void 0, deleted: void 0 };
  }
  var QueryLayerStateStreamResponse = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.inserted !== void 0) {
        QueryLayerStateResponse.encode(message.inserted, writer.uint32(10).fork()).ldelim();
      }
      if (message.updated !== void 0) {
        QueryLayerStateResponse.encode(message.updated, writer.uint32(18).fork()).ldelim();
      }
      if (message.deleted !== void 0) {
        QueryLayerStateResponse.encode(message.deleted, writer.uint32(26).fork()).ldelim();
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseQueryLayerStateStreamResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.inserted = QueryLayerStateResponse.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.updated = QueryLayerStateResponse.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag != 26) {
              break;
            }
            message.deleted = QueryLayerStateResponse.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return QueryLayerStateStreamResponse.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseQueryLayerStateStreamResponse();
      message.inserted = object2.inserted !== void 0 && object2.inserted !== null ? QueryLayerStateResponse.fromPartial(object2.inserted) : void 0;
      message.updated = object2.updated !== void 0 && object2.updated !== null ? QueryLayerStateResponse.fromPartial(object2.updated) : void 0;
      message.deleted = object2.deleted !== void 0 && object2.deleted !== null ? QueryLayerStateResponse.fromPartial(object2.deleted) : void 0;
      return message;
    }
  };
  function createBaseNamespace() {
    return { chainId: "", worldAddress: "" };
  }
  var Namespace = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.chainId !== "") {
        writer.uint32(10).string(message.chainId);
      }
      if (message.worldAddress !== "") {
        writer.uint32(18).string(message.worldAddress);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseNamespace();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.chainId = reader.string();
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.worldAddress = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return Namespace.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseNamespace();
      message.chainId = object2.chainId ?? "";
      message.worldAddress = object2.worldAddress ?? "";
      return message;
    }
  };
  function createBaseStateRequest() {
    return { namespace: void 0, worldTables: [], chainTables: [] };
  }
  var StateRequest = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.namespace !== void 0) {
        Namespace.encode(message.namespace, writer.uint32(10).fork()).ldelim();
      }
      for (const v7 of message.worldTables) {
        writer.uint32(18).string(v7);
      }
      for (const v7 of message.chainTables) {
        writer.uint32(26).string(v7);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseStateRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.namespace = Namespace.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.worldTables.push(reader.string());
            continue;
          case 3:
            if (tag != 26) {
              break;
            }
            message.chainTables.push(reader.string());
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return StateRequest.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseStateRequest();
      message.namespace = object2.namespace !== void 0 && object2.namespace !== null ? Namespace.fromPartial(object2.namespace) : void 0;
      message.worldTables = object2.worldTables?.map((e) => e) || [];
      message.chainTables = object2.chainTables?.map((e) => e) || [];
      return message;
    }
  };
  function createBaseSingleStateRequest() {
    return { namespace: void 0, table: "", filter: [], project: [] };
  }
  var SingleStateRequest = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.namespace !== void 0) {
        Namespace.encode(message.namespace, writer.uint32(10).fork()).ldelim();
      }
      if (message.table !== "") {
        writer.uint32(18).string(message.table);
      }
      for (const v7 of message.filter) {
        Filter.encode(v7, writer.uint32(26).fork()).ldelim();
      }
      for (const v7 of message.project) {
        ProjectedField.encode(v7, writer.uint32(34).fork()).ldelim();
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSingleStateRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.namespace = Namespace.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.table = reader.string();
            continue;
          case 3:
            if (tag != 26) {
              break;
            }
            message.filter.push(Filter.decode(reader, reader.uint32()));
            continue;
          case 4:
            if (tag != 34) {
              break;
            }
            message.project.push(ProjectedField.decode(reader, reader.uint32()));
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return SingleStateRequest.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseSingleStateRequest();
      message.namespace = object2.namespace !== void 0 && object2.namespace !== null ? Namespace.fromPartial(object2.namespace) : void 0;
      message.table = object2.table ?? "";
      message.filter = object2.filter?.map((e) => Filter.fromPartial(e)) || [];
      message.project = object2.project?.map((e) => ProjectedField.fromPartial(e)) || [];
      return message;
    }
  };
  function createBaseField() {
    return { tableName: "", tableField: "" };
  }
  var Field = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.tableName !== "") {
        writer.uint32(10).string(message.tableName);
      }
      if (message.tableField !== "") {
        writer.uint32(18).string(message.tableField);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseField();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.tableName = reader.string();
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.tableField = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return Field.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseField();
      message.tableName = object2.tableName ?? "";
      message.tableField = object2.tableField ?? "";
      return message;
    }
  };
  function createBaseProjectedField() {
    return { field: void 0, rename: void 0 };
  }
  var ProjectedField = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.field !== void 0) {
        Field.encode(message.field, writer.uint32(10).fork()).ldelim();
      }
      if (message.rename !== void 0) {
        writer.uint32(18).string(message.rename);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseProjectedField();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.field = Field.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.rename = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return ProjectedField.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseProjectedField();
      message.field = object2.field !== void 0 && object2.field !== null ? Field.fromPartial(object2.field) : void 0;
      message.rename = object2.rename ?? void 0;
      return message;
    }
  };
  function createBaseFilter() {
    return { field: void 0, operator: "", value: "", function: "" };
  }
  var Filter = {
    encode(message, writer = import_minimal.default.Writer.create()) {
      if (message.field !== void 0) {
        Field.encode(message.field, writer.uint32(10).fork()).ldelim();
      }
      if (message.operator !== "") {
        writer.uint32(18).string(message.operator);
      }
      if (message.value !== "") {
        writer.uint32(26).string(message.value);
      }
      if (message.function !== "") {
        writer.uint32(34).string(message.function);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal.default.Reader ? input : import_minimal.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseFilter();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.field = Field.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.operator = reader.string();
            continue;
          case 3:
            if (tag != 26) {
              break;
            }
            message.value = reader.string();
            continue;
          case 4:
            if (tag != 34) {
              break;
            }
            message.function = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return Filter.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseFilter();
      message.field = object2.field !== void 0 && object2.field !== null ? Field.fromPartial(object2.field) : void 0;
      message.operator = object2.operator ?? "";
      message.value = object2.value ?? "";
      message.function = object2.function ?? "";
      return message;
    }
  };
  var QueryLayerDefinition = {
    name: "QueryLayer",
    fullName: "mode.QueryLayer",
    methods: {
      /** Get state endpoint. */
      getState: {
        name: "GetState",
        requestType: StateRequest,
        requestStream: false,
        responseType: QueryLayerStateResponse,
        responseStream: false,
        options: {}
      },
      /** Stream state endpoint. */
      streamState: {
        name: "StreamState",
        requestType: StateRequest,
        requestStream: false,
        responseType: QueryLayerStateStreamResponse,
        responseStream: true,
        options: {}
      },
      /** Get state from single table endpoint. */
      single__GetState: {
        name: "Single__GetState",
        requestType: SingleStateRequest,
        requestStream: false,
        responseType: QueryLayerStateResponse,
        responseStream: false,
        options: {}
      },
      /** Stream state from single table endpoint. */
      single__StreamState: {
        name: "Single__StreamState",
        requestType: SingleStateRequest,
        requestStream: false,
        responseType: QueryLayerStateStreamResponse,
        responseStream: true,
        options: {}
      }
    }
  };

  // node_modules/@latticexyz/network/dist/chunk-34B3FIL2.js
  var import_nice_grpc_web = __toESM(require_lib31(), 1);
  var import_lodash = __toESM(require_lodash(), 1);
  var import_debug2 = __toESM(require_browser(), 1);
  var V2 = ((o3) => (o3.SystemCall = "SystemCall", o3.NetworkComponentUpdate = "NetworkComponentUpdate", o3))(V2 || {});
  function Mo(e) {
    return e.type === "SystemCall";
  }
  function ae(e) {
    return e.type === "NetworkComponentUpdate";
  }
  var dt = ((u3) => (u3[u3.BOOL = 0] = "BOOL", u3[u3.INT8 = 1] = "INT8", u3[u3.INT16 = 2] = "INT16", u3[u3.INT32 = 3] = "INT32", u3[u3.INT64 = 4] = "INT64", u3[u3.INT128 = 5] = "INT128", u3[u3.INT256 = 6] = "INT256", u3[u3.INT = 7] = "INT", u3[u3.UINT8 = 8] = "UINT8", u3[u3.UINT16 = 9] = "UINT16", u3[u3.UINT32 = 10] = "UINT32", u3[u3.UINT64 = 11] = "UINT64", u3[u3.UINT128 = 12] = "UINT128", u3[u3.UINT256 = 13] = "UINT256", u3[u3.BYTES = 14] = "BYTES", u3[u3.STRING = 15] = "STRING", u3[u3.ADDRESS = 16] = "ADDRESS", u3[u3.BYTES4 = 17] = "BYTES4", u3[u3.BOOL_ARRAY = 18] = "BOOL_ARRAY", u3[u3.INT8_ARRAY = 19] = "INT8_ARRAY", u3[u3.INT16_ARRAY = 20] = "INT16_ARRAY", u3[u3.INT32_ARRAY = 21] = "INT32_ARRAY", u3[u3.INT64_ARRAY = 22] = "INT64_ARRAY", u3[u3.INT128_ARRAY = 23] = "INT128_ARRAY", u3[u3.INT256_ARRAY = 24] = "INT256_ARRAY", u3[u3.INT_ARRAY = 25] = "INT_ARRAY", u3[u3.UINT8_ARRAY = 26] = "UINT8_ARRAY", u3[u3.UINT16_ARRAY = 27] = "UINT16_ARRAY", u3[u3.UINT32_ARRAY = 28] = "UINT32_ARRAY", u3[u3.UINT64_ARRAY = 29] = "UINT64_ARRAY", u3[u3.UINT128_ARRAY = 30] = "UINT128_ARRAY", u3[u3.UINT256_ARRAY = 31] = "UINT256_ARRAY", u3[u3.BYTES_ARRAY = 32] = "BYTES_ARRAY", u3[u3.STRING_ARRAY = 33] = "STRING_ARRAY", u3))(dt || {});
  var Ko = { [0]: "bool", [1]: "int8", [2]: "int16", [3]: "int32", [4]: "int64", [5]: "int128", [6]: "int256", [7]: "int", [8]: "uint8", [9]: "uint16", [10]: "uint32", [11]: "uint64", [12]: "uint128", [13]: "uint256", [14]: "bytes", [15]: "string", [16]: "address", [17]: "bytes4", [18]: "bool[]", [19]: "int8[]", [20]: "int16[]", [21]: "int32[]", [22]: "int64[]", [23]: "int128[]", [24]: "int256[]", [25]: "int[]", [26]: "uint8[]", [27]: "uint16[]", [28]: "uint32[]", [29]: "uint64[]", [30]: "uint128[]", [31]: "uint256[]", [32]: "bytes[]", [33]: "string[]" };
  async function ye(e, t3) {
    await Ir(() => Promise.all([e.getBlockNumber(), t3 ? t3.getBlockNumber() : Promise.resolve()]), [], 10, 1e3);
  }
  async function on(e, t3) {
    for (let o3 of wr(10)) {
      let a2 = await Ir(async () => {
        let c3 = await e.perform("getBlock", { includeTransactions: false, blockTag: e.formatter.blockTag(await e._getBlockTag("latest")) });
        return e.formatter.block(c3);
      }, [], 10, 1e3);
      if (t3 && a2.number < t3) {
        await R(300);
        continue;
      } else
        return a2;
    }
    throw new Error("Could not fetch a block with blockNumber " + t3);
  }
  async function rn(e, t3) {
    let o3 = await t3.getTransaction(e);
    o3.gasPrice = void 0;
    let n4 = await t3.call(o3);
    return import_utils21.defaultAbiCoder.decode(["string"], Zr(n4))[0];
  }
  var X = class extends JsonRpcProvider {
    constructor(t3, o3) {
      super(t3, o3);
    }
    async detectNetwork() {
      let t3 = this.network;
      if (t3 == null)
        throw new Error("No network");
      return t3;
    }
  };
  var Z2 = class extends JsonRpcBatchProvider {
    constructor(t3, o3) {
      super(t3, o3);
    }
    async detectNetwork() {
      let t3 = this.network;
      if (t3 == null)
        throw new Error("No network");
      return t3;
    }
  };
  function wt({ chainId: e, jsonRpcUrl: t3, wsRpcUrl: o3, externalProvider: n4, options: a2 }) {
    let c3 = { chainId: e, name: "mudChain" }, r2 = n4 ? { json: new Web3Provider(n4, c3), ws: void 0 } : { json: a2?.batch ? new Z2(t3, c3) : new X(t3, c3), ws: o3 ? new WebSocketProvider(o3, c3) : void 0 };
    return a2?.pollingInterval && (r2.json.pollingInterval = a2.pollingInterval), r2;
  }
  var xt = ((n4) => (n4[n4.DISCONNECTED = 0] = "DISCONNECTED", n4[n4.CONNECTING = 1] = "CONNECTING", n4[n4.CONNECTED = 2] = "CONNECTED", n4))(xt || {});
  async function ke(e) {
    let t3 = observable.box(0), o3 = observable.box(), n4 = [];
    async function a2() {
      if (t3.get() === 1)
        return;
      runInAction(() => t3.set(1));
      let r2 = o3.get();
      r2?.json.removeAllListeners(), r2?.ws?.removeAllListeners();
      try {
        r2?.ws?._websocket?.close();
      } catch {
      }
      let d6 = e.get();
      await Ir(async () => {
        let l4 = wt(d6);
        !d6?.options?.skipNetworkCheck && await ye(l4.json, l4.ws), runInAction(() => {
          o3.set(l4), t3.set(2);
        });
      });
    }
    n4.push(reaction(() => e.get(), () => a2())), n4.push(reaction(() => o3.get(), (r2) => {
      r2?.ws?._websocket && (r2.ws._websocket.onerror = a2, r2.ws._websocket.onclose = () => {
        t3.get() === 2 && a2();
      });
    }));
    let c3 = setInterval(async () => {
      if (t3.get() !== 2)
        return;
      let r2 = o3.get();
      if (r2?.ws)
        try {
          await Cr(r2.ws.getBlockNumber(), 1e4, "Network Request Timed out");
        } catch {
          a2();
        }
    }, 1e4);
    return n4.push(() => clearInterval(c3)), await a2(), { connected: mr(t3), providers: mr(o3), dispose: () => {
      for (let r2 of n4)
        r2();
      try {
        o3.get()?.ws?._websocket?.close();
      } catch {
      }
    } };
  }
  function we2(e, t3) {
    let o3 = new ReplaySubject(1), n4 = t3?.initialSync ? o3.pipe(take(1), filter((r2) => r2 > (t3.initialSync.initialBlockNumber || 0)), concatMap((r2) => {
      let d6 = r2 - t3.initialSync.initialBlockNumber;
      return range(0, Math.ceil(d6 / t3.initialSync.interval)).pipe(map2((l4) => t3.initialSync.initialBlockNumber + l4 * t3.initialSync.interval), endWith(r2));
    }), lr(50)) : EMPTY, a2 = reaction(() => e.get(), (r2) => {
      let d6 = r2?.ws || r2?.json, l4 = true;
      d6?.getBlockNumber().then((i4) => {
        l4 && o3.next(i4);
      }), d6?.on("block", (i4) => {
        l4 = false, o3.next(i4);
      });
    }, { fireImmediately: true });
    return { blockNumber$: concat(n4, o3), dispose: a2 };
  }
  var G2 = new Subject();
  var xn = new Subject();
  var En = new BehaviorSubject(null);
  var vn = new BehaviorSubject(null);
  var se = new BehaviorSubject(null);
  var Ee = new BehaviorSubject(null);
  var $t = self.indexedDB;
  var Ft = 2;
  function Mt(e, t3) {
    e.objectStoreNames.contains(t3) || e.createObjectStore(t3);
  }
  function Kt(e, t3, o3 = Ft, n4 = $t) {
    let [a2, c3, r2] = d(), d6 = n4.open(e, o3);
    return d6.onupgradeneeded = () => {
      let l4 = d6.result;
      for (let i4 of t3)
        Mt(l4, i4);
    }, d6.onsuccess = () => {
      let l4 = d6.result;
      a2(l4);
    }, d6.onerror = (l4) => {
      c3(new Error(JSON.stringify(l4)));
    }, r2;
  }
  async function Ae(e, t3, o3, n4) {
    let a2 = await Kt(e, t3, o3, n4);
    function c3(f5) {
      return a2.transaction(f5, "readwrite").objectStore(f5);
    }
    function r2(f5, g5, S3, b4 = false) {
      let h6 = c3(f5).put(S3, g5);
      if (b4)
        return;
      let [T4, I4, k3] = d();
      return h6.onerror = (R4) => {
        I4(new Error(JSON.stringify(R4)));
      }, h6.onsuccess = () => {
        T4();
      }, k3;
    }
    function d6(f5, g5) {
      let [S3, b4, N2] = d(), T4 = c3(f5).get(g5);
      return T4.onerror = (I4) => {
        b4(new Error(JSON.stringify(I4)));
      }, T4.onsuccess = () => {
        let I4 = T4.result;
        S3(I4);
      }, N2;
    }
    function l4(f5, g5) {
      let [S3, b4, N2] = d(), T4 = c3(f5).delete(g5);
      return T4.onerror = (I4) => {
        b4(new Error(JSON.stringify(I4)));
      }, T4.onsuccess = () => {
        S3();
      }, N2;
    }
    function i4(f5) {
      let [g5, S3, b4] = d(), h6 = c3(f5).getAllKeys();
      return h6.onerror = (T4) => {
        S3(new Error(JSON.stringify(T4)));
      }, h6.onsuccess = () => {
        let T4 = Or(h6.result), I4 = v(T4, (k3) => k3.toString());
        g5(I4);
      }, b4;
    }
    function m5(f5) {
      let [g5, S3, b4] = d(), h6 = c3(f5).getAll();
      return h6.onerror = (T4) => {
        S3(new Error(JSON.stringify(T4)));
      }, h6.onsuccess = () => {
        g5(Or(h6.result));
      }, b4;
    }
    async function p2(f5) {
      let [g5, S3] = await Promise.all([i4(f5), m5(f5)]);
      return kr(g5, S3);
    }
    return { set: r2, get: d6, remove: l4, keys: i4, values: m5, entries: p2, db: a2 };
  }
  var Ue = (0, import_debug.default)("mud:network");
  var te = Ue.extend("workers");
  var Wt = te.extend("CacheStore");
  function zt(e, t3, o3) {
    return `${e}-${t3}-${o3}`;
  }
  function _16() {
    let e = [], t3 = /* @__PURE__ */ new Map(), o3 = [], n4 = /* @__PURE__ */ new Map(), a2 = 0, c3 = /* @__PURE__ */ new Map(), r2 = new Subject();
    return { components: e, componentToIndex: t3, entities: o3, entityToIndex: n4, blockNumber: a2, state: c3, componentUpdate$: r2, keys: {}, tables: {} };
  }
  function $2(e, { component: t3, entity: o3, value: n4, partialValue: a2, initialValue: c3, blockNumber: r2, key: d6, namespace: l4, table: i4 }) {
    let m5 = f2(o3), { components: p2, entities: f5, componentToIndex: g5, entityToIndex: S3, state: b4, keys: N2, tables: h6 } = e, T4 = g5.get(t3);
    T4 == null && (T4 = p2.push(t3) - 1, g5.set(t3, T4));
    let I4 = S3.get(m5);
    I4 == null && (I4 = f5.push(m5) - 1, S3.set(m5, I4)), d6 && (N2[I4] = d6), l4 != null && i4 != null && (h6[T4] = { namespace: l4, table: i4 });
    let k3 = Wr([T4, I4]);
    if (a2 !== void 0) {
      let R4 = b4.get(k3);
      b4.set(k3, { ...c3, ...R4, ...a2 });
    } else
      n4 === void 0 ? (console.log("deleting key", k3), b4.delete(k3)) : b4.set(k3, n4);
    e.blockNumber = r2 - 1, e.componentUpdate$.next({ component: t3, entity: o3, blockNumber: r2 });
  }
  function ce(e, t3) {
    for (let o3 of t3)
      $2(e, o3);
  }
  function ie({ blockNumber: e, state: t3, components: o3, entities: n4, keys: a2, tables: c3 }) {
    return v(t3.entries(), ([r2, d6]) => {
      let [l4, i4] = Jr(r2), m5 = o3[l4], p2 = n4[i4], f5 = a2[i4], { namespace: g5, table: S3 } = c3[l4];
      if (m5 == null || p2 == null)
        throw new Error(`Unknown component / entity: ${m5}, ${p2}`);
      return { type: "NetworkComponentUpdate", component: m5, entity: p2, value: d6, namespace: g5, table: S3, key: f5, lastEventInTx: false, txHash: "cache", blockNumber: e };
    });
  }
  async function me(e, t3) {
    Wt("store cache with size", t3.state.size, "at block", t3.blockNumber), await e.set("ComponentValues", "current", t3.state), await e.set("Mappings", "components", t3.components), await e.set("Mappings", "entities", t3.entities), await e.set("BlockNumber", "current", t3.blockNumber), await e.set("Keys", "current", t3.keys), await e.set("Tables", "current", t3.tables);
  }
  async function Ye(e) {
    let t3 = await e.get("ComponentValues", "current") ?? /* @__PURE__ */ new Map(), o3 = await e.get("BlockNumber", "current") ?? 0, n4 = await e.get("Mappings", "components") ?? [], a2 = await e.get("Mappings", "entities") ?? [], c3 = await e.get("Keys", "current") ?? {}, r2 = await e.get("Tables", "current") ?? {}, d6 = /* @__PURE__ */ new Map(), l4 = /* @__PURE__ */ new Map(), i4 = new Subject();
    for (let m5 = 0; m5 < n4.length; m5++)
      d6.set(n4[m5], m5);
    for (let m5 = 0; m5 < a2.length; m5++)
      l4.set(a2[m5], m5);
    return { state: t3, blockNumber: o3, components: n4, entities: a2, componentToIndex: d6, entityToIndex: l4, componentUpdate$: i4, keys: c3, tables: r2 };
  }
  async function Le(e) {
    return await e.get("BlockNumber", "current") ?? 0;
  }
  function De(e, t3, o3, n4) {
    return Ae(zt("ECSCache", e, t3), ["ComponentValues", "BlockNumber", "Mappings", "Snapshot", "Keys", "Tables"], o3, n4);
  }
  var Pe = ((n4) => (n4[n4.CONNECTING = 0] = "CONNECTING", n4[n4.INITIAL = 1] = "INITIAL", n4[n4.LIVE = 2] = "LIVE", n4))(Pe || {});
  var J = "0x060d";
  var oe = new f("mudstore", "schema");
  var B2 = new f("mudstore", "StoreMetadata");
  var Oe2 = ["StoreSetRecord", "StoreSetField", "StoreDeleteRecord"];
  var _e = ["StoreEphemeralRecord"];
  function le(e) {
    let t3 = !e || e === "0x", o3 = t3 ? new Uint8Array(64).buffer : V(e).buffer, n4 = new DataView(o3), a2 = new DataView(o3.slice(32)), c3 = { ...$e(n4), rawSchema: e, isEmpty: t3 }, r2 = { ...$e(a2), rawSchema: e, isEmpty: t3 };
    return { valueSchema: c3, keySchema: r2 };
  }
  function $e(e) {
    let t3 = e.getUint16(0), o3 = e.getUint8(2), n4 = e.getUint8(3), a2 = [], c3 = [];
    for (let i4 = 4; i4 < 4 + o3; i4++)
      a2.push(e.getUint8(i4));
    for (let i4 = 4 + o3; i4 < 4 + o3 + n4; i4++)
      c3.push(e.getUint8(i4));
    let r2 = a2.reduce((i4, m5) => i4 + n(m5), 0);
    if (r2 !== t3)
      throw console.error("Schema static data length mismatch! Is `getStaticByteLength` outdated?", { schemaStaticDataLength: t3, actualStaticDataLength: r2, schemaBytes: e }), new Error("Schema static data length mismatch! Is `getStaticByteLength` outdated?");
    let l4 = `(${[...a2, ...c3].map((i4) => Y[i4]).join(",")})`;
    return { staticDataLength: t3, staticFields: a2, dynamicFields: c3, abi: l4 };
  }
  var de2 = {};
  function x2(e, t3, o3) {
    let n4 = `${e.address}:${t3.toHexString()}`, a2 = de2[n4];
    if (a2)
      return o3 && a2.then((m5) => {
        m5.valueSchema.rawSchema !== o3 && console.warn("a different schema was already registered for this table", { table: t3, currentSchema: m5, newSchema: o3, world: e.address });
      }), a2;
    if (o3) {
      console.log("registering schema for table", { table: t3.toString(), world: e.address, rawSchema: o3 });
      let m5 = Promise.resolve(le(o3));
      return de2[n4] = m5, m5;
    }
    console.log("fetching schema for table", { table: t3.toString(), world: e.address });
    let c3 = e, r2 = c3.getKeySchema(t3.toHexString()), d6 = c3.getSchema(t3.toHexString()), i4 = Promise.all([r2, d6]).then(([m5, p2]) => p2 + m5.substring(2)).then((m5) => {
      let p2 = le(m5);
      return p2.valueSchema.isEmpty && console.warn("Schema not found for table", { table: t3.toString(), world: e.address }), p2;
    });
    return de2[n4] = i4, i4;
  }
  var oo = (e) => {
    throw new Error(`Unsupported static field type: ${I2[e] ?? e}`);
  };
  var E2 = (e, t3, o3) => {
    let n4 = n(e), a2 = t3.slice(o3, o3 + n4), c3 = toHex(a2), r2 = c3.replace(/^0x$/, "0x0");
    switch (e) {
      case I2.BOOL:
        return Number(r2) !== 0;
      case I2.UINT8:
      case I2.UINT16:
      case I2.UINT24:
      case I2.UINT32:
      case I2.UINT40:
      case I2.UINT48:
        return Number(r2);
      case I2.UINT56:
      case I2.UINT64:
      case I2.UINT72:
      case I2.UINT80:
      case I2.UINT88:
      case I2.UINT96:
      case I2.UINT104:
      case I2.UINT112:
      case I2.UINT120:
      case I2.UINT128:
      case I2.UINT136:
      case I2.UINT144:
      case I2.UINT152:
      case I2.UINT160:
      case I2.UINT168:
      case I2.UINT176:
      case I2.UINT184:
      case I2.UINT192:
      case I2.UINT200:
      case I2.UINT208:
      case I2.UINT216:
      case I2.UINT224:
      case I2.UINT232:
      case I2.UINT240:
      case I2.UINT248:
      case I2.UINT256:
        return BigInt(r2);
      case I2.INT8:
      case I2.INT16:
      case I2.INT24:
      case I2.INT32:
      case I2.INT40:
      case I2.INT48: {
        let d6 = 2 ** (n4 * 8), l4 = Number(r2);
        return l4 < d6 / 2 ? l4 : l4 - d6;
      }
      case I2.INT56:
      case I2.INT64:
      case I2.INT72:
      case I2.INT80:
      case I2.INT88:
      case I2.INT96:
      case I2.INT104:
      case I2.INT112:
      case I2.INT120:
      case I2.INT128:
      case I2.INT136:
      case I2.INT144:
      case I2.INT152:
      case I2.INT160:
      case I2.INT168:
      case I2.INT176:
      case I2.INT184:
      case I2.INT192:
      case I2.INT200:
      case I2.INT208:
      case I2.INT216:
      case I2.INT224:
      case I2.INT232:
      case I2.INT240:
      case I2.INT248:
      case I2.INT256: {
        let d6 = 2n ** (BigInt(n4) * 8n), l4 = BigInt(r2);
        return l4 < d6 / 2n ? l4 : l4 - d6;
      }
      case I2.BYTES1:
      case I2.BYTES2:
      case I2.BYTES3:
      case I2.BYTES4:
      case I2.BYTES5:
      case I2.BYTES6:
      case I2.BYTES7:
      case I2.BYTES8:
      case I2.BYTES9:
      case I2.BYTES10:
      case I2.BYTES11:
      case I2.BYTES12:
      case I2.BYTES13:
      case I2.BYTES14:
      case I2.BYTES15:
      case I2.BYTES16:
      case I2.BYTES17:
      case I2.BYTES18:
      case I2.BYTES19:
      case I2.BYTES20:
      case I2.BYTES21:
      case I2.BYTES22:
      case I2.BYTES23:
      case I2.BYTES24:
      case I2.BYTES25:
      case I2.BYTES26:
      case I2.BYTES27:
      case I2.BYTES28:
      case I2.BYTES29:
      case I2.BYTES30:
      case I2.BYTES31:
      case I2.BYTES32:
      case I2.ADDRESS:
        return pad(c3, { dir: "right", size: n4 });
      default:
        return oo(e);
    }
  };
  var co = (e) => {
    throw new Error(`Unsupported dynamic field type: ${I2[e] ?? e}`);
  };
  var Y2 = (e, t3) => {
    if (e === I2.BYTES)
      return toHex(t3);
    if (e === I2.STRING)
      return bytesToString(t3);
    let o3 = u[e];
    if (o3 !== void 0) {
      let n4 = n(o3), a2 = t3.byteLength / n4;
      return new Array(a2).fill(void 0).map((c3, r2) => E2(o3, t3, r2 * n4));
    }
    return co(e);
  };
  var ne2 = (e, t3) => {
    let o3 = {}, n4 = V(t3), a2 = 0;
    e.staticFields.forEach((r2, d6) => {
      let l4 = E2(r2, n4, a2);
      a2 += n(r2), o3[d6] = l4;
    });
    let c3 = a2;
    if (c3 !== e.staticDataLength && console.warn("Decoded static data length does not match schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?", { expectedLength: e.staticDataLength, actualLength: c3, bytesOffset: a2, schema: e, hexData: t3 }), e.dynamicFields.length > 0) {
      let r2 = n4.slice(e.staticDataLength, e.staticDataLength + 32);
      a2 += 32;
      let d6 = I2.UINT56, l4 = I2.UINT40, i4 = E2(d6, r2, 0);
      e.dynamicFields.forEach((p2, f5) => {
        let g5 = E2(l4, r2, n(d6) + f5 * n(l4)), S3 = Y2(p2, n4.slice(a2, a2 + g5));
        a2 += g5, o3[e.staticFields.length + f5] = S3;
      });
      let m5 = a2 - 32 - c3;
      BigInt(m5) !== i4 && console.warn("Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?", { expectedLength: i4, actualLength: m5, bytesOffset: a2, schema: e, hexData: t3 });
    }
    return o3;
  };
  var fe = {};
  function L2(e, t3, o3) {
    let n4 = `${e.address}:${t3.toHexString()}`, a2 = fe[n4];
    if (a2)
      return o3 && a2.then((r2) => {
        JSON.stringify(r2) !== JSON.stringify(o3) && console.warn("different metadata already registered for this table", { table: t3, currentMetadata: r2, newMetadata: o3, world: e.address });
      }), a2;
    if (o3) {
      console.log("registering metadata for table", { table: t3.toString(), metadata: o3, world: e.address });
      let r2 = Promise.resolve(o3);
      return fe[n4] = r2, r2;
    }
    if (t3.toHexString() === oe.toHexString() || t3.toHexString() === B2.toHexString())
      return Promise.resolve(void 0);
    console.log("fetching metadata for table", { table: t3.toString(), world: e.address });
    let c3 = Promise.all([x2(e, B2), e["getRecord(bytes32,bytes32[])"](B2.toHexString(), [t3.toHexString()])]).then(([{ valueSchema: r2 }, d6]) => {
      r2.isEmpty && console.warn("Metadata schema not found", { table: B2.toString(), world: e.address }), (!d6 || d6 === "0x") && console.warn("Metadata not found for table", { table: t3.toString(), world: e.address });
      let l4 = ne2(r2, d6), i4 = l4[0];
      i4 !== t3.name && console.warn("Metadata table name does not match table ID", { tableName: i4, tableId: t3.toString(), world: e.address });
      let [m5] = utils_exports.defaultAbiCoder.decode(["string[]"], l4[1]);
      return { tableName: i4, fieldNames: m5 };
    });
    return fe[n4] = c3, c3;
  }
  function F3(e, t3) {
    let o3 = e.staticFields.map((a2) => Y[a2]);
    return t3.map((a2, c3) => decodeAbiParameters([{ type: o3[c3] }], a2)[0]).reduce((a2, c3, r2) => ({ ...a2, [r2]: c3 }), {});
  }
  async function W3(e, t3, o3, n4) {
    if (t3.toHexString() === oe.toHexString()) {
      let [i4, ...m5] = o3;
      m5.length && console.warn("registerSchema event has more than one value in key tuple, but this method only supports a single key", { table: t3, keyTuple: o3 }), x2(e, f.fromBytes32(utils_exports.arrayify(i4)), n4);
    }
    let { keySchema: a2, valueSchema: c3 } = await x2(e, t3), r2 = ne2(c3, n4), d6 = F3(a2, o3);
    if (t3.toHexString() === B2.toHexString()) {
      let [i4, ...m5] = o3;
      m5.length && console.warn("setMetadata event has more than one value in key tuple, but this method only supports a single key", { table: t3, keyTuple: o3 });
      let p2 = r2[0], [f5] = utils_exports.defaultAbiCoder.decode(["string[]"], r2[1]);
      L2(e, f.fromBytes32(utils_exports.arrayify(i4)), { tableName: p2, fieldNames: f5 });
    }
    let l4 = await L2(e, t3);
    if (l4) {
      let { tableName: i4, fieldNames: m5 } = l4, p2 = {};
      for (let [f5, g5] of m5.entries())
        p2[g5] = r2[f5];
      return { indexedValues: r2, namedValues: p2, indexedKey: d6 };
    }
    return console.warn(`Received data for ${t3.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`), { indexedValues: r2, indexedKey: d6 };
  }
  var Ke = (e, t3, o3) => {
    let n4 = {}, a2 = V(o3);
    return e.staticFields.forEach((c3, r2) => {
      r2 === t3 && (n4[t3] = E2(c3, a2, 0));
    }), e.dynamicFields.length > 0 && e.dynamicFields.forEach((c3, r2) => {
      e.staticFields.length + r2 === t3 && (n4[t3] = Y2(c3, a2));
    }), n4;
  };
  async function je2(e, t3, o3, n4, a2) {
    let c3 = await x2(e, t3), { valueSchema: r2, keySchema: d6 } = c3, l4 = Ke(r2, n4, a2), i4 = F3(d6, o3), m5 = [...r2.staticFields.map((g5) => E2(g5, new Uint8Array(0), 0)), ...r2.dynamicFields.map((g5) => Y2(g5, new Uint8Array(0)))], p2 = Object.fromEntries(m5.map((g5, S3) => [S3, g5])), f5 = await L2(e, t3);
    if (f5) {
      let { tableName: g5, fieldNames: S3 } = f5, b4 = Object.fromEntries(m5.map((N2, h6) => [S3[h6], N2]));
      return { schema: c3, indexedValues: l4, indexedInitialValues: p2, namedValues: { [S3[n4]]: l4[n4] }, namedInitialValues: b4, indexedKey: i4 };
    }
    return console.warn(`Received data for ${t3.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`), { schema: c3, indexedValues: l4, indexedInitialValues: p2, indexedKey: i4 };
  }
  function M(e) {
    return e.length === 0 ? J : f2(e.join(":"));
  }
  var He = async (e, t3, o3, n4, a2) => {
    let { blockNumber: c3, transactionHash: r2, logIndex: d6 } = o3, { args: l4, name: i4 } = n4, m5 = f.fromBytes32(utils_exports.arrayify(l4.table)), p2 = m5.toString(), f5 = M(l4.key), g5 = { type: "NetworkComponentUpdate", component: p2, entity: f5, value: void 0, blockNumber: c3, txHash: r2, logIndex: d6, lastEventInTx: a2, namespace: m5.namespace, table: m5.name, key: {} };
    if (i4 === "StoreSetRecord") {
      let { indexedValues: S3, namedValues: b4, indexedKey: N2, namedKey: h6 } = await W3(t3, m5, l4.key, l4.data);
      return { ...g5, value: { ...S3, ...b4 }, key: { ...N2, ...h6 }, devEmit: () => {
        G2.next({ event: i4, chainId: e, worldAddress: t3.address, blockNumber: c3, logIndex: d6, transactionHash: r2, table: m5, keyTuple: l4.key, indexedValues: S3, namedValues: b4 });
      } };
    }
    if (i4 === "StoreEphemeralRecord") {
      let { indexedValues: S3, namedValues: b4, indexedKey: N2, namedKey: h6 } = await W3(t3, m5, l4.key, l4.data);
      return { ...g5, ephemeral: true, value: { ...S3, ...b4 }, key: { ...N2, ...h6 }, devEmit: () => {
        G2.next({ event: i4, chainId: e, worldAddress: t3.address, blockNumber: c3, logIndex: d6, transactionHash: r2, table: m5, keyTuple: l4.key, indexedValues: S3, namedValues: b4 });
      } };
    }
    if (i4 === "StoreSetField") {
      console.log("set field");
      let { indexedValues: S3, indexedInitialValues: b4, namedValues: N2, namedInitialValues: h6, indexedKey: T4, namedKey: I4 } = await je2(t3, m5, l4.key, l4.schemaIndex, l4.data);
      return { ...g5, partialValue: { ...S3, ...N2 }, initialValue: { ...b4, ...h6 }, key: { ...T4, ...I4 }, devEmit: () => {
        G2.next({ event: i4, chainId: e, worldAddress: t3.address, blockNumber: c3, logIndex: d6, transactionHash: r2, table: m5, keyTuple: l4.key, indexedValues: S3, namedValues: N2 });
      } };
    }
    if (i4 === "StoreDeleteRecord") {
      let { keySchema: S3 } = await x2(t3, m5), b4 = F3(S3, l4.key);
      return { ...g5, key: b4, devEmit: () => {
        G2.next({ event: i4, chainId: e, worldAddress: t3.address, blockNumber: c3, logIndex: d6, transactionHash: r2, table: m5, keyTuple: l4.key });
      } };
    }
  };
  async function We(e, t3, o3) {
    let { chainId: n4 } = await e.provider.getNetwork(), c3 = [...Oe2, ..._e].map((p2) => e.filters[p2]().topics).filter(Tt), r2 = await Promise.all(c3.map((p2) => e.provider.getLogs({ address: e.address, topics: p2, fromBlock: t3, toBlock: o3 }))), d6 = (0, import_orderBy.default)(r2.flatMap((p2) => p2.map((f5) => ({ log: f5, parsedLog: e.interface.parseLog(f5) }))), ["log.blockNumber", "log.logIndex"]), l4 = {};
    d6.map(({ log: p2 }) => {
      l4[p2.transactionHash] = p2.logIndex;
    });
    let i4 = await Promise.all(d6.map(({ log: p2, parsedLog: f5 }) => {
      let { transactionHash: g5, logIndex: S3 } = p2;
      return He(n4, e, p2, f5, l4[g5] === S3);
    })), m5 = (0, import_orderBy.default)(i4.filter(Tt), ["blockNumber", "logIndex"]);
    return m5.forEach((p2) => p2.devEmit()), m5;
  }
  function ze(e) {
    return (0, import_nice_grpc_web.createClient)(QueryLayerDefinition, (0, import_nice_grpc_web.createChannel)(e));
  }
  function z(e) {
    return JSON.parse(new TextDecoder().decode(e));
  }
  function re(e) {
    if (e.cols[1] !== "block_number")
      throw new Error("Table does not contain block_number column");
    return Number(z(e.rows[0].values[1]));
  }
  async function Ze(e, t3, o3, n4) {
    let a2 = _16(), c3 = await e.getState({ chainTables: [], worldTables: [], namespace: { chainId: t3.toString(), worldAddress: o3.address } });
    console.log("syncTablesFromMode", c3);
    let r2 = Object.values(c3.worldTables).reduce((m5, p2) => m5 + p2.rows.length, 0), d6 = 0, l4 = re(c3.chainTables.block_number), i4 = [];
    for (let [m5, { rows: p2, cols: f5, types: g5 }] of Object.entries(c3.worldTables)) {
      let [S3, b4] = m5.split("__"), N2 = new f(S3, b4), h6 = N2.toString(), T4 = f5.findIndex((C4) => !C4.startsWith("key_")), I4 = g5.slice(0, T4), k3 = I4.map((C4) => _15[C4]), R4 = q(o(k3)), D4 = f5.slice(T4), j3 = g5.slice(T4).map((C4) => C4.match(/tuple\((.*)\[]\)/)?.[1] ?? C4), v7 = j3.map((C4) => _15[C4]), H3 = q(o(v7)) + R4.substring(2);
      i4.push(x2(o3, N2, H3)), i4.push(L2(o3, N2, { tableName: b4, fieldNames: D4 }));
      for (let C4 of p2) {
        console.log(b4, I4, j3, C4.values);
        let P4 = C4.values.slice(0, T4).map((U7, u3) => z(U7)), y4 = C4.values.slice(T4).map((U7, u3) => z(U7)), A3 = P4.reduce((U7, u3, lt) => ({ ...U7, [lt]: u3 }), {}), it = M(P4), mt = Object.fromEntries(y4.map((U7, u3) => [D4[u3], U7]));
        $2(a2, { type: "NetworkComponentUpdate", component: h6, entity: it, key: A3, value: mt, blockNumber: l4, namespace: N2.namespace, table: N2.name }), d6++, d6 % 100 === 0 && n4 && n4(Math.floor(d6 / r2));
      }
      console.log("done syncing from mode table", b4);
    }
    return console.log("done syncing from mode", d6, "rows processed"), await Promise.all(i4), a2;
  }
  async function et(e, t3) {
    try {
      let o3 = await e.single__GetState({ table: "block_number", namespace: { chainId: t3.toString() } });
      return re(o3.chainTables.block_number);
    } catch (o3) {
      return console.error("MODE Error: ", o3), -1;
    }
  }
  async function tt(e, t3, o3) {
    let n4 = [];
    for (let a2 of t3) {
      let { tableId: c3, keyTuple: r2, value: d6 } = a2, { indexedValues: l4, namedValues: i4, indexedKey: m5, namedKey: p2 } = await W3(e, c3, r2, d6), f5 = { ...m5, ...p2 }, g5 = c3.toString(), S3 = M(r2), b4 = { type: "NetworkComponentUpdate", component: g5, entity: S3, key: f5, value: { ...l4, ...i4 }, lastEventInTx: false, txHash: "cache", blockNumber: o3, namespace: c3.namespace, table: c3.name };
      n4.push(b4);
    }
    return n4;
  }
  function rt(e, t3) {
    let o3;
    return e.pipe(map2(async (n4) => {
      let a2 = o3 == null || o3 >= n4 ? n4 : o3 + 1, c3 = n4;
      o3 = c3;
      let r2 = await t3(a2, c3), d6 = (0, import_lodash.orderBy)(r2, ["blockNumber", "logIndex"]);
      return (0, import_debug2.default)(`fetched ${d6.length} events from block range ${a2} -> ${c3}`), d6;
    }), ur(), concatMap((n4) => of(...n4)));
  }
  async function at(e, t3, o3, n4 = 50, a2) {
    let c3 = [], r2 = o3 - t3, d6 = Math.ceil(r2 / n4), l4 = [...wr(d6, n4, t3)];
    for (let i4 = 0; i4 < l4.length; i4++) {
      let m5 = l4[i4], p2 = i4 === l4.length - 1 ? o3 : l4[i4 + 1] - 1, f5 = await e(m5, p2);
      a2 && a2(i4 * n4 / r2 * 100), (0, import_debug2.default)(`initial sync fetched ${c3.length} events from block range ${m5} -> ${p2}`), c3 = c3.concat((0, import_lodash.orderBy)(f5, ["blockNumber", "logIndex"]));
    }
    return c3;
  }
  var K2 = te.extend("SyncWorker");
  var $o = 3;
  var Fo = ((o3) => (o3[o3.Ack = 0] = "Ack", o3[o3.Config = 1] = "Config", o3))(Fo || {});
  var Ss = { type: 0 };
  var ct = class {
    input$ = new Subject();
    output$ = new Subject();
    syncState = { state: 0, msg: "", percentage: 0 };
    constructor() {
      K2("creating SyncWorker"), this.init();
    }
    setLoadingState(t3, o3 = 0) {
      let n4 = { ...this.syncState, ...t3 };
      this.syncState = n4;
      let a2 = { type: "NetworkComponentUpdate", component: Fr("component.LoadingState"), value: n4, entity: J, key: {}, namespace: "mudsync", table: "LoadingState", txHash: "worker", lastEventInTx: false, blockNumber: o3 };
      this.output$.next(a2);
    }
    async init() {
      this.setLoadingState({ state: 0, msg: "Connecting...", percentage: 0 });
      let t3 = await dr(this.input$.pipe(map2((y4) => y4.type === 1 ? y4.data : void 0), de())), o3 = t3.get(), { modeUrl: n4, chainId: a2, worldContract: c3, disableCache: r2, initialRecords: d6 } = o3;
      Ee.next(c3.address);
      let l4 = o3.cacheAgeThreshold || 100, i4 = o3.cacheInterval || 1, { providers: m5 } = await ke(computed(() => t3.get().provider)), p2 = m5.get().json, f5 = n4 ? ze(n4) : void 0, g5 = await De(a2, c3.address, $o);
      K2("start initial sync"), this.setLoadingState({ state: 1, msg: "Starting initial sync", percentage: 0 });
      let S3 = false, b4 = { current: _16() };
      se.next(b4.current);
      let { blockNumber$: N2 } = we2(m5), h6 = new Contract(c3.address, IStore_abi_default, p2), T4 = (y4, A3) => We(h6, y4, A3), I4 = rt(N2, T4), k3 = [];
      I4.subscribe((y4) => {
        if (!S3) {
          ae(y4) && k3.push(y4);
          return;
        }
        ae(y4) && ($2(b4.current, y4), y4.blockNumber > b4.current.blockNumber + 1 && y4.blockNumber % i4 === 0 && me(g5, b4.current)), this.output$.next(y4);
      });
      let R4 = xe(N2);
      this.setLoadingState({ state: 1, msg: "Fetching cache block number", percentage: 0 });
      let D4 = r2 ? -1 : await Le(g5);
      this.setLoadingState({ percentage: 50 });
      let j3 = f5 ? await et(f5, a2) : -1, v7 = o3.initialBlockNumber;
      if (v7 < 0) {
        let y4 = await p2.getLogs({ address: c3.address, topics: [getEventSelector("event HelloWorld()")], fromBlock: "earliest" });
        v7 = y4.length > 0 ? y4[0].blockNumber : 0;
      }
      this.setLoadingState({ percentage: 100 }), K2(`cache block: ${D4}, start sync at ${v7}`);
      let w3 = _16();
      if (d6) {
        console.log("Initial state from pre-loaded records"), this.setLoadingState({ state: 1, msg: "Loading initial state", percentage: 0 });
        let y4 = await tt(h6, d6, v7);
        ce(w3, y4), w3.blockNumber = v7;
      } else if (v7 > Math.max(D4, j3))
        w3.blockNumber = v7;
      else {
        let y4 = f5 && j3 > D4 + l4;
        console.log("syncFromMode", y4), y4 ? (console.log("Initial sync from MODE"), this.setLoadingState({ state: 1, msg: "Fetching initial state from MODE", percentage: 0 }), w3 = await Ze(f5, a2, h6, (A3) => this.setLoadingState({ percentage: A3 })), this.setLoadingState({ percentage: 100 })) : r2 || (this.setLoadingState({ state: 1, msg: "Fetching initial state from cache", percentage: 0 }), w3 = await Ye(g5), this.setLoadingState({ percentage: 100 })), K2(`got ${w3.state.size} items from ${y4 ? "mode" : "cache"}`);
      }
      let H3 = await R4;
      this.setLoadingState({ state: 1, msg: `Fetching state from block ${w3.blockNumber} to ${H3}`, percentage: 0 });
      let C4 = await at(T4, w3.blockNumber, H3, 50, (y4) => this.setLoadingState({ percentage: y4 }));
      K2(`got ${C4.length} items from block range ${w3.blockNumber} -> ${H3}`), ce(w3, [...C4, ...k3].filter((y4) => !y4.ephemeral)), b4.current = w3, se.next(b4.current), K2(`initial sync state size: ${b4.current.state.size}`), this.setLoadingState({ state: 1, msg: `Initializing with ${b4.current.state.size} state entries`, percentage: 0 });
      let P4 = 0;
      for (let y4 of ie(b4.current))
        if (P4++, this.output$.next(y4), P4 % 5e3 === 0) {
          let A3 = Math.floor(P4 / b4.current.state.size * 100);
          this.setLoadingState({ percentage: A3 });
        }
      me(g5, b4.current), this.setLoadingState({ state: 2, msg: "Streaming live events", percentage: 100 }, b4.current.blockNumber), S3 = true;
    }
    work(t3) {
      t3.subscribe(this.input$);
      let o3 = new Subject();
      return this.output$.pipe(bufferTime(16, null, 50), filter((n4) => n4.length > 0), concatMap((n4) => concat(of(n4), t3.pipe(filter((a2) => a2.type === 0), take(1), ignoreElements())))).subscribe(o3), o3;
    }
  };

  // node_modules/@scure/bip32/lib/esm/index.js
  init_hmac();

  // node_modules/@noble/hashes/esm/ripemd160.js
  init_sha2();
  init_utils2();
  var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = Uint8Array.from({ length: 16 }, (_18, i4) => i4);
  var Pi = Id.map((i4) => (9 * i4 + 5) % 16);
  var idxL = [Id];
  var idxR = [Pi];
  for (let i4 = 0; i4 < 4; i4++)
    for (let j3 of [idxL, idxR])
      j3.push(j3[i4].map((k3) => Rho[k3]));
  var shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i4) => new Uint8Array(i4));
  var shiftsL = idxL.map((idx, i4) => idx.map((j3) => shifts[i4][j3]));
  var shiftsR = idxR.map((idx, i4) => idx.map((j3) => shifts[i4][j3]));
  var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
  var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
  var rotl = (word, shift2) => word << shift2 | word >>> 32 - shift2;
  function f3(group, x8, y4, z5) {
    if (group === 0)
      return x8 ^ y4 ^ z5;
    else if (group === 1)
      return x8 & y4 | ~x8 & z5;
    else if (group === 2)
      return (x8 | ~y4) ^ z5;
    else if (group === 3)
      return x8 & z5 | y4 & ~z5;
    else
      return x8 ^ (y4 | ~z5);
  }
  var BUF = new Uint32Array(16);
  var RIPEMD160 = class extends SHA2 {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
      return [h0, h1, h22, h32, h42];
    }
    set(h0, h1, h22, h32, h42) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h22 | 0;
      this.h3 = h32 | 0;
      this.h4 = h42 | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4)
        BUF[i4] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br3 = bl, cl = this.h2 | 0, cr2 = cl, dl = this.h3 | 0, dr2 = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl[group], hbr = Kr[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL[group], sr = shiftsR[group];
        for (let i4 = 0; i4 < 16; i4++) {
          const tl = rotl(al + f3(group, bl, cl, dl) + BUF[rl[i4]] + hbl, sl[i4]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i4 = 0; i4 < 16; i4++) {
          const tr = rotl(ar + f3(rGroup, br3, cr2, dr2) + BUF[rr[i4]] + hbr, sr[i4]) + er | 0;
          ar = er, er = dr2, dr2 = rotl(cr2, 10) | 0, cr2 = br3, br3 = tr;
        }
      }
      this.set(this.h1 + cl + dr2 | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br3 | 0, this.h0 + bl + cr2 | 0);
    }
    roundClean() {
      BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd1602 = wrapConstructor(() => new RIPEMD160());

  // node_modules/@scure/bip32/lib/esm/index.js
  init_sha256();

  // node_modules/@noble/hashes/esm/sha512.js
  init_sha2();
  init_u64();
  init_utils2();
  var [SHA512_Kh, SHA512_Kl] = u64_default.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n4) => BigInt(n4)));
  var SHA512_W_H = new Uint32Array(80);
  var SHA512_W_L = new Uint32Array(80);
  var SHA512 = class extends SHA2 {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4) {
        SHA512_W_H[i4] = view.getUint32(offset);
        SHA512_W_L[i4] = view.getUint32(offset += 4);
      }
      for (let i4 = 16; i4 < 80; i4++) {
        const W15h = SHA512_W_H[i4 - 15] | 0;
        const W15l = SHA512_W_L[i4 - 15] | 0;
        const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
        const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i4 - 2] | 0;
        const W2l = SHA512_W_L[i4 - 2] | 0;
        const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
        const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
        const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i4 - 7], SHA512_W_L[i4 - 16]);
        const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i4 - 7], SHA512_W_H[i4 - 16]);
        SHA512_W_H[i4] = SUMh | 0;
        SHA512_W_L[i4] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i4 = 0; i4 < 80; i4++) {
        const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
        const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i4], SHA512_W_L[i4]);
        const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i4], SHA512_W_H[i4]);
        const T1l = T1ll | 0;
        const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
        const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64_default.add3L(T1l, sigma0l, MAJl);
        Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var SHA512_224 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 2352822216 | 0;
      this.Al = 424955298 | 0;
      this.Bh = 1944164710 | 0;
      this.Bl = 2312950998 | 0;
      this.Ch = 502970286 | 0;
      this.Cl = 855612546 | 0;
      this.Dh = 1738396948 | 0;
      this.Dl = 1479516111 | 0;
      this.Eh = 258812777 | 0;
      this.El = 2077511080 | 0;
      this.Fh = 2011393907 | 0;
      this.Fl = 79989058 | 0;
      this.Gh = 1067287976 | 0;
      this.Gl = 1780299464 | 0;
      this.Hh = 286451373 | 0;
      this.Hl = 2446758561 | 0;
      this.outputLen = 28;
    }
  };
  var SHA512_256 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 573645204 | 0;
      this.Al = 4230739756 | 0;
      this.Bh = 2673172387 | 0;
      this.Bl = 3360449730 | 0;
      this.Ch = 596883563 | 0;
      this.Cl = 1867755857 | 0;
      this.Dh = 2520282905 | 0;
      this.Dl = 1497426621 | 0;
      this.Eh = 2519219938 | 0;
      this.El = 2827943907 | 0;
      this.Fh = 3193839141 | 0;
      this.Fl = 1401305490 | 0;
      this.Gh = 721525244 | 0;
      this.Gl = 746961066 | 0;
      this.Hh = 246885852 | 0;
      this.Hl = 2177182882 | 0;
      this.outputLen = 32;
    }
  };
  var SHA384 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 3418070365 | 0;
      this.Al = 3238371032 | 0;
      this.Bh = 1654270250 | 0;
      this.Bl = 914150663 | 0;
      this.Ch = 2438529370 | 0;
      this.Cl = 812702999 | 0;
      this.Dh = 355462360 | 0;
      this.Dl = 4144912697 | 0;
      this.Eh = 1731405415 | 0;
      this.El = 4290775857 | 0;
      this.Fh = 2394180231 | 0;
      this.Fl = 1750603025 | 0;
      this.Gh = 3675008525 | 0;
      this.Gl = 1694076839 | 0;
      this.Hh = 1203062813 | 0;
      this.Hl = 3204075428 | 0;
      this.outputLen = 48;
    }
  };
  var sha5122 = wrapConstructor(() => new SHA512());
  var sha512_224 = wrapConstructor(() => new SHA512_224());
  var sha512_256 = wrapConstructor(() => new SHA512_256());
  var sha384 = wrapConstructor(() => new SHA384());

  // node_modules/@scure/bip32/lib/esm/index.js
  init_assert();
  init_utils2();
  init_secp256k1();
  init_modular();

  // node_modules/@scure/base/lib/esm/index.js
  function assertNumber(n4) {
    if (!Number.isSafeInteger(n4))
      throw new Error(`Wrong integer: ${n4}`);
  }
  function chain(...args) {
    const wrap = (a2, b4) => (c3) => a2(b4(c3));
    const encode = Array.from(args).reverse().reduce((acc, i4) => acc ? wrap(acc, i4.encode) : i4.encode, void 0);
    const decode = args.reduce((acc, i4) => acc ? wrap(acc, i4.decode) : i4.decode, void 0);
    return { encode, decode };
  }
  function alphabet(alphabet2) {
    return {
      encode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return digits.map((i4) => {
          assertNumber(i4);
          if (i4 < 0 || i4 >= alphabet2.length)
            throw new Error(`Digit index outside alphabet: ${i4} (alphabet: ${alphabet2.length})`);
          return alphabet2[i4];
        });
      },
      decode: (input) => {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("alphabet.decode input should be array of strings");
        return input.map((letter) => {
          if (typeof letter !== "string")
            throw new Error(`alphabet.decode: not string element=${letter}`);
          const index2 = alphabet2.indexOf(letter);
          if (index2 === -1)
            throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
          return index2;
        });
      }
    };
  }
  function join(separator = "") {
    if (typeof separator !== "string")
      throw new Error("join separator should be string");
    return {
      encode: (from2) => {
        if (!Array.isArray(from2) || from2.length && typeof from2[0] !== "string")
          throw new Error("join.encode input should be array of strings");
        for (let i4 of from2)
          if (typeof i4 !== "string")
            throw new Error(`join.encode: non-string input=${i4}`);
        return from2.join(separator);
      },
      decode: (to) => {
        if (typeof to !== "string")
          throw new Error("join.decode input should be string");
        return to.split(separator);
      }
    };
  }
  function padding(bits, chr = "=") {
    assertNumber(bits);
    if (typeof chr !== "string")
      throw new Error("padding chr should be string");
    return {
      encode(data) {
        if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
          throw new Error("padding.encode input should be array of strings");
        for (let i4 of data)
          if (typeof i4 !== "string")
            throw new Error(`padding.encode: non-string input=${i4}`);
        while (data.length * bits % 8)
          data.push(chr);
        return data;
      },
      decode(input) {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("padding.encode input should be array of strings");
        for (let i4 of input)
          if (typeof i4 !== "string")
            throw new Error(`padding.decode: non-string input=${i4}`);
        let end = input.length;
        if (end * bits % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; end > 0 && input[end - 1] === chr; end--) {
          if (!((end - 1) * bits % 8))
            throw new Error("Invalid padding: string has too much padding");
        }
        return input.slice(0, end);
      }
    };
  }
  function normalize(fn) {
    if (typeof fn !== "function")
      throw new Error("normalize fn should be function");
    return { encode: (from2) => from2, decode: (to) => fn(to) };
  }
  function convertRadix(data, from2, to) {
    if (from2 < 2)
      throw new Error(`convertRadix: wrong from=${from2}, base cannot be less than 2`);
    if (to < 2)
      throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data))
      throw new Error("convertRadix: data should be array");
    if (!data.length)
      return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data);
    digits.forEach((d6) => {
      assertNumber(d6);
      if (d6 < 0 || d6 >= from2)
        throw new Error(`Wrong integer: ${d6}`);
    });
    while (true) {
      let carry = 0;
      let done = true;
      for (let i4 = pos; i4 < digits.length; i4++) {
        const digit = digits[i4];
        const digitBase = from2 * carry + digit;
        if (!Number.isSafeInteger(digitBase) || from2 * carry / from2 !== carry || digitBase - digit !== from2 * carry) {
          throw new Error("convertRadix: carry overflow");
        }
        carry = digitBase % to;
        digits[i4] = Math.floor(digitBase / to);
        if (!Number.isSafeInteger(digits[i4]) || digits[i4] * to + carry !== digitBase)
          throw new Error("convertRadix: carry overflow");
        if (!done)
          continue;
        else if (!digits[i4])
          pos = i4;
        else
          done = false;
      }
      res.push(carry);
      if (done)
        break;
    }
    for (let i4 = 0; i4 < data.length - 1 && data[i4] === 0; i4++)
      res.push(0);
    return res.reverse();
  }
  var gcd = (a2, b4) => !b4 ? a2 : gcd(b4, a2 % b4);
  var radix2carry = (from2, to) => from2 + (to - gcd(from2, to));
  function convertRadix2(data, from2, to, padding2) {
    if (!Array.isArray(data))
      throw new Error("convertRadix2: data should be array");
    if (from2 <= 0 || from2 > 32)
      throw new Error(`convertRadix2: wrong from=${from2}`);
    if (to <= 0 || to > 32)
      throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from2, to) > 32) {
      throw new Error(`convertRadix2: carry overflow from=${from2} to=${to} carryBits=${radix2carry(from2, to)}`);
    }
    let carry = 0;
    let pos = 0;
    const mask = 2 ** to - 1;
    const res = [];
    for (const n4 of data) {
      assertNumber(n4);
      if (n4 >= 2 ** from2)
        throw new Error(`convertRadix2: invalid data word=${n4} from=${from2}`);
      carry = carry << from2 | n4;
      if (pos + from2 > 32)
        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
      pos += from2;
      for (; pos >= to; pos -= to)
        res.push((carry >> pos - to & mask) >>> 0);
      carry &= 2 ** pos - 1;
    }
    carry = carry << to - pos & mask;
    if (!padding2 && pos >= from2)
      throw new Error("Excess padding");
    if (!padding2 && carry)
      throw new Error(`Non-zero padding: ${carry}`);
    if (padding2 && pos > 0)
      res.push(carry >>> 0);
    return res;
  }
  function radix(num) {
    assertNumber(num);
    return {
      encode: (bytes2) => {
        if (!(bytes2 instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return convertRadix(Array.from(bytes2), 2 ** 8, num);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
      }
    };
  }
  function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (bytes2) => {
        if (!(bytes2 instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
      }
    };
  }
  function unsafeWrapper(fn) {
    if (typeof fn !== "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...args) {
      try {
        return fn.apply(null, args);
      } catch (e) {
      }
    };
  }
  function checksum(len, fn) {
    assertNumber(len);
    if (typeof fn !== "function")
      throw new Error("checksum fn should be function");
    return {
      encode(data) {
        if (!(data instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const checksum2 = fn(data).slice(0, len);
        const res = new Uint8Array(data.length + len);
        res.set(data);
        res.set(checksum2, data.length);
        return res;
      },
      decode(data) {
        if (!(data instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const payload = data.slice(0, -len);
        const newChecksum = fn(payload).slice(0, len);
        const oldChecksum = data.slice(-len);
        for (let i4 = 0; i4 < len; i4++)
          if (newChecksum[i4] !== oldChecksum[i4])
            throw new Error("Invalid checksum");
        return payload;
      }
    };
  }
  var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
  var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
  var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
  var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s4) => s4.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
  var base642 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
  var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
  var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
  var base582 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
  var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  var base58xmr = {
    encode(data) {
      let res = "";
      for (let i4 = 0; i4 < data.length; i4 += 8) {
        const block = data.subarray(i4, i4 + 8);
        res += base582.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
      }
      return res;
    },
    decode(str) {
      let res = [];
      for (let i4 = 0; i4 < str.length; i4 += 11) {
        const slice2 = str.slice(i4, i4 + 11);
        const blockLen = XMR_BLOCK_LEN.indexOf(slice2.length);
        const block = base582.decode(slice2);
        for (let j3 = 0; j3 < block.length - blockLen; j3++) {
          if (block[j3] !== 0)
            throw new Error("base58xmr: wrong padding");
        }
        res = res.concat(Array.from(block.slice(block.length - blockLen)));
      }
      return Uint8Array.from(res);
    }
  };
  var base58check = (sha2564) => chain(checksum(4, (data) => sha2564(sha2564(data))), base582);
  var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
  var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function bech32Polymod(pre) {
    const b4 = pre >> 25;
    let chk = (pre & 33554431) << 5;
    for (let i4 = 0; i4 < POLYMOD_GENERATORS.length; i4++) {
      if ((b4 >> i4 & 1) === 1)
        chk ^= POLYMOD_GENERATORS[i4];
    }
    return chk;
  }
  function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i4 = 0; i4 < len; i4++) {
      const c3 = prefix.charCodeAt(i4);
      if (c3 < 33 || c3 > 126)
        throw new Error(`Invalid prefix (${prefix})`);
      chk = bech32Polymod(chk) ^ c3 >> 5;
    }
    chk = bech32Polymod(chk);
    for (let i4 = 0; i4 < len; i4++)
      chk = bech32Polymod(chk) ^ prefix.charCodeAt(i4) & 31;
    for (let v7 of words)
      chk = bech32Polymod(chk) ^ v7;
    for (let i4 = 0; i4 < 6; i4++)
      chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
  }
  function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
      if (typeof prefix !== "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
      if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
      const actualLength = prefix.length + 7 + words.length;
      if (limit !== false && actualLength > limit)
        throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
      prefix = prefix.toLowerCase();
      return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
    }
    function decode(str, limit = 90) {
      if (typeof str !== "string")
        throw new Error(`bech32.decode input should be string, not ${typeof str}`);
      if (str.length < 8 || limit !== false && str.length > limit)
        throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
      const lowered = str.toLowerCase();
      if (str !== lowered && str !== str.toUpperCase())
        throw new Error(`String must be lowercase or uppercase`);
      str = lowered;
      const sepIndex = str.lastIndexOf("1");
      if (sepIndex === 0 || sepIndex === -1)
        throw new Error(`Letter "1" must be present between prefix and data only`);
      const prefix = str.slice(0, sepIndex);
      const _words2 = str.slice(sepIndex + 1);
      if (_words2.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
      const sum = bechChecksum(prefix, words, ENCODING_CONST);
      if (!_words2.endsWith(sum))
        throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
      return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
      const { prefix, words } = decode(str, false);
      return { prefix, words, bytes: fromWords(words) };
    }
    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
  }
  var bech322 = genBech32("bech32");
  var bech32m = genBech32("bech32m");
  var utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str)
  };
  var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s4) => {
    if (typeof s4 !== "string" || s4.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof s4} with length ${s4.length}`);
    return s4.toLowerCase();
  }));
  var CODERS = {
    utf8,
    hex,
    base16,
    base32,
    base64: base642,
    base64url,
    base58: base582,
    base58xmr
  };
  var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

  // node_modules/@scure/bip32/lib/esm/index.js
  var Point2 = secp256k1.ProjectivePoint;
  var base58check2 = base58check(sha2563);
  var MASTER_SECRET = utf8ToBytes("Bitcoin seed");

  // node_modules/viem/dist/esm/accounts/generateMnemonic.js
  var import_bip39 = __toESM(require_bip39(), 1);

  // node_modules/viem/dist/esm/accounts/generatePrivateKey.js
  init_secp256k1();
  init_toHex();
  function generatePrivateKey() {
    return toHex(secp256k1.utils.randomPrivateKey());
  }

  // node_modules/viem/dist/esm/accounts/hdKeyToAccount.js
  init_toHex();

  // node_modules/viem/dist/esm/accounts/privateKeyToAccount.js
  init_secp256k1();
  init_toHex();

  // node_modules/viem/dist/esm/accounts/toAccount.js
  init_address();
  init_isAddress();
  function toAccount(source) {
    if (typeof source === "string") {
      if (!isAddress2(source))
        throw new InvalidAddressError({ address: source });
      return {
        address: source,
        type: "json-rpc"
      };
    }
    if (!isAddress2(source.address))
      throw new InvalidAddressError({ address: source.address });
    return {
      address: source.address,
      signMessage: source.signMessage,
      signTransaction: source.signTransaction,
      signTypedData: source.signTypedData,
      source: "custom",
      type: "local"
    };
  }

  // node_modules/viem/dist/esm/accounts/utils/sign.js
  init_secp256k1();
  init_toHex();
  async function sign({ hash: hash3, privateKey }) {
    const { r: r2, s: s4, recovery } = secp256k1.sign(hash3.slice(2), privateKey.slice(2));
    return {
      r: toHex(r2),
      s: toHex(s4),
      v: recovery ? 28n : 27n
    };
  }

  // node_modules/viem/dist/esm/accounts/utils/signatureToHex.js
  init_secp256k1();
  init_fromHex();
  init_toHex();
  function signatureToHex({ r: r2, s: s4, v: v7 }) {
    return `0x${new secp256k1.Signature(hexToBigInt(r2), hexToBigInt(s4)).toCompactHex()}${toHex(v7).slice(2)}`;
  }

  // node_modules/viem/dist/esm/accounts/utils/signMessage.js
  async function signMessage2({ message, privateKey }) {
    const signature = await sign({ hash: hashMessage2(message), privateKey });
    return signatureToHex(signature);
  }

  // node_modules/viem/dist/esm/accounts/utils/signTransaction.js
  init_keccak256();
  async function signTransaction({ privateKey, transaction: transaction2 }) {
    const signature = await sign({
      hash: keccak2562(serializeTransaction2(transaction2)),
      privateKey
    });
    return serializeTransaction2(transaction2, signature);
  }

  // node_modules/viem/dist/esm/accounts/utils/signTypedData.js
  async function signTypedData2({ privateKey, ...typedData }) {
    const signature = await sign({
      hash: hashTypedData(typedData),
      privateKey
    });
    return signatureToHex(signature);
  }

  // node_modules/viem/dist/esm/accounts/privateKeyToAccount.js
  function privateKeyToAccount(privateKey) {
    const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
    const address = publicKeyToAddress(publicKey);
    const account = toAccount({
      address,
      async signMessage({ message }) {
        return signMessage2({ message, privateKey });
      },
      async signTransaction(transaction2) {
        return signTransaction({ privateKey, transaction: transaction2 });
      },
      async signTypedData(typedData) {
        return signTypedData2({ ...typedData, privateKey });
      }
    });
    return {
      ...account,
      publicKey,
      source: "privateKey"
    };
  }

  // node_modules/viem/dist/esm/accounts/mnemonicToAccount.js
  var import_bip392 = __toESM(require_bip39(), 1);

  // node_modules/viem/dist/esm/accounts/index.js
  init_parseAccount();

  // node_modules/viem/dist/esm/accounts/wordlists/czech.js
  var import_czech = __toESM(require_czech(), 1);

  // node_modules/viem/dist/esm/accounts/wordlists/english.js
  var import_english = __toESM(require_english(), 1);

  // node_modules/viem/dist/esm/accounts/wordlists/french.js
  var import_french = __toESM(require_french(), 1);

  // node_modules/viem/dist/esm/accounts/wordlists/italian.js
  var import_italian = __toESM(require_italian(), 1);

  // node_modules/viem/dist/esm/accounts/wordlists/japanese.js
  var import_japanese = __toESM(require_japanese(), 1);

  // node_modules/viem/dist/esm/accounts/wordlists/korean.js
  var import_korean = __toESM(require_korean(), 1);

  // node_modules/viem/dist/esm/accounts/wordlists/simplifiedChinese.js
  var import_simplified_chinese = __toESM(require_simplified_chinese(), 1);

  // node_modules/viem/dist/esm/accounts/wordlists/spanish.js
  var import_spanish = __toESM(require_spanish(), 1);

  // node_modules/viem/dist/esm/accounts/wordlists/traditionalChinese.js
  var import_traditional_chinese = __toESM(require_traditional_chinese(), 1);

  // node_modules/@latticexyz/common/dist/chains.js
  var chains_exports = {};
  __export(chains_exports, {
    latticeTestnet: () => t
  });
  var t = { name: "Lattice Testnet", id: 4242, network: "lattice-testnet", nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" }, rpcUrls: { default: { http: ["https://follower.testnet-chain.linfra.xyz"], webSocket: ["wss://follower.testnet-chain.linfra.xyz"] }, public: { http: ["https://follower.testnet-chain.linfra.xyz"], webSocket: ["wss://follower.testnet-chain.linfra.xyz"] } }, blockExplorers: { otterscan: { name: "Otterscan", url: "https://explorer.testnet-chain.linfra.xyz" }, default: { name: "Otterscan", url: "https://explorer.testnet-chain.linfra.xyz" } }, modeUrl: "https://mode.testnet-mud-services.linfra.xyz", faucetUrl: "https://faucet.testnet-mud-services.linfra.xyz" };

  // node_modules/@wagmi/chains/dist/index.mjs
  var dist_exports = {};
  __export(dist_exports, {
    arbitrum: () => arbitrum,
    arbitrumGoerli: () => arbitrumGoerli,
    arbitrumNova: () => arbitrumNova,
    aurora: () => aurora,
    auroraTestnet: () => auroraTestnet,
    avalanche: () => avalanche,
    avalancheFuji: () => avalancheFuji,
    baseGoerli: () => baseGoerli,
    boba: () => boba,
    bronos: () => bronos,
    bronosTestnet: () => bronosTestnet,
    bsc: () => bsc,
    bscTestnet: () => bscTestnet,
    canto: () => canto,
    celo: () => celo,
    celoAlfajores: () => celoAlfajores,
    celoCannoli: () => celoCannoli,
    confluxESpace: () => confluxESpace,
    cronos: () => cronos,
    crossbell: () => crossbell,
    dfk: () => dfk,
    dogechain: () => dogechain,
    ekta: () => ekta,
    ektaTestnet: () => ektaTestnet,
    evmos: () => evmos,
    evmosTestnet: () => evmosTestnet,
    fantom: () => fantom,
    fantomTestnet: () => fantomTestnet,
    filecoin: () => filecoin,
    filecoinCalibration: () => filecoinCalibration,
    filecoinHyperspace: () => filecoinHyperspace,
    flare: () => flare,
    flareTestnet: () => flareTestnet,
    foundry: () => foundry,
    fuse: () => fuse,
    gnosis: () => gnosis,
    gnosisChiado: () => gnosisChiado,
    goerli: () => goerli,
    haqqMainnet: () => haqqMainnet,
    haqqTestedge2: () => haqqTestedge2,
    hardhat: () => hardhat,
    harmonyOne: () => harmonyOne,
    iotex: () => iotex,
    iotexTestnet: () => iotexTestnet,
    klaytn: () => klaytn,
    lineaTestnet: () => lineaTestnet,
    localhost: () => localhost,
    mainnet: () => mainnet,
    metis: () => metis,
    metisGoerli: () => metisGoerli,
    moonbaseAlpha: () => moonbaseAlpha,
    moonbeam: () => moonbeam,
    moonriver: () => moonriver,
    neonDevnet: () => neonDevnet,
    nexi: () => nexi,
    oasys: () => oasys,
    okc: () => okc,
    optimism: () => optimism,
    optimismGoerli: () => optimismGoerli,
    polygon: () => polygon,
    polygonMumbai: () => polygonMumbai,
    polygonZkEvm: () => polygonZkEvm,
    polygonZkEvmTestnet: () => polygonZkEvmTestnet,
    pulsechain: () => pulsechain,
    pulsechainV4: () => pulsechainV4,
    scrollTestnet: () => scrollTestnet,
    sepolia: () => sepolia,
    shardeumSphinx: () => shardeumSphinx,
    skaleBlockBrawlers: () => skaleBlockBrawlers,
    skaleCalypso: () => skaleCalypso,
    skaleCalypsoTestnet: () => skaleCalypsoTestnet,
    skaleChaosTestnet: () => skaleChaosTestnet,
    skaleCryptoBlades: () => skaleCryptoBlades,
    skaleCryptoColosseum: () => skaleCryptoColosseum,
    skaleEuropa: () => skaleEuropa,
    skaleEuropaTestnet: () => skaleEuropaTestnet,
    skaleExorde: () => skaleExorde,
    skaleHumanProtocol: () => skaleHumanProtocol,
    skaleNebula: () => skaleNebula,
    skaleNebulaTestnet: () => skaleNebulaTestnet,
    skaleRazor: () => skaleRazor,
    skaleTitan: () => skaleTitan,
    skaleTitanTestnet: () => skaleTitanTestnet,
    songbird: () => songbird,
    songbirdTestnet: () => songbirdTestnet,
    syscoin: () => syscoin,
    taraxa: () => taraxa,
    taraxaTestnet: () => taraxaTestnet,
    telos: () => telos,
    telosTestnet: () => telosTestnet,
    thunderTestnet: () => thunderTestnet,
    wanchain: () => wanchain,
    wanchainTestnet: () => wanchainTestnet,
    xdc: () => xdc,
    xdcTestnet: () => xdcTestnet,
    zhejiang: () => zhejiang,
    zkSync: () => zkSync,
    zkSyncTestnet: () => zkSyncTestnet
  });
  var arbitrum = {
    id: 42161,
    name: "Arbitrum One",
    network: "arbitrum",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://arb-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://arbitrum-mainnet.infura.io/v3"],
        webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://arb1.arbitrum.io/rpc"]
      },
      public: {
        http: ["https://arb1.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
      default: { name: "Arbiscan", url: "https://arbiscan.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7654707
      }
    }
  };
  var arbitrumGoerli = {
    id: 421613,
    name: "Arbitrum Goerli",
    network: "arbitrum-goerli",
    nativeCurrency: {
      name: "Arbitrum Goerli Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://arb-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://arbitrum-goerli.infura.io/v3"],
        webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://goerli-rollup.arbitrum.io/rpc"]
      },
      public: {
        http: ["https://goerli-rollup.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      etherscan: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" },
      default: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 88114
      }
    },
    testnet: true
  };
  var arbitrumNova = {
    id: 42170,
    name: "Arbitrum Nova",
    network: "arbitrum-nova",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      blast: {
        http: ["https://arbitrum-nova.public.blastapi.io"],
        webSocket: ["wss://arbitrum-nova.public.blastapi.io"]
      },
      default: {
        http: ["https://nova.arbitrum.io/rpc"]
      },
      public: {
        http: ["https://nova.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      etherscan: { name: "Arbiscan", url: "https://nova.arbiscan.io" },
      blockScout: {
        name: "BlockScout",
        url: "https://nova-explorer.arbitrum.io/"
      },
      default: { name: "Arbiscan", url: "https://nova.arbiscan.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1746963
      }
    }
  };
  var aurora = {
    id: 1313161554,
    name: "Aurora",
    network: "aurora",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      infura: { http: ["https://aurora-mainnet.infura.io/v3"] },
      default: { http: ["https://mainnet.aurora.dev"] },
      public: { http: ["https://mainnet.aurora.dev"] }
    },
    blockExplorers: {
      etherscan: { name: "Aurorascan", url: "https://aurorascan.dev" },
      default: { name: "Aurorascan", url: "https://aurorascan.dev" }
    }
  };
  var auroraTestnet = {
    id: 1313161555,
    name: "Aurora Testnet",
    network: "aurora-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      infura: { http: ["https://aurora-testnet.infura.io/v3"] },
      default: { http: ["https://testnet.aurora.dev"] },
      public: { http: ["https://testnet.aurora.dev"] }
    },
    blockExplorers: {
      etherscan: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" },
      default: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" }
    },
    testnet: true
  };
  var avalanche = {
    id: 43114,
    name: "Avalanche",
    network: "avalanche",
    nativeCurrency: {
      decimals: 18,
      name: "Avalanche",
      symbol: "AVAX"
    },
    rpcUrls: {
      default: { http: ["https://api.avax.network/ext/bc/C/rpc"] },
      public: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
    },
    blockExplorers: {
      etherscan: { name: "SnowTrace", url: "https://snowtrace.io" },
      default: { name: "SnowTrace", url: "https://snowtrace.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 11907934
      }
    }
  };
  var avalancheFuji = {
    id: 43113,
    name: "Avalanche Fuji",
    network: "avalanche-fuji",
    nativeCurrency: {
      decimals: 18,
      name: "Avalanche Fuji",
      symbol: "AVAX"
    },
    rpcUrls: {
      default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] },
      public: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
    },
    blockExplorers: {
      etherscan: { name: "SnowTrace", url: "https://testnet.snowtrace.io" },
      default: { name: "SnowTrace", url: "https://testnet.snowtrace.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7096959
      }
    },
    testnet: true
  };
  var baseGoerli = {
    id: 84531,
    network: "base-goerli",
    name: "Base Goerli",
    nativeCurrency: { name: "Base Goerli", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://goerli.base.org"]
      },
      public: {
        http: ["https://goerli.base.org"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Basescan",
        url: "https://goerli.basescan.org"
      },
      default: {
        name: "Basescan",
        url: "https://goerli.basescan.org"
      }
    },
    testnet: true
  };
  var boba = {
    id: 288,
    name: "Boba Network",
    network: "boba",
    nativeCurrency: {
      decimals: 18,
      name: "Boba",
      symbol: "BOBA"
    },
    rpcUrls: {
      default: { http: ["https://mainnet.boba.network"] },
      public: { http: ["https://mainnet.boba.network"] }
    },
    blockExplorers: {
      etherscan: { name: "BOBAScan", url: "https://bobascan.com" },
      default: { name: "BOBAScan", url: "https://bobascan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 446859
      }
    }
  };
  var bronos = {
    id: 1039,
    name: "Bronos",
    network: "bronos",
    nativeCurrency: {
      decimals: 18,
      name: "BRO",
      symbol: "BRO"
    },
    rpcUrls: {
      default: { http: ["https://evm.bronos.org"] },
      public: { http: ["https://evm.bronos.org"] }
    },
    blockExplorers: {
      default: { name: "BronoScan", url: "https://broscan.bronos.org" }
    }
  };
  var bronosTestnet = {
    id: 1038,
    name: "Bronos Testnet",
    network: "bronos-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Bronos Coin",
      symbol: "tBRO"
    },
    rpcUrls: {
      default: { http: ["https://evm-testnet.bronos.org"] },
      public: { http: ["https://evm-testnet.bronos.org"] }
    },
    blockExplorers: {
      default: { name: "BronoScan", url: "https://tbroscan.bronos.org" }
    },
    testnet: true
  };
  var bsc = {
    id: 56,
    name: "BNB Smart Chain",
    network: "bsc",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "BNB"
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/bsc"] },
      public: { http: ["https://rpc.ankr.com/bsc"] }
    },
    blockExplorers: {
      etherscan: { name: "BscScan", url: "https://bscscan.com" },
      default: { name: "BscScan", url: "https://bscscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 15921452
      }
    }
  };
  var bscTestnet = {
    id: 97,
    name: "Binance Smart Chain Testnet",
    network: "bsc-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "tBNB"
    },
    rpcUrls: {
      default: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] },
      public: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] }
    },
    blockExplorers: {
      etherscan: { name: "BscScan", url: "https://testnet.bscscan.com" },
      default: { name: "BscScan", url: "https://testnet.bscscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 17422483
      }
    },
    testnet: true
  };
  var canto = {
    id: 7700,
    name: "Canto",
    network: "canto",
    nativeCurrency: {
      decimals: 18,
      name: "Canto",
      symbol: "CANTO"
    },
    rpcUrls: {
      default: { http: ["https://canto.slingshot.finance"] },
      public: { http: ["https://canto.slingshot.finance"] }
    },
    blockExplorers: {
      default: {
        name: "Canto EVM Explorer (Blockscout)",
        url: "https://evm.explorer.canto.io"
      }
    }
  };
  var celo = {
    id: 42220,
    name: "Celo",
    network: "celo",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "CELO"
    },
    rpcUrls: {
      default: { http: ["https://forno.celo.org"] },
      infura: {
        http: ["https://celo-mainnet.infura.io/v3"]
      },
      public: {
        http: ["https://forno.celo.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/mainnet"
      },
      etherscan: { name: "CeloScan", url: "https://celoscan.io" }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 13112599
      }
    },
    testnet: false
  };
  var celoAlfajores = {
    id: 44787,
    name: "Alfajores",
    network: "celo-alfajores",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "A-CELO"
    },
    rpcUrls: {
      default: {
        http: ["https://alfajores-forno.celo-testnet.org"]
      },
      infura: {
        http: ["https://celo-alfajores.infura.io/v3"]
      },
      public: {
        http: ["https://alfajores-forno.celo-testnet.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/alfajores"
      },
      etherscan: { name: "CeloScan", url: "https://alfajores.celoscan.io/" }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 14569001
      }
    },
    testnet: true
  };
  var celoCannoli = {
    id: 17323,
    name: "Cannoli",
    network: "celo-cannoli",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "C-CELO"
    },
    rpcUrls: {
      default: {
        http: ["https://forno.cannoli.celo-testnet.org"]
      },
      public: {
        http: ["https://forno.cannoli.celo-testnet.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/cannoli"
      }
    },
    contracts: {
      multicall3: {
        address: "0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718",
        blockCreated: 87429
      }
    },
    testnet: true
  };
  var confluxESpace = {
    id: 1030,
    name: "Conflux eSpace",
    network: "cfx-espace",
    nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://evm.confluxrpc.org"]
      },
      public: {
        http: ["https://evm.confluxrpc.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "ConfluxScan",
        url: "https://evm.confluxscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
        blockCreated: 68602935
      }
    }
  };
  var cronos = {
    id: 25,
    name: "Cronos",
    network: "cronos",
    nativeCurrency: {
      decimals: 18,
      name: "Cronos",
      symbol: "CRO"
    },
    rpcUrls: {
      default: { http: ["https://node.croswap.com/rpc"] },
      public: { http: ["https://node.croswap.com/rpc"] }
    },
    blockExplorers: {
      etherscan: { name: "CronosScan", url: "https://cronoscan.com" },
      default: { name: "CronosScan", url: "https://cronoscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1963112
      }
    }
  };
  var crossbell = {
    id: 3737,
    network: "crossbell",
    name: "Crossbell",
    nativeCurrency: {
      decimals: 18,
      name: "CSB",
      symbol: "CSB"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.crossbell.io"]
      },
      public: {
        http: ["https://rpc.crossbell.io"]
      }
    },
    blockExplorers: {
      default: { name: "CrossScan", url: "https://scan.crossbell.io" }
    },
    contracts: {
      multicall3: {
        address: "0xBB9759009cDaC82774EfC84D94cD9F7440f75Fcf",
        blockCreated: 23499787
      }
    }
  };
  var dfk = {
    id: 53935,
    name: "DFK Chain",
    network: "dfk",
    nativeCurrency: {
      decimals: 18,
      name: "Jewel",
      symbol: "JEWEL"
    },
    rpcUrls: {
      default: {
        http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
      },
      public: {
        http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "DFKSubnetScan",
        url: "https://subnets.avax.network/defi-kingdoms"
      },
      default: {
        name: "DFKSubnetScan",
        url: "https://subnets.avax.network/defi-kingdoms"
      }
    }
  };
  var dogechain = {
    id: 2e3,
    name: "Dogechain",
    network: "dogechain",
    nativeCurrency: {
      decimals: 18,
      name: "Dogechain",
      symbol: "DC"
    },
    rpcUrls: {
      default: { http: ["https://rpc.dogechain.dog"] },
      public: { http: ["https://rpc.dogechain.dog"] }
    },
    blockExplorers: {
      etherscan: {
        name: "DogeChainExplorer",
        url: "https://explorer.dogechain.dog"
      },
      default: {
        name: "DogeChainExplorer",
        url: "https://explorer.dogechain.dog"
      }
    }
  };
  var evmos = {
    id: 9001,
    name: "Evmos",
    network: "evmos",
    nativeCurrency: {
      decimals: 18,
      name: "Evmos",
      symbol: "EVMOS"
    },
    rpcUrls: {
      default: { http: ["https://eth.bd.evmos.org:8545"] },
      public: { http: ["https://eth.bd.evmos.org:8545"] }
    },
    blockExplorers: {
      default: { name: "Evmos Block Explorer", url: "https://escan.live/" }
    }
  };
  var evmosTestnet = {
    id: 9e3,
    name: "Evmos Testnet",
    network: "evmos-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Evmos",
      symbol: "EVMOS"
    },
    rpcUrls: {
      default: { http: ["https://eth.bd.evmos.dev:8545"] },
      public: { http: ["https://eth.bd.evmos.dev:8545"] }
    },
    blockExplorers: {
      default: {
        name: "Evmos Testnet Block Explorer",
        url: "https://evm.evmos.dev/"
      }
    }
  };
  var ekta = {
    id: 1994,
    name: "Ekta",
    network: "ekta",
    nativeCurrency: {
      decimals: 18,
      name: "EKTA",
      symbol: "EKTA"
    },
    rpcUrls: {
      public: { http: ["https://main.ekta.io"] },
      default: { http: ["https://main.ekta.io"] }
    },
    blockExplorers: {
      default: { name: "Ektascan", url: "https://ektascan.io" }
    }
  };
  var ektaTestnet = {
    id: 1004,
    name: "Ekta Testnet",
    network: "ekta-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "EKTA",
      symbol: "EKTA"
    },
    rpcUrls: {
      public: { http: ["https://test.ekta.io:8545"] },
      default: { http: ["https://test.ekta.io:8545"] }
    },
    blockExplorers: {
      default: { name: "Test Ektascan", url: "https://test.ektascan.io" }
    },
    testnet: true
  };
  var fantom = {
    id: 250,
    name: "Fantom",
    network: "fantom",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/fantom"] },
      public: { http: ["https://rpc.ankr.com/fantom"] }
    },
    blockExplorers: {
      etherscan: { name: "FTMScan", url: "https://ftmscan.com" },
      default: { name: "FTMScan", url: "https://ftmscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 33001987
      }
    }
  };
  var fantomTestnet = {
    id: 4002,
    name: "Fantom Testnet",
    network: "fantom-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpc.testnet.fantom.network"] },
      public: { http: ["https://rpc.testnet.fantom.network"] }
    },
    blockExplorers: {
      etherscan: { name: "FTMScan", url: "https://testnet.ftmscan.com" },
      default: { name: "FTMScan", url: "https://testnet.ftmscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 8328688
      }
    }
  };
  var filecoin = {
    id: 314,
    name: "Filecoin Mainnet",
    network: "filecoin-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "filecoin",
      symbol: "FIL"
    },
    rpcUrls: {
      default: { http: ["https://api.node.glif.io/rpc/v1"] },
      public: { http: ["https://api.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: { name: "Filfox", url: "https://filfox.info/en" },
      filscan: { name: "Filscan", url: "https://filscan.io" },
      filscout: { name: "Filscout", url: "https://filscout.io/en" },
      glif: { name: "Glif", url: "https://explorer.glif.io" }
    }
  };
  var filecoinCalibration = {
    id: 314159,
    name: "Filecoin Calibration",
    network: "filecoin-calibration",
    nativeCurrency: {
      decimals: 18,
      name: "testnet filecoin",
      symbol: "tFIL"
    },
    rpcUrls: {
      default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] },
      public: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: { name: "Filscan", url: "https://calibration.filscan.io" }
    }
  };
  var filecoinHyperspace = {
    id: 3141,
    name: "Filecoin Hyperspace",
    network: "filecoin-hyperspace",
    nativeCurrency: {
      decimals: 18,
      name: "testnet filecoin",
      symbol: "tFIL"
    },
    rpcUrls: {
      default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] },
      public: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: { name: "Filfox", url: "https://hyperspace.filfox.info/en" },
      filscan: { name: "Filscan", url: "https://hyperspace.filscan.io" }
    }
  };
  var flare = {
    id: 14,
    name: "Flare Mainnet",
    network: "flare-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "flare",
      symbol: "FLR"
    },
    rpcUrls: {
      default: { http: ["https://flare-api.flare.network/ext/C/rpc"] },
      public: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Flare Explorer",
        url: "https://flare-explorer.flare.network"
      }
    }
  };
  var flareTestnet = {
    id: 114,
    name: "Coston2",
    network: "coston2",
    nativeCurrency: {
      decimals: 18,
      name: "coston2flare",
      symbol: "C2FLR"
    },
    rpcUrls: {
      default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] },
      public: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Coston2 Explorer",
        url: "https://coston2-explorer.flare.network"
      }
    },
    testnet: true
  };
  var foundry = {
    id: 31337,
    name: "Foundry",
    network: "foundry",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["http://127.0.0.1:8545"],
        webSocket: ["ws://127.0.0.1:8545"]
      },
      public: {
        http: ["http://127.0.0.1:8545"],
        webSocket: ["ws://127.0.0.1:8545"]
      }
    }
  };
  var fuse = {
    id: 122,
    name: "Fuse",
    network: "fuse",
    nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
    rpcUrls: {
      default: { http: ["https://rpc.fuse.io"] },
      public: { http: ["https://fuse-mainnet.chainstacklabs.com"] }
    },
    blockExplorers: {
      default: { name: "Fuse Explorer", url: "https://explorer.fuse.io" }
    }
  };
  var iotex = {
    id: 4689,
    name: "IoTeX",
    network: "iotex",
    nativeCurrency: {
      decimals: 18,
      name: "IoTeX",
      symbol: "IOTX"
    },
    rpcUrls: {
      default: {
        http: ["https://babel-api.mainnet.iotex.io"],
        webSocket: ["wss://babel-api.mainnet.iotex.io"]
      },
      public: {
        http: ["https://babel-api.mainnet.iotex.io"],
        webSocket: ["wss://babel-api.mainnet.iotex.io"]
      }
    },
    blockExplorers: {
      default: { name: "IoTeXScan", url: "https://iotexscan.io" }
    }
  };
  var iotexTestnet = {
    id: 4690,
    name: "IoTeX Testnet",
    network: "iotex-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "IoTeX",
      symbol: "IOTX"
    },
    rpcUrls: {
      default: {
        http: ["https://babel-api.testnet.iotex.io"],
        webSocket: ["wss://babel-api.testnet.iotex.io"]
      },
      public: {
        http: ["https://babel-api.testnet.iotex.io"],
        webSocket: ["wss://babel-api.testnet.iotex.io"]
      }
    },
    blockExplorers: {
      default: { name: "IoTeXScan", url: "https://testnet.iotexscan.io" }
    }
  };
  var goerli = {
    id: 5,
    network: "goerli",
    name: "Goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://goerli.infura.io/v3"],
        webSocket: ["wss://goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.ankr.com/eth_goerli"]
      },
      public: {
        http: ["https://rpc.ankr.com/eth_goerli"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://goerli.etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://goerli.etherscan.io"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0xA292E2E58d4ddEb29C33c63173d0E8B7a2A4c62e",
        blockCreated: 8610406
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 6507670
      }
    },
    testnet: true
  };
  var gnosis = {
    id: 100,
    name: "Gnosis",
    network: "gnosis",
    nativeCurrency: {
      decimals: 18,
      name: "Gnosis",
      symbol: "xDAI"
    },
    rpcUrls: {
      default: { http: ["https://rpc.gnosischain.com"] },
      public: { http: ["https://rpc.gnosischain.com"] }
    },
    blockExplorers: {
      etherscan: {
        name: "Gnosisscan",
        url: "https://gnosisscan.io/"
      },
      default: {
        name: "Gnosis Chain Explorer",
        url: "https://blockscout.com/xdai/mainnet/"
      }
    }
  };
  var gnosisChiado = {
    id: 10200,
    name: "Gnosis Chiado",
    network: "chiado",
    nativeCurrency: {
      decimals: 18,
      name: "Gnosis",
      symbol: "xDAI"
    },
    rpcUrls: {
      default: { http: ["https://rpc.chiadochain.net"] },
      public: { http: ["https://rpc.chiadochain.net"] }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://blockscout.chiadochain.net"
      }
    }
  };
  var hardhat = {
    id: 31337,
    name: "Hardhat",
    network: "hardhat",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["http://127.0.0.1:8545"] },
      public: { http: ["http://127.0.0.1:8545"] }
    }
  };
  var harmonyOne = {
    id: 16666e5,
    name: "Harmony One",
    network: "harmony",
    nativeCurrency: {
      name: "Harmony",
      symbol: "ONE",
      decimals: 18
    },
    rpcUrls: {
      public: { http: ["https://rpc.ankr.com/harmony"] },
      default: { http: ["https://rpc.ankr.com/harmony"] }
    },
    blockExplorers: {
      default: { name: "Harmony Explorer", url: "https://explorer.harmony.one" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 24185753
      }
    }
  };
  var haqqMainnet = {
    id: 11235,
    name: "HAQQ Mainnet",
    network: "haqq-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Islamic Coin",
      symbol: "ISLM"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.eth.haqq.network"]
      },
      public: {
        http: ["https://rpc.eth.haqq.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "HAQQ Explorer",
        url: "https://explorer.haqq.network"
      }
    }
  };
  var haqqTestedge2 = {
    id: 54211,
    name: "HAQQ Testedge 2",
    network: "haqq-testedge-2",
    nativeCurrency: {
      decimals: 18,
      name: "Islamic Coin",
      symbol: "ISLMT"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.eth.testedge2.haqq.network"]
      },
      public: {
        http: ["https://rpc.eth.testedge2.haqq.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "HAQQ Explorer",
        url: "https://explorer.testedge2.haqq.network"
      }
    }
  };
  var klaytn = {
    id: 8217,
    name: "Klaytn",
    network: "klaytn",
    nativeCurrency: {
      decimals: 18,
      name: "Klaytn",
      symbol: "KLAY"
    },
    rpcUrls: {
      default: { http: ["https://cypress.fautor.app/archive"] },
      public: { http: ["https://cypress.fautor.app/archive"] }
    },
    blockExplorers: {
      etherscan: { name: "KlaytnScope", url: "https://scope.klaytn.com" },
      default: { name: "KlaytnScope", url: "https://scope.klaytn.com" }
    }
  };
  var lineaTestnet = {
    id: 59140,
    name: "Linea Goerli Testnet",
    network: "linea-testnet",
    nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      infura: {
        http: ["https://consensys-zkevm-goerli-prealpha.infura.io/v3"],
        webSocket: ["wss://consensys-zkevm-goerli-prealpha.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.goerli.linea.build"],
        webSocket: ["wss://rpc.goerli.linea.build"]
      },
      public: {
        http: ["https://rpc.goerli.linea.build"],
        webSocket: ["wss://rpc.goerli.linea.build"]
      }
    },
    blockExplorers: {
      default: {
        name: "BlockScout",
        url: "https://explorer.goerli.linea.build"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 498623
      }
    },
    testnet: true
  };
  var localhost = {
    id: 1337,
    name: "Localhost",
    network: "localhost",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["http://127.0.0.1:8545"] },
      public: { http: ["http://127.0.0.1:8545"] }
    }
  };
  var mainnet = {
    id: 1,
    network: "homestead",
    name: "Ethereum",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://mainnet.infura.io/v3"],
        webSocket: ["wss://mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://cloudflare-eth.com"]
      },
      public: {
        http: ["https://cloudflare-eth.com"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://etherscan.io"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da",
        blockCreated: 16773775
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  };
  var metis = {
    id: 1088,
    name: "Metis",
    network: "andromeda",
    nativeCurrency: {
      decimals: 18,
      name: "Metis",
      symbol: "METIS"
    },
    rpcUrls: {
      default: { http: ["https://andromeda.metis.io/?owner=1088"] },
      public: { http: ["https://andromeda.metis.io/?owner=1088"] }
    },
    blockExplorers: {
      default: {
        name: "Andromeda Explorer",
        url: "https://andromeda-explorer.metis.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 2338552
      }
    }
  };
  var metisGoerli = {
    id: 599,
    name: "Metis Goerli",
    network: "metis-goerli",
    nativeCurrency: {
      decimals: 18,
      name: "Metis Goerli",
      symbol: "METIS"
    },
    rpcUrls: {
      default: { http: ["https://goerli.gateway.metisdevops.link"] },
      public: { http: ["https://goerli.gateway.metisdevops.link"] }
    },
    blockExplorers: {
      default: {
        name: "Metis Goerli Explorer",
        url: "https://goerli.explorer.metisdevops.link"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1006207
      }
    }
  };
  var moonbaseAlpha = {
    id: 1287,
    name: "Moonbase Alpha",
    network: "moonbase-alpha",
    nativeCurrency: {
      decimals: 18,
      name: "DEV",
      symbol: "DEV"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.api.moonbase.moonbeam.network"],
        webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
      },
      public: {
        http: ["https://rpc.api.moonbase.moonbeam.network"],
        webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonbase.moonscan.io"
      },
      etherscan: {
        name: "Moonscan",
        url: "https://moonbase.moonscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1850686
      }
    },
    testnet: true
  };
  var moonbeam = {
    id: 1284,
    name: "Moonbeam",
    network: "moonbeam",
    nativeCurrency: {
      decimals: 18,
      name: "GLMR",
      symbol: "GLMR"
    },
    rpcUrls: {
      public: {
        http: ["https://moonbeam.public.blastapi.io"],
        webSocket: ["wss://moonbeam.public.blastapi.io"]
      },
      default: {
        http: ["https://moonbeam.public.blastapi.io"],
        webSocket: ["wss://moonbeam.public.blastapi.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonscan.io"
      },
      etherscan: {
        name: "Moonscan",
        url: "https://moonscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 609002
      }
    },
    testnet: false
  };
  var moonriver = {
    id: 1285,
    name: "Moonriver",
    network: "moonriver",
    nativeCurrency: {
      decimals: 18,
      name: "MOVR",
      symbol: "MOVR"
    },
    rpcUrls: {
      public: {
        http: ["https://moonriver.public.blastapi.io"],
        webSocket: ["wss://moonriver.public.blastapi.io"]
      },
      default: {
        http: ["https://moonriver.public.blastapi.io"],
        webSocket: ["wss://moonriver.public.blastapi.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonriver.moonscan.io"
      },
      etherscan: {
        name: "Moonscan",
        url: "https://moonriver.moonscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1597904
      }
    },
    testnet: false
  };
  var neonDevnet = {
    id: 245022926,
    network: "neonDevnet",
    name: "Neon EVM DevNet",
    nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://devnet.neonevm.org"]
      },
      public: {
        http: ["https://devnet.neonevm.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Neonscan",
        url: "https://neonscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 205206112
      }
    },
    testnet: true
  };
  var nexi = {
    id: 4242,
    name: "Nexi",
    network: "nexi",
    nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.chain.nexi.technology"]
      },
      public: {
        http: ["https://rpc.chain.nexi.technology"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "NexiScan",
        url: "https://www.nexiscan.com"
      },
      default: {
        name: "NexiScan",
        url: "https://www.nexiscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
        blockCreated: 25770160
      }
    }
  };
  var oasys = {
    id: 248,
    name: "Oasys",
    network: "oasys",
    nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.mainnet.oasys.games"]
      },
      public: {
        http: ["https://rpc.mainnet.oasys.games"]
      }
    },
    blockExplorers: {
      default: {
        name: "OasysScan",
        url: "https://scan.oasys.games"
      }
    }
  };
  var okc = {
    id: 66,
    name: "OKC",
    network: "okc",
    nativeCurrency: {
      decimals: 18,
      name: "OKT",
      symbol: "OKT"
    },
    rpcUrls: {
      default: { http: ["https://exchainrpc.okex.org"] },
      public: { http: ["https://exchainrpc.okex.org"] }
    },
    blockExplorers: {
      default: { name: "oklink", url: "https://www.oklink.com/okc" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 10364792
      }
    }
  };
  var optimism = {
    id: 10,
    name: "Optimism",
    network: "optimism",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://opt-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://optimism-mainnet.infura.io/v3"],
        webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://mainnet.optimism.io"]
      },
      public: {
        http: ["https://mainnet.optimism.io"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://optimistic.etherscan.io"
      },
      default: {
        name: "Optimism Explorer",
        url: "https://explorer.optimism.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 4286263
      }
    }
  };
  var optimismGoerli = {
    id: 420,
    name: "Optimism Goerli",
    network: "optimism-goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://opt-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://opt-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://optimism-goerli.infura.io/v3"],
        webSocket: ["wss://optimism-goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://goerli.optimism.io"]
      },
      public: {
        http: ["https://goerli.optimism.io"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://goerli-optimism.etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://goerli-optimism.etherscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 49461
      }
    },
    testnet: true
  };
  var polygon = {
    id: 137,
    name: "Polygon",
    network: "matic",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://polygon-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://polygon-mainnet.infura.io/v3"],
        webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://polygon-rpc.com"]
      },
      public: {
        http: ["https://polygon-rpc.com"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "PolygonScan",
        url: "https://polygonscan.com"
      },
      default: {
        name: "PolygonScan",
        url: "https://polygonscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    }
  };
  var polygonMumbai = {
    id: 80001,
    name: "Polygon Mumbai",
    network: "maticmum",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://polygon-mumbai.g.alchemy.com/v2"],
        webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://polygon-mumbai.infura.io/v3"],
        webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
      },
      default: {
        http: ["https://matic-mumbai.chainstacklabs.com"]
      },
      public: {
        http: ["https://matic-mumbai.chainstacklabs.com"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "PolygonScan",
        url: "https://mumbai.polygonscan.com"
      },
      default: {
        name: "PolygonScan",
        url: "https://mumbai.polygonscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    },
    testnet: true
  };
  var polygonZkEvmTestnet = {
    id: 1442,
    name: "Polygon zkEVM Testnet",
    network: "polygon-zkevm-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.public.zkevm-test.net"]
      },
      public: {
        http: ["https://rpc.public.zkevm-test.net"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://explorer.public.zkevm-test.net"
      }
    },
    testnet: true
  };
  var polygonZkEvm = {
    id: 1101,
    name: "Polygon zkEVM",
    network: "polygon-zkevm",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://zkevm-rpc.com"]
      },
      public: {
        http: ["https://zkevm-rpc.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://zkevm.polygonscan.com"
      }
    }
  };
  var pulsechain = {
    id: 369,
    network: "pulsechain",
    name: "Pulsechain",
    nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.pulsechain.com"],
        webSocket: ["wss://ws.pulsechain.com"]
      },
      public: {
        http: ["https://rpc.pulsechain.com"],
        webSocket: ["wss://ws.pulsechain.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://scan.pulsechain.com"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  };
  var pulsechainV4 = {
    id: 943,
    network: "pulsechainV4",
    name: "Pulsechain V4",
    testnet: true,
    nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.v4.testnet.pulsechain.com"],
        webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
      },
      public: {
        http: ["https://rpc.v4.testnet.pulsechain.com"],
        webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://scan.v4.testnet.pulsechain.com"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  };
  var scrollTestnet = {
    id: 534353,
    name: "Scroll Testnet",
    network: "scroll-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://alpha-rpc.scroll.io/l2"],
        webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
      },
      public: {
        http: ["https://alpha-rpc.scroll.io/l2"],
        webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://blockscout.scroll.io"
      }
    },
    testnet: true
  };
  var sepolia = {
    id: 11155111,
    network: "sepolia",
    name: "Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-sepolia.g.alchemy.com/v2"],
        webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://sepolia.infura.io/v3"],
        webSocket: ["wss://sepolia.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.sepolia.org"]
      },
      public: {
        http: ["https://rpc.sepolia.org"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://sepolia.etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://sepolia.etherscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 6507670
      }
    },
    testnet: true
  };
  var skaleBlockBrawlers = {
    id: 391845894,
    name: "SKALE | Block Brawlers",
    network: "skale-brawl",
    nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleCalypso = {
    id: 1564830818,
    name: "SKALE | Calypso NFT Hub",
    network: "skale-calypso",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleCalypsoTestnet = {
    id: 344106930,
    name: "SKALE | Calypso NFT Hub Testnet",
    network: "skale-calypso-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
        ]
      },
      public: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
        ]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var skaleChaosTestnet = {
    id: 1351057110,
    name: "SKALE | Chaos Testnet",
    network: "skale-chaos-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
        ]
      },
      public: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
        ]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var skaleCryptoBlades = {
    id: 1026062157,
    name: "SKALE | CryptoBlades",
    network: "skale-cryptoblades",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleCryptoColosseum = {
    id: 2046399126,
    name: "SKALE | Crypto Colosseum",
    network: "skale-crypto-coloseeum",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleEuropa = {
    id: 2046399126,
    name: "SKALE | Europa Liquidity Hub",
    network: "skale-europa",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleEuropaTestnet = {
    id: 476158412,
    name: "SKALE | Europa Liquidity Hub Testnet",
    network: "skale-europa-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"]
      },
      public: {
        http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var skaleExorde = {
    id: 2139927552,
    name: "SKALE | Exorde",
    network: "skale-exorde",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleHumanProtocol = {
    id: 1273227453,
    name: "SKALE | Human Protocol",
    network: "skale-human-protocol",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleNebula = {
    id: 1482601649,
    name: "SKALE | Nebula Gaming Hub",
    network: "skale-nebula",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleNebulaTestnet = {
    id: 503129905,
    name: "SKALE | Nebula Gaming Hub Testnet",
    network: "skale-nebula-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"]
      },
      public: {
        http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var skaleRazor = {
    id: 278611351,
    name: "SKALE | Razor Network",
    network: "skale-razor",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleTitan = {
    id: 1350216234,
    name: "SKALE | Titan Community Hub",
    network: "skale-titan",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleTitanTestnet = {
    id: 1517929550,
    name: "SKALE | Titan Community Hub Testnet",
    network: "skale-titan-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
        ]
      },
      public: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
        ]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var songbird = {
    id: 19,
    name: "Songbird Mainnet",
    network: "songbird-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "songbird",
      symbol: "SGB"
    },
    rpcUrls: {
      default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] },
      public: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Songbird Explorer",
        url: "https://songbird-explorer.flare.network"
      }
    }
  };
  var songbirdTestnet = {
    id: 16,
    name: "Coston",
    network: "coston",
    nativeCurrency: {
      decimals: 18,
      name: "costonflare",
      symbol: "CFLR"
    },
    rpcUrls: {
      default: { http: ["https://coston-api.flare.network/ext/C/rpc"] },
      public: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Coston Explorer",
        url: "https://coston-explorer.flare.network"
      }
    },
    testnet: true
  };
  var shardeumSphinx = {
    id: 8082,
    name: "Shardeum Sphinx",
    network: "shmSphinx",
    nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sphinx.shardeum.org"]
      },
      public: {
        http: ["https://sphinx.shardeum.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Shardeum Explorer",
        url: "https://explorer-sphinx.shardeum.org"
      }
    },
    testnet: true
  };
  var syscoin = {
    id: 57,
    name: "Syscoin Mainnet",
    network: "syscoin",
    nativeCurrency: {
      decimals: 8,
      name: "Syscoin",
      symbol: "SYS"
    },
    rpcUrls: {
      default: { http: ["https://rpc.syscoin.org"] },
      public: { http: ["https://rpc.syscoin.org"] }
    },
    blockExplorers: {
      default: { name: "SyscoinExplorer", url: "https://explorer.syscoin.org" }
    },
    contracts: {
      multicall3: {
        address: "0x000562033783B1136159E10d976B519C929cdE8e",
        blockCreated: 80637
      }
    }
  };
  var taraxa = {
    id: 841,
    name: "Taraxa Mainnet",
    network: "taraxa",
    nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.mainnet.taraxa.io"]
      },
      public: {
        http: ["https://rpc.mainnet.taraxa.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Taraxa Explorer",
        url: "https://explorer.mainnet.taraxa.io"
      }
    }
  };
  var taraxaTestnet = {
    id: 842,
    name: "Taraxa Testnet",
    network: "taraxa-testnet",
    nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.testnet.taraxa.io"]
      },
      public: {
        http: ["https://rpc.testnet.taraxa.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Taraxa Explorer",
        url: "https://explorer.testnet.taraxa.io"
      }
    },
    testnet: true
  };
  var telos = {
    id: 40,
    name: "Telos",
    network: "telos",
    nativeCurrency: {
      decimals: 18,
      name: "Telos",
      symbol: "TLOS"
    },
    rpcUrls: {
      default: { http: ["https://mainnet.telos.net/evm"] },
      public: { http: ["https://mainnet.telos.net/evm"] }
    },
    blockExplorers: {
      default: {
        name: "Teloscan",
        url: "https://www.teloscan.io/"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 246530709
      }
    }
  };
  var telosTestnet = {
    id: 41,
    name: "Telos",
    network: "telosTestnet",
    nativeCurrency: {
      decimals: 18,
      name: "Telos",
      symbol: "TLOS"
    },
    rpcUrls: {
      default: { http: ["https://testnet.telos.net/evm"] },
      public: { http: ["https://testnet.telos.net/evm"] }
    },
    blockExplorers: {
      default: {
        name: "Teloscan (testnet)",
        url: "https://testnet.teloscan.io/"
      }
    },
    testnet: true
  };
  var thunderTestnet = {
    id: 997,
    name: "5ireChain Thunder Testnet",
    network: "5ireChain",
    nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc-testnet.5ire.network"]
      },
      public: {
        http: ["https://rpc-testnet.5ire.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "5ireChain Explorer",
        url: "https://explorer.5ire.network"
      }
    },
    testnet: true
  };
  var wanchain = {
    id: 888,
    name: "Wanchain",
    network: "wanchain",
    nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://gwan-ssl.wandevs.org:56891",
          "https://gwan2-ssl.wandevs.org"
        ]
      },
      public: {
        http: [
          "https://gwan-ssl.wandevs.org:56891",
          "https://gwan2-ssl.wandevs.org"
        ]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "WanScan",
        url: "https://wanscan.org"
      },
      default: {
        name: "WanScan",
        url: "https://wanscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
        blockCreated: 25312390
      }
    }
  };
  var wanchainTestnet = {
    id: 999,
    name: "Wanchain Testnet",
    network: "wanchainTestnet",
    nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://gwan-ssl.wandevs.org:46891"]
      },
      public: {
        http: ["https://gwan-ssl.wandevs.org:46891"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "WanScanTest",
        url: "https://wanscan.org"
      },
      default: {
        name: "WanScanTest",
        url: "https://wanscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
        blockCreated: 24743448
      }
    },
    testnet: true
  };
  var xdc = {
    id: 50,
    name: "XinFin Network",
    network: "xdc",
    nativeCurrency: {
      decimals: 18,
      name: "XDC",
      symbol: "XDC"
    },
    rpcUrls: {
      default: { http: ["https://rpc.xinfin.network"] },
      public: { http: ["https://rpc.xinfin.network"] }
    },
    blockExplorers: {
      xinfin: { name: "XinFin", url: "https://explorer.xinfin.network" },
      default: { name: "Blocksscan", url: "https://xdc.blocksscan.io" }
    }
  };
  var xdcTestnet = {
    id: 51,
    name: "Apothem Network",
    network: "xdc-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "TXDC",
      symbol: "TXDC"
    },
    rpcUrls: {
      default: { http: ["https://erpc.apothem.network"] },
      public: { http: ["https://erpc.apothem.network"] }
    },
    blockExplorers: {
      xinfin: { name: "XinFin", url: "https://explorer.apothem.network" },
      default: { name: "Blocksscan", url: "https://apothem.blocksscan.io" }
    }
  };
  var zhejiang = {
    id: 1337803,
    network: "zhejiang",
    name: "Zhejiang",
    nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.zhejiang.ethpandaops.io"]
      },
      public: {
        http: ["https://rpc.zhejiang.ethpandaops.io"]
      }
    },
    blockExplorers: {
      beaconchain: {
        name: "Etherscan",
        url: "https://zhejiang.beaconcha.in"
      },
      blockscout: {
        name: "Blockscout",
        url: "https://blockscout.com/eth/zhejiang-testnet"
      },
      default: {
        name: "Beaconchain",
        url: "https://zhejiang.beaconcha.in"
      }
    },
    testnet: true
  };
  var zkSync = {
    id: 324,
    name: "zkSync Era",
    network: "zksync-era",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://mainnet.era.zksync.io"],
        webSocket: ["wss://mainnet.era.zksync.io/ws"]
      },
      public: {
        http: ["https://mainnet.era.zksync.io"],
        webSocket: ["wss://mainnet.era.zksync.io/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "zkExplorer",
        url: "https://explorer.zksync.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0x47898B2C52C957663aE9AB46922dCec150a2272c"
      }
    }
  };
  var zkSyncTestnet = {
    id: 280,
    name: "zkSync Era Testnet",
    network: "zksync-era-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet.era.zksync.dev"],
        webSocket: ["wss://testnet.era.zksync.dev/ws"]
      },
      public: {
        http: ["https://testnet.era.zksync.dev"],
        webSocket: ["wss://testnet.era.zksync.dev/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "zkExplorer",
        url: "https://goerli.explorer.zksync.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0x89e4EDbEC85362a285d7a1D5D255ccD2b8106be2"
      }
    },
    testnet: true
  };

  // node_modules/async-mutex/index.mjs
  var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
  var E_ALREADY_LOCKED = new Error("mutex already locked");
  var E_CANCELED = new Error("request for lock canceled");
  var __awaiter$2 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Semaphore = class {
    constructor(_maxConcurrency, _cancelError = E_CANCELED) {
      this._maxConcurrency = _maxConcurrency;
      this._cancelError = _cancelError;
      this._queue = [];
      this._waiters = [];
      if (_maxConcurrency <= 0) {
        throw new Error("semaphore must be initialized to a positive value");
      }
      this._value = _maxConcurrency;
    }
    acquire() {
      const locked = this.isLocked();
      const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));
      if (!locked)
        this._dispatch();
      return ticketPromise;
    }
    runExclusive(callback) {
      return __awaiter$2(this, void 0, void 0, function* () {
        const [value, release] = yield this.acquire();
        try {
          return yield callback(value);
        } finally {
          release();
        }
      });
    }
    waitForUnlock() {
      return __awaiter$2(this, void 0, void 0, function* () {
        if (!this.isLocked()) {
          return Promise.resolve();
        }
        const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));
        return waitPromise;
      });
    }
    isLocked() {
      return this._value <= 0;
    }
    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */
    release() {
      if (this._maxConcurrency > 1) {
        throw new Error("this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
      }
      if (this._currentReleaser) {
        const releaser = this._currentReleaser;
        this._currentReleaser = void 0;
        releaser();
      }
    }
    cancel() {
      this._queue.forEach((ticket) => ticket.reject(this._cancelError));
      this._queue = [];
    }
    _dispatch() {
      const nextTicket = this._queue.shift();
      if (!nextTicket)
        return;
      let released = false;
      this._currentReleaser = () => {
        if (released)
          return;
        released = true;
        this._value++;
        this._resolveWaiters();
        this._dispatch();
      };
      nextTicket.resolve([this._value--, this._currentReleaser]);
    }
    _resolveWaiters() {
      this._waiters.forEach((waiter) => waiter.resolve());
      this._waiters = [];
    }
  };
  var __awaiter$1 = function(thisArg, _arguments, P4, generator) {
    function adopt(value) {
      return value instanceof P4 ? value : new P4(function(resolve) {
        resolve(value);
      });
    }
    return new (P4 || (P4 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Mutex = class {
    constructor(cancelError) {
      this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const [, releaser] = yield this._semaphore.acquire();
        return releaser;
      });
    }
    runExclusive(callback) {
      return this._semaphore.runExclusive(() => callback());
    }
    isLocked() {
      return this._semaphore.isLocked();
    }
    waitForUnlock() {
      return this._semaphore.waitForUnlock();
    }
    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */
    release() {
      this._semaphore.release();
    }
    cancel() {
      return this._semaphore.cancel();
    }
  };

  // node_modules/@latticexyz/network/dist/index.js
  var import_utils53 = __toESM(require_utils5(), 1);
  var import_nice_grpc_web2 = __toESM(require_lib31(), 1);
  var import_grpc_web = __toESM(require_grpc_web_client_umd(), 1);

  // node_modules/long/index.js
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e) {
  }
  function Long(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c3 = Math.clz32(value & -value);
    return value ? 31 - c3 : c3;
  }
  Long.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache2;
    if (unsigned) {
      value >>>= 0;
      if (cache2 = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache2)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache2 = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache2)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  Long.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str, unsigned, radix3) {
    if (str.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix3 = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return unsigned ? UZERO : ZERO;
    radix3 = radix3 || 10;
    if (radix3 < 2 || 36 < radix3)
      throw RangeError("radix");
    var p2;
    if ((p2 = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p2 === 0) {
      return fromString(str.substring(1), unsigned, radix3).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix3, 8));
    var result = ZERO;
    for (var i4 = 0; i4 < str.length; i4 += 8) {
      var size3 = Math.min(8, str.length - i4), value = parseInt(str.substring(i4, i4 + size3), radix3);
      if (size3 < 8) {
        var power = fromNumber(pow_dbl(radix3, size3));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long.fromString = fromString;
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  Long.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO = fromInt(0);
  Long.ZERO = ZERO;
  var UZERO = fromInt(0, true);
  Long.UZERO = UZERO;
  var ONE = fromInt(1);
  Long.ONE = ONE;
  var UONE = fromInt(1, true);
  Long.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString2(radix3) {
    radix3 = radix3 || 10;
    if (radix3 < 2 || 36 < radix3)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix3), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix3) + rem1.toInt().toString(radix3);
      } else
        return "-" + this.neg().toString(radix3);
    }
    var radixToPower = fromNumber(pow_dbl(radix3, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix3);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
      /* validates */
      other
    );
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
      /* validates */
      other
    ) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
      /* validates */
      other
    ) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add2(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
      return this;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm["mul"](
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (multiplier.isZero())
      return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32)
      return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b4;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b4 = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b4, this.high << numBits | this.low >>> b4, this.unsigned);
    }
    numBits -= 32;
    b4 = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b4, this.low << numBits | this.high >>> b4, this.unsigned);
  };
  LongPrototype.rotl = LongPrototype.rotateLeft;
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b4;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b4 = 32 - numBits;
      return fromBits(this.high << b4 | this.low >>> numBits, this.low << b4 | this.high >>> numBits, this.unsigned);
    }
    numBits -= 32;
    b4 = 32 - numBits;
    return fromBits(this.low << b4 | this.high >>> numBits, this.high << b4 | this.low >>> numBits, this.unsigned);
  };
  LongPrototype.rotr = LongPrototype.rotateRight;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes3(le2) {
    return le2 ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long.fromBytes = function fromBytes2(bytes2, unsigned, le2) {
    return le2 ? Long.fromBytesLE(bytes2, unsigned) : Long.fromBytesBE(bytes2, unsigned);
  };
  Long.fromBytesLE = function fromBytesLE(bytes2, unsigned) {
    return new Long(
      bytes2[0] | bytes2[1] << 8 | bytes2[2] << 16 | bytes2[3] << 24,
      bytes2[4] | bytes2[5] << 8 | bytes2[6] << 16 | bytes2[7] << 24,
      unsigned
    );
  };
  Long.fromBytesBE = function fromBytesBE(bytes2, unsigned) {
    return new Long(
      bytes2[4] << 24 | bytes2[5] << 16 | bytes2[6] << 8 | bytes2[7],
      bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3],
      unsigned
    );
  };
  var long_default = Long;

  // node_modules/@latticexyz/services/dist/ecs-relay.js
  var import_minimal2 = __toESM(require_minimal2(), 1);
  var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw "Unable to locate global object";
  })();
  if (import_minimal2.default.util.Long !== long_default) {
    import_minimal2.default.util.Long = long_default;
    import_minimal2.default.configure();
  }

  // node_modules/@latticexyz/services/dist/faucet.js
  var import_minimal3 = __toESM(require_minimal2(), 1);
  function createBaseLinkedTwitterPair() {
    return { username: "", address: "" };
  }
  var LinkedTwitterPair = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.username !== "") {
        writer.uint32(10).string(message.username);
      }
      if (message.address !== "") {
        writer.uint32(18).string(message.address);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseLinkedTwitterPair();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.username = reader.string();
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.address = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return LinkedTwitterPair.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseLinkedTwitterPair();
      message.username = object2.username ?? "";
      message.address = object2.address ?? "";
      return message;
    }
  };
  function createBaseDripRequest() {
    return { username: "", address: "" };
  }
  var DripRequest = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.username !== "") {
        writer.uint32(10).string(message.username);
      }
      if (message.address !== "") {
        writer.uint32(18).string(message.address);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseDripRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.username = reader.string();
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.address = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return DripRequest.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseDripRequest();
      message.username = object2.username ?? "";
      message.address = object2.address ?? "";
      return message;
    }
  };
  function createBaseDripDevRequest() {
    return { address: "" };
  }
  var DripDevRequest = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.address !== "") {
        writer.uint32(10).string(message.address);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseDripDevRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.address = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return DripDevRequest.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseDripDevRequest();
      message.address = object2.address ?? "";
      return message;
    }
  };
  function createBaseDripResponse() {
    return { dripTxHash: "", ecsTxHash: "" };
  }
  var DripResponse = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.dripTxHash !== "") {
        writer.uint32(10).string(message.dripTxHash);
      }
      if (message.ecsTxHash !== "") {
        writer.uint32(18).string(message.ecsTxHash);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseDripResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.dripTxHash = reader.string();
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.ecsTxHash = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return DripResponse.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseDripResponse();
      message.dripTxHash = object2.dripTxHash ?? "";
      message.ecsTxHash = object2.ecsTxHash ?? "";
      return message;
    }
  };
  function createBaseTimeUntilDripResponse() {
    return { timeUntilDripMinutes: 0, timeUntilDripSeconds: 0 };
  }
  var TimeUntilDripResponse = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.timeUntilDripMinutes !== 0) {
        writer.uint32(9).double(message.timeUntilDripMinutes);
      }
      if (message.timeUntilDripSeconds !== 0) {
        writer.uint32(17).double(message.timeUntilDripSeconds);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseTimeUntilDripResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 9) {
              break;
            }
            message.timeUntilDripMinutes = reader.double();
            continue;
          case 2:
            if (tag != 17) {
              break;
            }
            message.timeUntilDripSeconds = reader.double();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return TimeUntilDripResponse.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseTimeUntilDripResponse();
      message.timeUntilDripMinutes = object2.timeUntilDripMinutes ?? 0;
      message.timeUntilDripSeconds = object2.timeUntilDripSeconds ?? 0;
      return message;
    }
  };
  function createBaseGetLinkedTwittersRequest() {
    return {};
  }
  var GetLinkedTwittersRequest = {
    encode(_18, writer = import_minimal3.default.Writer.create()) {
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetLinkedTwittersRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return GetLinkedTwittersRequest.fromPartial(base ?? {});
    },
    fromPartial(_18) {
      const message = createBaseGetLinkedTwittersRequest();
      return message;
    }
  };
  function createBaseGetLinkedTwittersResponse() {
    return { linkedTwitters: [] };
  }
  var GetLinkedTwittersResponse = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      for (const v7 of message.linkedTwitters) {
        LinkedTwitterPair.encode(v7, writer.uint32(10).fork()).ldelim();
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseGetLinkedTwittersResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.linkedTwitters.push(LinkedTwitterPair.decode(reader, reader.uint32()));
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return GetLinkedTwittersResponse.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseGetLinkedTwittersResponse();
      message.linkedTwitters = object2.linkedTwitters?.map((e) => LinkedTwitterPair.fromPartial(e)) || [];
      return message;
    }
  };
  function createBaseLinkedTwitterForAddressRequest() {
    return { address: "" };
  }
  var LinkedTwitterForAddressRequest = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.address !== "") {
        writer.uint32(10).string(message.address);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseLinkedTwitterForAddressRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.address = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return LinkedTwitterForAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseLinkedTwitterForAddressRequest();
      message.address = object2.address ?? "";
      return message;
    }
  };
  function createBaseLinkedTwitterForAddressResponse() {
    return { username: "" };
  }
  var LinkedTwitterForAddressResponse = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.username !== "") {
        writer.uint32(10).string(message.username);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseLinkedTwitterForAddressResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.username = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return LinkedTwitterForAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseLinkedTwitterForAddressResponse();
      message.username = object2.username ?? "";
      return message;
    }
  };
  function createBaseLinkedAddressForTwitterRequest() {
    return { username: "" };
  }
  var LinkedAddressForTwitterRequest = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.username !== "") {
        writer.uint32(10).string(message.username);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseLinkedAddressForTwitterRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.username = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return LinkedAddressForTwitterRequest.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseLinkedAddressForTwitterRequest();
      message.username = object2.username ?? "";
      return message;
    }
  };
  function createBaseLinkedAddressForTwitterResponse() {
    return { address: "" };
  }
  var LinkedAddressForTwitterResponse = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.address !== "") {
        writer.uint32(10).string(message.address);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseLinkedAddressForTwitterResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.address = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return LinkedAddressForTwitterResponse.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseLinkedAddressForTwitterResponse();
      message.address = object2.address ?? "";
      return message;
    }
  };
  function createBaseSetLinkedTwitterRequest() {
    return { address: "", username: "", signature: "" };
  }
  var SetLinkedTwitterRequest = {
    encode(message, writer = import_minimal3.default.Writer.create()) {
      if (message.address !== "") {
        writer.uint32(10).string(message.address);
      }
      if (message.username !== "") {
        writer.uint32(18).string(message.username);
      }
      if (message.signature !== "") {
        writer.uint32(26).string(message.signature);
      }
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetLinkedTwitterRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag != 10) {
              break;
            }
            message.address = reader.string();
            continue;
          case 2:
            if (tag != 18) {
              break;
            }
            message.username = reader.string();
            continue;
          case 3:
            if (tag != 26) {
              break;
            }
            message.signature = reader.string();
            continue;
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return SetLinkedTwitterRequest.fromPartial(base ?? {});
    },
    fromPartial(object2) {
      const message = createBaseSetLinkedTwitterRequest();
      message.address = object2.address ?? "";
      message.username = object2.username ?? "";
      message.signature = object2.signature ?? "";
      return message;
    }
  };
  function createBaseSetLinkedTwitterResponse() {
    return {};
  }
  var SetLinkedTwitterResponse = {
    encode(_18, writer = import_minimal3.default.Writer.create()) {
      return writer;
    },
    decode(input, length) {
      const reader = input instanceof import_minimal3.default.Reader ? input : import_minimal3.default.Reader.create(input);
      let end = length === void 0 ? reader.len : reader.pos + length;
      const message = createBaseSetLinkedTwitterResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) == 4 || tag == 0) {
          break;
        }
        reader.skipType(tag & 7);
      }
      return message;
    },
    create(base) {
      return SetLinkedTwitterResponse.fromPartial(base ?? {});
    },
    fromPartial(_18) {
      const message = createBaseSetLinkedTwitterResponse();
      return message;
    }
  };
  var FaucetServiceDefinition = {
    name: "FaucetService",
    fullName: "faucet.FaucetService",
    methods: {
      drip: {
        name: "Drip",
        requestType: DripRequest,
        requestStream: false,
        responseType: DripResponse,
        responseStream: false,
        options: {}
      },
      dripDev: {
        name: "DripDev",
        requestType: DripDevRequest,
        requestStream: false,
        responseType: DripResponse,
        responseStream: false,
        options: {}
      },
      dripVerifyTweet: {
        name: "DripVerifyTweet",
        requestType: DripRequest,
        requestStream: false,
        responseType: DripResponse,
        responseStream: false,
        options: {}
      },
      timeUntilDrip: {
        name: "TimeUntilDrip",
        requestType: DripRequest,
        requestStream: false,
        responseType: TimeUntilDripResponse,
        responseStream: false,
        options: {}
      },
      getLinkedTwitters: {
        name: "GetLinkedTwitters",
        requestType: GetLinkedTwittersRequest,
        requestStream: false,
        responseType: GetLinkedTwittersResponse,
        responseStream: false,
        options: {}
      },
      getLinkedTwitterForAddress: {
        name: "GetLinkedTwitterForAddress",
        requestType: LinkedTwitterForAddressRequest,
        requestStream: false,
        responseType: LinkedTwitterForAddressResponse,
        responseStream: false,
        options: {}
      },
      getLinkedAddressForTwitter: {
        name: "GetLinkedAddressForTwitter",
        requestType: LinkedAddressForTwitterRequest,
        requestStream: false,
        responseType: LinkedAddressForTwitterResponse,
        responseStream: false,
        options: {}
      },
      /** Admin utility endpoints for modifying state. Requires a signature with faucet private key. */
      setLinkedTwitter: {
        name: "SetLinkedTwitter",
        requestType: SetLinkedTwitterRequest,
        requestStream: false,
        responseType: SetLinkedTwitterResponse,
        responseStream: false,
        options: {}
      }
    }
  };
  var tsProtoGlobalThis2 = (() => {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw "Unable to locate global object";
  })();
  if (import_minimal3.default.util.Long !== long_default) {
    import_minimal3.default.util.Long = long_default;
    import_minimal3.default.configure();
  }

  // node_modules/@latticexyz/network/dist/index.js
  var import_nice_grpc_web3 = __toESM(require_lib31(), 1);
  var import_meta = {};
  function ee(e, t3) {
    return new import_wallet2.Wallet(e, t3.json);
  }
  function te2(e) {
    let { initialTime: t3, period: a2 } = e, r2 = { currentTime: t3, lastUpdateTime: t3, time$: new ReplaySubject(1), dispose: () => clearInterval(u3), update: n4 }, u3 = s4();
    c3();
    function c3() {
      r2.time$.next(r2.currentTime);
    }
    function s4() {
      return setInterval(() => {
        r2.currentTime += a2, c3();
      }, a2);
    }
    function n4(m5) {
      clearInterval(u3), r2.currentTime = m5, r2.lastUpdateTime = m5, c3(), u3 = s4();
    }
    return r2;
  }
  async function pr(e) {
    let t3 = observable(e), a2 = [], { providers: r2, connected: u3, dispose: c3 } = await ke(computed(() => toJS(t3.provider)));
    a2.push(c3);
    let s4 = computed(() => {
      let o3 = r2.get();
      if (t3.provider.externalProvider)
        return o3.json.getSigner();
      let l4 = t3.privateKey;
      if (l4 && o3)
        return ee(l4, o3);
    }), n4 = t3.provider.externalProvider ? await s4.get()?.getAddress() : void 0, m5 = computed(() => t3.privateKey ? new import_wallet2.Wallet(t3.privateKey).address.toLowerCase() : n4?.toLowerCase()), f5 = computed(() => t3.privateKey ? new import_wallet2.Wallet(t3.privateKey).address : n4), { blockNumber$: b4, dispose: T4 } = we2(r2);
    a2.push(T4);
    let y4 = te2(t3.clock);
    a2.push(y4.dispose);
    let h6 = combineLatest([b4, cr(r2)]).pipe(throttleTime(t3.clock.syncInterval, void 0, { leading: true, trailing: true }), concatMap(([o3, l4]) => l4 ? on(l4.json, o3) : EMPTY), map2((o3) => o3.timestamp * 1e3), filter((o3) => o3 !== y4.lastUpdateTime), filter((o3) => o3 !== y4.currentTime)).subscribe(y4.update);
    a2.push(() => h6?.unsubscribe());
    try {
      let o3 = Object.values({ ...chains_exports, ...dist_exports });
      t3.chainConfig && o3.unshift(t3.chainConfig);
      let l4 = o3.find((d6) => d6.id === t3.chainId), C4 = createPublicClient({ chain: l4, transport: fallback([webSocket2(), http2()]), pollingInterval: t3.provider.options?.pollingInterval ?? t3.clock.period ?? 1e3 }), g5 = t3.privateKey ? privateKeyToAccount(t3.privateKey) : null, i4 = g5 ? createWalletClient({ account: g5, chain: l4, transport: fallback([webSocket2(), http2()]), pollingInterval: t3.provider.options?.pollingInterval ?? t3.clock.period ?? 1e3 }) : null;
      En.next(C4), vn.next(i4);
    } catch (o3) {
      console.error("Could not initialize viem clients, dev tools may not work:", o3);
    }
    return { providers: r2, signer: s4, connected: u3, blockNumber$: b4, dispose: () => {
      for (let o3 of a2)
        o3();
    }, clock: y4, config: t3, connectedAddress: m5, connectedAddressChecksummed: f5 };
  }
  async function br2({ config: e, asyncConfig: t3, signerOrProvider: a2 }) {
    let r2 = computed(() => Ge(e, (s4) => s4 && new Contract(s4.address, s4.abi, a2.get())));
    if (!t3)
      return { contracts: r2, config: e };
    let u3 = await t3(r2.get()), c3 = computed(() => Ge(u3, (s4) => s4 && new Contract(s4.address, s4.abi, a2.get())));
    return { contracts: computed(() => ({ ...r2.get(), ...c3.get() })), config: { ...e, ...u3 } };
  }
  function me2(e, t3, a2, r2) {
    let { concurrency: u3 } = r2 || {}, c3 = Ye2(), s4 = new Mutex(), n4 = observable.box(null), m5 = computed(() => {
      let i4 = t3.connected.get(), d6 = e.get(), p2 = t3.signer.get(), v7 = t3.providers.get()?.json, x8 = n4.get();
      if (!(i4 !== 2 || !d6 || !p2 || !v7 || x8 == null))
        return { contracts: d6, signer: p2, provider: v7, nonce: x8 };
    }), f5 = 0;
    async function b4() {
      runInAction(() => n4.set(null));
      let i4 = await t3.signer.get()?.getTransactionCount() ?? null;
      runInAction(() => n4.set(i4));
    }
    let T4 = autorun(b4);
    function y4() {
      runInAction(() => {
        let i4 = n4.get(), d6 = i4 == null ? null : i4 + 1;
        n4.set(d6);
      });
    }
    function h6(i4, d6, p2) {
      let [v7, x8, P4] = d(), w3 = p2.length > 0 && He2(p2[p2.length - 1]), I4 = w3 ? p2[p2.length - 1] : {}, R4 = w3 ? p2.slice(0, p2.length - 1) : p2, D4 = i4.interface.fragments.find((S3) => S3.name === d6), Te2 = D4 && D4.stateMutability, L3 = I4.gasLimit, we3 = L3 == null ? () => i4.estimateGas[d6](...p2) : () => L3, ve3 = async (S3, xe2) => {
        try {
          let k3 = i4.populateTransaction[d6];
          if (k3 == null)
            throw new Error("Member does not exist.");
          if (!(k3 instanceof Function))
            throw new Error(`Internal TxQueue error: Member is not a function and should not be proxied. Tried to call "${String(d6)}".`);
          let G5 = { gasPrice: a2.getValue(), ...I4, nonce: S3, gasLimit: xe2 };
          r2?.devMode && (G5.gasPrice = 0);
          let E4 = await k3(...R4, G5);
          E4.nonce = S3, E4.chainId = t3.config.chainId;
          let N2;
          try {
            let W4 = await i4.signer.signTransaction(E4);
            N2 = await i4.provider.perform("sendTransaction", { signedTransaction: W4 });
          } catch {
            N2 = (await i4.signer.sendTransaction(E4)).hash;
          }
          let $5 = i4.provider.getTransaction(N2), U7 = async () => (await $5).wait();
          return v7({ hash: N2, wait: U7, response: $5 }), { hash: N2, wait: U7 };
        } catch (k3) {
          throw x8(k3), k3;
        }
      };
      return c3.add(br(), { execute: ve3, estimateGas: we3, cancel: (S3) => x8(S3 ?? new Error("TX_CANCELLED")), stateMutability: Te2 }), o3(), P4;
    }
    async function o3() {
      if (u3 != null && f5 >= u3)
        return;
      let i4 = c3.next();
      if (!i4)
        return;
      f5++, o3();
      let d6 = await s4.runExclusive(async () => {
        let p2, v7 = i4.stateMutability, x8;
        try {
          x8 = await i4.estimateGas();
        } catch (w3) {
          return console.error("[TXQueue] GAS ESTIMATION ERROR", w3), i4.cancel(w3);
        }
        let { nonce: P4 } = await P(m5);
        try {
          return await i4.execute(P4, x8);
        } catch (w3) {
          console.warn("[TXQueue] TXQUEUE EXECUTION FAILED", w3), p2 = w3;
        } finally {
          let w3 = p2 && "transaction" in p2 && i4.stateMutability !== "view", I4 = !p2 && v7 !== "view" || w3, R4 = p2 && ("code" in p2 && p2.code === "NONCE_EXPIRED" || JSON.stringify(p2).includes("transaction already imported"));
          console.log(`[TXQueue] TX Sent (error=${!!p2}, isMutationError=${!!w3} incNonce=${!!I4} resetNonce=${!!R4})`), I4 && y4(), R4 && await b4(), p2 && i4.cancel(p2);
        }
      });
      if (d6?.hash)
        try {
          await d6.wait();
        } catch (p2) {
          console.warn("[TXQueue] tx failed in block", p2), rn(d6.hash, t3.providers.get().json).then((w3) => console.warn("[TXQueue] Revert reason:", w3));
          let P4 = `mud trace --config deploy.json --world ${new URLSearchParams(window.location.search).get("worldAddress")} --tx ${d6.hash}`;
          console.log("---------- DEBUG COMMANDS (RUN IN TERMINAL) -------------"), console.log("Trace:"), console.log(P4), console.log("---------------------------------------------------------");
        }
      f5--, o3();
    }
    function l4(i4) {
      return Ge(i4, (d6, p2) => p2 in BaseContract.prototype || !(d6 instanceof Function) ? d6 : (...v7) => h6(i4, p2, v7));
    }
    let C4 = computed(() => {
      let i4 = m5.get()?.contracts;
      if (i4)
        return Ge(i4, l4);
    });
    return { txQueue: Je(C4), dispose: T4, ready: computed(() => m5 ? true : void 0) };
  }
  function He2(e) {
    return typeof e != "object" || Array.isArray(e) || e === null ? false : "gasLimit" in e || "gasPrice" in e || "maxFeePerGas" in e || "maxPriorityFeePerGas" in e || "nonce" in e || "type" in e || "accessList" in e || "customData" in e || "value" in e || "blockTag" in e || "from" in e;
  }
  function Ye2() {
    let e = /* @__PURE__ */ new Map();
    function t3() {
      return [...e.entries()].sort((n4, m5) => n4[1].priority >= m5[1].priority ? -1 : 1);
    }
    function a2(n4, m5, f5 = 1) {
      e.set(n4, { element: m5, priority: f5 });
    }
    function r2(n4) {
      e.delete(n4);
    }
    function u3(n4, m5) {
      let f5 = e.get(n4);
      f5 && e.set(n4, { ...f5, priority: m5 });
    }
    function c3() {
      if (e.size === 0)
        return;
      let [n4, m5] = t3()[0];
      return e.delete(n4), m5.element;
    }
    function s4() {
      return e.size;
    }
    return { add: a2, remove: r2, setPriority: u3, next: c3, size: s4 };
  }
  function Lr(e, t3) {
    let a2 = t3?.thread || "worker", r2 = new Subject(), u3 = new Subject(), c3;
    e = e || timer(0, 16).pipe(map2(() => Ss));
    let s4 = e.subscribe(r2);
    if (a2 === "worker") {
      let n4 = new Worker(new URL("./workers/Sync.worker.js", import_meta.url), { type: "module" }), m5 = Hr(n4, r2).subscribe(u3);
      c3 = () => {
        n4.terminate(), m5?.unsubscribe(), s4?.unsubscribe();
      };
    } else {
      let n4 = new ct().work(r2).subscribe(u3);
      c3 = () => {
        n4?.unsubscribe(), s4?.unsubscribe();
      };
    }
    return { ecsEvents$: u3, input$: r2, dispose: c3 };
  }
  function Zr2(e, t3) {
    return (a2) => {
      let r2 = [], u3 = Object.values(a2);
      for (let c3 of Object.keys(a2)) {
        let s4 = e.findIndex((n4) => n4 === c3);
        r2.push(Ko[t3[s4]]);
      }
      return import_utils53.defaultAbiCoder.encode(r2, u3);
    };
  }
  function Rn(e) {
    return (0, import_nice_grpc_web3.createClient)(FaucetServiceDefinition, (0, import_nice_grpc_web3.createChannel)(e));
  }
  async function An(e, t3 = { priorityFeeMultiplier: 1 }) {
    let a2 = await e.getChainId(), r2 = { nonce: await e.getTransactionCount() }, u3 = {};
    await s4(t3.priorityFeeMultiplier);
    async function c3(n4, m5, f5, b4 = { retryCount: 0 }) {
      let T4 = `${m5}(${f5.map((y4) => `'${y4}'`).join(",")})`;
      console.log(`executing transaction: ${T4} with nonce ${r2.nonce}`);
      try {
        let { argsWithoutOverrides: y4, overrides: h6 } = Tt3(f5), l4 = { type: 2, gasLimit: h6.gasLimit ?? await n4.estimateGas[m5].apply(null, f5), nonce: r2.nonce++, ...u3, ...h6 }, C4 = await n4.populateTransaction[m5](...y4, l4);
        C4.chainId = a2;
        let g5;
        try {
          let d6 = await e.signTransaction(C4);
          g5 = await e.provider.perform("sendTransaction", { signedTransaction: d6 });
        } catch (d6) {
          console.warn("signing failed, falling back to sendTransaction", d6), g5 = (await e.sendTransaction(C4)).hash;
        }
        xn.next(g5);
        let i4 = e.provider.getTransaction(g5);
        return { hash: g5, tx: i4 };
      } catch (y4) {
        if (y4?.message.includes("transaction already imported")) {
          if (b4.retryCount === 0)
            return s4(t3.priorityFeeMultiplier * 1.1), c3(n4, m5, f5, { retryCount: b4.retryCount++ });
          throw new Error(`Gas estimation error for ${T4}: ${y4?.reason}`);
        }
        throw y4;
      }
    }
    async function s4(n4) {
      let m5 = await e.provider.getFeeData();
      if (!m5.lastBaseFeePerGas)
        throw new Error("Can not fetch lastBaseFeePerGas from RPC");
      u3.maxPriorityFeePerGas = m5.lastBaseFeePerGas.eq(0) ? 0 : Math.floor(15e8 * n4), u3.maxFeePerGas = m5.lastBaseFeePerGas.mul(2).add(u3.maxPriorityFeePerGas);
    }
    return { fastTxExecute: c3, updateFeePerGas: s4, gasConfig: u3, currentNonce: r2 };
  }
  function Tt3(e) {
    let t3 = e.length > 0 && wt2(e[e.length - 1]), a2 = t3 ? e[e.length - 1] : {};
    return { argsWithoutOverrides: t3 ? e.slice(0, e.length - 1) : e, overrides: a2 };
  }
  function wt2(e) {
    return typeof e != "object" || Array.isArray(e) || e === null ? false : "gasLimit" in e || "gasPrice" in e || "maxFeePerGas" in e || "maxPriorityFeePerGas" in e || "nonce" in e || "type" in e || "accessList" in e || "customData" in e || "value" in e || "blockTag" in e || "from" in e;
  }
  var he2 = [{ inputs: [{ internalType: "bytes32", name: "tableId", type: "bytes32" }], name: "snapSync_system_getNumKeysInTable", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "tableId", type: "bytes32" }, { internalType: "uint256", name: "limit", type: "uint256" }, { internalType: "uint256", name: "offset", type: "uint256" }], name: "snapSync_system_getRecords", outputs: [{ components: [{ internalType: "bytes32", name: "tableId", type: "bytes32" }, { internalType: "bytes32[]", name: "keyTuple", type: "bytes32[]" }, { internalType: "bytes", name: "value", type: "bytes" }], internalType: "struct SyncRecord[]", name: "", type: "tuple[]" }], stateMutability: "view", type: "function" }];
  async function Gn(e, t3, a2, r2) {
    let u3 = new Contract(e, he2, r2), c3 = 100, s4 = t3.map((m5) => m5.toHexString()), n4 = [];
    for (let m5 of s4) {
      let f5 = (await u3.callStatic.snapSync_system_getNumKeysInTable(m5, { blockTag: a2 })).toNumber();
      if (f5 === 0)
        continue;
      let b4 = f5, T4 = Math.ceil(f5 / c3);
      for (let y4 = 0; y4 < T4; y4++) {
        let h6 = Math.min(b4, c3), o3 = y4 * c3;
        b4 -= h6;
        let C4 = (await u3.callStatic.snapSync_system_getRecords(m5, h6, o3, { blockTag: a2 })).map((g5) => ({ tableId: f.fromHexString(g5[0]), keyTuple: g5[1], value: g5[2] }));
        n4.push(...C4);
      }
    }
    return n4;
  }

  // node_modules/@latticexyz/std-client/dist/index.js
  var import_react = __toESM(require_react(), 1);

  // node_modules/@latticexyz/world/types/ethers-contracts/factories/IWorldKernel.sol/IWorldKernel__factory.ts
  var _abi = [
    {
      inputs: [
        {
          internalType: "string",
          name: "resource",
          type: "string"
        },
        {
          internalType: "address",
          name: "caller",
          type: "address"
        }
      ],
      name: "AccessDenied",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4"
        }
      ],
      name: "FunctionSelectorExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4"
        }
      ],
      name: "FunctionSelectorNotFound",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "resource",
          type: "string"
        }
      ],
      name: "InvalidSelector",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "module",
          type: "string"
        }
      ],
      name: "ModuleAlreadyInstalled",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "resource",
          type: "string"
        }
      ],
      name: "ResourceExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "resource",
          type: "string"
        }
      ],
      name: "ResourceNotFound",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "system",
          type: "address"
        }
      ],
      name: "SystemExists",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [],
      name: "HelloWorld",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes",
          name: "funcSelectorAndArgs",
          type: "bytes"
        }
      ],
      name: "call",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        }
      ],
      name: "deleteRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract IModule",
          name: "module",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "args",
          type: "bytes"
        }
      ],
      name: "installRootModule",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "byteLengthToPop",
          type: "uint256"
        }
      ],
      name: "popFromField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "dataToPush",
          type: "bytes"
        }
      ],
      name: "pushToField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "setField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "setRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "startByteIndex",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "dataToSet",
          type: "bytes"
        }
      ],
      name: "updateInField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ];
  var IWorldKernel__factory = class {
    static createInterface() {
      return new utils_exports.Interface(_abi);
    }
    static connect(address, signerOrProvider) {
      return new Contract(address, _abi, signerOrProvider);
    }
  };
  IWorldKernel__factory.abi = _abi;

  // node_modules/@latticexyz/solecs/abi/Component.sol/Component.json
  var Component_default = {
    abi: [
      {
        inputs: [],
        name: "BareComponent__NotImplemented",
        type: "error"
      },
      {
        inputs: [],
        name: "OwnableWritable__NotWriter",
        type: "error"
      },
      {
        inputs: [],
        name: "Ownable__NotOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "Ownable__NotTransitiveOwner",
        type: "error"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "writer",
            type: "address"
          }
        ],
        name: "authorizeWriter",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getEntities",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "value",
            type: "bytes"
          }
        ],
        name: "getEntitiesWithValue",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "entity",
            type: "uint256"
          }
        ],
        name: "getRawValue",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSchema",
        outputs: [
          {
            internalType: "string[]",
            name: "keys",
            type: "string[]"
          },
          {
            internalType: "enum LibTypes.SchemaValue[]",
            name: "values",
            type: "uint8[]"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "entity",
            type: "uint256"
          }
        ],
        name: "has",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "indexer",
            type: "address"
          }
        ],
        name: "registerIndexer",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_world",
            type: "address"
          }
        ],
        name: "registerWorld",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "entity",
            type: "uint256"
          }
        ],
        name: "remove",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "entity",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "value",
            type: "bytes"
          }
        ],
        name: "set",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "writer",
            type: "address"
          }
        ],
        name: "unauthorizeWriter",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "world",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "writeAccess",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    bytecode: {
      object: "0x",
      sourceMap: "",
      linkReferences: {}
    },
    deployedBytecode: {
      object: "0x",
      sourceMap: "",
      linkReferences: {}
    },
    methodIdentifiers: {
      "authorizeWriter(address)": "4fef6a38",
      "getEntities()": "31b933b9",
      "getEntitiesWithValue(bytes)": "b361be46",
      "getRawValue(uint256)": "b8bc073d",
      "getSchema()": "6b122fe0",
      "has(uint256)": "cccf7a8e",
      "id()": "af640d0f",
      "owner()": "8da5cb5b",
      "registerIndexer(address)": "75c0669c",
      "registerWorld(address)": "9d2c76b4",
      "remove(uint256)": "4cc82215",
      "set(uint256,bytes)": "8b282947",
      "transferOwnership(address)": "f2fde38b",
      "unauthorizeWriter(address)": "bf4fe57e",
      "world()": "30b67baa",
      "writeAccess(address)": "861eb905"
    },
    rawMetadata: '{"compiler":{"version":"0.8.13+commit.abaa5c0e"},"language":"Solidity","output":{"abi":[{"inputs":[],"name":"BareComponent__NotImplemented","type":"error"},{"inputs":[],"name":"OwnableWritable__NotWriter","type":"error"},{"inputs":[],"name":"Ownable__NotOwner","type":"error"},{"inputs":[],"name":"Ownable__NotTransitiveOwner","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[{"internalType":"address","name":"writer","type":"address"}],"name":"authorizeWriter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getEntities","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"value","type":"bytes"}],"name":"getEntitiesWithValue","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"entity","type":"uint256"}],"name":"getRawValue","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getSchema","outputs":[{"internalType":"string[]","name":"keys","type":"string[]"},{"internalType":"enum LibTypes.SchemaValue[]","name":"values","type":"uint8[]"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint256","name":"entity","type":"uint256"}],"name":"has","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"id","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"indexer","type":"address"}],"name":"registerIndexer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_world","type":"address"}],"name":"registerWorld","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"entity","type":"uint256"}],"name":"remove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"entity","type":"uint256"},{"internalType":"bytes","name":"value","type":"bytes"}],"name":"set","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"writer","type":"address"}],"name":"unauthorizeWriter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"world","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"}],"name":"writeAccess","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"devdoc":{"kind":"dev","methods":{"authorizeWriter(address)":{"params":{"writer":"Address to grant write access to."}},"getEntitiesWithValue(bytes)":{"params":{"value":"Abi-encoded value to get the list of entities with this value for."}},"getRawValue(uint256)":{"params":{"entity":"Entity to get the raw value in this component for."}},"has(uint256)":{"params":{"entity":"Entity to check whether it has a value in this component for."}},"owner()":{"returns":{"_0":"conrtact owner"}},"registerIndexer(address)":{"params":{"indexer":"Address of the indexer to notify when a component value is set."}},"registerWorld(address)":{"params":{"_world":"Address of the World contract."}},"remove(uint256)":{"params":{"entity":"Entity to remove from this component."}},"set(uint256,bytes)":{"params":{"entity":"Entity to set the value for.","value":"Value to set for the given entity."}},"transferOwnership(address)":{"params":{"account":"address of new owner"}},"unauthorizeWriter(address)":{"params":{"writer":"Address to revoke write access."}}},"version":1},"userdoc":{"kind":"user","methods":{"authorizeWriter(address)":{"notice":"Grant write access to the given address. Can only be called by the owner."},"getEntities()":{"notice":"Get a list of all entities that have a value in this component."},"getEntitiesWithValue(bytes)":{"notice":"Get a list of all entities that have the specified value in this component."},"getRawValue(uint256)":{"notice":"Get the raw (abi-encoded) value of the given entity in this component."},"getSchema()":{"notice":"Return the keys and value types of the schema of this component. "},"has(uint256)":{"notice":"Check whether the given entity has a value in this component."},"id()":{"notice":"Public identifier of this component "},"owner()":{"notice":"get the ERC173 contract owner"},"registerIndexer(address)":{"notice":"Register a new indexer that gets notified when a component value is set."},"registerWorld(address)":{"notice":"Register this component in the given world."},"remove(uint256)":{"notice":"Remove the given entity from this component. Registers the update in the World contract. Can only be called by addresses with write access to this component."},"set(uint256,bytes)":{"notice":"Set the given component value for the given entity. Registers the update in the World contract. Can only be called by addresses with write access to this component."},"transferOwnership(address)":{"notice":"transfer contract ownership to new account"},"unauthorizeWriter(address)":{"notice":"Revoke write access from the given address. Can only be called by the owner."},"world()":{"notice":"Reference to the World contract this component is registered in "},"writeAccess(address)":{"notice":"Whether given operator has write access "}},"notice":"Components are a key-value store from entity id to component value. They are registered in the World and register updates to their state in the World. They have an owner, who can grant write access to more addresses. (Systems that want to write to a component need to be given write access first.) Everyone has read access.","version":1}},"settings":{"compilationTarget":{"src/Component.sol":"Component"},"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":true,"runs":3000},"remappings":[":@solidstate/=node_modules/@solidstate/",":ds-test/=node_modules/ds-test/src/",":forge-std/=node_modules/forge-std/src/",":hardhat/=node_modules/hardhat/",":memmove/=node_modules/memmove/src/",":solmate/=node_modules/solmate/src/"]},"sources":{"node_modules/@solidstate/contracts/access/ownable/IOwnable.sol":{"keccak256":"0xd2d21c507ed587cd5de6cc016d4b9c7e956e468108b784455a400301707031c1","license":"MIT","urls":["bzz-raw://091a98176309554295f1d471f888b1567d07e0250b11e23fa540739b6dfdce38","dweb:/ipfs/Qme69DrKhhtwkSBMU456C3NxzXNMC7AJ4sVNMg5rKcrtPn"]},"node_modules/@solidstate/contracts/access/ownable/IOwnableInternal.sol":{"keccak256":"0x6237a634712261bd82d5c7753780d35f77af215406d1e59512052f743f8f1c60","license":"MIT","urls":["bzz-raw://8e54ac6cd1b376224b8d148c704693ff3f7ac9f69954fd30ee3d949fa17210c3","dweb:/ipfs/QmWjq37K3gg29XhFbepg5GbmmFYoyXb81sh2K1MnVZqG6y"]},"node_modules/@solidstate/contracts/access/ownable/Ownable.sol":{"keccak256":"0xe16b09090c1251f8cc97fb2cc10c86675e0d0d9f0fc0032b417c37c8dba2db5f","license":"MIT","urls":["bzz-raw://8482effd630de3e3eb3c66ce6bc5ddd12838381e6e585df42116b4fd7764e4bc","dweb:/ipfs/Qma9ga6QS2SooCYKyB7J5EHE8uUGiAv49kosEyjHt9Zg79"]},"node_modules/@solidstate/contracts/access/ownable/OwnableInternal.sol":{"keccak256":"0x0185d24250a5e6fbafce443b9ba19bba761803e3e5d91ba423bfb1f5f0bbdbf9","license":"MIT","urls":["bzz-raw://547fadeaec559ee824f4dd37b2ef972a061ca59576f5733cf643e00d88a4db52","dweb:/ipfs/QmYx6rmRmZZQkoS8TykMVsz9ZvfQ8MfSPt6UzWJ8pyj8qF"]},"node_modules/@solidstate/contracts/access/ownable/OwnableStorage.sol":{"keccak256":"0x7385e2020de914f75cabdc83c6adf88ed21e9de14669a89b3832b80f4f8c7b73","license":"MIT","urls":["bzz-raw://a367c512bf29fb4923ed5d2454783e3dae88e5e03dec216e65c3986f3c3a8995","dweb:/ipfs/QmfYkD6osr6SQzod6wc7WPae6YvVnYbn2BjJuHrYL3ERXM"]},"node_modules/@solidstate/contracts/interfaces/IERC173.sol":{"keccak256":"0x9b18a5ad66323c65a81ecd62c3536db99115fe69a30b56a04409de941da7deb6","license":"MIT","urls":["bzz-raw://a93684363c5bfd4e31fa2cc2d3402e9451ba61c7dbb404e8e50658610fb2a555","dweb:/ipfs/QmanFgF5v5GjBBrAEYCpaZyXRFRvzLGgB8SQcSEf9Dkj5Q"]},"node_modules/@solidstate/contracts/interfaces/IERC173Internal.sol":{"keccak256":"0x9644c3e56c9ecd1763f8aaa437d5d573a7f64a8d93ad7bea1a9c44beb5911b89","license":"MIT","urls":["bzz-raw://c32cfda38b44878ab196d32eeb72823a9f9904e8193286c787caccfb2e5bfa75","dweb:/ipfs/QmfBNKWUSKaJtYL3JJ3YFioXCVFeeakqQ4cR5XzAxxZkCx"]},"node_modules/@solidstate/contracts/utils/AddressUtils.sol":{"keccak256":"0x7d924db4dbd9210923ab08db77db3c77438014c255fd49fa208ebce283d991bf","license":"MIT","urls":["bzz-raw://5189eebdf91899224a14b4cd5184fa9e67a9b8904e6d88ff9610944d06c63929","dweb:/ipfs/QmRwNhfcp98pPgbzK4i9hbypHLTWPGYpuRCtEJRCTNASRm"]},"node_modules/@solidstate/contracts/utils/UintUtils.sol":{"keccak256":"0x5aaeaea22a0800402c6f2d8ce6185293bc64f74f6c390c1b1c53b624b43972f8","license":"MIT","urls":["bzz-raw://8b1c95c745da8ca4de7b68e65ef9122dab4e748c3ae3c9f5fd5aa7c65887c9d2","dweb:/ipfs/QmX2KURY4JbM4NVFp5KPYsNxoJGA8n8w6SdAFdD5Pasgza"]},"node_modules/memmove/src/Array.sol":{"keccak256":"0x0d7681d3392c34f811cebc9598c5e8f4eef6aba431dca9e1fa87267ba51a4515","license":"MIT","urls":["bzz-raw://0ffb5179dd40ccacadc2cb26ac99e9ea5148796f6d21413d7e0f37913831bea1","dweb:/ipfs/QmfJogaoqook5JgnUZKib6w6khzViUag3EQb1EZ8aUEasQ"]},"node_modules/memmove/src/LinkedList.sol":{"keccak256":"0x2374863d39689178dda92b841e77b835ba8fa550561be23b7861d2e52c0fe8c1","license":"MIT","urls":["bzz-raw://8538ec6ca6be4e1b25b74dfd2139586fa2b9dab8d49d91428ed64dc683884598","dweb:/ipfs/Qma7Z6urenqG5Dzqwe8ouGiFH37mbsJEX83tqjSq1PTnRc"]},"src/BareComponent.sol":{"keccak256":"0x2cd722acd3cad5a9318bd5907a3d9f3849756727a5b2303eaf76aa7ea8caa65a","license":"MIT","urls":["bzz-raw://890e17cd1f2f2ed87c99ca7b9383f7eabb31570989247a81e268a636b163a89a","dweb:/ipfs/QmXJEKkMBQniSwHvC9aqHjRCaMohwkpPT7ssCtkL31j4FA"]},"src/Component.sol":{"keccak256":"0x40085c2f86bf6be7a756015025477aa46308b1618083ece93ae13093881a6874","license":"MIT","urls":["bzz-raw://ca8653540b5674e50abfd4b4898009b472fc7fd2fba456146c1a1c44b615d83a","dweb:/ipfs/QmSqbRng5fHuGUKgkFuNw3BfoefNteYU95sYi4g9QjCCNh"]},"src/LibTypes.sol":{"keccak256":"0xa3898035fd9fa865bcfc9861e3b5ecce36be3196fb27705e50a02fed9831f102","license":"MIT","urls":["bzz-raw://273284a35a950f6d0bc4223d345cf46c59972a00510ddbc4ba695ede38714798","dweb:/ipfs/QmdqzKMaAfKWfBzUsrzsDMWnyxSKJRuEvrc6VTR5VarQaH"]},"src/MapSet.sol":{"keccak256":"0xe1a1f412b22d586c01a3e9e0e0af40893b880260f6765b9a5e23e56154dae1db","license":"MIT","urls":["bzz-raw://f8aeddb1af783e43e8ca8a004954016c9f00d9d217d86454b3a3839ef0981288","dweb:/ipfs/QmegHggcpmgGgL9xbZKqnWMwNMSqvs622MuhyEhR9bVfb9"]},"src/Ownable.sol":{"keccak256":"0x7572ffd98860b2539eacdbb2112ce3d25ad8521c5d95f91e21ea5588a6904209","license":"MIT","urls":["bzz-raw://3516b95146224d3fc04c5cc2818161fa9504a048894f6dd905b1e42307494fc4","dweb:/ipfs/QmTqvvAs1fSLzXVWjAgSt3TtE3MM3M1DFXRzkkSsixtVza"]},"src/OwnableWritable.sol":{"keccak256":"0x0e3e9a7ca8ee0a020753c233db1b757f09f3be37d9ea21614892311e6d29baaf","license":"MIT","urls":["bzz-raw://43d631dfbedce59f2f0d594bfd432eafaaa75e76a381368d309bbadb062ec76c","dweb:/ipfs/QmNjGZPJGAXf26HgMCUk68euquWUkKQ13sEyLMvkjTJ91A"]},"src/OwnableWritableStorage.sol":{"keccak256":"0x9f99bbacdfd6c5b0779bd18d3900dd4f957c5a0d89d5986815fae2eff8254df5","license":"MIT","urls":["bzz-raw://3ee736ebade674846118859290603b8ad2cc91efbe13e3621aa52fb4987cb0b4","dweb:/ipfs/QmNUzZS4LPhBCacrPNjbQXLV4anrvNxQ2yPEPETj3sgbzW"]},"src/Set.sol":{"keccak256":"0xcddfd88e4fd1c183470f470dbe5e6fdd48ed0d26bd1ccefb8070a476bc8ba344","license":"MIT","urls":["bzz-raw://e81ffd8a5b104abd04876a42d613378181009bae9368779223fabc1b1d514e46","dweb:/ipfs/QmUywR2WzJfzPn1bRkd7e6Sy6jo3q9AjuQWU55BHKUiNME"]},"src/interfaces/IComponent.sol":{"keccak256":"0xc25ab58cac1449fcd501ddcc56dade0653a7946adcd9eee2931bc095eda2a6b4","license":"MIT","urls":["bzz-raw://c9505da36322f3b3de4dc0aaf0aec911e76be6cbd091f4d142070a7316df4629","dweb:/ipfs/QmY5aGhwzBV5fXeLRDuzWMUfbPZGGdggbLdARhrkjmPBYW"]},"src/interfaces/IERC173.sol":{"keccak256":"0x2bd9a729a3bfcfc445bc557a914aee17fcaf1c0f74b909b6a91a5d3755a699e9","license":"MIT","urls":["bzz-raw://203741d681a686fb75f0715332e554083733f349100dfe11252c17fbe9cd094e","dweb:/ipfs/QmaBXDHiU4ZdJ8K5jQZ3FfswMpWEqSPsBWGFkJMU2qmmWi"]},"src/interfaces/IEntityContainer.sol":{"keccak256":"0x4506db1dcbdbe68a397107a57bfa3da888a889f14181a90eb728cfecc60700b8","license":"MIT","urls":["bzz-raw://23f5c02d110f5abf6340a08a2a8b7e0b5668f211fe6baf41213e6c4f69dece10","dweb:/ipfs/QmYfKeZMeEUNExsxjkCF5nGdw8KRyPe1t5tcGFTEkP7CkV"]},"src/interfaces/IEntityIndexer.sol":{"keccak256":"0xd89023b2a5e9961be3c9d49d9f7f9ac7dcc416e3f43a8758dc058d1db2eea6b5","license":"MIT","urls":["bzz-raw://3266ea1dd5a7f372f8814db24ac4981730f66fba8e6f90f614246ca5cec529b4","dweb:/ipfs/QmQ71BtaBsDjfke46dndaTBVhyXAHxs5qs7d9GHJwVXuvw"]},"src/interfaces/IOwnableWritable.sol":{"keccak256":"0x804db2685d65f5d4029431c47276b6ac43d3c329ea4ce75358928dbd4d11ee77","license":"MIT","urls":["bzz-raw://a1d85dfe46f678ce4cf3a788092519251a24c2c015f9e858a81111b506b0ee78","dweb:/ipfs/QmVmE4f8axCeh8V2kcs8nxYd27rSiwvXJbDbNCg3VZHSXY"]},"src/interfaces/IUint256Component.sol":{"keccak256":"0x12e2eaa4c5663048343e43a1994c446baacb16a4aacbe314ed5202d878751be9","license":"MIT","urls":["bzz-raw://2d78184a1b1868773f2d5a7cf54bb42bccc666dc75cea14eeed15b8573fd000f","dweb:/ipfs/QmemXPHPB7V8StWR8kZcKt3eDxB78sZFZW4Dp7TcEFTxx9"]},"src/interfaces/IWorld.sol":{"keccak256":"0xd4e257a8c2c2ddceba671d791df0556d40b15b06f6ca479784afb143d2919adf","license":"MIT","urls":["bzz-raw://dcf752a88f0679992ebea18e93de0c13bf0d840c222b764865c889c72349d9e1","dweb:/ipfs/QmaSpUThcJGNkZnz4uAHLJKdhYTeQQCSCKagDaTF8h9DJ7"]},"src/interfaces/Query.sol":{"keccak256":"0x987e47a4d3f076910382b4e8619f607ea15abdedd786d6095bd27126ff6f941c","license":"MIT","urls":["bzz-raw://8c3d57f9da85917b77e1043a179d3b516bc8c00a8880fdcb1bffca7e53169059","dweb:/ipfs/QmaHxqsT1ZpS8toN88qxgbeaDSMvnhYv9J9FMjVnKrMgoP"]}},"version":1}',
    metadata: {
      compiler: {
        version: "0.8.13+commit.abaa5c0e"
      },
      language: "Solidity",
      output: {
        abi: [
          {
            inputs: [],
            type: "error",
            name: "BareComponent__NotImplemented"
          },
          {
            inputs: [],
            type: "error",
            name: "OwnableWritable__NotWriter"
          },
          {
            inputs: [],
            type: "error",
            name: "Ownable__NotOwner"
          },
          {
            inputs: [],
            type: "error",
            name: "Ownable__NotTransitiveOwner"
          },
          {
            inputs: [
              {
                internalType: "address",
                name: "previousOwner",
                type: "address",
                indexed: true
              },
              {
                internalType: "address",
                name: "newOwner",
                type: "address",
                indexed: true
              }
            ],
            type: "event",
            name: "OwnershipTransferred",
            anonymous: false
          },
          {
            inputs: [
              {
                internalType: "address",
                name: "writer",
                type: "address"
              }
            ],
            stateMutability: "nonpayable",
            type: "function",
            name: "authorizeWriter"
          },
          {
            inputs: [],
            stateMutability: "view",
            type: "function",
            name: "getEntities",
            outputs: [
              {
                internalType: "uint256[]",
                name: "",
                type: "uint256[]"
              }
            ]
          },
          {
            inputs: [
              {
                internalType: "bytes",
                name: "value",
                type: "bytes"
              }
            ],
            stateMutability: "view",
            type: "function",
            name: "getEntitiesWithValue",
            outputs: [
              {
                internalType: "uint256[]",
                name: "",
                type: "uint256[]"
              }
            ]
          },
          {
            inputs: [
              {
                internalType: "uint256",
                name: "entity",
                type: "uint256"
              }
            ],
            stateMutability: "view",
            type: "function",
            name: "getRawValue",
            outputs: [
              {
                internalType: "bytes",
                name: "",
                type: "bytes"
              }
            ]
          },
          {
            inputs: [],
            stateMutability: "pure",
            type: "function",
            name: "getSchema",
            outputs: [
              {
                internalType: "string[]",
                name: "keys",
                type: "string[]"
              },
              {
                internalType: "enum LibTypes.SchemaValue[]",
                name: "values",
                type: "uint8[]"
              }
            ]
          },
          {
            inputs: [
              {
                internalType: "uint256",
                name: "entity",
                type: "uint256"
              }
            ],
            stateMutability: "view",
            type: "function",
            name: "has",
            outputs: [
              {
                internalType: "bool",
                name: "",
                type: "bool"
              }
            ]
          },
          {
            inputs: [],
            stateMutability: "view",
            type: "function",
            name: "id",
            outputs: [
              {
                internalType: "uint256",
                name: "",
                type: "uint256"
              }
            ]
          },
          {
            inputs: [],
            stateMutability: "view",
            type: "function",
            name: "owner",
            outputs: [
              {
                internalType: "address",
                name: "",
                type: "address"
              }
            ]
          },
          {
            inputs: [
              {
                internalType: "address",
                name: "indexer",
                type: "address"
              }
            ],
            stateMutability: "nonpayable",
            type: "function",
            name: "registerIndexer"
          },
          {
            inputs: [
              {
                internalType: "address",
                name: "_world",
                type: "address"
              }
            ],
            stateMutability: "nonpayable",
            type: "function",
            name: "registerWorld"
          },
          {
            inputs: [
              {
                internalType: "uint256",
                name: "entity",
                type: "uint256"
              }
            ],
            stateMutability: "nonpayable",
            type: "function",
            name: "remove"
          },
          {
            inputs: [
              {
                internalType: "uint256",
                name: "entity",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "value",
                type: "bytes"
              }
            ],
            stateMutability: "nonpayable",
            type: "function",
            name: "set"
          },
          {
            inputs: [
              {
                internalType: "address",
                name: "account",
                type: "address"
              }
            ],
            stateMutability: "nonpayable",
            type: "function",
            name: "transferOwnership"
          },
          {
            inputs: [
              {
                internalType: "address",
                name: "writer",
                type: "address"
              }
            ],
            stateMutability: "nonpayable",
            type: "function",
            name: "unauthorizeWriter"
          },
          {
            inputs: [],
            stateMutability: "view",
            type: "function",
            name: "world",
            outputs: [
              {
                internalType: "address",
                name: "",
                type: "address"
              }
            ]
          },
          {
            inputs: [
              {
                internalType: "address",
                name: "operator",
                type: "address"
              }
            ],
            stateMutability: "view",
            type: "function",
            name: "writeAccess",
            outputs: [
              {
                internalType: "bool",
                name: "",
                type: "bool"
              }
            ]
          }
        ],
        devdoc: {
          kind: "dev",
          methods: {
            "authorizeWriter(address)": {
              params: {
                writer: "Address to grant write access to."
              }
            },
            "getEntitiesWithValue(bytes)": {
              params: {
                value: "Abi-encoded value to get the list of entities with this value for."
              }
            },
            "getRawValue(uint256)": {
              params: {
                entity: "Entity to get the raw value in this component for."
              }
            },
            "has(uint256)": {
              params: {
                entity: "Entity to check whether it has a value in this component for."
              }
            },
            "owner()": {
              returns: {
                _0: "conrtact owner"
              }
            },
            "registerIndexer(address)": {
              params: {
                indexer: "Address of the indexer to notify when a component value is set."
              }
            },
            "registerWorld(address)": {
              params: {
                _world: "Address of the World contract."
              }
            },
            "remove(uint256)": {
              params: {
                entity: "Entity to remove from this component."
              }
            },
            "set(uint256,bytes)": {
              params: {
                entity: "Entity to set the value for.",
                value: "Value to set for the given entity."
              }
            },
            "transferOwnership(address)": {
              params: {
                account: "address of new owner"
              }
            },
            "unauthorizeWriter(address)": {
              params: {
                writer: "Address to revoke write access."
              }
            }
          },
          version: 1
        },
        userdoc: {
          kind: "user",
          methods: {
            "authorizeWriter(address)": {
              notice: "Grant write access to the given address. Can only be called by the owner."
            },
            "getEntities()": {
              notice: "Get a list of all entities that have a value in this component."
            },
            "getEntitiesWithValue(bytes)": {
              notice: "Get a list of all entities that have the specified value in this component."
            },
            "getRawValue(uint256)": {
              notice: "Get the raw (abi-encoded) value of the given entity in this component."
            },
            "getSchema()": {
              notice: "Return the keys and value types of the schema of this component. "
            },
            "has(uint256)": {
              notice: "Check whether the given entity has a value in this component."
            },
            "id()": {
              notice: "Public identifier of this component "
            },
            "owner()": {
              notice: "get the ERC173 contract owner"
            },
            "registerIndexer(address)": {
              notice: "Register a new indexer that gets notified when a component value is set."
            },
            "registerWorld(address)": {
              notice: "Register this component in the given world."
            },
            "remove(uint256)": {
              notice: "Remove the given entity from this component. Registers the update in the World contract. Can only be called by addresses with write access to this component."
            },
            "set(uint256,bytes)": {
              notice: "Set the given component value for the given entity. Registers the update in the World contract. Can only be called by addresses with write access to this component."
            },
            "transferOwnership(address)": {
              notice: "transfer contract ownership to new account"
            },
            "unauthorizeWriter(address)": {
              notice: "Revoke write access from the given address. Can only be called by the owner."
            },
            "world()": {
              notice: "Reference to the World contract this component is registered in "
            },
            "writeAccess(address)": {
              notice: "Whether given operator has write access "
            }
          },
          version: 1
        }
      },
      settings: {
        remappings: [
          ":@solidstate/=node_modules/@solidstate/",
          ":ds-test/=node_modules/ds-test/src/",
          ":forge-std/=node_modules/forge-std/src/",
          ":hardhat/=node_modules/hardhat/",
          ":memmove/=node_modules/memmove/src/",
          ":solmate/=node_modules/solmate/src/"
        ],
        optimizer: {
          enabled: true,
          runs: 3e3
        },
        metadata: {
          bytecodeHash: "ipfs"
        },
        compilationTarget: {
          "src/Component.sol": "Component"
        },
        libraries: {}
      },
      sources: {
        "node_modules/@solidstate/contracts/access/ownable/IOwnable.sol": {
          keccak256: "0xd2d21c507ed587cd5de6cc016d4b9c7e956e468108b784455a400301707031c1",
          urls: [
            "bzz-raw://091a98176309554295f1d471f888b1567d07e0250b11e23fa540739b6dfdce38",
            "dweb:/ipfs/Qme69DrKhhtwkSBMU456C3NxzXNMC7AJ4sVNMg5rKcrtPn"
          ],
          license: "MIT"
        },
        "node_modules/@solidstate/contracts/access/ownable/IOwnableInternal.sol": {
          keccak256: "0x6237a634712261bd82d5c7753780d35f77af215406d1e59512052f743f8f1c60",
          urls: [
            "bzz-raw://8e54ac6cd1b376224b8d148c704693ff3f7ac9f69954fd30ee3d949fa17210c3",
            "dweb:/ipfs/QmWjq37K3gg29XhFbepg5GbmmFYoyXb81sh2K1MnVZqG6y"
          ],
          license: "MIT"
        },
        "node_modules/@solidstate/contracts/access/ownable/Ownable.sol": {
          keccak256: "0xe16b09090c1251f8cc97fb2cc10c86675e0d0d9f0fc0032b417c37c8dba2db5f",
          urls: [
            "bzz-raw://8482effd630de3e3eb3c66ce6bc5ddd12838381e6e585df42116b4fd7764e4bc",
            "dweb:/ipfs/Qma9ga6QS2SooCYKyB7J5EHE8uUGiAv49kosEyjHt9Zg79"
          ],
          license: "MIT"
        },
        "node_modules/@solidstate/contracts/access/ownable/OwnableInternal.sol": {
          keccak256: "0x0185d24250a5e6fbafce443b9ba19bba761803e3e5d91ba423bfb1f5f0bbdbf9",
          urls: [
            "bzz-raw://547fadeaec559ee824f4dd37b2ef972a061ca59576f5733cf643e00d88a4db52",
            "dweb:/ipfs/QmYx6rmRmZZQkoS8TykMVsz9ZvfQ8MfSPt6UzWJ8pyj8qF"
          ],
          license: "MIT"
        },
        "node_modules/@solidstate/contracts/access/ownable/OwnableStorage.sol": {
          keccak256: "0x7385e2020de914f75cabdc83c6adf88ed21e9de14669a89b3832b80f4f8c7b73",
          urls: [
            "bzz-raw://a367c512bf29fb4923ed5d2454783e3dae88e5e03dec216e65c3986f3c3a8995",
            "dweb:/ipfs/QmfYkD6osr6SQzod6wc7WPae6YvVnYbn2BjJuHrYL3ERXM"
          ],
          license: "MIT"
        },
        "node_modules/@solidstate/contracts/interfaces/IERC173.sol": {
          keccak256: "0x9b18a5ad66323c65a81ecd62c3536db99115fe69a30b56a04409de941da7deb6",
          urls: [
            "bzz-raw://a93684363c5bfd4e31fa2cc2d3402e9451ba61c7dbb404e8e50658610fb2a555",
            "dweb:/ipfs/QmanFgF5v5GjBBrAEYCpaZyXRFRvzLGgB8SQcSEf9Dkj5Q"
          ],
          license: "MIT"
        },
        "node_modules/@solidstate/contracts/interfaces/IERC173Internal.sol": {
          keccak256: "0x9644c3e56c9ecd1763f8aaa437d5d573a7f64a8d93ad7bea1a9c44beb5911b89",
          urls: [
            "bzz-raw://c32cfda38b44878ab196d32eeb72823a9f9904e8193286c787caccfb2e5bfa75",
            "dweb:/ipfs/QmfBNKWUSKaJtYL3JJ3YFioXCVFeeakqQ4cR5XzAxxZkCx"
          ],
          license: "MIT"
        },
        "node_modules/@solidstate/contracts/utils/AddressUtils.sol": {
          keccak256: "0x7d924db4dbd9210923ab08db77db3c77438014c255fd49fa208ebce283d991bf",
          urls: [
            "bzz-raw://5189eebdf91899224a14b4cd5184fa9e67a9b8904e6d88ff9610944d06c63929",
            "dweb:/ipfs/QmRwNhfcp98pPgbzK4i9hbypHLTWPGYpuRCtEJRCTNASRm"
          ],
          license: "MIT"
        },
        "node_modules/@solidstate/contracts/utils/UintUtils.sol": {
          keccak256: "0x5aaeaea22a0800402c6f2d8ce6185293bc64f74f6c390c1b1c53b624b43972f8",
          urls: [
            "bzz-raw://8b1c95c745da8ca4de7b68e65ef9122dab4e748c3ae3c9f5fd5aa7c65887c9d2",
            "dweb:/ipfs/QmX2KURY4JbM4NVFp5KPYsNxoJGA8n8w6SdAFdD5Pasgza"
          ],
          license: "MIT"
        },
        "node_modules/memmove/src/Array.sol": {
          keccak256: "0x0d7681d3392c34f811cebc9598c5e8f4eef6aba431dca9e1fa87267ba51a4515",
          urls: [
            "bzz-raw://0ffb5179dd40ccacadc2cb26ac99e9ea5148796f6d21413d7e0f37913831bea1",
            "dweb:/ipfs/QmfJogaoqook5JgnUZKib6w6khzViUag3EQb1EZ8aUEasQ"
          ],
          license: "MIT"
        },
        "node_modules/memmove/src/LinkedList.sol": {
          keccak256: "0x2374863d39689178dda92b841e77b835ba8fa550561be23b7861d2e52c0fe8c1",
          urls: [
            "bzz-raw://8538ec6ca6be4e1b25b74dfd2139586fa2b9dab8d49d91428ed64dc683884598",
            "dweb:/ipfs/Qma7Z6urenqG5Dzqwe8ouGiFH37mbsJEX83tqjSq1PTnRc"
          ],
          license: "MIT"
        },
        "src/BareComponent.sol": {
          keccak256: "0x2cd722acd3cad5a9318bd5907a3d9f3849756727a5b2303eaf76aa7ea8caa65a",
          urls: [
            "bzz-raw://890e17cd1f2f2ed87c99ca7b9383f7eabb31570989247a81e268a636b163a89a",
            "dweb:/ipfs/QmXJEKkMBQniSwHvC9aqHjRCaMohwkpPT7ssCtkL31j4FA"
          ],
          license: "MIT"
        },
        "src/Component.sol": {
          keccak256: "0x40085c2f86bf6be7a756015025477aa46308b1618083ece93ae13093881a6874",
          urls: [
            "bzz-raw://ca8653540b5674e50abfd4b4898009b472fc7fd2fba456146c1a1c44b615d83a",
            "dweb:/ipfs/QmSqbRng5fHuGUKgkFuNw3BfoefNteYU95sYi4g9QjCCNh"
          ],
          license: "MIT"
        },
        "src/LibTypes.sol": {
          keccak256: "0xa3898035fd9fa865bcfc9861e3b5ecce36be3196fb27705e50a02fed9831f102",
          urls: [
            "bzz-raw://273284a35a950f6d0bc4223d345cf46c59972a00510ddbc4ba695ede38714798",
            "dweb:/ipfs/QmdqzKMaAfKWfBzUsrzsDMWnyxSKJRuEvrc6VTR5VarQaH"
          ],
          license: "MIT"
        },
        "src/MapSet.sol": {
          keccak256: "0xe1a1f412b22d586c01a3e9e0e0af40893b880260f6765b9a5e23e56154dae1db",
          urls: [
            "bzz-raw://f8aeddb1af783e43e8ca8a004954016c9f00d9d217d86454b3a3839ef0981288",
            "dweb:/ipfs/QmegHggcpmgGgL9xbZKqnWMwNMSqvs622MuhyEhR9bVfb9"
          ],
          license: "MIT"
        },
        "src/Ownable.sol": {
          keccak256: "0x7572ffd98860b2539eacdbb2112ce3d25ad8521c5d95f91e21ea5588a6904209",
          urls: [
            "bzz-raw://3516b95146224d3fc04c5cc2818161fa9504a048894f6dd905b1e42307494fc4",
            "dweb:/ipfs/QmTqvvAs1fSLzXVWjAgSt3TtE3MM3M1DFXRzkkSsixtVza"
          ],
          license: "MIT"
        },
        "src/OwnableWritable.sol": {
          keccak256: "0x0e3e9a7ca8ee0a020753c233db1b757f09f3be37d9ea21614892311e6d29baaf",
          urls: [
            "bzz-raw://43d631dfbedce59f2f0d594bfd432eafaaa75e76a381368d309bbadb062ec76c",
            "dweb:/ipfs/QmNjGZPJGAXf26HgMCUk68euquWUkKQ13sEyLMvkjTJ91A"
          ],
          license: "MIT"
        },
        "src/OwnableWritableStorage.sol": {
          keccak256: "0x9f99bbacdfd6c5b0779bd18d3900dd4f957c5a0d89d5986815fae2eff8254df5",
          urls: [
            "bzz-raw://3ee736ebade674846118859290603b8ad2cc91efbe13e3621aa52fb4987cb0b4",
            "dweb:/ipfs/QmNUzZS4LPhBCacrPNjbQXLV4anrvNxQ2yPEPETj3sgbzW"
          ],
          license: "MIT"
        },
        "src/Set.sol": {
          keccak256: "0xcddfd88e4fd1c183470f470dbe5e6fdd48ed0d26bd1ccefb8070a476bc8ba344",
          urls: [
            "bzz-raw://e81ffd8a5b104abd04876a42d613378181009bae9368779223fabc1b1d514e46",
            "dweb:/ipfs/QmUywR2WzJfzPn1bRkd7e6Sy6jo3q9AjuQWU55BHKUiNME"
          ],
          license: "MIT"
        },
        "src/interfaces/IComponent.sol": {
          keccak256: "0xc25ab58cac1449fcd501ddcc56dade0653a7946adcd9eee2931bc095eda2a6b4",
          urls: [
            "bzz-raw://c9505da36322f3b3de4dc0aaf0aec911e76be6cbd091f4d142070a7316df4629",
            "dweb:/ipfs/QmY5aGhwzBV5fXeLRDuzWMUfbPZGGdggbLdARhrkjmPBYW"
          ],
          license: "MIT"
        },
        "src/interfaces/IERC173.sol": {
          keccak256: "0x2bd9a729a3bfcfc445bc557a914aee17fcaf1c0f74b909b6a91a5d3755a699e9",
          urls: [
            "bzz-raw://203741d681a686fb75f0715332e554083733f349100dfe11252c17fbe9cd094e",
            "dweb:/ipfs/QmaBXDHiU4ZdJ8K5jQZ3FfswMpWEqSPsBWGFkJMU2qmmWi"
          ],
          license: "MIT"
        },
        "src/interfaces/IEntityContainer.sol": {
          keccak256: "0x4506db1dcbdbe68a397107a57bfa3da888a889f14181a90eb728cfecc60700b8",
          urls: [
            "bzz-raw://23f5c02d110f5abf6340a08a2a8b7e0b5668f211fe6baf41213e6c4f69dece10",
            "dweb:/ipfs/QmYfKeZMeEUNExsxjkCF5nGdw8KRyPe1t5tcGFTEkP7CkV"
          ],
          license: "MIT"
        },
        "src/interfaces/IEntityIndexer.sol": {
          keccak256: "0xd89023b2a5e9961be3c9d49d9f7f9ac7dcc416e3f43a8758dc058d1db2eea6b5",
          urls: [
            "bzz-raw://3266ea1dd5a7f372f8814db24ac4981730f66fba8e6f90f614246ca5cec529b4",
            "dweb:/ipfs/QmQ71BtaBsDjfke46dndaTBVhyXAHxs5qs7d9GHJwVXuvw"
          ],
          license: "MIT"
        },
        "src/interfaces/IOwnableWritable.sol": {
          keccak256: "0x804db2685d65f5d4029431c47276b6ac43d3c329ea4ce75358928dbd4d11ee77",
          urls: [
            "bzz-raw://a1d85dfe46f678ce4cf3a788092519251a24c2c015f9e858a81111b506b0ee78",
            "dweb:/ipfs/QmVmE4f8axCeh8V2kcs8nxYd27rSiwvXJbDbNCg3VZHSXY"
          ],
          license: "MIT"
        },
        "src/interfaces/IUint256Component.sol": {
          keccak256: "0x12e2eaa4c5663048343e43a1994c446baacb16a4aacbe314ed5202d878751be9",
          urls: [
            "bzz-raw://2d78184a1b1868773f2d5a7cf54bb42bccc666dc75cea14eeed15b8573fd000f",
            "dweb:/ipfs/QmemXPHPB7V8StWR8kZcKt3eDxB78sZFZW4Dp7TcEFTxx9"
          ],
          license: "MIT"
        },
        "src/interfaces/IWorld.sol": {
          keccak256: "0xd4e257a8c2c2ddceba671d791df0556d40b15b06f6ca479784afb143d2919adf",
          urls: [
            "bzz-raw://dcf752a88f0679992ebea18e93de0c13bf0d840c222b764865c889c72349d9e1",
            "dweb:/ipfs/QmaSpUThcJGNkZnz4uAHLJKdhYTeQQCSCKagDaTF8h9DJ7"
          ],
          license: "MIT"
        },
        "src/interfaces/Query.sol": {
          keccak256: "0x987e47a4d3f076910382b4e8619f607ea15abdedd786d6095bd27126ff6f941c",
          urls: [
            "bzz-raw://8c3d57f9da85917b77e1043a179d3b516bc8c00a8880fdcb1bffca7e53169059",
            "dweb:/ipfs/QmaHxqsT1ZpS8toN88qxgbeaDSMvnhYv9J9FMjVnKrMgoP"
          ],
          license: "MIT"
        }
      },
      version: 1
    },
    ast: {
      absolutePath: "src/Component.sol",
      id: 1991,
      exportedSymbols: {
        BareComponent: [
          1727
        ],
        Component: [
          1990
        ],
        IEntityIndexer: [
          5358
        ],
        IWorld: [
          5545
        ],
        LibTypes: [
          3826
        ],
        MapSet: [
          4019
        ],
        Set: [
          4371
        ]
      },
      nodeType: "SourceUnit",
      src: "32:3467:24",
      nodes: [
        {
          id: 1729,
          nodeType: "PragmaDirective",
          src: "32:24:24",
          nodes: [],
          literals: [
            "solidity",
            ">=",
            "0.8",
            ".0"
          ]
        },
        {
          id: 1731,
          nodeType: "ImportDirective",
          src: "58:65:24",
          nodes: [],
          absolutePath: "src/interfaces/IEntityIndexer.sol",
          file: "./interfaces/IEntityIndexer.sol",
          nameLocation: "-1:-1:-1",
          scope: 1991,
          sourceUnit: 5359,
          symbolAliases: [
            {
              foreign: {
                id: 1730,
                name: "IEntityIndexer",
                nodeType: "Identifier",
                overloadedDeclarations: [],
                referencedDeclaration: 5358,
                src: "67:14:24",
                typeDescriptions: {}
              },
              nameLocation: "-1:-1:-1"
            }
          ],
          unitAlias: ""
        },
        {
          id: 1733,
          nodeType: "ImportDirective",
          src: "124:49:24",
          nodes: [],
          absolutePath: "src/interfaces/IWorld.sol",
          file: "./interfaces/IWorld.sol",
          nameLocation: "-1:-1:-1",
          scope: 1991,
          sourceUnit: 5546,
          symbolAliases: [
            {
              foreign: {
                id: 1732,
                name: "IWorld",
                nodeType: "Identifier",
                overloadedDeclarations: [],
                referencedDeclaration: 5545,
                src: "133:6:24",
                typeDescriptions: {}
              },
              nameLocation: "-1:-1:-1"
            }
          ],
          unitAlias: ""
        },
        {
          id: 1735,
          nodeType: "ImportDirective",
          src: "174:52:24",
          nodes: [],
          absolutePath: "src/BareComponent.sol",
          file: "./BareComponent.sol",
          nameLocation: "-1:-1:-1",
          scope: 1991,
          sourceUnit: 1728,
          symbolAliases: [
            {
              foreign: {
                id: 1734,
                name: "BareComponent",
                nodeType: "Identifier",
                overloadedDeclarations: [],
                referencedDeclaration: 1727,
                src: "183:13:24",
                typeDescriptions: {}
              },
              nameLocation: "-1:-1:-1"
            }
          ],
          unitAlias: ""
        },
        {
          id: 1737,
          nodeType: "ImportDirective",
          src: "228:32:24",
          nodes: [],
          absolutePath: "src/Set.sol",
          file: "./Set.sol",
          nameLocation: "-1:-1:-1",
          scope: 1991,
          sourceUnit: 4372,
          symbolAliases: [
            {
              foreign: {
                id: 1736,
                name: "Set",
                nodeType: "Identifier",
                overloadedDeclarations: [],
                referencedDeclaration: 4371,
                src: "237:3:24",
                typeDescriptions: {}
              },
              nameLocation: "-1:-1:-1"
            }
          ],
          unitAlias: ""
        },
        {
          id: 1739,
          nodeType: "ImportDirective",
          src: "261:38:24",
          nodes: [],
          absolutePath: "src/MapSet.sol",
          file: "./MapSet.sol",
          nameLocation: "-1:-1:-1",
          scope: 1991,
          sourceUnit: 4020,
          symbolAliases: [
            {
              foreign: {
                id: 1738,
                name: "MapSet",
                nodeType: "Identifier",
                overloadedDeclarations: [],
                referencedDeclaration: 4019,
                src: "270:6:24",
                typeDescriptions: {}
              },
              nameLocation: "-1:-1:-1"
            }
          ],
          unitAlias: ""
        },
        {
          id: 1741,
          nodeType: "ImportDirective",
          src: "300:42:24",
          nodes: [],
          absolutePath: "src/LibTypes.sol",
          file: "./LibTypes.sol",
          nameLocation: "-1:-1:-1",
          scope: 1991,
          sourceUnit: 3827,
          symbolAliases: [
            {
              foreign: {
                id: 1740,
                name: "LibTypes",
                nodeType: "Identifier",
                overloadedDeclarations: [],
                referencedDeclaration: 3826,
                src: "309:8:24",
                typeDescriptions: {}
              },
              nameLocation: "-1:-1:-1"
            }
          ],
          unitAlias: ""
        },
        {
          id: 1990,
          nodeType: "ContractDefinition",
          src: "691:2807:24",
          nodes: [
            {
              id: 1748,
              nodeType: "VariableDeclaration",
              src: "795:21:24",
              nodes: [],
              constant: false,
              documentation: {
                id: 1745,
                nodeType: "StructuredDocumentation",
                src: "740:52:24",
                text: "Set of entities with values in this component "
              },
              mutability: "mutable",
              name: "entities",
              nameLocation: "808:8:24",
              scope: 1990,
              stateVariable: true,
              storageLocation: "default",
              typeDescriptions: {
                typeIdentifier: "t_contract$_Set_$4371",
                typeString: "contract Set"
              },
              typeName: {
                id: 1747,
                nodeType: "UserDefinedTypeName",
                pathNode: {
                  id: 1746,
                  name: "Set",
                  nodeType: "IdentifierPath",
                  referencedDeclaration: 4371,
                  src: "795:3:24"
                },
                referencedDeclaration: 4371,
                src: "795:3:24",
                typeDescriptions: {
                  typeIdentifier: "t_contract$_Set_$4371",
                  typeString: "contract Set"
                }
              },
              visibility: "internal"
            },
            {
              id: 1752,
              nodeType: "VariableDeclaration",
              src: "876:31:24",
              nodes: [],
              constant: false,
              documentation: {
                id: 1749,
                nodeType: "StructuredDocumentation",
                src: "821:52:24",
                text: "Reverse mapping from value to set of entities "
              },
              mutability: "mutable",
              name: "valueToEntities",
              nameLocation: "892:15:24",
              scope: 1990,
              stateVariable: true,
              storageLocation: "default",
              typeDescriptions: {
                typeIdentifier: "t_contract$_MapSet_$4019",
                typeString: "contract MapSet"
              },
              typeName: {
                id: 1751,
                nodeType: "UserDefinedTypeName",
                pathNode: {
                  id: 1750,
                  name: "MapSet",
                  nodeType: "IdentifierPath",
                  referencedDeclaration: 4019,
                  src: "876:6:24"
                },
                referencedDeclaration: 4019,
                src: "876:6:24",
                typeDescriptions: {
                  typeIdentifier: "t_contract$_MapSet_$4019",
                  typeString: "contract MapSet"
                }
              },
              visibility: "internal"
            },
            {
              id: 1757,
              nodeType: "VariableDeclaration",
              src: "983:34:24",
              nodes: [],
              constant: false,
              documentation: {
                id: 1753,
                nodeType: "StructuredDocumentation",
                src: "912:68:24",
                text: "List of indexers to be updated when a component value changes "
              },
              mutability: "mutable",
              name: "indexers",
              nameLocation: "1009:8:24",
              scope: 1990,
              stateVariable: true,
              storageLocation: "default",
              typeDescriptions: {
                typeIdentifier: "t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage",
                typeString: "contract IEntityIndexer[]"
              },
              typeName: {
                baseType: {
                  id: 1755,
                  nodeType: "UserDefinedTypeName",
                  pathNode: {
                    id: 1754,
                    name: "IEntityIndexer",
                    nodeType: "IdentifierPath",
                    referencedDeclaration: 5358,
                    src: "983:14:24"
                  },
                  referencedDeclaration: 5358,
                  src: "983:14:24",
                  typeDescriptions: {
                    typeIdentifier: "t_contract$_IEntityIndexer_$5358",
                    typeString: "contract IEntityIndexer"
                  }
                },
                id: 1756,
                nodeType: "ArrayTypeName",
                src: "983:16:24",
                typeDescriptions: {
                  typeIdentifier: "t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage_ptr",
                  typeString: "contract IEntityIndexer[]"
                }
              },
              visibility: "internal"
            },
            {
              id: 1783,
              nodeType: "FunctionDefinition",
              src: "1022:135:24",
              nodes: [],
              body: {
                id: 1782,
                nodeType: "Block",
                src: "1090:67:24",
                nodes: [],
                statements: [
                  {
                    expression: {
                      id: 1773,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      lValueRequested: false,
                      leftHandSide: {
                        id: 1768,
                        name: "entities",
                        nodeType: "Identifier",
                        overloadedDeclarations: [],
                        referencedDeclaration: 1748,
                        src: "1096:8:24",
                        typeDescriptions: {
                          typeIdentifier: "t_contract$_Set_$4371",
                          typeString: "contract Set"
                        }
                      },
                      nodeType: "Assignment",
                      operator: "=",
                      rightHandSide: {
                        arguments: [],
                        expression: {
                          argumentTypes: [],
                          id: 1771,
                          isConstant: false,
                          isLValue: false,
                          isPure: false,
                          lValueRequested: false,
                          nodeType: "NewExpression",
                          src: "1107:7:24",
                          typeDescriptions: {
                            typeIdentifier: "t_function_creation_nonpayable$__$returns$_t_contract$_Set_$4371_$",
                            typeString: "function () returns (contract Set)"
                          },
                          typeName: {
                            id: 1770,
                            nodeType: "UserDefinedTypeName",
                            pathNode: {
                              id: 1769,
                              name: "Set",
                              nodeType: "IdentifierPath",
                              referencedDeclaration: 4371,
                              src: "1111:3:24"
                            },
                            referencedDeclaration: 4371,
                            src: "1111:3:24",
                            typeDescriptions: {
                              typeIdentifier: "t_contract$_Set_$4371",
                              typeString: "contract Set"
                            }
                          }
                        },
                        id: 1772,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        kind: "functionCall",
                        lValueRequested: false,
                        names: [],
                        nodeType: "FunctionCall",
                        src: "1107:9:24",
                        tryCall: false,
                        typeDescriptions: {
                          typeIdentifier: "t_contract$_Set_$4371",
                          typeString: "contract Set"
                        }
                      },
                      src: "1096:20:24",
                      typeDescriptions: {
                        typeIdentifier: "t_contract$_Set_$4371",
                        typeString: "contract Set"
                      }
                    },
                    id: 1774,
                    nodeType: "ExpressionStatement",
                    src: "1096:20:24"
                  },
                  {
                    expression: {
                      id: 1780,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      lValueRequested: false,
                      leftHandSide: {
                        id: 1775,
                        name: "valueToEntities",
                        nodeType: "Identifier",
                        overloadedDeclarations: [],
                        referencedDeclaration: 1752,
                        src: "1122:15:24",
                        typeDescriptions: {
                          typeIdentifier: "t_contract$_MapSet_$4019",
                          typeString: "contract MapSet"
                        }
                      },
                      nodeType: "Assignment",
                      operator: "=",
                      rightHandSide: {
                        arguments: [],
                        expression: {
                          argumentTypes: [],
                          id: 1778,
                          isConstant: false,
                          isLValue: false,
                          isPure: false,
                          lValueRequested: false,
                          nodeType: "NewExpression",
                          src: "1140:10:24",
                          typeDescriptions: {
                            typeIdentifier: "t_function_creation_nonpayable$__$returns$_t_contract$_MapSet_$4019_$",
                            typeString: "function () returns (contract MapSet)"
                          },
                          typeName: {
                            id: 1777,
                            nodeType: "UserDefinedTypeName",
                            pathNode: {
                              id: 1776,
                              name: "MapSet",
                              nodeType: "IdentifierPath",
                              referencedDeclaration: 4019,
                              src: "1144:6:24"
                            },
                            referencedDeclaration: 4019,
                            src: "1144:6:24",
                            typeDescriptions: {
                              typeIdentifier: "t_contract$_MapSet_$4019",
                              typeString: "contract MapSet"
                            }
                          }
                        },
                        id: 1779,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        kind: "functionCall",
                        lValueRequested: false,
                        names: [],
                        nodeType: "FunctionCall",
                        src: "1140:12:24",
                        tryCall: false,
                        typeDescriptions: {
                          typeIdentifier: "t_contract$_MapSet_$4019",
                          typeString: "contract MapSet"
                        }
                      },
                      src: "1122:30:24",
                      typeDescriptions: {
                        typeIdentifier: "t_contract$_MapSet_$4019",
                        typeString: "contract MapSet"
                      }
                    },
                    id: 1781,
                    nodeType: "ExpressionStatement",
                    src: "1122:30:24"
                  }
                ]
              },
              implemented: true,
              kind: "constructor",
              modifiers: [
                {
                  arguments: [
                    {
                      id: 1764,
                      name: "_world",
                      nodeType: "Identifier",
                      overloadedDeclarations: [],
                      referencedDeclaration: 1759,
                      src: "1077:6:24",
                      typeDescriptions: {
                        typeIdentifier: "t_address",
                        typeString: "address"
                      }
                    },
                    {
                      id: 1765,
                      name: "_id",
                      nodeType: "Identifier",
                      overloadedDeclarations: [],
                      referencedDeclaration: 1761,
                      src: "1085:3:24",
                      typeDescriptions: {
                        typeIdentifier: "t_uint256",
                        typeString: "uint256"
                      }
                    }
                  ],
                  id: 1766,
                  kind: "baseConstructorSpecifier",
                  modifierName: {
                    id: 1763,
                    name: "BareComponent",
                    nodeType: "IdentifierPath",
                    referencedDeclaration: 1727,
                    src: "1063:13:24"
                  },
                  nodeType: "ModifierInvocation",
                  src: "1063:26:24"
                }
              ],
              name: "",
              nameLocation: "-1:-1:-1",
              parameters: {
                id: 1762,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1759,
                    mutability: "mutable",
                    name: "_world",
                    nameLocation: "1042:6:24",
                    nodeType: "VariableDeclaration",
                    scope: 1783,
                    src: "1034:14:24",
                    stateVariable: false,
                    storageLocation: "default",
                    typeDescriptions: {
                      typeIdentifier: "t_address",
                      typeString: "address"
                    },
                    typeName: {
                      id: 1758,
                      name: "address",
                      nodeType: "ElementaryTypeName",
                      src: "1034:7:24",
                      stateMutability: "nonpayable",
                      typeDescriptions: {
                        typeIdentifier: "t_address",
                        typeString: "address"
                      }
                    },
                    visibility: "internal"
                  },
                  {
                    constant: false,
                    id: 1761,
                    mutability: "mutable",
                    name: "_id",
                    nameLocation: "1058:3:24",
                    nodeType: "VariableDeclaration",
                    scope: 1783,
                    src: "1050:11:24",
                    stateVariable: false,
                    storageLocation: "default",
                    typeDescriptions: {
                      typeIdentifier: "t_uint256",
                      typeString: "uint256"
                    },
                    typeName: {
                      id: 1760,
                      name: "uint256",
                      nodeType: "ElementaryTypeName",
                      src: "1050:7:24",
                      typeDescriptions: {
                        typeIdentifier: "t_uint256",
                        typeString: "uint256"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "1033:29:24"
              },
              returnParameters: {
                id: 1767,
                nodeType: "ParameterList",
                parameters: [],
                src: "1090:0:24"
              },
              scope: 1990,
              stateMutability: "nonpayable",
              virtual: false,
              visibility: "internal"
            },
            {
              id: 1798,
              nodeType: "FunctionDefinition",
              src: "1204:111:24",
              nodes: [],
              body: {
                id: 1797,
                nodeType: "Block",
                src: "1277:38:24",
                nodes: [],
                statements: [
                  {
                    expression: {
                      arguments: [
                        {
                          id: 1794,
                          name: "entity",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1786,
                          src: "1303:6:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        ],
                        expression: {
                          id: 1792,
                          name: "entities",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1748,
                          src: "1290:8:24",
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_Set_$4371",
                            typeString: "contract Set"
                          }
                        },
                        id: 1793,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "has",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 4352,
                        src: "1290:12:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_external_view$_t_uint256_$returns$_t_bool_$",
                          typeString: "function (uint256) view external returns (bool)"
                        }
                      },
                      id: 1795,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "1290:20:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_bool",
                        typeString: "bool"
                      }
                    },
                    functionReturnParameters: 1791,
                    id: 1796,
                    nodeType: "Return",
                    src: "1283:27:24"
                  }
                ]
              },
              baseFunctions: [
                1633
              ],
              documentation: {
                id: 1784,
                nodeType: "StructuredDocumentation",
                src: "1161:40:24",
                text: " @inheritdoc BareComponent"
              },
              functionSelector: "cccf7a8e",
              implemented: true,
              kind: "function",
              modifiers: [],
              name: "has",
              nameLocation: "1213:3:24",
              overrides: {
                id: 1788,
                nodeType: "OverrideSpecifier",
                overrides: [],
                src: "1253:8:24"
              },
              parameters: {
                id: 1787,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1786,
                    mutability: "mutable",
                    name: "entity",
                    nameLocation: "1225:6:24",
                    nodeType: "VariableDeclaration",
                    scope: 1798,
                    src: "1217:14:24",
                    stateVariable: false,
                    storageLocation: "default",
                    typeDescriptions: {
                      typeIdentifier: "t_uint256",
                      typeString: "uint256"
                    },
                    typeName: {
                      id: 1785,
                      name: "uint256",
                      nodeType: "ElementaryTypeName",
                      src: "1217:7:24",
                      typeDescriptions: {
                        typeIdentifier: "t_uint256",
                        typeString: "uint256"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "1216:16:24"
              },
              returnParameters: {
                id: 1791,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1790,
                    mutability: "mutable",
                    name: "",
                    nameLocation: "-1:-1:-1",
                    nodeType: "VariableDeclaration",
                    scope: 1798,
                    src: "1271:4:24",
                    stateVariable: false,
                    storageLocation: "default",
                    typeDescriptions: {
                      typeIdentifier: "t_bool",
                      typeString: "bool"
                    },
                    typeName: {
                      id: 1789,
                      name: "bool",
                      nodeType: "ElementaryTypeName",
                      src: "1271:4:24",
                      typeDescriptions: {
                        typeIdentifier: "t_bool",
                        typeString: "bool"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "1270:6:24"
              },
              scope: 1990,
              stateMutability: "view",
              virtual: true,
              visibility: "public"
            },
            {
              id: 1811,
              nodeType: "FunctionDefinition",
              src: "1400:116:24",
              nodes: [],
              body: {
                id: 1810,
                nodeType: "Block",
                src: "1479:37:24",
                nodes: [],
                statements: [
                  {
                    expression: {
                      arguments: [],
                      expression: {
                        argumentTypes: [],
                        expression: {
                          id: 1806,
                          name: "entities",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1748,
                          src: "1492:8:24",
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_Set_$4371",
                            typeString: "contract Set"
                          }
                        },
                        id: 1807,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "getItems",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 4361,
                        src: "1492:17:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_external_view$__$returns$_t_array$_t_uint256_$dyn_memory_ptr_$",
                          typeString: "function () view external returns (uint256[] memory)"
                        }
                      },
                      id: 1808,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "1492:19:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_array$_t_uint256_$dyn_memory_ptr",
                        typeString: "uint256[] memory"
                      }
                    },
                    functionReturnParameters: 1805,
                    id: 1809,
                    nodeType: "Return",
                    src: "1485:26:24"
                  }
                ]
              },
              baseFunctions: [
                1659
              ],
              documentation: {
                id: 1799,
                nodeType: "StructuredDocumentation",
                src: "1319:78:24",
                text: " Get a list of all entities that have a value in this component."
              },
              functionSelector: "31b933b9",
              implemented: true,
              kind: "function",
              modifiers: [],
              name: "getEntities",
              nameLocation: "1409:11:24",
              overrides: {
                id: 1801,
                nodeType: "OverrideSpecifier",
                overrides: [],
                src: "1443:8:24"
              },
              parameters: {
                id: 1800,
                nodeType: "ParameterList",
                parameters: [],
                src: "1420:2:24"
              },
              returnParameters: {
                id: 1805,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1804,
                    mutability: "mutable",
                    name: "",
                    nameLocation: "-1:-1:-1",
                    nodeType: "VariableDeclaration",
                    scope: 1811,
                    src: "1461:16:24",
                    stateVariable: false,
                    storageLocation: "memory",
                    typeDescriptions: {
                      typeIdentifier: "t_array$_t_uint256_$dyn_memory_ptr",
                      typeString: "uint256[]"
                    },
                    typeName: {
                      baseType: {
                        id: 1802,
                        name: "uint256",
                        nodeType: "ElementaryTypeName",
                        src: "1461:7:24",
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      id: 1803,
                      nodeType: "ArrayTypeName",
                      src: "1461:9:24",
                      typeDescriptions: {
                        typeIdentifier: "t_array$_t_uint256_$dyn_storage_ptr",
                        typeString: "uint256[]"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "1460:18:24"
              },
              scope: 1990,
              stateMutability: "view",
              virtual: true,
              visibility: "public"
            },
            {
              id: 1832,
              nodeType: "FunctionDefinition",
              src: "1698:228:24",
              nodes: [],
              body: {
                id: 1831,
                nodeType: "Block",
                src: "1804:122:24",
                nodes: [],
                statements: [
                  {
                    expression: {
                      arguments: [
                        {
                          arguments: [
                            {
                              arguments: [
                                {
                                  id: 1826,
                                  name: "value",
                                  nodeType: "Identifier",
                                  overloadedDeclarations: [],
                                  referencedDeclaration: 1814,
                                  src: "1913:5:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_bytes_memory_ptr",
                                    typeString: "bytes memory"
                                  }
                                }
                              ],
                              expression: {
                                argumentTypes: [
                                  {
                                    typeIdentifier: "t_bytes_memory_ptr",
                                    typeString: "bytes memory"
                                  }
                                ],
                                id: 1825,
                                name: "keccak256",
                                nodeType: "Identifier",
                                overloadedDeclarations: [],
                                referencedDeclaration: -8,
                                src: "1903:9:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$",
                                  typeString: "function (bytes memory) pure returns (bytes32)"
                                }
                              },
                              id: 1827,
                              isConstant: false,
                              isLValue: false,
                              isPure: false,
                              kind: "functionCall",
                              lValueRequested: false,
                              names: [],
                              nodeType: "FunctionCall",
                              src: "1903:16:24",
                              tryCall: false,
                              typeDescriptions: {
                                typeIdentifier: "t_bytes32",
                                typeString: "bytes32"
                              }
                            }
                          ],
                          expression: {
                            argumentTypes: [
                              {
                                typeIdentifier: "t_bytes32",
                                typeString: "bytes32"
                              }
                            ],
                            id: 1824,
                            isConstant: false,
                            isLValue: false,
                            isPure: true,
                            lValueRequested: false,
                            nodeType: "ElementaryTypeNameExpression",
                            src: "1895:7:24",
                            typeDescriptions: {
                              typeIdentifier: "t_type$_t_uint256_$",
                              typeString: "type(uint256)"
                            },
                            typeName: {
                              id: 1823,
                              name: "uint256",
                              nodeType: "ElementaryTypeName",
                              src: "1895:7:24",
                              typeDescriptions: {}
                            }
                          },
                          id: 1828,
                          isConstant: false,
                          isLValue: false,
                          isPure: false,
                          kind: "typeConversion",
                          lValueRequested: false,
                          names: [],
                          nodeType: "FunctionCall",
                          src: "1895:25:24",
                          tryCall: false,
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        ],
                        expression: {
                          id: 1821,
                          name: "valueToEntities",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1752,
                          src: "1870:15:24",
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_MapSet_$4019",
                            typeString: "contract MapSet"
                          }
                        },
                        id: 1822,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "getItems",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 4005,
                        src: "1870:24:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_external_view$_t_uint256_$returns$_t_array$_t_uint256_$dyn_memory_ptr_$",
                          typeString: "function (uint256) view external returns (uint256[] memory)"
                        }
                      },
                      id: 1829,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "1870:51:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_array$_t_uint256_$dyn_memory_ptr",
                        typeString: "uint256[] memory"
                      }
                    },
                    functionReturnParameters: 1820,
                    id: 1830,
                    nodeType: "Return",
                    src: "1863:58:24"
                  }
                ]
              },
              baseFunctions: [
                1673
              ],
              documentation: {
                id: 1812,
                nodeType: "StructuredDocumentation",
                src: "1520:175:24",
                text: " Get a list of all entities that have the specified value in this component.\n @param value Abi-encoded value to get the list of entities with this value for."
              },
              functionSelector: "b361be46",
              implemented: true,
              kind: "function",
              modifiers: [],
              name: "getEntitiesWithValue",
              nameLocation: "1707:20:24",
              overrides: {
                id: 1816,
                nodeType: "OverrideSpecifier",
                overrides: [],
                src: "1768:8:24"
              },
              parameters: {
                id: 1815,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1814,
                    mutability: "mutable",
                    name: "value",
                    nameLocation: "1741:5:24",
                    nodeType: "VariableDeclaration",
                    scope: 1832,
                    src: "1728:18:24",
                    stateVariable: false,
                    storageLocation: "memory",
                    typeDescriptions: {
                      typeIdentifier: "t_bytes_memory_ptr",
                      typeString: "bytes"
                    },
                    typeName: {
                      id: 1813,
                      name: "bytes",
                      nodeType: "ElementaryTypeName",
                      src: "1728:5:24",
                      typeDescriptions: {
                        typeIdentifier: "t_bytes_storage_ptr",
                        typeString: "bytes"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "1727:20:24"
              },
              returnParameters: {
                id: 1820,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1819,
                    mutability: "mutable",
                    name: "",
                    nameLocation: "-1:-1:-1",
                    nodeType: "VariableDeclaration",
                    scope: 1832,
                    src: "1786:16:24",
                    stateVariable: false,
                    storageLocation: "memory",
                    typeDescriptions: {
                      typeIdentifier: "t_array$_t_uint256_$dyn_memory_ptr",
                      typeString: "uint256[]"
                    },
                    typeName: {
                      baseType: {
                        id: 1817,
                        name: "uint256",
                        nodeType: "ElementaryTypeName",
                        src: "1786:7:24",
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      id: 1818,
                      nodeType: "ArrayTypeName",
                      src: "1786:9:24",
                      typeDescriptions: {
                        typeIdentifier: "t_array$_t_uint256_$dyn_storage_ptr",
                        typeString: "uint256[]"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "1785:18:24"
              },
              scope: 1990,
              stateMutability: "view",
              virtual: true,
              visibility: "public"
            },
            {
              id: 1850,
              nodeType: "FunctionDefinition",
              src: "2104:128:24",
              nodes: [],
              body: {
                id: 1849,
                nodeType: "Block",
                src: "2183:49:24",
                nodes: [],
                statements: [
                  {
                    expression: {
                      arguments: [
                        {
                          arguments: [
                            {
                              id: 1845,
                              name: "indexer",
                              nodeType: "Identifier",
                              overloadedDeclarations: [],
                              referencedDeclaration: 1835,
                              src: "2218:7:24",
                              typeDescriptions: {
                                typeIdentifier: "t_address",
                                typeString: "address"
                              }
                            }
                          ],
                          expression: {
                            argumentTypes: [
                              {
                                typeIdentifier: "t_address",
                                typeString: "address"
                              }
                            ],
                            id: 1844,
                            name: "IEntityIndexer",
                            nodeType: "Identifier",
                            overloadedDeclarations: [],
                            referencedDeclaration: 5358,
                            src: "2203:14:24",
                            typeDescriptions: {
                              typeIdentifier: "t_type$_t_contract$_IEntityIndexer_$5358_$",
                              typeString: "type(contract IEntityIndexer)"
                            }
                          },
                          id: 1846,
                          isConstant: false,
                          isLValue: false,
                          isPure: false,
                          kind: "typeConversion",
                          lValueRequested: false,
                          names: [],
                          nodeType: "FunctionCall",
                          src: "2203:23:24",
                          tryCall: false,
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_IEntityIndexer_$5358",
                            typeString: "contract IEntityIndexer"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_contract$_IEntityIndexer_$5358",
                            typeString: "contract IEntityIndexer"
                          }
                        ],
                        expression: {
                          id: 1841,
                          name: "indexers",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1757,
                          src: "2189:8:24",
                          typeDescriptions: {
                            typeIdentifier: "t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage",
                            typeString: "contract IEntityIndexer[] storage ref"
                          }
                        },
                        id: 1843,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "push",
                        nodeType: "MemberAccess",
                        src: "2189:13:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_arraypush_nonpayable$_t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage_ptr_$_t_contract$_IEntityIndexer_$5358_$returns$__$bound_to$_t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage_ptr_$",
                          typeString: "function (contract IEntityIndexer[] storage pointer,contract IEntityIndexer)"
                        }
                      },
                      id: 1847,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "2189:38:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_tuple$__$",
                        typeString: "tuple()"
                      }
                    },
                    id: 1848,
                    nodeType: "ExpressionStatement",
                    src: "2189:38:24"
                  }
                ]
              },
              baseFunctions: [
                1684
              ],
              documentation: {
                id: 1833,
                nodeType: "StructuredDocumentation",
                src: "1930:171:24",
                text: " Register a new indexer that gets notified when a component value is set.\n @param indexer Address of the indexer to notify when a component value is set."
              },
              functionSelector: "75c0669c",
              implemented: true,
              kind: "function",
              modifiers: [
                {
                  id: 1839,
                  kind: "modifierInvocation",
                  modifierName: {
                    id: 1838,
                    name: "onlyWriter",
                    nodeType: "IdentifierPath",
                    referencedDeclaration: 4089,
                    src: "2172:10:24"
                  },
                  nodeType: "ModifierInvocation",
                  src: "2172:10:24"
                }
              ],
              name: "registerIndexer",
              nameLocation: "2113:15:24",
              overrides: {
                id: 1837,
                nodeType: "OverrideSpecifier",
                overrides: [],
                src: "2163:8:24"
              },
              parameters: {
                id: 1836,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1835,
                    mutability: "mutable",
                    name: "indexer",
                    nameLocation: "2137:7:24",
                    nodeType: "VariableDeclaration",
                    scope: 1850,
                    src: "2129:15:24",
                    stateVariable: false,
                    storageLocation: "default",
                    typeDescriptions: {
                      typeIdentifier: "t_address",
                      typeString: "address"
                    },
                    typeName: {
                      id: 1834,
                      name: "address",
                      nodeType: "ElementaryTypeName",
                      src: "2129:7:24",
                      stateMutability: "nonpayable",
                      typeDescriptions: {
                        typeIdentifier: "t_address",
                        typeString: "address"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "2128:17:24"
              },
              returnParameters: {
                id: 1840,
                nodeType: "ParameterList",
                parameters: [],
                src: "2183:0:24"
              },
              scope: 1990,
              stateMutability: "nonpayable",
              virtual: true,
              visibility: "external"
            },
            {
              id: 1920,
              nodeType: "FunctionDefinition",
              src: "2279:579:24",
              nodes: [],
              body: {
                id: 1919,
                nodeType: "Block",
                src: "2355:503:24",
                nodes: [],
                statements: [
                  {
                    expression: {
                      arguments: [
                        {
                          id: 1862,
                          name: "entity",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1853,
                          src: "2398:6:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        ],
                        expression: {
                          id: 1859,
                          name: "entities",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1748,
                          src: "2385:8:24",
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_Set_$4371",
                            typeString: "contract Set"
                          }
                        },
                        id: 1861,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "add",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 4245,
                        src: "2385:12:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_external_nonpayable$_t_uint256_$returns$__$",
                          typeString: "function (uint256) external"
                        }
                      },
                      id: 1863,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "2385:20:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_tuple$__$",
                        typeString: "tuple()"
                      }
                    },
                    id: 1864,
                    nodeType: "ExpressionStatement",
                    src: "2385:20:24"
                  },
                  {
                    expression: {
                      arguments: [
                        {
                          arguments: [
                            {
                              arguments: [
                                {
                                  baseExpression: {
                                    id: 1871,
                                    name: "entityToValue",
                                    nodeType: "Identifier",
                                    overloadedDeclarations: [],
                                    referencedDeclaration: 1535,
                                    src: "2528:13:24",
                                    typeDescriptions: {
                                      typeIdentifier: "t_mapping$_t_uint256_$_t_bytes_storage_$",
                                      typeString: "mapping(uint256 => bytes storage ref)"
                                    }
                                  },
                                  id: 1873,
                                  indexExpression: {
                                    id: 1872,
                                    name: "entity",
                                    nodeType: "Identifier",
                                    overloadedDeclarations: [],
                                    referencedDeclaration: 1853,
                                    src: "2542:6:24",
                                    typeDescriptions: {
                                      typeIdentifier: "t_uint256",
                                      typeString: "uint256"
                                    }
                                  },
                                  isConstant: false,
                                  isLValue: true,
                                  isPure: false,
                                  lValueRequested: false,
                                  nodeType: "IndexAccess",
                                  src: "2528:21:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_bytes_storage",
                                    typeString: "bytes storage ref"
                                  }
                                }
                              ],
                              expression: {
                                argumentTypes: [
                                  {
                                    typeIdentifier: "t_bytes_storage",
                                    typeString: "bytes storage ref"
                                  }
                                ],
                                id: 1870,
                                name: "keccak256",
                                nodeType: "Identifier",
                                overloadedDeclarations: [],
                                referencedDeclaration: -8,
                                src: "2518:9:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$",
                                  typeString: "function (bytes memory) pure returns (bytes32)"
                                }
                              },
                              id: 1874,
                              isConstant: false,
                              isLValue: false,
                              isPure: false,
                              kind: "functionCall",
                              lValueRequested: false,
                              names: [],
                              nodeType: "FunctionCall",
                              src: "2518:32:24",
                              tryCall: false,
                              typeDescriptions: {
                                typeIdentifier: "t_bytes32",
                                typeString: "bytes32"
                              }
                            }
                          ],
                          expression: {
                            argumentTypes: [
                              {
                                typeIdentifier: "t_bytes32",
                                typeString: "bytes32"
                              }
                            ],
                            id: 1869,
                            isConstant: false,
                            isLValue: false,
                            isPure: true,
                            lValueRequested: false,
                            nodeType: "ElementaryTypeNameExpression",
                            src: "2510:7:24",
                            typeDescriptions: {
                              typeIdentifier: "t_type$_t_uint256_$",
                              typeString: "type(uint256)"
                            },
                            typeName: {
                              id: 1868,
                              name: "uint256",
                              nodeType: "ElementaryTypeName",
                              src: "2510:7:24",
                              typeDescriptions: {}
                            }
                          },
                          id: 1875,
                          isConstant: false,
                          isLValue: false,
                          isPure: false,
                          kind: "typeConversion",
                          lValueRequested: false,
                          names: [],
                          nodeType: "FunctionCall",
                          src: "2510:41:24",
                          tryCall: false,
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        },
                        {
                          id: 1876,
                          name: "entity",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1853,
                          src: "2553:6:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          },
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        ],
                        expression: {
                          id: 1865,
                          name: "valueToEntities",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1752,
                          src: "2487:15:24",
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_MapSet_$4019",
                            typeString: "contract MapSet"
                          }
                        },
                        id: 1867,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "remove",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 3949,
                        src: "2487:22:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_external_nonpayable$_t_uint256_$_t_uint256_$returns$__$",
                          typeString: "function (uint256,uint256) external"
                        }
                      },
                      id: 1877,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "2487:73:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_tuple$__$",
                        typeString: "tuple()"
                      }
                    },
                    id: 1878,
                    nodeType: "ExpressionStatement",
                    src: "2487:73:24"
                  },
                  {
                    expression: {
                      arguments: [
                        {
                          arguments: [
                            {
                              arguments: [
                                {
                                  id: 1885,
                                  name: "value",
                                  nodeType: "Identifier",
                                  overloadedDeclarations: [],
                                  referencedDeclaration: 1855,
                                  src: "2654:5:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_bytes_memory_ptr",
                                    typeString: "bytes memory"
                                  }
                                }
                              ],
                              expression: {
                                argumentTypes: [
                                  {
                                    typeIdentifier: "t_bytes_memory_ptr",
                                    typeString: "bytes memory"
                                  }
                                ],
                                id: 1884,
                                name: "keccak256",
                                nodeType: "Identifier",
                                overloadedDeclarations: [],
                                referencedDeclaration: -8,
                                src: "2644:9:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$",
                                  typeString: "function (bytes memory) pure returns (bytes32)"
                                }
                              },
                              id: 1886,
                              isConstant: false,
                              isLValue: false,
                              isPure: false,
                              kind: "functionCall",
                              lValueRequested: false,
                              names: [],
                              nodeType: "FunctionCall",
                              src: "2644:16:24",
                              tryCall: false,
                              typeDescriptions: {
                                typeIdentifier: "t_bytes32",
                                typeString: "bytes32"
                              }
                            }
                          ],
                          expression: {
                            argumentTypes: [
                              {
                                typeIdentifier: "t_bytes32",
                                typeString: "bytes32"
                              }
                            ],
                            id: 1883,
                            isConstant: false,
                            isLValue: false,
                            isPure: true,
                            lValueRequested: false,
                            nodeType: "ElementaryTypeNameExpression",
                            src: "2636:7:24",
                            typeDescriptions: {
                              typeIdentifier: "t_type$_t_uint256_$",
                              typeString: "type(uint256)"
                            },
                            typeName: {
                              id: 1882,
                              name: "uint256",
                              nodeType: "ElementaryTypeName",
                              src: "2636:7:24",
                              typeDescriptions: {}
                            }
                          },
                          id: 1887,
                          isConstant: false,
                          isLValue: false,
                          isPure: false,
                          kind: "typeConversion",
                          lValueRequested: false,
                          names: [],
                          nodeType: "FunctionCall",
                          src: "2636:25:24",
                          tryCall: false,
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        },
                        {
                          id: 1888,
                          name: "entity",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1853,
                          src: "2663:6:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          },
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        ],
                        expression: {
                          id: 1879,
                          name: "valueToEntities",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1752,
                          src: "2616:15:24",
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_MapSet_$4019",
                            typeString: "contract MapSet"
                          }
                        },
                        id: 1881,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "add",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 3878,
                        src: "2616:19:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_external_nonpayable$_t_uint256_$_t_uint256_$returns$__$",
                          typeString: "function (uint256,uint256) external"
                        }
                      },
                      id: 1889,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "2616:54:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_tuple$__$",
                        typeString: "tuple()"
                      }
                    },
                    id: 1890,
                    nodeType: "ExpressionStatement",
                    src: "2616:54:24"
                  },
                  {
                    expression: {
                      arguments: [
                        {
                          id: 1894,
                          name: "entity",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1853,
                          src: "2739:6:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        },
                        {
                          id: 1895,
                          name: "value",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1855,
                          src: "2747:5:24",
                          typeDescriptions: {
                            typeIdentifier: "t_bytes_memory_ptr",
                            typeString: "bytes memory"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          },
                          {
                            typeIdentifier: "t_bytes_memory_ptr",
                            typeString: "bytes memory"
                          }
                        ],
                        expression: {
                          id: 1891,
                          name: "super",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: -25,
                          src: "2728:5:24",
                          typeDescriptions: {
                            typeIdentifier: "t_type$_t_super$_Component_$1990_$",
                            typeString: "type(contract super Component)"
                          }
                        },
                        id: 1893,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "_set",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 1707,
                        src: "2728:10:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_internal_nonpayable$_t_uint256_$_t_bytes_memory_ptr_$returns$__$",
                          typeString: "function (uint256,bytes memory)"
                        }
                      },
                      id: 1896,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "2728:25:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_tuple$__$",
                        typeString: "tuple()"
                      }
                    },
                    id: 1897,
                    nodeType: "ExpressionStatement",
                    src: "2728:25:24"
                  },
                  {
                    body: {
                      id: 1917,
                      nodeType: "Block",
                      src: "2806:48:24",
                      statements: [
                        {
                          expression: {
                            arguments: [
                              {
                                id: 1913,
                                name: "entity",
                                nodeType: "Identifier",
                                overloadedDeclarations: [],
                                referencedDeclaration: 1853,
                                src: "2833:6:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_uint256",
                                  typeString: "uint256"
                                }
                              },
                              {
                                id: 1914,
                                name: "value",
                                nodeType: "Identifier",
                                overloadedDeclarations: [],
                                referencedDeclaration: 1855,
                                src: "2841:5:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_bytes_memory_ptr",
                                  typeString: "bytes memory"
                                }
                              }
                            ],
                            expression: {
                              argumentTypes: [
                                {
                                  typeIdentifier: "t_uint256",
                                  typeString: "uint256"
                                },
                                {
                                  typeIdentifier: "t_bytes_memory_ptr",
                                  typeString: "bytes memory"
                                }
                              ],
                              expression: {
                                baseExpression: {
                                  id: 1909,
                                  name: "indexers",
                                  nodeType: "Identifier",
                                  overloadedDeclarations: [],
                                  referencedDeclaration: 1757,
                                  src: "2814:8:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage",
                                    typeString: "contract IEntityIndexer[] storage ref"
                                  }
                                },
                                id: 1911,
                                indexExpression: {
                                  id: 1910,
                                  name: "i",
                                  nodeType: "Identifier",
                                  overloadedDeclarations: [],
                                  referencedDeclaration: 1899,
                                  src: "2823:1:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_uint256",
                                    typeString: "uint256"
                                  }
                                },
                                isConstant: false,
                                isLValue: true,
                                isPure: false,
                                lValueRequested: false,
                                nodeType: "IndexAccess",
                                src: "2814:11:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_contract$_IEntityIndexer_$5358",
                                  typeString: "contract IEntityIndexer"
                                }
                              },
                              id: 1912,
                              isConstant: false,
                              isLValue: false,
                              isPure: false,
                              lValueRequested: false,
                              memberName: "update",
                              nodeType: "MemberAccess",
                              referencedDeclaration: 5352,
                              src: "2814:18:24",
                              typeDescriptions: {
                                typeIdentifier: "t_function_external_nonpayable$_t_uint256_$_t_bytes_memory_ptr_$returns$__$",
                                typeString: "function (uint256,bytes memory) external"
                              }
                            },
                            id: 1915,
                            isConstant: false,
                            isLValue: false,
                            isPure: false,
                            kind: "functionCall",
                            lValueRequested: false,
                            names: [],
                            nodeType: "FunctionCall",
                            src: "2814:33:24",
                            tryCall: false,
                            typeDescriptions: {
                              typeIdentifier: "t_tuple$__$",
                              typeString: "tuple()"
                            }
                          },
                          id: 1916,
                          nodeType: "ExpressionStatement",
                          src: "2814:33:24"
                        }
                      ]
                    },
                    condition: {
                      commonType: {
                        typeIdentifier: "t_uint256",
                        typeString: "uint256"
                      },
                      id: 1905,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      lValueRequested: false,
                      leftExpression: {
                        id: 1902,
                        name: "i",
                        nodeType: "Identifier",
                        overloadedDeclarations: [],
                        referencedDeclaration: 1899,
                        src: "2780:1:24",
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      nodeType: "BinaryOperation",
                      operator: "<",
                      rightExpression: {
                        expression: {
                          id: 1903,
                          name: "indexers",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1757,
                          src: "2784:8:24",
                          typeDescriptions: {
                            typeIdentifier: "t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage",
                            typeString: "contract IEntityIndexer[] storage ref"
                          }
                        },
                        id: 1904,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "length",
                        nodeType: "MemberAccess",
                        src: "2784:15:24",
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      src: "2780:19:24",
                      typeDescriptions: {
                        typeIdentifier: "t_bool",
                        typeString: "bool"
                      }
                    },
                    id: 1918,
                    initializationExpression: {
                      assignments: [
                        1899
                      ],
                      declarations: [
                        {
                          constant: false,
                          id: 1899,
                          mutability: "mutable",
                          name: "i",
                          nameLocation: "2773:1:24",
                          nodeType: "VariableDeclaration",
                          scope: 1918,
                          src: "2765:9:24",
                          stateVariable: false,
                          storageLocation: "default",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          },
                          typeName: {
                            id: 1898,
                            name: "uint256",
                            nodeType: "ElementaryTypeName",
                            src: "2765:7:24",
                            typeDescriptions: {
                              typeIdentifier: "t_uint256",
                              typeString: "uint256"
                            }
                          },
                          visibility: "internal"
                        }
                      ],
                      id: 1901,
                      initialValue: {
                        hexValue: "30",
                        id: 1900,
                        isConstant: false,
                        isLValue: false,
                        isPure: true,
                        kind: "number",
                        lValueRequested: false,
                        nodeType: "Literal",
                        src: "2777:1:24",
                        typeDescriptions: {
                          typeIdentifier: "t_rational_0_by_1",
                          typeString: "int_const 0"
                        },
                        value: "0"
                      },
                      nodeType: "VariableDeclarationStatement",
                      src: "2765:13:24"
                    },
                    loopExpression: {
                      expression: {
                        id: 1907,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        nodeType: "UnaryOperation",
                        operator: "++",
                        prefix: false,
                        src: "2801:3:24",
                        subExpression: {
                          id: 1906,
                          name: "i",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1899,
                          src: "2801:1:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        },
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      id: 1908,
                      nodeType: "ExpressionStatement",
                      src: "2801:3:24"
                    },
                    nodeType: "ForStatement",
                    src: "2760:94:24"
                  }
                ]
              },
              baseFunctions: [
                1707
              ],
              documentation: {
                id: 1851,
                nodeType: "StructuredDocumentation",
                src: "2236:40:24",
                text: " @inheritdoc BareComponent"
              },
              implemented: true,
              kind: "function",
              modifiers: [],
              name: "_set",
              nameLocation: "2288:4:24",
              overrides: {
                id: 1857,
                nodeType: "OverrideSpecifier",
                overrides: [],
                src: "2346:8:24"
              },
              parameters: {
                id: 1856,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1853,
                    mutability: "mutable",
                    name: "entity",
                    nameLocation: "2301:6:24",
                    nodeType: "VariableDeclaration",
                    scope: 1920,
                    src: "2293:14:24",
                    stateVariable: false,
                    storageLocation: "default",
                    typeDescriptions: {
                      typeIdentifier: "t_uint256",
                      typeString: "uint256"
                    },
                    typeName: {
                      id: 1852,
                      name: "uint256",
                      nodeType: "ElementaryTypeName",
                      src: "2293:7:24",
                      typeDescriptions: {
                        typeIdentifier: "t_uint256",
                        typeString: "uint256"
                      }
                    },
                    visibility: "internal"
                  },
                  {
                    constant: false,
                    id: 1855,
                    mutability: "mutable",
                    name: "value",
                    nameLocation: "2322:5:24",
                    nodeType: "VariableDeclaration",
                    scope: 1920,
                    src: "2309:18:24",
                    stateVariable: false,
                    storageLocation: "memory",
                    typeDescriptions: {
                      typeIdentifier: "t_bytes_memory_ptr",
                      typeString: "bytes"
                    },
                    typeName: {
                      id: 1854,
                      name: "bytes",
                      nodeType: "ElementaryTypeName",
                      src: "2309:5:24",
                      typeDescriptions: {
                        typeIdentifier: "t_bytes_storage_ptr",
                        typeString: "bytes"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "2292:36:24"
              },
              returnParameters: {
                id: 1858,
                nodeType: "ParameterList",
                parameters: [],
                src: "2355:0:24"
              },
              scope: 1990,
              stateMutability: "nonpayable",
              virtual: true,
              visibility: "internal"
            },
            {
              id: 1989,
              nodeType: "FunctionDefinition",
              src: "2905:591:24",
              nodes: [],
              body: {
                id: 1988,
                nodeType: "Block",
                src: "2964:532:24",
                nodes: [],
                statements: [
                  {
                    condition: {
                      commonType: {
                        typeIdentifier: "t_uint256",
                        typeString: "uint256"
                      },
                      id: 1939,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      lValueRequested: false,
                      leftExpression: {
                        arguments: [
                          {
                            arguments: [
                              {
                                arguments: [
                                  {
                                    baseExpression: {
                                      id: 1932,
                                      name: "entityToValue",
                                      nodeType: "Identifier",
                                      overloadedDeclarations: [],
                                      referencedDeclaration: 1535,
                                      src: "3066:13:24",
                                      typeDescriptions: {
                                        typeIdentifier: "t_mapping$_t_uint256_$_t_bytes_storage_$",
                                        typeString: "mapping(uint256 => bytes storage ref)"
                                      }
                                    },
                                    id: 1934,
                                    indexExpression: {
                                      id: 1933,
                                      name: "entity",
                                      nodeType: "Identifier",
                                      overloadedDeclarations: [],
                                      referencedDeclaration: 1923,
                                      src: "3080:6:24",
                                      typeDescriptions: {
                                        typeIdentifier: "t_uint256",
                                        typeString: "uint256"
                                      }
                                    },
                                    isConstant: false,
                                    isLValue: true,
                                    isPure: false,
                                    lValueRequested: false,
                                    nodeType: "IndexAccess",
                                    src: "3066:21:24",
                                    typeDescriptions: {
                                      typeIdentifier: "t_bytes_storage",
                                      typeString: "bytes storage ref"
                                    }
                                  }
                                ],
                                expression: {
                                  argumentTypes: [
                                    {
                                      typeIdentifier: "t_bytes_storage",
                                      typeString: "bytes storage ref"
                                    }
                                  ],
                                  id: 1931,
                                  name: "keccak256",
                                  nodeType: "Identifier",
                                  overloadedDeclarations: [],
                                  referencedDeclaration: -8,
                                  src: "3056:9:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$",
                                    typeString: "function (bytes memory) pure returns (bytes32)"
                                  }
                                },
                                id: 1935,
                                isConstant: false,
                                isLValue: false,
                                isPure: false,
                                kind: "functionCall",
                                lValueRequested: false,
                                names: [],
                                nodeType: "FunctionCall",
                                src: "3056:32:24",
                                tryCall: false,
                                typeDescriptions: {
                                  typeIdentifier: "t_bytes32",
                                  typeString: "bytes32"
                                }
                              }
                            ],
                            expression: {
                              argumentTypes: [
                                {
                                  typeIdentifier: "t_bytes32",
                                  typeString: "bytes32"
                                }
                              ],
                              id: 1930,
                              isConstant: false,
                              isLValue: false,
                              isPure: true,
                              lValueRequested: false,
                              nodeType: "ElementaryTypeNameExpression",
                              src: "3048:7:24",
                              typeDescriptions: {
                                typeIdentifier: "t_type$_t_uint256_$",
                                typeString: "type(uint256)"
                              },
                              typeName: {
                                id: 1929,
                                name: "uint256",
                                nodeType: "ElementaryTypeName",
                                src: "3048:7:24",
                                typeDescriptions: {}
                              }
                            },
                            id: 1936,
                            isConstant: false,
                            isLValue: false,
                            isPure: false,
                            kind: "typeConversion",
                            lValueRequested: false,
                            names: [],
                            nodeType: "FunctionCall",
                            src: "3048:41:24",
                            tryCall: false,
                            typeDescriptions: {
                              typeIdentifier: "t_uint256",
                              typeString: "uint256"
                            }
                          }
                        ],
                        expression: {
                          argumentTypes: [
                            {
                              typeIdentifier: "t_uint256",
                              typeString: "uint256"
                            }
                          ],
                          expression: {
                            id: 1927,
                            name: "valueToEntities",
                            nodeType: "Identifier",
                            overloadedDeclarations: [],
                            referencedDeclaration: 1752,
                            src: "3027:15:24",
                            typeDescriptions: {
                              typeIdentifier: "t_contract$_MapSet_$4019",
                              typeString: "contract MapSet"
                            }
                          },
                          id: 1928,
                          isConstant: false,
                          isLValue: false,
                          isPure: false,
                          lValueRequested: false,
                          memberName: "size",
                          nodeType: "MemberAccess",
                          referencedDeclaration: 4018,
                          src: "3027:20:24",
                          typeDescriptions: {
                            typeIdentifier: "t_function_external_view$_t_uint256_$returns$_t_uint256_$",
                            typeString: "function (uint256) view external returns (uint256)"
                          }
                        },
                        id: 1937,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        kind: "functionCall",
                        lValueRequested: false,
                        names: [],
                        nodeType: "FunctionCall",
                        src: "3027:63:24",
                        tryCall: false,
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      nodeType: "BinaryOperation",
                      operator: "==",
                      rightExpression: {
                        hexValue: "30",
                        id: 1938,
                        isConstant: false,
                        isLValue: false,
                        isPure: true,
                        kind: "number",
                        lValueRequested: false,
                        nodeType: "Literal",
                        src: "3094:1:24",
                        typeDescriptions: {
                          typeIdentifier: "t_rational_0_by_1",
                          typeString: "int_const 0"
                        },
                        value: "0"
                      },
                      src: "3027:68:24",
                      typeDescriptions: {
                        typeIdentifier: "t_bool",
                        typeString: "bool"
                      }
                    },
                    id: 1941,
                    nodeType: "IfStatement",
                    src: "3023:81:24",
                    trueBody: {
                      functionReturnParameters: 1926,
                      id: 1940,
                      nodeType: "Return",
                      src: "3097:7:24"
                    }
                  },
                  {
                    expression: {
                      arguments: [
                        {
                          arguments: [
                            {
                              arguments: [
                                {
                                  baseExpression: {
                                    id: 1948,
                                    name: "entityToValue",
                                    nodeType: "Identifier",
                                    overloadedDeclarations: [],
                                    referencedDeclaration: 1535,
                                    src: "3201:13:24",
                                    typeDescriptions: {
                                      typeIdentifier: "t_mapping$_t_uint256_$_t_bytes_storage_$",
                                      typeString: "mapping(uint256 => bytes storage ref)"
                                    }
                                  },
                                  id: 1950,
                                  indexExpression: {
                                    id: 1949,
                                    name: "entity",
                                    nodeType: "Identifier",
                                    overloadedDeclarations: [],
                                    referencedDeclaration: 1923,
                                    src: "3215:6:24",
                                    typeDescriptions: {
                                      typeIdentifier: "t_uint256",
                                      typeString: "uint256"
                                    }
                                  },
                                  isConstant: false,
                                  isLValue: true,
                                  isPure: false,
                                  lValueRequested: false,
                                  nodeType: "IndexAccess",
                                  src: "3201:21:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_bytes_storage",
                                    typeString: "bytes storage ref"
                                  }
                                }
                              ],
                              expression: {
                                argumentTypes: [
                                  {
                                    typeIdentifier: "t_bytes_storage",
                                    typeString: "bytes storage ref"
                                  }
                                ],
                                id: 1947,
                                name: "keccak256",
                                nodeType: "Identifier",
                                overloadedDeclarations: [],
                                referencedDeclaration: -8,
                                src: "3191:9:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_function_keccak256_pure$_t_bytes_memory_ptr_$returns$_t_bytes32_$",
                                  typeString: "function (bytes memory) pure returns (bytes32)"
                                }
                              },
                              id: 1951,
                              isConstant: false,
                              isLValue: false,
                              isPure: false,
                              kind: "functionCall",
                              lValueRequested: false,
                              names: [],
                              nodeType: "FunctionCall",
                              src: "3191:32:24",
                              tryCall: false,
                              typeDescriptions: {
                                typeIdentifier: "t_bytes32",
                                typeString: "bytes32"
                              }
                            }
                          ],
                          expression: {
                            argumentTypes: [
                              {
                                typeIdentifier: "t_bytes32",
                                typeString: "bytes32"
                              }
                            ],
                            id: 1946,
                            isConstant: false,
                            isLValue: false,
                            isPure: true,
                            lValueRequested: false,
                            nodeType: "ElementaryTypeNameExpression",
                            src: "3183:7:24",
                            typeDescriptions: {
                              typeIdentifier: "t_type$_t_uint256_$",
                              typeString: "type(uint256)"
                            },
                            typeName: {
                              id: 1945,
                              name: "uint256",
                              nodeType: "ElementaryTypeName",
                              src: "3183:7:24",
                              typeDescriptions: {}
                            }
                          },
                          id: 1952,
                          isConstant: false,
                          isLValue: false,
                          isPure: false,
                          kind: "typeConversion",
                          lValueRequested: false,
                          names: [],
                          nodeType: "FunctionCall",
                          src: "3183:41:24",
                          tryCall: false,
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        },
                        {
                          id: 1953,
                          name: "entity",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1923,
                          src: "3226:6:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          },
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        ],
                        expression: {
                          id: 1942,
                          name: "valueToEntities",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1752,
                          src: "3160:15:24",
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_MapSet_$4019",
                            typeString: "contract MapSet"
                          }
                        },
                        id: 1944,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "remove",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 3949,
                        src: "3160:22:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_external_nonpayable$_t_uint256_$_t_uint256_$returns$__$",
                          typeString: "function (uint256,uint256) external"
                        }
                      },
                      id: 1954,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "3160:73:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_tuple$__$",
                        typeString: "tuple()"
                      }
                    },
                    id: 1955,
                    nodeType: "ExpressionStatement",
                    src: "3160:73:24"
                  },
                  {
                    expression: {
                      arguments: [
                        {
                          id: 1959,
                          name: "entity",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1923,
                          src: "3302:6:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        ],
                        expression: {
                          id: 1956,
                          name: "entities",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1748,
                          src: "3286:8:24",
                          typeDescriptions: {
                            typeIdentifier: "t_contract$_Set_$4371",
                            typeString: "contract Set"
                          }
                        },
                        id: 1958,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "remove",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 4294,
                        src: "3286:15:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_external_nonpayable$_t_uint256_$returns$__$",
                          typeString: "function (uint256) external"
                        }
                      },
                      id: 1960,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "3286:23:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_tuple$__$",
                        typeString: "tuple()"
                      }
                    },
                    id: 1961,
                    nodeType: "ExpressionStatement",
                    src: "3286:23:24"
                  },
                  {
                    expression: {
                      arguments: [
                        {
                          id: 1965,
                          name: "entity",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1923,
                          src: "3391:6:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        }
                      ],
                      expression: {
                        argumentTypes: [
                          {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        ],
                        expression: {
                          id: 1962,
                          name: "super",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: -25,
                          src: "3377:5:24",
                          typeDescriptions: {
                            typeIdentifier: "t_type$_t_super$_Component_$1990_$",
                            typeString: "type(contract super Component)"
                          }
                        },
                        id: 1964,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "_remove",
                        nodeType: "MemberAccess",
                        referencedDeclaration: 1726,
                        src: "3377:13:24",
                        typeDescriptions: {
                          typeIdentifier: "t_function_internal_nonpayable$_t_uint256_$returns$__$",
                          typeString: "function (uint256)"
                        }
                      },
                      id: 1966,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      kind: "functionCall",
                      lValueRequested: false,
                      names: [],
                      nodeType: "FunctionCall",
                      src: "3377:21:24",
                      tryCall: false,
                      typeDescriptions: {
                        typeIdentifier: "t_tuple$__$",
                        typeString: "tuple()"
                      }
                    },
                    id: 1967,
                    nodeType: "ExpressionStatement",
                    src: "3377:21:24"
                  },
                  {
                    body: {
                      id: 1986,
                      nodeType: "Block",
                      src: "3451:41:24",
                      statements: [
                        {
                          expression: {
                            arguments: [
                              {
                                id: 1983,
                                name: "entity",
                                nodeType: "Identifier",
                                overloadedDeclarations: [],
                                referencedDeclaration: 1923,
                                src: "3478:6:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_uint256",
                                  typeString: "uint256"
                                }
                              }
                            ],
                            expression: {
                              argumentTypes: [
                                {
                                  typeIdentifier: "t_uint256",
                                  typeString: "uint256"
                                }
                              ],
                              expression: {
                                baseExpression: {
                                  id: 1979,
                                  name: "indexers",
                                  nodeType: "Identifier",
                                  overloadedDeclarations: [],
                                  referencedDeclaration: 1757,
                                  src: "3459:8:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage",
                                    typeString: "contract IEntityIndexer[] storage ref"
                                  }
                                },
                                id: 1981,
                                indexExpression: {
                                  id: 1980,
                                  name: "i",
                                  nodeType: "Identifier",
                                  overloadedDeclarations: [],
                                  referencedDeclaration: 1969,
                                  src: "3468:1:24",
                                  typeDescriptions: {
                                    typeIdentifier: "t_uint256",
                                    typeString: "uint256"
                                  }
                                },
                                isConstant: false,
                                isLValue: true,
                                isPure: false,
                                lValueRequested: false,
                                nodeType: "IndexAccess",
                                src: "3459:11:24",
                                typeDescriptions: {
                                  typeIdentifier: "t_contract$_IEntityIndexer_$5358",
                                  typeString: "contract IEntityIndexer"
                                }
                              },
                              id: 1982,
                              isConstant: false,
                              isLValue: false,
                              isPure: false,
                              lValueRequested: false,
                              memberName: "remove",
                              nodeType: "MemberAccess",
                              referencedDeclaration: 5357,
                              src: "3459:18:24",
                              typeDescriptions: {
                                typeIdentifier: "t_function_external_nonpayable$_t_uint256_$returns$__$",
                                typeString: "function (uint256) external"
                              }
                            },
                            id: 1984,
                            isConstant: false,
                            isLValue: false,
                            isPure: false,
                            kind: "functionCall",
                            lValueRequested: false,
                            names: [],
                            nodeType: "FunctionCall",
                            src: "3459:26:24",
                            tryCall: false,
                            typeDescriptions: {
                              typeIdentifier: "t_tuple$__$",
                              typeString: "tuple()"
                            }
                          },
                          id: 1985,
                          nodeType: "ExpressionStatement",
                          src: "3459:26:24"
                        }
                      ]
                    },
                    condition: {
                      commonType: {
                        typeIdentifier: "t_uint256",
                        typeString: "uint256"
                      },
                      id: 1975,
                      isConstant: false,
                      isLValue: false,
                      isPure: false,
                      lValueRequested: false,
                      leftExpression: {
                        id: 1972,
                        name: "i",
                        nodeType: "Identifier",
                        overloadedDeclarations: [],
                        referencedDeclaration: 1969,
                        src: "3425:1:24",
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      nodeType: "BinaryOperation",
                      operator: "<",
                      rightExpression: {
                        expression: {
                          id: 1973,
                          name: "indexers",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1757,
                          src: "3429:8:24",
                          typeDescriptions: {
                            typeIdentifier: "t_array$_t_contract$_IEntityIndexer_$5358_$dyn_storage",
                            typeString: "contract IEntityIndexer[] storage ref"
                          }
                        },
                        id: 1974,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        memberName: "length",
                        nodeType: "MemberAccess",
                        src: "3429:15:24",
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      src: "3425:19:24",
                      typeDescriptions: {
                        typeIdentifier: "t_bool",
                        typeString: "bool"
                      }
                    },
                    id: 1987,
                    initializationExpression: {
                      assignments: [
                        1969
                      ],
                      declarations: [
                        {
                          constant: false,
                          id: 1969,
                          mutability: "mutable",
                          name: "i",
                          nameLocation: "3418:1:24",
                          nodeType: "VariableDeclaration",
                          scope: 1987,
                          src: "3410:9:24",
                          stateVariable: false,
                          storageLocation: "default",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          },
                          typeName: {
                            id: 1968,
                            name: "uint256",
                            nodeType: "ElementaryTypeName",
                            src: "3410:7:24",
                            typeDescriptions: {
                              typeIdentifier: "t_uint256",
                              typeString: "uint256"
                            }
                          },
                          visibility: "internal"
                        }
                      ],
                      id: 1971,
                      initialValue: {
                        hexValue: "30",
                        id: 1970,
                        isConstant: false,
                        isLValue: false,
                        isPure: true,
                        kind: "number",
                        lValueRequested: false,
                        nodeType: "Literal",
                        src: "3422:1:24",
                        typeDescriptions: {
                          typeIdentifier: "t_rational_0_by_1",
                          typeString: "int_const 0"
                        },
                        value: "0"
                      },
                      nodeType: "VariableDeclarationStatement",
                      src: "3410:13:24"
                    },
                    loopExpression: {
                      expression: {
                        id: 1977,
                        isConstant: false,
                        isLValue: false,
                        isPure: false,
                        lValueRequested: false,
                        nodeType: "UnaryOperation",
                        operator: "++",
                        prefix: false,
                        src: "3446:3:24",
                        subExpression: {
                          id: 1976,
                          name: "i",
                          nodeType: "Identifier",
                          overloadedDeclarations: [],
                          referencedDeclaration: 1969,
                          src: "3446:1:24",
                          typeDescriptions: {
                            typeIdentifier: "t_uint256",
                            typeString: "uint256"
                          }
                        },
                        typeDescriptions: {
                          typeIdentifier: "t_uint256",
                          typeString: "uint256"
                        }
                      },
                      id: 1978,
                      nodeType: "ExpressionStatement",
                      src: "3446:3:24"
                    },
                    nodeType: "ForStatement",
                    src: "3405:87:24"
                  }
                ]
              },
              baseFunctions: [
                1726
              ],
              documentation: {
                id: 1921,
                nodeType: "StructuredDocumentation",
                src: "2862:40:24",
                text: " @inheritdoc BareComponent"
              },
              implemented: true,
              kind: "function",
              modifiers: [],
              name: "_remove",
              nameLocation: "2914:7:24",
              overrides: {
                id: 1925,
                nodeType: "OverrideSpecifier",
                overrides: [],
                src: "2955:8:24"
              },
              parameters: {
                id: 1924,
                nodeType: "ParameterList",
                parameters: [
                  {
                    constant: false,
                    id: 1923,
                    mutability: "mutable",
                    name: "entity",
                    nameLocation: "2930:6:24",
                    nodeType: "VariableDeclaration",
                    scope: 1989,
                    src: "2922:14:24",
                    stateVariable: false,
                    storageLocation: "default",
                    typeDescriptions: {
                      typeIdentifier: "t_uint256",
                      typeString: "uint256"
                    },
                    typeName: {
                      id: 1922,
                      name: "uint256",
                      nodeType: "ElementaryTypeName",
                      src: "2922:7:24",
                      typeDescriptions: {
                        typeIdentifier: "t_uint256",
                        typeString: "uint256"
                      }
                    },
                    visibility: "internal"
                  }
                ],
                src: "2921:16:24"
              },
              returnParameters: {
                id: 1926,
                nodeType: "ParameterList",
                parameters: [],
                src: "2964:0:24"
              },
              scope: 1990,
              stateMutability: "nonpayable",
              virtual: true,
              visibility: "internal"
            }
          ],
          abstract: true,
          baseContracts: [
            {
              baseName: {
                id: 1743,
                name: "BareComponent",
                nodeType: "IdentifierPath",
                referencedDeclaration: 1727,
                src: "722:13:24"
              },
              id: 1744,
              nodeType: "InheritanceSpecifier",
              src: "722:13:24"
            }
          ],
          canonicalName: "Component",
          contractDependencies: [
            4019,
            4371
          ],
          contractKind: "contract",
          documentation: {
            id: 1742,
            nodeType: "StructuredDocumentation",
            src: "344:346:24",
            text: " Components are a key-value store from entity id to component value.\n They are registered in the World and register updates to their state in the World.\n They have an owner, who can grant write access to more addresses.\n (Systems that want to write to a component need to be given write access first.)\n Everyone has read access."
          },
          fullyImplemented: false,
          linearizedBaseContracts: [
            1990,
            1727,
            4128,
            4038,
            1072,
            6937,
            7308,
            6813,
            5307,
            5375,
            1131,
            6953
          ],
          name: "Component",
          nameLocation: "709:9:24",
          scope: 1991,
          usedErrors: [
            1527,
            4053,
            7305,
            7307
          ]
        }
      ],
      license: "MIT"
    },
    id: 24
  };

  // node_modules/@latticexyz/store-cache/dist/index.js
  var import_tuple_database = __toESM(require_main(), 1);
  var import_tuple_database2 = __toESM(require_main(), 1);

  // node_modules/@latticexyz/common/dist/utils.js
  function n2(a2, ...r2) {
    return (...e) => a2(...r2, ...e);
  }

  // node_modules/@latticexyz/store-cache/dist/index.js
  function D() {
    return new import_tuple_database.TupleDatabase(new import_tuple_database.InMemoryTupleStorage());
  }
  function g2(t3, n4, e, a2, i4, o3, s4) {
    let r2 = S2(t3, e, a2, i4), l4 = n4.get(r2) ?? s4?.defaultValue, u3 = s4?.transaction ?? n4.transact();
    return u3.set(r2, { ...l4, ...o3 }), s4?.transaction || u3.commit(), u3;
  }
  function y(t3, n4, e, a2, i4) {
    return n4.get(S2(t3, e, a2, i4));
  }
  function d2(t3, n4, e, a2, i4, o3) {
    let s4 = o3?.transaction ?? n4.transact();
    return s4.remove(S2(t3, e, a2, i4)), o3?.transaction || s4.commit(), s4;
  }
  function T2(t3, n4, e) {
    let a2 = k(t3, e);
    return n4.scan(a2).map(({ key: o3, value: s4 }) => ({ namespace: o3[0], table: o3[1], key: m2(o3), value: s4 }));
  }
  function b2(t3, n4, e, a2) {
    let i4 = k(t3, a2);
    return n4.subscribe(i4, (o3) => {
      let s4 = {};
      for (let r2 of o3.set ?? []) {
        let [l4, u3] = r2.key;
        if (typeof l4 != "string" || typeof u3 != "string") {
          console.warn("store-cache: Expected first tuple elements to be namespace and table, ignoring set operation:", r2);
          continue;
        }
        s4[f4(l4, u3)] ??= { namespace: l4, table: u3, set: [], remove: [] }, s4[f4(l4, u3)].set.push({ key: m2(r2.key), value: r2.value });
      }
      for (let r2 of o3.remove ?? []) {
        let [l4, u3] = r2;
        if (typeof l4 != "string" || typeof u3 != "string") {
          console.warn("store-cache: Expected first tuple elements to be namespace and table, ignoring remove operation:", r2);
          continue;
        }
        s4[f4(l4, u3)] ??= { namespace: l4, table: u3, set: [], remove: [] }, s4[f4(l4, u3)].remove.push({ key: m2(r2) });
      }
      e(Object.values(s4));
    });
  }
  function x3(t3) {
    if (t3 == null)
      return;
    let n4 = {};
    for (let e in t3)
      n4[e] = g(t3[e]);
    return n4;
  }
  function k(t3, n4) {
    let { table: e, key: a2 } = n4 || {}, i4 = n4 ? n4.namespace ?? t3.namespace : void 0, o3 = e != null && i4 != null ? [i4, e] : void 0, s4 = {};
    return e && (s4.gte = a2?.gte && p(a2.gte, c(t3, e)), s4.gt = a2?.gt && p(a2.gt, c(t3, e)), s4.lte = a2?.lte && p(a2.lte, c(t3, e)), s4.lt = a2?.lt && p(a2.lt, c(t3, e)), a2?.eq && (s4.gte = p(a2.eq, c(t3, e)), s4.lte = p(a2.eq, c(t3, e)))), { prefix: o3, ...s4 };
  }
  function S2(t3, n4, e, a2) {
    return [n4, e, ...p(a2, c(t3, e))];
  }
  function c(t3, n4) {
    let e = t3.tables[n4];
    return e ? Object.getOwnPropertyNames(e.keySchema) : void 0;
  }
  function p(t3, n4) {
    let e = [];
    for (let a2 of n4 ?? Object.keys(t3))
      e.push({ [a2]: V3(t3[a2]) });
    return e;
  }
  function m2(t3) {
    let n4 = {};
    for (let e of t3)
      if (!(e === null || Array.isArray(e) || typeof e != "object"))
        for (let [a2, i4] of Object.entries(e))
          n4[a2] = w(i4);
    return n4;
  }
  function V3(t3) {
    return typeof t3 == "bigint" ? `${t3.toString()}n` : t3;
  }
  function w(t3) {
    return typeof t3 == "string" && /^-?\d+n$/.test(t3) ? BigInt(t3.slice(0, -1)) : t3;
  }
  function f4(t3, n4) {
    return t3 + "/" + n4;
  }
  function h2(t3, n4) {
    let e = new import_tuple_database2.TupleDatabaseClient(t3), { namespace: a2 } = n4, i4 = {}, o3 = { set: n2(g2, n4, e), get: n2(y, n4, e), remove: n2(d2, n4, e), subscribe: n2(b2, n4, e), scan: n2(T2, n4, e) };
    for (let s4 in n4.tables)
      i4[s4] = { set: (r2, l4, u3) => o3.set(a2, s4, r2, l4, { defaultValue: x3(n4.tables?.[s4].schema), ...u3 }), get: n2(o3.get, a2, s4), remove: n2(o3.remove, a2, s4), subscribe: (r2, l4) => b2(n4, e, r2, { namespace: a2, table: s4, ...l4 }), scan: (r2) => T2(n4, e, { namespace: a2, table: s4, ...r2 }) };
    return { tables: i4, _tupleDatabaseClient: e, ...o3 };
  }

  // node_modules/@latticexyz/std-client/dist/index.js
  function D2(t3, e) {
    return Be(t3, { value: U2.String }, e);
  }
  var V4 = ((a2) => (a2[a2.Requested = 0] = "Requested", a2[a2.Executing = 1] = "Executing", a2[a2.WaitingForTxEvents = 2] = "WaitingForTxEvents", a2[a2.Complete = 3] = "Complete", a2[a2.Failed = 4] = "Failed", a2[a2.Cancelled = 5] = "Cancelled", a2[a2.TxReduced = 6] = "TxReduced", a2))(V4 || {});
  async function re2(t3, e, o3) {
    let r2 = {};
    async function i4(d6) {
      let a2 = K(d6), c3 = je(e, d6).value;
      console.info("[SyncUtils] Creating encoder for " + a2);
      let s4 = new Contract(a2, Component_default.abi, o3.get()), [m5, x8] = await s4.getSchema();
      r2[c3] = Zr2(m5, x8);
    }
    for (let d6 of T(e))
      i4(d6);
    let u3 = e.update$.subscribe((d6) => i4(d6.entity));
    return t3.registerDisposer(() => u3?.unsubscribe()), r2;
  }
  function ie2(t3, e, o3, r2, i4, u3, d6, a2) {
    let c3 = new Subject(), s4 = false, m5 = timer(0, 100).pipe(filter(() => !s4), map2(() => Ss)).subscribe(i4), x8 = o3.subscribe((C4) => {
      s4 = true;
      for (let n4 of C4)
        if (ae(n4)) {
          if (n4.lastEventInTx && c3.next(n4.txHash), d6 && u3) {
            let { namespace: b4, table: y4, key: S3 } = n4, E4 = u3.tables[y4];
            if (!(!E4 || b4 !== u3.namespace)) {
              let O5 = oe2(S3, Object.getOwnPropertyNames(E4.keySchema)), R4 = n4.value ?? n4.partialValue;
              if (R4) {
                let H3 = oe2(R4, Object.getOwnPropertyNames(E4.schema));
                d6.set(b4, y4, O5, H3);
              } else
                d6.remove(b4, y4, O5);
            }
          }
          let l4 = n4.entity ?? t3.registerEntity({ id: n4.entity }), f5 = r2[n4.component];
          if (!f5) {
            console.warn("Unknown component:", n4);
            continue;
          }
          let p2 = e[f5];
          n4.partialValue !== void 0 ? Re(p2, l4, n4.partialValue, n4.initialValue) : n4.value === void 0 ? I(p2, l4) : C(p2, l4, n4.value);
        } else
          a2 && Mo(n4) && a2(n4);
      i4.next(Ss), s4 = false;
    });
    return t3.registerDisposer(() => {
      x8?.unsubscribe(), m5?.unsubscribe();
    }), { txReduced$: c3.asObservable() };
  }
  function oe2(t3, e) {
    let o3 = {};
    return e.forEach((r2, i4) => {
      i4 in t3 && (o3[r2] = t3[i4]);
    }), o3;
  }
  function ae2(t3) {
    return { Hooks: (() => {
      let e = new f("mudstore", "Hooks");
      return Be(t3, { value: U2.StringArray }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), Callbacks: (() => {
      let e = new f("mudstore", "Callbacks");
      return Be(t3, { value: U2.StringArray }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), StoreMetadata: (() => {
      let e = new f("mudstore", "StoreMetadata");
      return Be(t3, { tableName: U2.String, abiEncodedFieldNames: U2.String }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), Mixed: (() => {
      let e = new f("mudstore", "Mixed");
      return Be(t3, { u32: U2.Number, u128: U2.BigInt, a32: U2.NumberArray, s: U2.String }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), Vector2: (() => {
      let e = new f("mudstore", "Vector2");
      return Be(t3, { x: U2.Number, y: U2.Number }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })() };
  }
  function se2(t3) {
    return { NamespaceOwner: (() => {
      let e = new f("", "NamespaceOwner");
      return Be(t3, { owner: U2.String }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), ResourceAccess: (() => {
      let e = new f("", "ResourceAccess");
      return Be(t3, { access: U2.Boolean }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), InstalledModules: (() => {
      let e = new f("", "InstalledModules");
      return Be(t3, { moduleAddress: U2.String }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), Systems: (() => {
      let e = new f("", "Systems");
      return Be(t3, { system: U2.String, publicAccess: U2.Boolean }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), SystemRegistry: (() => {
      let e = new f("", "SystemRegistry");
      return Be(t3, { resourceSelector: U2.String }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), SystemHooks: (() => {
      let e = new f("", "SystemHooks");
      return Be(t3, { value: U2.StringArray }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), ResourceType: (() => {
      let e = new f("", "ResourceType");
      return Be(t3, { resourceType: U2.Number }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), FunctionSelectors: (() => {
      let e = new f("", "FunctionSelector");
      return Be(t3, { namespace: U2.String, name: U2.String, systemFunctionSelector: U2.String }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), KeysInTable: (() => {
      let e = new f("", "KeysInTable");
      return Be(t3, { keys0: U2.StringArray, keys1: U2.StringArray, keys2: U2.StringArray, keys3: U2.StringArray, keys4: U2.StringArray }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })(), UsedKeysIndex: (() => {
      let e = new f("", "UsedKeysIndex");
      return Be(t3, { has: U2.Boolean, index: U2.Number }, { metadata: { contractId: e.toHexString(), tableId: e.toString() } });
    })() };
  }
  async function Hr2({ networkConfig: t3, world: e, contractComponents: o3, initialGasPrice: r2, fetchSystemCalls: i4, syncThread: u3, storeConfig: d6, syncStoreCache: a2 = true, worldAbi: c3 = IWorldKernel__factory.abi }) {
    i.next(c3);
    let s4 = D2(e, { id: "SystemsRegistry", metadata: { contractId: "world.component.systems" } }), m5 = D2(e, { id: "ComponentsRegistry", metadata: { contractId: "world.component.components" } }), x8 = Be(e, { state: U2.Number, msg: U2.String, percentage: U2.Number }, { id: "LoadingState", metadata: { contractId: "component.LoadingState" } }), C4 = new f("mudstore", "schema"), n4 = Be(e, { valueSchema: U2.String, keySchema: U2.String }, { metadata: { contractId: C4.toHexString(), tableId: C4.toString() } }), l4 = ae2(e), f5 = se2(e), p2 = { storeSchemaComponent: n4, ...l4, ...f5, ...o3, SystemsRegistry: s4, ComponentsRegistry: m5, LoadingState: x8 }, b4 = {};
    function y4(v7, B5) {
      let { contractId: we3, tableId: J3 } = B5.metadata;
      J3 ? b4[J3] = v7 : b4[Fr(we3)] = v7;
    }
    for (let v7 of Object.keys(p2))
      y4(v7, p2[v7]);
    let S3 = await pr(t3);
    e.registerDisposer(S3.dispose);
    let E4 = computed(() => S3.signer.get() || S3.providers.get().json), { contracts: O5, config: R4 } = await br2({ config: { World: { abi: IWorldKernel__factory.abi, address: t3.worldAddress } }, signerOrProvider: E4 }), H3 = new BehaviorSubject(r2 || Math.ceil((await E4.get().getGasPrice()).toNumber() * 1.3)), { txQueue: fe3, dispose: ye2 } = me2(O5, S3, H3, { devMode: t3.devMode });
    e.registerDisposer(ye2);
    let ge4 = e.registerEntity({ id: J }), P4 = S3.connectedAddress.get(), be2 = P4 ? e.registerEntity({ id: P4 }) : void 0, q4 = new Subject(), { provider: { externalProvider: Jt2, ...Ce3 }, ...Se } = t3, { ecsEvents$: G5, input$: xe2, dispose: ve3 } = Lr(q4, { thread: u3 });
    e.registerDisposer(ve3);
    function Te2(v7, B5) {
      xe2.next({ type: Fo.Config, data: { ...Se, provider: Ce3, worldContract: R4.World, initialBlockNumber: B5 ?? t3.initialBlockNumber, disableCache: t3.disableCache || [31337, 1337].includes(t3.chainId), fetchSystemCalls: i4, initialRecords: v7 } });
    }
    let he3 = D(), z5 = h2(he3, d6), { txReduced$: Ie2 } = ie2(e, p2, G5, b4, q4, a2 ? d6 : void 0, a2 ? z5 : void 0), Ee2 = t3.encoders ? re2(e, m5, E4) : new Promise((v7) => v7({}));
    return { txQueue: fe3, txReduced$: Ie2, encoders: Ee2, network: S3, startSync: Te2, gasPriceInput$: H3, ecsEvent$: G5.pipe(concatMap((v7) => from(v7))), mappings: b4, registerComponent: y4, networkConfig: t3, world: e, components: p2, singletonEntityId: J, singletonEntity: ge4, playerEntityId: P4, playerEntity: be2, storeCache: z5 };
  }
  function ue(t3, e) {
    if (!isHex(t3))
      throw console.error("Private key found in cache is not valid hex", { privateKey: t3, cacheKey: e }), new Error(`Private key found in cache (${e}) is not valid hex`);
    privateKeyToAccount(t3);
  }
  function Gt(t3 = "mud:burnerWallet") {
    let e = localStorage.getItem(t3);
    e != null && ue(e, t3);
    let o3 = e != null ? new BehaviorSubject(e) : (() => {
      let r2 = generatePrivateKey();
      return console.log("New burner wallet created:", privateKeyToAccount(r2)), localStorage.setItem(t3, r2), new BehaviorSubject(r2);
    })();
    return window.addEventListener("storage", function r2(i4) {
      if (o3.closed) {
        window.removeEventListener("storage", r2);
        return;
      }
      if (i4.key === t3 && i4.storageArea === localStorage) {
        if (!i4.newValue) {
          console.warn("Burner wallet removed from cache! You may need to reload to create a new wallet.");
          return;
        }
        ue(i4.newValue, t3), o3.next(i4.newValue);
      }
    }), o3;
  }

  // src/contracts/worlds.json
  var worlds_default = {
    "31337": {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  };

  // src/mud/supportedChains.ts
  var supportedChains = [foundry, t];

  // src/mud/getNetworkConfig.ts
  var worlds = worlds_default;
  async function getNetworkConfig() {
    const params = new URLSearchParams(window.location.search);
    const chainId = Number(params.get("chainId") || 31337);
    const chainIndex = supportedChains.findIndex((c3) => c3.id === chainId);
    const chain2 = supportedChains[chainIndex];
    if (!chain2) {
      throw new Error(`Chain ${chainId} not found`);
    }
    const world2 = worlds[chain2.id.toString()];
    const worldAddress = params.get("worldAddress") || world2?.address;
    if (!worldAddress) {
      throw new Error(`No world address found for chain ${chainId}. Did you run \`mud deploy\`?`);
    }
    const initialBlockNumber = params.has("initialBlockNumber") ? Number(params.get("initialBlockNumber")) : world2?.blockNumber ?? -1;
    return {
      clock: {
        period: 1e3,
        initialTime: 0,
        syncInterval: 5e3
      },
      provider: {
        chainId,
        jsonRpcUrl: params.get("rpc") ?? chain2.rpcUrls.default.http[0],
        wsRpcUrl: params.get("wsRpc") ?? chain2.rpcUrls.default.webSocket?.[0]
      },
      privateKey: Gt().value,
      chainId,
      modeUrl: params.get("mode") ?? chain2.modeUrl,
      faucetServiceUrl: params.get("faucet") ?? chain2.faucetUrl,
      worldAddress,
      initialBlockNumber,
      snapSync: true,
      //params.get("snapSync") === "true",
      disableCache: params.get("cache") === "false"
    };
  }

  // src/mud/contractComponents.ts
  function defineContractComponents(world2) {
    return {
      PlayerComponent: (() => {
        const tableId = new f("", "PlayerComponent");
        return Be(
          world2,
          {
            value: U2.Boolean
          },
          {
            metadata: {
              contractId: tableId.toHexString(),
              tableId: tableId.toString()
            }
          }
        );
      })(),
      PlayerSeedComponent: (() => {
        const tableId = new f("", "PlayerSeedCompon");
        return Be(
          world2,
          {
            value: U2.Number
          },
          {
            metadata: {
              contractId: tableId.toHexString(),
              tableId: tableId.toString()
            }
          }
        );
      })(),
      PlayerScoreComponent: (() => {
        const tableId = new f("", "PlayerScoreCompo");
        return Be(
          world2,
          {
            value: U2.BigInt
          },
          {
            metadata: {
              contractId: tableId.toHexString(),
              tableId: tableId.toString()
            }
          }
        );
      })(),
      PlayerStageComponent: (() => {
        const tableId = new f("", "PlayerStageCompo");
        return Be(
          world2,
          {
            value: U2.BigInt
          },
          {
            metadata: {
              contractId: tableId.toHexString(),
              tableId: tableId.toString()
            }
          }
        );
      })(),
      PlayerConfigComponent: (() => {
        const tableId = new f("", "PlayerConfigComp");
        return Be(
          world2,
          {
            config: U2.BigIntArray
          },
          {
            metadata: {
              contractId: tableId.toHexString(),
              tableId: tableId.toString()
            }
          }
        );
      })(),
      SeedComponent: (() => {
        const tableId = new f("", "SeedComponent");
        return Be(
          world2,
          {
            value: U2.BigInt,
            updatePeriod: U2.BigInt,
            startFrom: U2.BigInt
          },
          {
            metadata: {
              contractId: tableId.toHexString(),
              tableId: tableId.toString()
            }
          }
        );
      })(),
      RankComponent: (() => {
        const tableId = new f("", "RankComponent");
        return Be(
          world2,
          {
            addr: U2.StringArray,
            score: U2.NumberArray
          },
          {
            metadata: {
              contractId: tableId.toHexString(),
              tableId: tableId.toString()
            }
          }
        );
      })(),
      GameConfigComponent: (() => {
        const tableId = new f("", "GameConfigCompon");
        return Be(
          world2,
          {
            config: U2.BigInt
          },
          {
            metadata: {
              contractId: tableId.toHexString(),
              tableId: tableId.toString()
            }
          }
        );
      })()
    };
  }

  // src/mud/world.ts
  var world = Jt();

  // src/contracts/types/ethers-contracts/factories/IWorld__factory.ts
  var _abi2 = [
    {
      inputs: [
        {
          internalType: "string",
          name: "resource",
          type: "string"
        },
        {
          internalType: "address",
          name: "caller",
          type: "address"
        }
      ],
      name: "AccessDenied",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4"
        }
      ],
      name: "FunctionSelectorExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4"
        }
      ],
      name: "FunctionSelectorNotFound",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "resource",
          type: "string"
        }
      ],
      name: "InvalidSelector",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "module",
          type: "string"
        }
      ],
      name: "ModuleAlreadyInstalled",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "resource",
          type: "string"
        }
      ],
      name: "ResourceExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "resource",
          type: "string"
        }
      ],
      name: "ResourceNotFound",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "length",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "received",
          type: "uint256"
        }
      ],
      name: "StoreCore_DataIndexOverflow",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "expected",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "received",
          type: "uint256"
        }
      ],
      name: "StoreCore_InvalidDataLength",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "expected",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "received",
          type: "uint256"
        }
      ],
      name: "StoreCore_InvalidFieldNamesLength",
      type: "error"
    },
    {
      inputs: [],
      name: "StoreCore_NotDynamicField",
      type: "error"
    },
    {
      inputs: [],
      name: "StoreCore_NotImplemented",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "tableId",
          type: "bytes32"
        },
        {
          internalType: "string",
          name: "tableIdString",
          type: "string"
        }
      ],
      name: "StoreCore_TableAlreadyExists",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "tableId",
          type: "bytes32"
        },
        {
          internalType: "string",
          name: "tableIdString",
          type: "string"
        }
      ],
      name: "StoreCore_TableNotFound",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "system",
          type: "address"
        }
      ],
      name: "SystemExists",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [],
      name: "HelloWorld",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          indexed: false,
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        }
      ],
      name: "StoreDeleteRecord",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          indexed: false,
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "StoreEphemeralRecord",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          indexed: false,
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          indexed: false,
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "StoreSetField",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          indexed: false,
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "StoreSetRecord",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes",
          name: "funcSelectorAndArgs",
          type: "bytes"
        }
      ],
      name: "call",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }
      ],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        }
      ],
      name: "deleteRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        }
      ],
      name: "deleteRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "emitEphemeralRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "emitEphemeralRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        }
      ],
      name: "getField",
      outputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        }
      ],
      name: "getFieldLength",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        },
        {
          internalType: "uint256",
          name: "start",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "end",
          type: "uint256"
        }
      ],
      name: "getFieldSlice",
      outputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        }
      ],
      name: "getKeySchema",
      outputs: [
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        }
      ],
      name: "getRecord",
      outputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        }
      ],
      name: "getRecord",
      outputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        }
      ],
      name: "getSchema",
      outputs: [
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "address",
          name: "grantee",
          type: "address"
        }
      ],
      name: "grantAccess",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract IModule",
          name: "module",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "args",
          type: "bytes"
        }
      ],
      name: "installModule",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract IModule",
          name: "module",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "args",
          type: "bytes"
        }
      ],
      name: "installRootModule",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "isStore",
      outputs: [],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "joinGame",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "byteLengthToPop",
          type: "uint256"
        }
      ],
      name: "popFromField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "byteLengthToPop",
          type: "uint256"
        }
      ],
      name: "popFromField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "dataToPush",
          type: "bytes"
        }
      ],
      name: "pushToField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "dataToPush",
          type: "bytes"
        }
      ],
      name: "pushToField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "string",
          name: "systemFunctionName",
          type: "string"
        },
        {
          internalType: "string",
          name: "systemFunctionArguments",
          type: "string"
        }
      ],
      name: "registerFunctionSelector",
      outputs: [
        {
          internalType: "bytes4",
          name: "worldFunctionSelector",
          type: "bytes4"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "address",
          name: "hook",
          type: "address"
        }
      ],
      name: "registerHook",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        }
      ],
      name: "registerNamespace",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes4",
          name: "worldFunctionSelector",
          type: "bytes4"
        },
        {
          internalType: "bytes4",
          name: "systemFunctionSelector",
          type: "bytes4"
        }
      ],
      name: "registerRootFunctionSelector",
      outputs: [
        {
          internalType: "bytes4",
          name: "",
          type: "bytes4"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "Schema",
          name: "schema",
          type: "bytes32"
        },
        {
          internalType: "Schema",
          name: "keySchema",
          type: "bytes32"
        }
      ],
      name: "registerSchema",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "contract IStoreHook",
          name: "hook",
          type: "address"
        }
      ],
      name: "registerStoreHook",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "contract System",
          name: "system",
          type: "address"
        },
        {
          internalType: "bool",
          name: "publicAccess",
          type: "bool"
        }
      ],
      name: "registerSystem",
      outputs: [
        {
          internalType: "bytes32",
          name: "resourceSelector",
          type: "bytes32"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "contract ISystemHook",
          name: "hook",
          type: "address"
        }
      ],
      name: "registerSystemHook",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "Schema",
          name: "valueSchema",
          type: "bytes32"
        },
        {
          internalType: "Schema",
          name: "keySchema",
          type: "bytes32"
        }
      ],
      name: "registerTable",
      outputs: [
        {
          internalType: "bytes32",
          name: "resourceSelector",
          type: "bytes32"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "contract IStoreHook",
          name: "hook",
          type: "address"
        }
      ],
      name: "registerTableHook",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "address",
          name: "grantee",
          type: "address"
        }
      ],
      name: "revokeAccess",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "setField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "setField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "string",
          name: "tableName",
          type: "string"
        },
        {
          internalType: "string[]",
          name: "fieldNames",
          type: "string[]"
        }
      ],
      name: "setMetadata",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "string",
          name: "tableName",
          type: "string"
        },
        {
          internalType: "string[]",
          name: "fieldNames",
          type: "string[]"
        }
      ],
      name: "setMetadata",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "setRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "setRecord",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "table",
          type: "bytes32"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "startByteIndex",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "dataToSet",
          type: "bytes"
        }
      ],
      name: "updateInField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes16",
          name: "namespace",
          type: "bytes16"
        },
        {
          internalType: "bytes16",
          name: "name",
          type: "bytes16"
        },
        {
          internalType: "bytes32[]",
          name: "key",
          type: "bytes32[]"
        },
        {
          internalType: "uint8",
          name: "schemaIndex",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "startByteIndex",
          type: "uint256"
        },
        {
          internalType: "bytes",
          name: "dataToSet",
          type: "bytes"
        }
      ],
      name: "updateInField",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint32[]",
          name: "_opts",
          type: "uint32[]"
        },
        {
          internalType: "uint256",
          name: "_seed",
          type: "uint256"
        }
      ],
      name: "verify",
      outputs: [
        {
          internalType: "bool",
          name: "pass",
          type: "bool"
        },
        {
          internalType: "uint256",
          name: "score",
          type: "uint256"
        }
      ],
      stateMutability: "pure",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "entity",
          type: "bytes32"
        },
        {
          internalType: "bytes32",
          name: "index",
          type: "bytes32"
        },
        {
          internalType: "uint32[]",
          name: "_opts",
          type: "uint32[]"
        }
      ],
      name: "verifyGamePlay",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ];
  var IWorld__factory = class {
    static createInterface() {
      return new utils_exports.Interface(_abi2);
    }
    static connect(address, signerOrProvider) {
      return new Contract(address, _abi2, signerOrProvider);
    }
  };
  __publicField(IWorld__factory, "abi", _abi2);

  // node_modules/chalk/source/vendor/ansi-styles/index.js
  var ANSI_BACKGROUND_OFFSET = 10;
  var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
  var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
  var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
  var styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      // Bright color
      blackBright: [90, 39],
      gray: [90, 39],
      // Alias of `blackBright`
      grey: [90, 39],
      // Alias of `blackBright`
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgGray: [100, 49],
      // Alias of `bgBlackBright`
      bgGrey: [100, 49],
      // Alias of `bgBlackBright`
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };
  var modifierNames = Object.keys(styles.modifier);
  var foregroundColorNames = Object.keys(styles.color);
  var backgroundColorNames = Object.keys(styles.bgColor);
  var colorNames = [...foregroundColorNames, ...backgroundColorNames];
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = wrapAnsi16();
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    Object.defineProperties(styles, {
      rgbToAnsi256: {
        value(red, green, blue) {
          if (red === green && green === blue) {
            if (red < 8) {
              return 16;
            }
            if (red > 248) {
              return 231;
            }
            return Math.round((red - 8) / 247 * 24) + 232;
          }
          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
        },
        enumerable: false
      },
      hexToRgb: {
        value(hex2) {
          const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex2.toString(16));
          if (!matches) {
            return [0, 0, 0];
          }
          let [colorString] = matches;
          if (colorString.length === 3) {
            colorString = [...colorString].map((character) => character + character).join("");
          }
          const integer = Number.parseInt(colorString, 16);
          return [
            /* eslint-disable no-bitwise */
            integer >> 16 & 255,
            integer >> 8 & 255,
            integer & 255
            /* eslint-enable no-bitwise */
          ];
        },
        enumerable: false
      },
      hexToAnsi256: {
        value: (hex2) => styles.rgbToAnsi256(...styles.hexToRgb(hex2)),
        enumerable: false
      },
      ansi256ToAnsi: {
        value(code) {
          if (code < 8) {
            return 30 + code;
          }
          if (code < 16) {
            return 90 + (code - 8);
          }
          let red;
          let green;
          let blue;
          if (code >= 232) {
            red = ((code - 232) * 10 + 8) / 255;
            green = red;
            blue = red;
          } else {
            code -= 16;
            const remainder = code % 36;
            red = Math.floor(code / 36) / 5;
            green = Math.floor(remainder / 6) / 5;
            blue = remainder % 6 / 5;
          }
          const value = Math.max(red, green, blue) * 2;
          if (value === 0) {
            return 30;
          }
          let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
          if (value === 2) {
            result += 60;
          }
          return result;
        },
        enumerable: false
      },
      rgbToAnsi: {
        value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
        enumerable: false
      },
      hexToAnsi: {
        value: (hex2) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex2)),
        enumerable: false
      }
    });
    return styles;
  }
  var ansiStyles = assembleStyles();
  var ansi_styles_default = ansiStyles;

  // node_modules/chalk/source/vendor/supports-color/browser.js
  var level = (() => {
    if (navigator.userAgentData) {
      const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
      if (brand && brand.version > 93) {
        return 3;
      }
    }
    if (/\b(Chrome|Chromium)\//.test(navigator.userAgent)) {
      return 1;
    }
    return 0;
  })();
  var colorSupport = level !== 0 && {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
  var supportsColor = {
    stdout: colorSupport,
    stderr: colorSupport
  };
  var browser_default2 = supportsColor;

  // node_modules/chalk/source/utilities.js
  function stringReplaceAll(string, substring, replacer) {
    let index2 = string.indexOf(substring);
    if (index2 === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.slice(endIndex, index2) + substring + replacer;
      endIndex = index2 + substringLength;
      index2 = string.indexOf(substring, endIndex);
    } while (index2 !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
  }
  function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index2) {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index2 - 1] === "\r";
      returnValue += string.slice(endIndex, gotCR ? index2 - 1 : index2) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index2 + 1;
      index2 = string.indexOf("\n", endIndex);
    } while (index2 !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
  }

  // node_modules/chalk/source/index.js
  var { stdout: stdoutColor, stderr: stderrColor } = browser_default2;
  var GENERATOR = Symbol("GENERATOR");
  var STYLER = Symbol("STYLER");
  var IS_EMPTY = Symbol("IS_EMPTY");
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles2 = /* @__PURE__ */ Object.create(null);
  var applyOptions = (object2, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object2.level = options.level === void 0 ? colorLevel : options.level;
  };
  var chalkFactory = (options) => {
    const chalk2 = (...strings) => strings.join(" ");
    applyOptions(chalk2, options);
    Object.setPrototypeOf(chalk2, createChalk.prototype);
    return chalk2;
  };
  function createChalk(options) {
    return chalkFactory(options);
  }
  Object.setPrototypeOf(createChalk.prototype, Function.prototype);
  for (const [styleName, style] of Object.entries(ansi_styles_default)) {
    styles2[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles2.visible = {
    get() {
      const builder = createBuilder(this, this[STYLER], true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  var getModelAnsi = (model, level2, type, ...arguments_) => {
    if (model === "rgb") {
      if (level2 === "ansi16m") {
        return ansi_styles_default[type].ansi16m(...arguments_);
      }
      if (level2 === "ansi256") {
        return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
      }
      return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
    }
    if (model === "hex") {
      return getModelAnsi("rgb", level2, type, ...ansi_styles_default.hexToRgb(...arguments_));
    }
    return ansi_styles_default[type][model](...arguments_);
  };
  var usedModels = ["rgb", "hex", "ansi256"];
  for (const model of usedModels) {
    styles2[model] = {
      get() {
        const { level: level2 } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level2], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles2[bgModel] = {
      get() {
        const { level: level2 } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level2], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles2,
    level: {
      enumerable: true,
      get() {
        return this[GENERATOR].level;
      },
      set(level2) {
        this[GENERATOR].level = level2;
      }
    }
  });
  var createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    Object.setPrototypeOf(builder, proto);
    builder[GENERATOR] = self2;
    builder[STYLER] = _styler;
    builder[IS_EMPTY] = _isEmpty;
    return builder;
  };
  var applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2[IS_EMPTY] ? "" : string;
    }
    let styler = self2[STYLER];
    if (styler === void 0) {
      return string;
    }
    const { openAll, closeAll } = styler;
    if (string.includes("\x1B")) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  Object.defineProperties(createChalk.prototype, styles2);
  var chalk = createChalk();
  var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
  var source_default = chalk;

  // node_modules/zod/lib/index.mjs
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k3) => typeof obj[obj[k3]] !== "number");
      const filtered = {};
      for (const k3 of validKeys) {
        filtered[k3] = obj[k3];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
      const keys = [];
      for (const key in object2) {
        if (Object.prototype.hasOwnProperty.call(object2, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array2, separator = " | ") {
      return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_18, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first2, second) => {
      return {
        ...first2,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t3 = typeof data;
    switch (t3) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i4 = 0;
            while (i4 < issue.path.length) {
              const el = issue.path[i4];
              const terminal = i4 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i4++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var overrideErrorMap = errorMap;
  function setErrorMap(map3) {
    overrideErrorMap = map3;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m5) => !!m5).slice().reverse();
    for (const map3 of maps) {
      errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x8) => !!x8)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s4 of results) {
        if (s4.status === "aborted")
          return INVALID;
        if (s4.status === "dirty")
          status.dirty();
        arrayValue.push(s4.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (typeof value.value !== "undefined" || pair.alwaysSet) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x8) => x8.status === "aborted";
  var isDirty = (x8) => x8.status === "dirty";
  var isValid = (x8) => x8.status === "valid";
  var isAsync = (x8) => typeof Promise !== "undefined" && x8 instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[a-z][a-z0-9]*$/;
  var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
  var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
  var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
  var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
  var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
      }
    }
  };
  function isValidIP(ip, version7) {
    if ((version7 === "v4" || !version7) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version7 === "v6" || !version7) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class extends ZodType {
    constructor() {
      super(...arguments);
      this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
      this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
      this.trim = () => new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
      this.toLowerCase = () => new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
      this.toUpperCase = () => new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx2,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  var ZodNumber = class extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i4) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i4) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i4));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index2) {
      return new ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  var ZodDiscriminatedUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a2, b4) {
    const aType = getParsedType(a2);
    const bType = getParsedType(b4);
    if (a2 === b4) {
      return { valid: true, data: a2 };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b4);
      const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a2, ...b4 };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a2[key], b4[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a2.length !== b4.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a2.length; index2++) {
        const itemA = a2[index2];
        const itemB = b4[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b4) {
      return { valid: true, data: a2 };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x8) => !!x8);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first2, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first2,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first2,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i4) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i4)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size3, message) {
      return this.min(size3, message).max(size3, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x8) => !!x8),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x8) => !!x8),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        return OK(async (...args) => {
          const error = new ZodError([]);
          const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await fn(...parsedArgs);
          const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        return OK((...args) => {
          const parsedArgs = this._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = fn(...parsedArgs.data);
          const parsedReturns = this._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values) {
      return ZodEnum.create(values);
    }
    exclude(values) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
  };
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data);
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a2, b4) {
      return new ZodPipeline({
        in: a2,
        out: b4,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var custom2 = (check, params = {}, fatal) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        if (!check(data)) {
          const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
          const p22 = typeof p2 === "string" ? { message: p2 } : p2;
          ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom2((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;
  var z2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    custom: custom2,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });

  // node_modules/zod-validation-error/dist/esm/utils/joinPath.js
  var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
  function joinPath(path) {
    if (path.length === 1) {
      return path[0].toString();
    }
    return path.reduce((acc, item) => {
      if (typeof item === "number") {
        return acc + "[" + item.toString() + "]";
      }
      if (item.includes('"')) {
        return acc + '["' + escapeQuotes(item) + '"]';
      }
      if (!identifierRegex.test(item)) {
        return acc + '["' + item + '"]';
      }
      const separator = acc.length === 0 ? "" : ".";
      return acc + separator + item;
    }, "");
  }
  function escapeQuotes(str) {
    return str.replace(/"/g, '\\"');
  }

  // node_modules/zod-validation-error/dist/esm/utils/NonEmptyArray.js
  function isNonEmptyArray(value) {
    return value.length !== 0;
  }

  // node_modules/zod-validation-error/dist/esm/ValidationError.js
  var ValidationError = class extends Error {
    details;
    name;
    constructor(message, details = []) {
      super(message);
      this.details = details;
      this.name = "ZodValidationError";
    }
    toString() {
      return this.message;
    }
  };
  function fromZodIssue(issue, issueSeparator, unionSeparator) {
    if (issue.code === "invalid_union") {
      return issue.unionErrors.reduce((acc, zodError) => {
        const newIssues = zodError.issues.map((issue2) => fromZodIssue(issue2, issueSeparator, unionSeparator)).join(issueSeparator);
        if (!acc.includes(newIssues)) {
          acc.push(newIssues);
        }
        return acc;
      }, []).join(unionSeparator);
    }
    if (isNonEmptyArray(issue.path)) {
      if (issue.path.length === 1) {
        const identifier = issue.path[0];
        if (typeof identifier === "number") {
          return `${issue.message} at index ${identifier}`;
        }
      }
      return `${issue.message} at "${joinPath(issue.path)}"`;
    }
    return issue.message;
  }
  function fromZodError(zodError, options = {}) {
    const { maxIssuesInMessage = 99, issueSeparator = "; ", unionSeparator = ", or ", prefixSeparator = ": ", prefix = "Validation error" } = options;
    const reason = zodError.errors.slice(0, maxIssuesInMessage).map((issue) => fromZodIssue(issue, issueSeparator, unionSeparator)).join(issueSeparator);
    const message = reason ? [prefix, reason].join(prefixSeparator) : prefix;
    return new ValidationError(message, zodError.errors);
  }

  // node_modules/@latticexyz/config/dist/chunk-AXXYPYMM.js
  var a = Object.defineProperty;
  var m3 = (r2, e, o3) => e in r2 ? a(r2, e, { enumerable: true, configurable: true, writable: true, value: o3 }) : r2[e] = o3;
  var x4 = (r2, e, o3) => (m3(r2, typeof e != "symbol" ? e + "" : e, o3), o3);
  var t2 = class extends Error {
    name = "MUDContextAlreadyCreatedError";
    message = "MUD context was already created";
  };
  var s2 = class extends Error {
    name = "MUDContextNotCreatedError";
    message = "MUD context has not been created";
  };
  function l(r2, e) {
    return fromZodError(r2, { prefix: source_default.red(e), prefixSeparator: `
- `, issueSeparator: `
- ` });
  }

  // node_modules/@latticexyz/config/dist/chunk-4G6ZGMDP.js
  var g3 = 16;
  function d3(e, t3) {
    /^\w+$/.test(e) || t3.addIssue({ code: ZodIssueCode.custom, message: "Name must contain only alphanumeric & underscore characters" });
  }
  function x5(e, t3) {
    d3(e, t3), /^[A-Z]/.test(e) || t3.addIssue({ code: ZodIssueCode.custom, message: "Name must start with a capital letter" });
  }
  function C2(e, t3) {
    d3(e, t3), /^[a-z]/.test(e) || t3.addIssue({ code: ZodIssueCode.custom, message: "Name must start with a lowercase letter" });
  }
  function h3(e, t3) {
    e.length === 0 && t3.addIssue({ code: ZodIssueCode.custom, message: "Enum must not be empty" }), e.length >= 256 && t3.addIssue({ code: ZodIssueCode.custom, message: "Length of enum must be < 256" });
    let o3 = M3(e);
    o3.length > 0 && t3.addIssue({ code: ZodIssueCode.custom, message: `Enum must not have duplicate names for: ${o3.join(", ")}` });
  }
  function c2(e, t3) {
    return (o3, n4) => {
      if (o3 === "") {
        e && n4.addIssue({ code: ZodIssueCode.custom, message: "Route must not be empty" });
        return;
      }
      o3[0] !== "/" && n4.addIssue({ code: ZodIssueCode.custom, message: 'Route must start with "/"' }), o3[o3.length - 1] === "/" && n4.addIssue({ code: ZodIssueCode.custom, message: 'Route must not end with "/"' });
      let a2 = o3.split("/");
      t3 && a2.length > 2 && n4.addIssue({ code: ZodIssueCode.custom, message: 'Route must only have one level (e.g. "/foo")' });
      for (let u3 = 1; u3 < a2.length; u3++)
        a2[u3] === "" && n4.addIssue({ code: ZodIssueCode.custom, message: 'Route must not contain empty route fragments (e.g. "//")' }), /^\w+$/.test(a2[u3]) || n4.addIssue({ code: ZodIssueCode.custom, message: "Route must contain only alphanumeric & underscore characters" });
    };
  }
  var y2 = c2(true, false);
  var R3 = c2(false, false);
  var b3 = c2(true, true);
  function D3(e, t3) {
    utils_exports.isAddress(e) || t3.addIssue({ code: ZodIssueCode.custom, message: "Address must be a valid Ethereum address" });
  }
  function M3(e) {
    let t3 = /* @__PURE__ */ new Set(), o3 = /* @__PURE__ */ new Set();
    for (let n4 of e)
      t3.has(n4) && o3.add(n4), t3.add(n4);
    return [...o3];
  }
  function U4(e, t3) {
    e.length > g3 && t3.addIssue({ code: ZodIssueCode.custom, message: `Selector must be <= ${g3} characters` }), /^\w*$/.test(e) || t3.addIssue({ code: ZodIssueCode.custom, message: "Selector must contain only alphanumeric & underscore characters" });
  }
  function z3(e) {
    let t3 = e.match(/^(\w+)\[(\d+)\]$/);
    return t3 ? { elementType: t3[1], staticLength: Number.parseInt(t3[2]) } : null;
  }
  var v4 = z2.string().superRefine(x5);
  var $3 = z2.string().superRefine(C2);
  var B3 = z2.string().superRefine(d3);
  var G3 = z2.array(v4).superRefine(h3);
  var O3 = z2.string().superRefine(y2);
  var V5 = z2.string().superRefine(b3);
  var j = z2.string().superRefine(R3);
  var k2 = z2.string().superRefine(D3);
  var P2 = z2.string().superRefine(U4);
  var l2 = class {
    static isCreated() {
      return this._global.__mudCoreContext !== void 0;
    }
    static createContext() {
      if (this.isCreated())
        throw new t2();
      let t3 = this._global, o3 = new l2();
      return t3.__mudCoreContext = o3, o3;
    }
    static getContext() {
      let o3 = this._global.__mudCoreContext;
      if (o3 === void 0)
        throw new s2();
      return o3;
    }
    configExtenders = [];
  };
  var i2 = l2;
  x4(i2, "_global", typeof global > "u" ? window.global ?? {} : global);
  function Y3(e) {
    let t3 = e, o3 = i2.getContext();
    for (let n4 of o3.configExtenders)
      t3 = n4(t3);
    return t3;
  }
  function q2(e) {
    i2.getContext().configExtenders.push(e);
  }
  var w2 = ((o3) => (o3[o3.TABLE_ID = 0] = "TABLE_ID", o3[o3.SYSTEM_ADDRESS = 1] = "SYSTEM_ADDRESS", o3))(w2 || {});
  function ee2(e) {
    return { type: 0, input: e };
  }

  // node_modules/@latticexyz/world/dist/chunk-JOQBBVRS.js
  var d4 = { registerFunctionSelector: true, openAccess: true, accessList: [] };
  var o2 = { worldContractName: void 0, worldInterfaceName: "IWorld", systems: {}, excludeSystems: [], postDeployScript: "PostDeploy", deploysDirectory: "./deploys", worldsFile: "./worlds.json", worldgenDirectory: "world", worldImportPath: "@latticexyz/world/src/", modules: [] };
  var y3 = v4;
  var h4 = v4;
  var z4 = z2.array(y3.or(k2)).default(d4.accessList);
  var v5 = z2.intersection(z2.object({ name: P2.optional(), registerFunctionSelectors: z2.boolean().default(d4.registerFunctionSelector) }), z2.discriminatedUnion("openAccess", [z2.object({ openAccess: z2.literal(true).default(d4.openAccess) }), z2.object({ openAccess: z2.literal(false), accessList: z4 })]));
  var x6 = z2.object({ value: z2.union([z2.string(), z2.number(), z2.instanceof(Uint8Array)]), type: z2.string() });
  var E3 = z2.object({ type: z2.nativeEnum(w2), input: z2.string() });
  var N = z2.object({ name: h4, root: z2.boolean().default(false), args: z2.array(z2.union([x6, E3])).default([]) });
  var T3 = z2.object({ worldContractName: z2.string().optional(), worldInterfaceName: z2.string().default(o2.worldInterfaceName), systems: z2.record(y3, v5).default(o2.systems), excludeSystems: z2.array(y3).default(o2.excludeSystems), postDeployScript: z2.string().default(o2.postDeployScript), deploysDirectory: z2.string().default(o2.deploysDirectory), worldsFile: z2.string().default(o2.worldsFile), worldgenDirectory: z2.string().default(o2.worldgenDirectory), worldImportPath: z2.string().default(o2.worldImportPath), modules: z2.array(N).default(o2.modules) });
  var M4 = T3.catchall(z2.any());

  // node_modules/@latticexyz/store/dist/chunk-NFP4I5XK.js
  var l3 = { storeImportPath: "@latticexyz/store/src/", userTypesPath: "Types", codegenDirectory: "codegen" };
  var g4 = { namespace: "", enums: {} };
  var m4 = { directory: "tables", keySchema: { key: "bytes32" }, tableIdArgument: false, storeArgument: true, ephemeral: false };
  var j2 = v4;
  var O4 = $3;
  var v6 = $3;
  var I3 = v4;
  var d5 = z2.string();
  var _17 = z2.string();
  var P3 = z2.record(O4, _17).default(m4.keySchema);
  var U6 = z2.record(v6, d5).refine((e) => Object.keys(e).length > 0, "Table schema may not be empty");
  var K3 = d5.transform((e) => U6.parse({ value: e }));
  var q3 = U6.or(K3);
  var h5 = z2.object({ directory: z2.string().default(m4.directory), name: P2.optional(), tableIdArgument: z2.boolean().default(m4.tableIdArgument), storeArgument: z2.boolean().default(m4.storeArgument), dataStruct: z2.boolean().optional(), keySchema: P3, schema: q3, ephemeral: z2.boolean().default(m4.ephemeral) }).transform((e) => (Object.keys(e.schema).length === 1 ? e.dataStruct ??= false : e.dataStruct ??= true, e));
  var B4 = d5.transform((e) => h5.parse({ schema: { value: e } }));
  var M5 = h5.or(B4);
  var $4 = z2.record(j2, M5).transform((e) => {
    for (let n4 of Object.keys(e)) {
      let s4 = e[n4];
      s4.name = n4.slice(0, g3), e[n4] = s4;
    }
    return e;
  });
  var H2 = z2.object({ enums: z2.record(I3, G3).default(g4.enums) });
  var x7 = z2.object({ namespace: P2.default(g4.namespace), storeImportPath: z2.string().default(l3.storeImportPath), tables: $4, userTypesPath: z2.string().default(l3.userTypesPath), codegenDirectory: z2.string().default(l3.codegenDirectory) }).merge(H2);
  var se3 = x7.superRefine(C3);
  var re3 = x7.catchall(z2.any()).superRefine(C3);
  function C3(e, n4) {
    for (let a2 of Object.values(e.tables)) {
      let c3 = Object.keys(a2.keySchema), N2 = Object.keys(a2.schema), T4 = M3([...c3, ...N2]);
      T4.length > 0 && n4.addIssue({ code: ZodIssueCode.custom, message: `Field and key names within one table must be unique: ${T4.join(", ")}` });
    }
    let s4 = Object.keys(e.tables), r2 = Object.keys(e.enums), i4 = r2, E4 = [...s4, ...i4], u3 = M3(E4);
    u3.length > 0 && n4.addIssue({ code: ZodIssueCode.custom, message: `Table library names, enum names must be globally unique: ${u3.join(", ")}` });
    let A3 = Object.values(e.tables).map(({ name: a2 }) => a2), y4 = M3(A3);
    y4.length > 0 && n4.addIssue({ code: ZodIssueCode.custom, message: `Table names must be unique: ${y4.join(", ")}` });
    for (let a2 of Object.values(e.tables)) {
      for (let c3 of Object.values(a2.keySchema))
        F4(r2, c3, n4);
      for (let c3 of Object.values(a2.schema))
        G4(i4, r2, c3, n4);
    }
  }
  function G4(e, n4, s4, r2) {
    if (!s.includes(s4) && !e.includes(s4)) {
      let i4 = z3(s4);
      i4 ? V6(n4, i4.elementType, i4.staticLength, r2) : r2.addIssue({ code: ZodIssueCode.custom, message: `${s4} is not a valid abi type, and is not defined in userTypes` });
    }
  }
  function F4(e, n4, s4) {
    !U3.includes(n4) && !e.includes(n4) && s4.addIssue({ code: ZodIssueCode.custom, message: `${n4} is not a static type` });
  }
  function V6(e, n4, s4, r2) {
    F4(e, n4, r2), s4 === 0 ? r2.addIssue({ code: ZodIssueCode.custom, message: "Static array length must not be 0" }) : s4 >= 2 ** 16 && r2.addIssue({ code: ZodIssueCode.custom, message: "Static array length must be less than 2**16" });
  }

  // node_modules/@latticexyz/config/dist/register/index.js
  i2.isCreated() || i2.createContext();

  // node_modules/@latticexyz/store/dist/chunk-ORDXZBBB.js
  q2((r2) => {
    try {
      return re3.parse(r2);
    } catch (o3) {
      throw o3 instanceof ZodError ? l(o3, "StoreConfig Validation Error") : o3;
    }
  });
  function s3(r2) {
    return Y3(r2);
  }

  // node_modules/@latticexyz/world/dist/chunk-24XAL2ND.js
  q2((r2) => {
    try {
      return M4.parse(r2);
    } catch (o3) {
      throw o3 instanceof ZodError ? l(o3, "WorldConfig Validation Error") : o3;
    }
  });

  // node_modules/@latticexyz/world/dist/ts/plugins/snapsync/index.js
  var i3 = z2.object({ snapSync: z2.boolean() }).catchall(z2.any());
  q2((n4) => {
    let r2 = { ...n4 };
    if (i3.parse(n4).snapSync) {
      let s4 = M4.parse(n4), p2 = re3.parse(n4), c3 = Object.entries(p2.tables).filter(([e, t3]) => !t3.ephemeral).map(([e, t3]) => e).map((e) => ({ name: "KeysInTableModule", root: true, args: [ee2(e)] }));
      r2.modules = [...s4.modules, { name: "SnapSyncModule", root: true, args: [] }, ...c3];
    }
    return r2;
  });

  // src/contracts/mud.config.ts
  var mud_config_default = s3({
    snapSync: true,
    systems: {
      PlayerSystem: {
        openAccess: true
      },
      GameSystem: {
        openAccess: true
      }
    },
    enums: {
      GameConfigType: [
        "SlotNum",
        "ComposeNumMin",
        "ComposeNumMax",
        "TypeNum",
        "LevelBlockInitNum",
        "BorderStep",
        "LevelNum",
        "CardSize",
        "ViewWidth",
        "ViewHeight",
        "TotalRangeNum",
        "StageNum",
        "RemoveRule"
      ],
      RemoveRuleType: ["Continue", "Discrete"]
    },
    tables: {
      PlayerComponent: "bool",
      PlayerSeedComponent: {
        keySchema: {
          entity: "bytes32",
          index: "bytes32"
        },
        schema: {
          value: "uint32"
        }
      },
      PlayerScoreComponent: {
        keySchema: {
          entity: "bytes32",
          index: "bytes32"
        },
        schema: {
          value: "uint256"
        }
      },
      PlayerStageComponent: {
        keySchema: {
          entity: "bytes32",
          index: "bytes32"
        },
        schema: {
          value: "uint256"
        }
      },
      PlayerConfigComponent: {
        schema: {
          config: "uint256[3]"
        }
      },
      SeedComponent: {
        keySchema: {},
        schema: {
          value: "uint256",
          updatePeriod: "uint256",
          startFrom: "uint256"
        }
      },
      RankComponent: {
        schema: {
          addr: "address[10]",
          score: "uint32[10]"
        }
      },
      GameConfigComponent: {
        keySchema: {
          entity: "bytes32",
          index: "bytes32"
        },
        schema: {
          config: "uint256"
        }
      }
    }
  });

  // src/mud/setupNetwork.ts
  async function setupNetwork() {
    const contractComponents = defineContractComponents(world);
    const networkConfig = await getNetworkConfig();
    const result = await Hr2({
      networkConfig,
      world,
      contractComponents,
      syncThread: "main",
      storeConfig: mud_config_default,
      worldAbi: IWorld__factory.abi
    });
    const signer = result.network.signer.get();
    if (networkConfig.faucetServiceUrl && signer) {
      const address = await signer.getAddress();
      console.info("[Dev Faucet]: Player address -> ", address);
      const faucet = Rn(networkConfig.faucetServiceUrl);
      const requestDrip = async () => {
        const balance = await signer.getBalance();
        console.info(`[Dev Faucet]: Player balance -> ${balance}`);
        const lowBalance = balance?.lte(utils_exports.parseEther("1"));
        if (lowBalance) {
          console.info("[Dev Faucet]: Balance is low, dripping funds to player");
          await faucet.dripDev({ address });
          await faucet.dripDev({ address });
        }
      };
      requestDrip();
      setInterval(requestDrip, 2e4);
    }
    const provider = result.network.providers.get().json;
    const signerOrProvider = signer ?? provider;
    const worldContract = IWorld__factory.connect(networkConfig.worldAddress, signerOrProvider);
    if (networkConfig.snapSync) {
      const currentBlockNumber = await provider.getBlockNumber();
      const tableRecords = await Gn(
        networkConfig.worldAddress,
        Ot(mud_config_default),
        currentBlockNumber,
        signerOrProvider
      );
      console.log(`Syncing ${tableRecords.length} records`);
      result.startSync(tableRecords, currentBlockNumber);
    } else {
      result.startSync();
    }
    const fastTxExecutor = signer?.provider instanceof JsonRpcProvider ? await An(signer) : null;
    function bindFastTxExecute(contract) {
      return async function(...args) {
        if (!fastTxExecutor) {
          throw new Error("no signer");
        }
        const { tx } = await fastTxExecutor.fastTxExecute(contract, ...args);
        return await tx;
      };
    }
    return {
      ...result,
      worldContract,
      worldSend: bindFastTxExecute(worldContract),
      fastTxExecutor
    };
  }

  // src/mud/setup.ts
  async function setup() {
    const network = await setupNetwork();
    const components = createClientComponents(network);
    const systemCalls = createSystemCalls(network, components);
    return {
      network,
      components,
      systemCalls
    };
  }

  // src/scene/Login.generated.ts
  var LoginBase = class extends Laya.Scene {
    Start_Button;
    Rank_Button;
    Mask;
  };

  // src/scene/Login.ts
  var { regClass: regClass6, property: property6 } = Laya;
  var Login = class extends LoginBase {
    gameComponents;
    result;
    onAwake() {
      console.log("Login start");
      this.Start_Button.on(Laya.Event.CLICK, this, this.onStartButtenEvent.bind(this));
      this.Rank_Button.on(Laya.Event.CLICK, this, this.onRankButtenEvent.bind(this));
      const net = NetMgr.getInstance();
      if (net.GetMud() === void 0) {
        setup().then(async (result) => {
          const net2 = NetMgr.getInstance();
          net2.SetMud(result);
          console.log("load mud success");
          console.log(net2);
          const {
            components: { PlayerComponent },
            network: { world: world2, playerEntity },
            systemCalls: { joinGame }
          } = result;
          const player = x(PlayerComponent, playerEntity);
          if (player === void 0) {
            const ret = await joinGame();
            if (ret) {
              Laya.timer.once(1e3, this, this.changeBg.bind(this));
            }
          } else {
            Laya.timer.once(1e3, this, this.changeBg.bind(this));
          }
        });
      }
    }
    onOpened(param) {
    }
    changeBg() {
      Laya.Tween.to(this.Mask, { alpha: 0 }, 1200, Laya.Ease.linearIn);
    }
    onActionFinishEvent() {
      this.onChangeScene();
    }
    onStartButtenEvent() {
      Laya.Tween.to(this.Mask, { alpha: 1 }, 1200, Laya.Ease.linearIn, Laya.Handler.create(this, this.onActionFinishEvent.bind(this)));
    }
    onRankButtenEvent() {
      Laya.Scene.open("resources/prefab/P_rank.lh", false, { "text": "112" });
    }
    onChangeScene() {
      Laya.Scene.open("resources/scene/Game.ls", true, null, null, null);
      Laya.Scene.close("resources/scene/Login.ls");
      Laya.Scene.destroy("resources/scene/Login.ls");
    }
  };
  Login = __decorateClass([
    regClass6("b33edd45-b3d0-4823-b4f3-d9d1f05f0101")
  ], Login);
})();
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

elen/src/elen.js:
  (***
   * @license
   * https://github.com/ealmansi/elen
   * Copyright (c) 2017 Emilio Almansi
   * Distributed under the MIT software license, see the accompanying
   * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
   *)

@latticexyz/utils/dist/index.js:
  (**
   * UUID.core.js - UUID.js for Minimalists
   *
   * @file
   * @author  LiosK
   * @version v4.2.0
   * @license Apache License 2.0: Copyright (c) 2010-2018 LiosK
   * @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js
   *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
