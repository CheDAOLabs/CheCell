import { uuid, mapObject, filterNullish } from '@latticexyz/utils';
import { pipe, map, Subject, filter, from, merge, concatMap, of, concat, EMPTY } from 'rxjs';
import { observable } from 'mobx';

/**
 * Type enum is used to specify value types in {@link ComponentSchema} to be able
 * to access type values in JavaScript in addition to TypeScript type checks.
 */
var Type;
(function (Type) {
    Type[Type["Boolean"] = 0] = "Boolean";
    Type[Type["Number"] = 1] = "Number";
    Type[Type["OptionalNumber"] = 2] = "OptionalNumber";
    Type[Type["BigInt"] = 3] = "BigInt";
    Type[Type["OptionalBigInt"] = 4] = "OptionalBigInt";
    Type[Type["String"] = 5] = "String";
    Type[Type["OptionalString"] = 6] = "OptionalString";
    Type[Type["NumberArray"] = 7] = "NumberArray";
    Type[Type["OptionalNumberArray"] = 8] = "OptionalNumberArray";
    Type[Type["BigIntArray"] = 9] = "BigIntArray";
    Type[Type["OptionalBigIntArray"] = 10] = "OptionalBigIntArray";
    Type[Type["StringArray"] = 11] = "StringArray";
    Type[Type["OptionalStringArray"] = 12] = "OptionalStringArray";
    Type[Type["Entity"] = 13] = "Entity";
    Type[Type["OptionalEntity"] = 14] = "OptionalEntity";
    Type[Type["EntityArray"] = 15] = "EntityArray";
    Type[Type["OptionalEntityArray"] = 16] = "OptionalEntityArray";
    Type[Type["T"] = 17] = "T";
    Type[Type["OptionalT"] = 18] = "OptionalT";
})(Type || (Type = {}));
/**
 * Used to specify type of {@link ComponentUpdate}.
 * - Enter: Update added a value to an entity that did not have a value before
 * - Exit: Update removed a value from an entity that had a value before
 * - Update: Update changed a value of an entity that already had a value before. Note: the value doesn't need to be different from the previous value.
 * - Noop: Update did nothing (removed a value from an entity that did not have a value)
 */
var UpdateType;
(function (UpdateType) {
    UpdateType[UpdateType["Enter"] = 0] = "Enter";
    UpdateType[UpdateType["Exit"] = 1] = "Exit";
    UpdateType[UpdateType["Update"] = 2] = "Update";
    UpdateType[UpdateType["Noop"] = 3] = "Noop";
})(UpdateType || (UpdateType = {}));
/**
 * Helper constant with all optional {@link Type}s.
 */
const OptionalTypes = [
    Type.OptionalEntity,
    Type.OptionalEntityArray,
    Type.OptionalNumber,
    Type.OptionalNumberArray,
    Type.OptionalBigInt,
    Type.OptionalBigIntArray,
    Type.OptionalString,
    Type.OptionalStringArray,
    Type.OptionalT,
];

/**
 * Create an indexed component from a given component.
 *
 * @remarks
 * An indexed component keeps a "reverse mapping" from {@link ComponentValue} to the Set of {@link createEntity Entities} with this value.
 * This adds a performance overhead to modifying component values and a memory overhead since in the worst case there is one Set per entity (if every entity has a different component value).
 * In return the performance for querying for entities with a given component value is close to O(1) (instead of O(#entities) in a regular non-indexed component).
 * As a rule of thumb only components that are added to many entities and are queried with {@link HasValue} a lot should be indexed (eg. the Position component).
 *
 * @dev This could be made more (memory) efficient by using a hash of the component value as key, but would require handling hash collisions.
 *
 * @param component {@link defineComponent Component} to index.
 * @returns Indexed version of the component.
 */
function createIndexer(component) {
    const valueToEntities = new Map();
    function getEntitiesWithValue(value) {
        const entities = valueToEntities.get(getValueKey(value));
        return entities ? new Set([...entities]) : new Set();
    }
    function getValueKey(value) {
        return Object.values(value).join("/");
    }
    function add(entity, value) {
        if (!value)
            return;
        const valueKey = getValueKey(value);
        let entitiesWithValue = valueToEntities.get(valueKey);
        if (!entitiesWithValue) {
            entitiesWithValue = new Set();
            valueToEntities.set(valueKey, entitiesWithValue);
        }
        entitiesWithValue.add(entity);
    }
    function remove(entity, value) {
        if (!value)
            return;
        const valueKey = getValueKey(value);
        const entitiesWithValue = valueToEntities.get(valueKey);
        if (!entitiesWithValue)
            return;
        entitiesWithValue.delete(entity);
    }
    // Initial indexing
    for (const entity of getComponentEntities(component)) {
        const value = getComponentValue(component, entity);
        add(entity, value);
    }
    // Keeping index up to date
    const subscription = component.update$.subscribe(({ entity, value }) => {
        // Remove from previous location
        remove(entity, value[1]);
        // Add to new location
        add(entity, value[0]);
    });
    component.world.registerDisposer(() => subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe());
    return { ...component, getEntitiesWithValue };
}

/**
 * Type guard to infer the TypeScript type of a given component update
 *
 * @param update Component update to infer the type of.
 * @param component {@link defineComponent Component} to check whether the given update corresponds to it.
 * @returns True (+ infered type for `update`) if `update` belongs to `component`. Else false.
 */
function isComponentUpdate(update, component) {
    return update.component === component;
}
/**
 * Helper function to create a component update for the current component value of a given entity.
 *
 * @param entity Entity to create the component update for.
 * @param component Component to create the component update for.
 * @returns Component update corresponding to the given entity, the given component and the entity's current component value.
 */
function toUpdate(entity, component) {
    const value = getComponentValue(component, entity);
    return {
        entity,
        component,
        value: [value, undefined],
        type: value == null ? UpdateType.Noop : UpdateType.Enter,
    };
}
/**
 * Helper function to turn a stream of {@link EntityIndex EntityIndices} into a stream of component updates of the given component.
 * @param component Component to create update stream for.
 * @returns Unary function to be used with RxJS that turns stream of {@link EntityIndex EntityIndices} into stream of component updates.
 */
function toUpdateStream(component) {
    return pipe(map((entity) => toUpdate(entity, component)));
}
/**
 * Helper function to check whether a given component is indexed.
 * @param c
 * @returns
 */
function isIndexer(c) {
    return "getEntitiesWithValue" in c;
}
/**
 * Helper function to check whether a given component value is partial or full.
 * @param component
 * @param value
 * @returns
 */
function isFullComponentValue(component, value) {
    return Object.keys(component.schema).every((key) => key in value);
}

/**
 * Components contain state indexed by entities and are one of the fundamental building blocks in ECS.
 * Besides containing the state, components expose an rxjs update$ stream, that emits an event any time the value
 * of an entity in this component is updated.
 *
 * @param world {@link World} object this component should be registered onto.
 * @param schema {@link Schema} of component values. Uses Type enum as bridge between typescript types and javascript accessible values.
 * @param options Optional: {
 *    id: descriptive id for this component (otherwise an autogenerated id is used),
 *    metadata: arbitrary metadata (eg. contractId for solecs mapped components),
 *    indexed: if this flag is set, an indexer is applied to this component (see {@link createIndexer})
 * }
 * @returns Component object linked to the provided World
 *
 * @remarks
 * Components work with {@link EntityIndex}, not {@link EntityID}. Get the {@link EntityID} from a given {@link EntityIndex} via {@link World}.entities[EntityIndex].
 *
 * @example
 * ```
 * const Position = defineComponent(world, { x: Type.Number, y: Type.Number }, { id: "Position" });
 * ```
 */
function defineComponent(world, schema, options) {
    var _a;
    if (Object.keys(schema).length === 0)
        throw new Error("Component schema must have at least one key");
    const id = (_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : uuid();
    const values = mapObject(schema, () => new Map());
    const update$ = new Subject();
    const metadata = options === null || options === void 0 ? void 0 : options.metadata;
    const entities = () => Object.values(values)[0].keys();
    let component = { values, schema, id, update$, metadata, entities, world };
    if (options === null || options === void 0 ? void 0 : options.indexed)
        component = createIndexer(component);
    world.registerComponent(component);
    return component;
}
/**
 * Set the value for a given entity in a given component.
 *
 * @param component {@link defineComponent Component} to be updated.
 * @param entity {@link EntityIndex} of the entity whose value in the given component should be set.
 * @param value Value to set, schema must match the component schema.
 *
 * @example
 * ```
 * setComponent(Position, entity, { x: 1, y: 2 });
 * ```
 */
function setComponent(component, entity, value) {
    var _a, _b, _c, _d, _e;
    const prevValue = getComponentValue(component, entity);
    for (const [key, val] of Object.entries(value)) {
        if (component.values[key]) {
            component.values[key].set(entity, val);
        }
        else {
            const isTableFieldIndex = ((_a = component.metadata) === null || _a === void 0 ? void 0 : _a.tableId) && /^\d+$/.test(key);
            if (!isTableFieldIndex) {
                // If this key looks like a field index from `defineStoreComponents`,
                // we can ignore this value without logging anything.
                //
                // Otherwise, we should let the user know we found undefined data.
                console.warn("Component definition for", (_e = (_c = (_b = component.metadata) === null || _b === void 0 ? void 0 : _b.tableId) !== null && _c !== void 0 ? _c : (_d = component.metadata) === null || _d === void 0 ? void 0 : _d.contractId) !== null && _e !== void 0 ? _e : component.id, "is missing key", key, ", ignoring value", val, "for entity", entity, ". Existing keys: ", Object.keys(component.values));
            }
        }
    }
    component.update$.next({ entity, value: [value, prevValue], component });
}
/**
 * Update the value for a given entity in a given component while keeping the old value of keys not included in the update.
 *
 * @param component {@link defineComponent Component} to be updated.
 * @param entity {@link EntityIndex} of the entity whose value in the given component should be updated.
 * @param value Partial value to be set, remaining keys will be taken from the existing component value.
 *
 * @remarks
 * This function fails silently during runtime if a partial value is set for an entity that
 * does not have a component value yet, since then a partial value will be set in the component for this entity.
 *
 * @example
 * ```
 * updateComponent(Position, entity, { x: 1 });
 * ```
 */
function updateComponent(component, entity, value, initialValue) {
    const currentValue = getComponentValue(component, entity);
    if (currentValue === undefined) {
        if (initialValue === undefined) {
            throw new Error("Can't update component without a current value or initial value");
        }
        setComponent(component, entity, { ...initialValue, ...value });
    }
    else {
        setComponent(component, entity, { ...currentValue, ...value });
    }
}
/**
 * Remove a given entity from a given component.
 *
 * @param component {@link defineComponent Component} to be updated.
 * @param entity {@link EntityIndex} of the entity whose value should be removed from this component.
 */
function removeComponent(component, entity) {
    const prevValue = getComponentValue(component, entity);
    for (const key of Object.keys(component.values)) {
        component.values[key].delete(entity);
    }
    component.update$.next({ entity, value: [undefined, prevValue], component });
}
/**
 * Check whether a component contains a value for a given entity.
 *
 * @param component {@link defineComponent Component} to check whether it has a value for the given entity.
 * @param entity {@link EntityIndex} of the entity to check whether it has a value in the given component.
 * @returns true if the component contains a value for the given entity, else false.
 */
function hasComponent(component, entity) {
    const map = Object.values(component.values)[0];
    return map.has(entity);
}
/**
 * Get the value of a given entity in the given component.
 * Returns undefined if no value or only a partial value is found.
 *
 * @param component {@link defineComponent Component} to get the value from for the given entity.
 * @param entity {@link EntityIndex} of the entity to get the value for from the given component.
 * @returns Value of the given entity in the given component or undefined if no value exists.
 */
function getComponentValue(component, entity) {
    const value = {};
    // Get the value of each schema key
    const schemaKeys = Object.keys(component.schema);
    for (const key of schemaKeys) {
        const val = component.values[key].get(entity);
        if (val === undefined && !OptionalTypes.includes(component.schema[key]))
            return undefined;
        value[key] = val;
    }
    return value;
}
/**
 * Get the value of a given entity in the given component.
 * Throws an error if no value exists for the given entity in the given component.
 *
 * @param component {@link defineComponent Component} to get the value from for the given entity.
 * @param entity {@link EntityIndex} of the entity to get the value for from the given component.
 * @returns Value of the given entity in the given component.
 *
 * @remarks
 * Throws an error if no value exists in the component for the given entity.
 */
function getComponentValueStrict(component, entity) {
    const value = getComponentValue(component, entity);
    if (!value)
        throw new Error(`No value for component ${component.id} on entity ${component.world.entities[entity]}`);
    return value;
}
/**
 * Compare two {@link ComponentValue}s.
 * `a` can be a partial component value, in which case only the keys present in `a` are compared to the corresponding keys in `b`.
 *
 * @param a Partial {@link ComponentValue} to compare to `b`
 * @param b Component value to compare `a` to.
 * @returns True if `a` equals `b` in the keys present in a or neither `a` nor `b` are defined, else false.
 *
 * @example
 * ```
 * componentValueEquals({ x: 1, y: 2 }, { x: 1, y: 3 }) // returns false because value of y doesn't match
 * componentValueEquals({ x: 1 }, { x: 1, y: 3 }) // returns true because x is equal and y is not present in a
 * ```
 */
function componentValueEquals(a, b) {
    if (!a && !b)
        return true;
    if (!a || !b)
        return false;
    let equals = true;
    for (const key of Object.keys(a)) {
        equals = a[key] === b[key];
        if (!equals)
            return false;
    }
    return equals;
}
/**
 * Util to create a tuple of a component and value with matching schema.
 * (Used to enforce Typescript type safety.)
 *
 * @param component {@link defineComponent Component} with {@link ComponentSchema} `S`
 * @param value {@link ComponentValue} with {@link ComponentSchema} `S`
 * @returns Tuple `[component, value]`
 */
function withValue(component, value) {
    return [component, value];
}
/**
 * Get a set of entities that have the given component value in the given component.
 *
 * @param component {@link defineComponent Component} to get entities with the given value from.
 * @param value look for entities with this {@link ComponentValue}.
 * @returns Set with {@link EntityIndex EntityIndices} of the entities with the given component value.
 */
function getEntitiesWithValue(component, value) {
    // Shortcut for indexers
    if (isIndexer(component) && isFullComponentValue(component, value)) {
        return component.getEntitiesWithValue(value);
    }
    // Trivial implementation for regular components
    const entities = new Set();
    for (const entity of getComponentEntities(component)) {
        const val = getComponentValue(component, entity);
        if (componentValueEquals(value, val)) {
            entities.add(entity);
        }
    }
    return entities;
}
/**
 * Get a set of all entities of the given component.
 *
 * @param component {@link defineComponent Component} to get all entities from
 * @returns Set of all entities in the given component.
 */
function getComponentEntities(component) {
    return component.entities();
}
/**
 * An overridable component is a mirror of the source component, with functions to lazily override specific entity values.
 * Lazily override means the values are not actually set to the source component, but the override is only returned if the value is read.
 *
 * - When an override for an entity is added to the component, the override is propagated via the component's `update$` stream.
 * - While an override is set for a specific entity, no updates to the source component for this entity will be propagated to the `update$` stream.
 * - When an override is removed for a specific entity and there are more overrides targeting this entity,
 * the override with the highest nonce will be propagated to the `update$` stream.
 * - When an override is removed for a specific entity and there are no more overrides targeting this entity,
 * the non-overridden underlying component value of this entity will be propagated to the `update$` stream.
 *
 * @param component {@link defineComponent Component} to use as underlying source for the overridable component
 * @returns overridable component
 */
function overridableComponent(component) {
    let nonce = 0;
    // Map from OverrideId to Override (to be able to add multiple overrides to the same Entity)
    const overrides = new Map();
    // Map from EntityIndex to current overridden component value
    const overriddenEntityValues = new Map();
    // Update event stream that takes into account overridden entity values
    const update$ = new Subject();
    // Add a new override to some entity
    function addOverride(id, update) {
        overrides.set(id, { update, nonce: nonce++ });
        setOverriddenComponentValue(update.entity, update.value);
    }
    // Remove an override from an entity
    function removeOverride(id) {
        var _a;
        const affectedEntity = (_a = overrides.get(id)) === null || _a === void 0 ? void 0 : _a.update.entity;
        overrides.delete(id);
        if (affectedEntity == null)
            return;
        // If there are more overries affecting this entity,
        // set the overriddenEntityValue to the last override
        const relevantOverrides = [...overrides.values()]
            .filter((o) => o.update.entity === affectedEntity)
            .sort((a, b) => (a.nonce < b.nonce ? -1 : 1));
        if (relevantOverrides.length > 0) {
            const lastOverride = relevantOverrides[relevantOverrides.length - 1];
            setOverriddenComponentValue(affectedEntity, lastOverride.update.value);
        }
        else {
            setOverriddenComponentValue(affectedEntity, undefined);
        }
    }
    // Internal function to get the current overridden value or value of the source component
    function getOverriddenComponentValue(entity) {
        const originalValue = getComponentValue(component, entity);
        const overriddenValue = overriddenEntityValues.get(entity);
        return (originalValue || overriddenValue) && overriddenValue !== null // null is a valid override, in this case return undefined
            ? { ...originalValue, ...overriddenValue }
            : undefined;
    }
    const valueProxyHandler = (key) => ({
        get(target, prop) {
            // Intercept calls to component.value[key].get(entity)
            if (prop === "get") {
                return (entity) => {
                    const originalValue = target.get(entity);
                    const overriddenValue = overriddenEntityValues.get(entity);
                    return overriddenValue && overriddenValue[key] != null ? overriddenValue[key] : originalValue;
                };
            }
            // Intercept calls to component.value[key].has(entity)
            if (prop === "has") {
                return (entity) => {
                    return target.has(entity) || overriddenEntityValues.has(entity);
                };
            }
            // Intercept calls to component.value[key].keys()
            if (prop === "keys") {
                return () => new Set([...target.keys(), ...overriddenEntityValues.keys()]).values();
            }
            return Reflect.get(target, prop, target);
        },
    });
    const partialValues = {};
    for (const key of Object.keys(component.values)) {
        partialValues[key] = new Proxy(component.values[key], valueProxyHandler(key));
    }
    const valuesProxy = partialValues;
    const overriddenComponent = new Proxy(component, {
        get(target, prop) {
            if (prop === "addOverride")
                return addOverride;
            if (prop === "removeOverride")
                return removeOverride;
            if (prop === "values")
                return valuesProxy;
            if (prop === "update$")
                return update$;
            if (prop === "entities")
                return () => new Set([...overriddenEntityValues.keys(), ...target.entities()]).values();
            return Reflect.get(target, prop);
        },
        has(target, prop) {
            if (prop === "addOverride" || prop === "removeOverride")
                return true;
            return prop in target;
        },
    });
    // Internal function to set the current overridden component value and emit the update event
    function setOverriddenComponentValue(entity, value) {
        // Check specifically for undefined - null is a valid override
        const prevValue = getOverriddenComponentValue(entity);
        if (value !== undefined)
            overriddenEntityValues.set(entity, value);
        else
            overriddenEntityValues.delete(entity);
        update$.next({ entity, value: [getOverriddenComponentValue(entity), prevValue], component: overriddenComponent });
    }
    // Channel through update events from the original component if there are no overrides
    component.update$
        .pipe(filter((e) => !overriddenEntityValues.get(e.entity)), map((update) => ({ ...update, component: overriddenComponent })))
        .subscribe(update$);
    return overriddenComponent;
}
function getLocalCacheId(component, uniqueWorldIdentifier) {
    return `localcache-${uniqueWorldIdentifier}-${component.id}`;
}
function clearLocalCache(component, uniqueWorldIdentifier) {
    localStorage.removeItem(getLocalCacheId(component, uniqueWorldIdentifier));
}
// Note: Only proof of concept for now - use this only for component that do not update frequently
function createLocalCache(component, uniqueWorldIdentifier) {
    const { world, update$, values } = component;
    const cacheId = getLocalCacheId(component, uniqueWorldIdentifier);
    let numUpdates = 0;
    const creation = Date.now();
    // On creation, check if this component has locally cached values
    const encodedCache = localStorage.getItem(cacheId);
    if (encodedCache) {
        const cache = JSON.parse(encodedCache);
        const state = {};
        for (const [key, values] of cache) {
            for (const [entity, value] of values) {
                state[entity] = state[entity] || {};
                state[entity][key] = value;
            }
        }
        for (const [entityId, value] of Object.entries(state)) {
            const entityIndex = world.registerEntity({ id: entityId });
            setComponent(component, entityIndex, value);
        }
        console.info("Loading component", component.id, "from local cache.");
    }
    // Flush the entire component to the local cache every time it updates.
    // Note: this is highly unperformant and should only be used for components that
    // don't update often and don't have many values
    const updateSub = update$.subscribe(() => {
        numUpdates++;
        const encoded = JSON.stringify(Object.entries(mapObject(values, (m) => [...m.entries()].map((e) => [world.entities[e[0]], e[1]]))));
        localStorage.setItem(cacheId, encoded);
        if (numUpdates > 200) {
            console.warn("Component with id", component.id, "was locally cached", numUpdates, "times since", new Date(creation).toLocaleTimeString(), "- the local cache is in an alpha state and should not be used with components that update frequently yet");
        }
    });
    component.world.registerDisposer(() => updateSub === null || updateSub === void 0 ? void 0 : updateSub.unsubscribe());
    return component;
}

/**
 * Register a new entity in the given {@link World} and initialize it with the given {@link ComponentValue}s.
 *
 * @param world World object this entity should be registered in.
 * @param components Array of [{@link defineComponent Component}, {@link ComponentValue}] tuples to be added to this entity.
 * (Use {@link withValue} to generate these tuples with type safety.)
 * @param options Optional: {
 *   id: {@link EntityID} for this entity. Use this for entities that were created outside of recs, eg. in the corresponding solecs contracts.
 *   idSuffix: string to be appended to the auto-generated id. Use this for improved readability. Do not use this if the `id` option is provided.
 * }
 * @returns index of this entity in the {@link World}. This {@link EntityIndex} is used to refer to this entity in other recs methods (eg {@link setComponent}).
 * (This is to avoid having to store strings in every component.)
 */
function createEntity(world, components, options) {
    const entity = world.registerEntity(options !== null && options !== void 0 ? options : {});
    if (components) {
        for (const [component, value] of components) {
            setComponent(component, entity, value);
        }
    }
    return entity;
}

var QueryFragmentType;
(function (QueryFragmentType) {
    QueryFragmentType[QueryFragmentType["Has"] = 0] = "Has";
    QueryFragmentType[QueryFragmentType["HasValue"] = 1] = "HasValue";
    QueryFragmentType[QueryFragmentType["Not"] = 2] = "Not";
    QueryFragmentType[QueryFragmentType["NotValue"] = 3] = "NotValue";
    QueryFragmentType[QueryFragmentType["ProxyRead"] = 4] = "ProxyRead";
    QueryFragmentType[QueryFragmentType["ProxyExpand"] = 5] = "ProxyExpand";
})(QueryFragmentType || (QueryFragmentType = {}));
function isOptionalType(t) {
    return [
        Type.OptionalNumber,
        Type.OptionalBigInt,
        Type.OptionalString,
        Type.OptionalEntity,
        Type.OptionalEntityArray,
        Type.OptionalNumberArray,
        Type.OptionalBigIntArray,
        Type.OptionalStringArray,
    ].includes(t);
}
function isArrayType(t) {
    return [
        Type.NumberArray,
        Type.OptionalNumberArray,
        Type.BigIntArray,
        Type.OptionalBigIntArray,
        Type.StringArray,
        Type.OptionalStringArray,
        Type.EntityArray,
        Type.OptionalEntityArray,
    ].includes(t);
}
function isNumberType(t) {
    return [Type.Number, Type.OptionalNumber].includes(t);
}
function isEntityType(t) {
    return [Type.Entity, Type.OptionalEntity].includes(t);
}

/**
 * Create a {@link HasQueryFragment}.
 *
 * @remarks
 * The {@link HasQueryFragment} filters for entities that have the given component,
 * independent from the component value.
 *
 * @example
 * Query for all entities with a `Position`.
 * ```
 * runQuery([Has(Position)]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
function Has(component) {
    return { type: QueryFragmentType.Has, component };
}
/**
 * Create a {@link NotQueryFragment}.
 *
 * @remarks
 * The {@link NotQueryFragment} filters for entities that don't have the given component,
 * independent from the component value.
 *
 * @example
 * Query for all entities with a `Position` that are not `Movable`.
 * ```
 * runQuery([Has(Position), Not(Movable)]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
function Not(component) {
    return { type: QueryFragmentType.Not, component };
}
/**
 * Create a {@link HasValueQueryFragment}.
 *
 * @remarks
 * The {@link HasValueQueryFragment} filters for entities that have the given component
 * with the given component value.
 *
 * @example
 * Query for all entities at Position (0,0).
 * ```
 * runQuery([HasValue(Position, { x: 0, y: 0 })]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @param value Only include entities with this (partial) component value from the result.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
function HasValue(component, value) {
    return { type: QueryFragmentType.HasValue, component, value };
}
/**
 * Create a {@link NotValueQueryFragment}.
 *
 * @remarks
 * The {@link NotValueQueryFragment} filters for entities that don't have the given component
 * with the given component value.
 *
 * @example
 * Query for all entities that have a `Position`, except for those at `Position` (0,0).
 * ```
 * runQuery([Has(Position), NotValue(Position, { x: 0, y: 0 })]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @param value Exclude entities with this (partial) component value from the result.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
function NotValue(component, value) {
    return { type: QueryFragmentType.NotValue, component, value };
}
/**
 * Create a {@link ProxyReadQueryFragment}.
 *
 * @remarks
 * The {@link ProxyReadQueryFragment} activates the "proxy read mode" for the rest of the query.
 * This means that for all remaining fragments in the query not only the entities themselves are checked, but also
 * their "ancestors" up to the given `depth` on the relationship chain defined by the given `component`.
 *
 * @example
 * Query for all entities that have a `Position` and are (directly or indirectly) owned by an entity with `Name` "Alice".
 * ```
 * runQuery([Has(Position), ProxyRead(OwnedByEntity, Number.MAX_SAFE_INTEGER), HasValue(Name, { name: "Alice" })]);
 * ```
 *
 * @param component Component this query fragment refers to.
 * @param depth Max depth in the relationship chain to traverse.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
function ProxyRead(component, depth) {
    return { type: QueryFragmentType.ProxyRead, component, depth };
}
/**
 * Create a {@link ProxyExpandQueryFragment}.
 *
 * @remarks
 * The {@link ProxyExpandQueryFragment} activates the "proxy expand mode" for the rest of the query.
 * This means that for all remaining fragments in the query not only the matching entities themselves are included in the intermediate set,
 * but also all their "children" down to the given `depth` on the relationship chain defined by the given `component`.
 *
 * @example
 * Query for all entities (directly or indirectly) owned by an entity with `Name` "Alice".
 * ```
 * runQuery([ProxyExpand(OwnedByEntity, Number.MAX_SAFE_INTEGER), HasValue(Name, { name: "Alice" })]);
 * ```
 *
 * @param component Component to apply this query fragment to.
 * @param depth Max depth in the relationship chain to traverse.
 * @returns query fragment to be used in {@link runQuery} or {@link defineQuery}.
 */
function ProxyExpand(component, depth) {
    return { type: QueryFragmentType.ProxyExpand, component, depth };
}
/**
 * Helper function to check whether a given entity passes a given query fragment.
 *
 * @param entity Entity to check.
 * @param fragment Query fragment to check.
 * @returns True if the entity passes the query fragment, else false.
 */
function passesQueryFragment(entity, fragment) {
    if (fragment.type === QueryFragmentType.Has) {
        // Entity must have the given component
        return hasComponent(fragment.component, entity);
    }
    if (fragment.type === QueryFragmentType.HasValue) {
        // Entity must have the given component value
        return componentValueEquals(fragment.value, getComponentValue(fragment.component, entity));
    }
    if (fragment.type === QueryFragmentType.Not) {
        // Entity must not have the given component
        return !hasComponent(fragment.component, entity);
    }
    if (fragment.type === QueryFragmentType.NotValue) {
        // Entity must not have the given component value
        return !componentValueEquals(fragment.value, getComponentValue(fragment.component, entity));
    }
    throw new Error("Unknown query fragment");
}
/**
 * Helper function to check whether a query fragment is "positive" (ie `Has` or `HasValue`)
 *
 * @param fragment Query fragment to check.
 * @returns True if the query fragment is positive, else false.
 */
function isPositiveFragment(fragment) {
    return fragment.type === QueryFragmentType.Has || fragment.type == QueryFragmentType.HasValue;
}
/**
 * Helper function to check whether a query fragment is "negative" (ie `Not` or `NotValue`)
 *
 * @param fragment Query fragment to check.
 * @returns True if the query fragment is negative, else false.
 */
function isNegativeFragment(fragment) {
    return fragment.type === QueryFragmentType.Not || fragment.type == QueryFragmentType.NotValue;
}
/**
 * Helper function to check whether a query fragment is a setting fragment (ie `ProxyExpand` or `ProxyRead`)
 *
 * @param fragment Query fragment to check.
 * @returns True if the query fragment is a setting fragment, else false.
 */
function isSettingFragment(fragment) {
    return fragment.type === QueryFragmentType.ProxyExpand || fragment.type == QueryFragmentType.ProxyRead;
}
/**
 * Helper function to check whether the result of a query pass check is a breaking state.
 *
 * @remarks
 * For positive fragments (Has/HasValue) we need to find any passing entity up the proxy chain
 * so as soon as passes is true, we can early return. For negative fragments (Not/NotValue) every entity
 * up the proxy chain must pass, so we can early return if we find one that doesn't pass.
 *
 * @param passes Boolean result of previous query pass check.
 * @param fragment Fragment that was used in the query pass check.
 * @returns True if the result is breaking pass state, else false.
 */
function isBreakingPassState(passes, fragment) {
    return (passes && isPositiveFragment(fragment)) || (!passes && isNegativeFragment(fragment));
}
/**
 * Helper function to check whether an entity passes a query fragment when taking into account a {@link ProxyReadQueryFragment}.
 *
 * @param entity {@link EntityIndex} of the entity to check.
 * @param fragment Query fragment to check.
 * @param proxyRead {@link ProxyReadQueryFragment} to take into account.
 * @returns True if the entity passes the query fragment, else false.
 */
function passesQueryFragmentProxy(entity, fragment, proxyRead) {
    let proxyEntity = entity;
    let passes = false;
    for (let i = 0; i < proxyRead.depth; i++) {
        const value = getComponentValue(proxyRead.component, proxyEntity);
        // If the current entity does not have the proxy component, abort
        if (!value)
            return null;
        const entityId = value.value;
        const entityIndex = proxyRead.component.world.entityToIndex.get(entityId);
        if (entityIndex === undefined)
            return null;
        // Move up the proxy chain
        proxyEntity = entityIndex;
        passes = passesQueryFragment(proxyEntity, fragment);
        if (isBreakingPassState(passes, fragment)) {
            return passes;
        }
    }
    return passes;
}
/**
 * Recursively compute all direct and indirect child entities up to the specified depth
 * down the relationship chain defined by the given component.
 *
 * @param entity Entity to get all child entities for up to the specified depth
 * @param component Component to use for the relationship chain.
 * @param depth Depth up to which the recursion should be applied.
 * @returns Set of entities that are child entities of the given entity via the given component.
 */
function getChildEntities(entity, component, depth) {
    if (depth === 0)
        return new Set();
    const entityId = component.world.entities[entity];
    const directChildEntities = getEntitiesWithValue(component, { value: entityId });
    if (depth === 1)
        return directChildEntities;
    const indirectChildEntities = [...directChildEntities]
        .map((childEntity) => [...getChildEntities(childEntity, component, depth - 1)])
        .flat();
    return new Set([...directChildEntities, ...indirectChildEntities]);
}
/**
 * Execute a list of query fragments to receive a Set of matching entities.
 *
 * @remarks
 * The query fragments are executed from left to right and are concatenated with a logical `AND`.
 * For performance reasons, the most restrictive query fragment should be first in the list of query fragments,
 * in order to reduce the number of entities the next query fragment needs to be checked for.
 * If no proxy fragments are used, every entity in the resulting set passes every query fragment.
 * If setting fragments are used, the order of the query fragments influences the result, since settings only apply to
 * fragments after the setting fragment.
 *
 * @param fragments Query fragments to execute.
 * @param initialSet Optional: provide a Set of entities to execute the query on. If none is given, all existing entities are used for the query.
 * @returns Set of entities matching the query fragments.
 */
function runQuery(fragments, initialSet) {
    var _a;
    let entities = initialSet ? new Set([...initialSet]) : undefined; // Copy to a fresh set because it will be modified in place
    let proxyRead = undefined;
    let proxyExpand = undefined;
    // Process fragments
    for (let i = 0; i < fragments.length; i++) {
        const fragment = fragments[i];
        if (isSettingFragment(fragment)) {
            // Store setting fragments for subsequent query fragments
            if (fragment.type === QueryFragmentType.ProxyRead)
                proxyRead = fragment;
            if (fragment.type === QueryFragmentType.ProxyExpand)
                proxyExpand = fragment;
        }
        else if (!entities) {
            // Handle entity query fragments
            // First regular fragment must be Has or HasValue
            if (isNegativeFragment(fragment)) {
                throw new Error("First EntityQueryFragment must be Has or HasValue");
            }
            // Create the first interim result
            entities =
                fragment.type === QueryFragmentType.Has
                    ? new Set([...getComponentEntities(fragment.component)])
                    : getEntitiesWithValue(fragment.component, fragment.value);
            // Add entity's children up to the specified depth if proxy expand is active
            if (proxyExpand && proxyExpand.depth > 0) {
                for (const entity of [...entities]) {
                    for (const childEntity of getChildEntities(entity, proxyExpand.component, proxyExpand.depth)) {
                        entities.add(childEntity);
                    }
                }
            }
        }
        else {
            // There already is an interim result, apply the current fragment
            for (const entity of [...entities]) {
                // Branch 1: Simple / check if the current entity passes the query fragment
                let passes = passesQueryFragment(entity, fragment);
                // Branch 2: Proxy upwards / check if proxy entity passes the query
                if (proxyRead && proxyRead.depth > 0 && !isBreakingPassState(passes, fragment)) {
                    passes = (_a = passesQueryFragmentProxy(entity, fragment, proxyRead)) !== null && _a !== void 0 ? _a : passes;
                }
                // If the entity didn't pass the query fragment, remove it from the interim set
                if (!passes)
                    entities.delete(entity);
                // Branch 3: Proxy downwards / run the query fragments on child entities if proxy expand is active
                if (proxyExpand && proxyExpand.depth > 0) {
                    const childEntities = getChildEntities(entity, proxyExpand.component, proxyExpand.depth);
                    for (const childEntity of childEntities) {
                        // Add the child entity if it passes the direct check
                        // or if a proxy read is active and it passes the proxy read check
                        if (passesQueryFragment(childEntity, fragment) ||
                            (proxyRead && proxyRead.depth > 0 && passesQueryFragmentProxy(childEntity, fragment, proxyRead)))
                            entities.add(childEntity);
                    }
                }
            }
        }
    }
    return entities !== null && entities !== void 0 ? entities : new Set();
}
/**
 * Create a query object including an update$ stream and a Set of entities currently matching the query.
 *
 * @remarks
 * `update$` stream needs to be subscribed to in order for the logic inside the stream to be executed and therefore
 * in order for the `matching` set to be updated.
 *
 * `defineQuery` should be strongly preferred over `runQuery` if the query is used for systems or other
 * use cases that repeatedly require the query result or updates to the query result. `defineQuery` does not
 * reevaluate the entire query if an accessed component changes, but only performs the minimal set of checks
 * on the updated entity to evaluate wether the entity still matches the query, resulting in significant performance
 * advantages over `runQuery`.
 *
 * The query fragments are executed from left to right and are concatenated with a logical `AND`.
 * For performance reasons, the most restrictive query fragment should be first in the list of query fragments,
 * in order to reduce the number of entities the next query fragment needs to be checked for.
 * If no proxy fragments are used, every entity in the resulting set passes every query fragment.
 * If setting fragments are used, the order of the query fragments influences the result, since settings only apply to
 * fragments after the setting fragment.
 *
 * @param fragments Query fragments to execute.
 * @param options Optional: {
 *   runOnInit: if true, the query is executed once with `runQuery` to build an iniital Set of matching entities. If false only updates after the query was created are considered.
 *   initialSet: if given, this set is passed to `runOnInit` when building the initial Set of matching entities.
 * }
 * @returns Query object: {
 *  update$: RxJS stream of updates to the query result. The update contains the component update that caused the query update, as well as the {@link UpdateType update type}.
 *  matching: Mobx observable set of entities currently matching the query.
 * }.
 */
function defineQuery(fragments, options) {
    const initialSet = (options === null || options === void 0 ? void 0 : options.runOnInit) || (options === null || options === void 0 ? void 0 : options.initialSet) ? runQuery(fragments, options.initialSet) : new Set();
    const matching = observable(initialSet);
    const initial$ = from(matching).pipe(toUpdateStream(fragments[0].component));
    const containsProxy = fragments.findIndex((v) => [QueryFragmentType.ProxyExpand, QueryFragmentType.ProxyRead].includes(v.type)) !== -1;
    const internal$ = merge(...fragments.map((f) => f.component.update$)) // Combine all component update streams accessed accessed in this query
        .pipe(containsProxy // Query contains proxies
        ? concatMap((update) => {
            // If the query contains proxy read or expand fragments, entities up or down the proxy chain might match due to this update.
            // We have to run the entire query again and compare the result.
            // TODO: We might be able to make this more efficient by first computing the set of entities that are potentially touched by this update
            // and then only rerun the query on this set.
            const newMatchingSet = runQuery(fragments, options === null || options === void 0 ? void 0 : options.initialSet);
            const updates = [];
            for (const previouslyMatchingEntity of matching) {
                // Entity matched before but doesn't match now
                if (!newMatchingSet.has(previouslyMatchingEntity)) {
                    matching.delete(previouslyMatchingEntity);
                    updates.push({
                        entity: previouslyMatchingEntity,
                        type: UpdateType.Exit,
                        component: update.component,
                        value: [undefined, undefined],
                    });
                }
            }
            for (const matchingEntity of newMatchingSet) {
                if (matching.has(matchingEntity)) {
                    // Entity matched before and still matches
                    updates.push({
                        entity: matchingEntity,
                        type: UpdateType.Update,
                        component: update.component,
                        value: [getComponentValue(update.component, matchingEntity), undefined],
                    });
                }
                else {
                    // Entity didn't match before but matches now
                    matching.add(matchingEntity);
                    updates.push({
                        entity: matchingEntity,
                        type: UpdateType.Enter,
                        component: update.component,
                        value: [getComponentValue(update.component, matchingEntity), undefined],
                    });
                }
            }
            return of(...updates);
        })
        : // Query does not contain proxies
            map((update) => {
                if (matching.has(update.entity)) {
                    // If this entity matched the query before, check if it still matches it
                    // Find fragments accessign this component (linear search is fine since the number fragments is likely small)
                    const relevantFragments = fragments.filter((f) => f.component.id === update.component.id);
                    const pass = relevantFragments.every((f) => passesQueryFragment(update.entity, f)); // We early return if the query contains proxies
                    if (pass) {
                        // Entity passed before and still passes, forward update
                        return { ...update, type: UpdateType.Update };
                    }
                    else {
                        // Entity passed before but not anymore, forward update and exit
                        matching.delete(update.entity);
                        return { ...update, type: UpdateType.Exit };
                    }
                }
                // This entity didn't match before, check all fragments
                const pass = fragments.every((f) => passesQueryFragment(update.entity, f)); // We early return if the query contains proxies
                if (pass) {
                    // Entity didn't pass before but passes now, forward update end enter
                    matching.add(update.entity);
                    return { ...update, type: UpdateType.Enter };
                }
            }), filterNullish());
    // Create a new Subject to allow multiple observers
    // but only subscribe to the internal stream when the update stream is
    // subscribed to, in order to get the same behavior as if exposing the
    // internal stream directly (ie only running the internal$ pipe if there are subscribers)
    const update$ = new Subject();
    const world = fragments[0].component.world;
    const subscribe = update$.subscribe.bind(update$);
    update$.subscribe = (observer) => {
        const subscription = internal$.subscribe(update$);
        world.registerDisposer(() => subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe());
        return subscribe(observer);
    };
    return {
        matching,
        update$: concat(initial$, update$),
    };
}
/**
 * Define a query object that only passes update events of type {@link UpdateType}.Update to the `update$` stream.
 * See {@link defineQuery} for details.
 *
 * @param fragments Query fragments
 * @returns Stream of component updates of entities that had already matched the query
 */
function defineUpdateQuery(fragments, options) {
    return defineQuery(fragments, options).update$.pipe(filter((e) => e.type === UpdateType.Update));
}
/**
 * Define a query object that only passes update events of type {@link UpdateType}.Enter to the `update$` stream.
 * See {@link defineQuery} for details.
 *
 * @param fragments Query fragments
 * @returns Stream of component updates of entities matching the query for the first time
 */
function defineEnterQuery(fragments, options) {
    return defineQuery(fragments, options).update$.pipe(filter((e) => e.type === UpdateType.Enter));
}
/**
 * Define a query object that only passes update events of type {@link UpdateType}.Exit to the `update$` stream.
 * See {@link defineQuery} for details.
 *
 * @param fragments Query fragments
 * @returns Stream of component updates of entities not matching the query anymore for the first time
 */
function defineExitQuery(fragments, options) {
    return defineQuery(fragments, options).update$.pipe(filter((e) => e.type === UpdateType.Exit));
}

/**
 * Create a system that is called on every update of the given observable.
 *
 * @remarks
 * Advantage of using this function over directly subscribing to the RxJS observable is that the system is registered in the `world` and
 * disposed when the `world` is disposed (eg. during a hot reload in development).
 *
 * @param world {@link World} object this system should be registered in.
 * @param observable$ Observable to react to.
 * @param system System function to run on updates of the `observable$`. System function gets passed the update events from the `observable$`.
 */
function defineRxSystem(world, observable$, system) {
    const subscription = observable$.subscribe(system);
    world.registerDisposer(() => subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe());
}
/**
 * Create a system that is called on every event of the given {@link defineUpdateQuery update query}.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Update query to react to.
 * @param system System function to run when the result of the given update query changes.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities matching the query when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
function defineUpdateSystem(world, query, system, options = { runOnInit: true }) {
    defineRxSystem(world, defineUpdateQuery(query, options), system);
}
/**
 * Create a system that is called on every event of the given {@link defineEnterQuery enter query}.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Enter query to react to.
 * @param system System function to run when the result of the given enter query changes.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities matching the query when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
function defineEnterSystem(world, query, system, options = { runOnInit: true }) {
    defineRxSystem(world, defineEnterQuery(query, options), system);
}
/**
 * Create a system that is called on every event of the given {@link defineExitQuery exit query}.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Exit query to react to.
 * @param system System function to run when the result of the given exit query changes.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities matching the query when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
function defineExitSystem(world, query, system, options = { runOnInit: true }) {
    defineRxSystem(world, defineExitQuery(query, options), system);
}
/**
 * Create a system that is called on every event of the given {@link defineQuery query}.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Query to react to.
 * @param system System function to run when the result of the given query changes.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities matching the query when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
function defineSystem(world, query, system, options = { runOnInit: true }) {
    defineRxSystem(world, defineQuery(query, options).update$, system);
}
/**
 * Create a system that is called every time the given component is updated.
 *
 * @param world {@link World} object this system should be registered in.
 * @param component Component to whose updates to react.
 * @param system System function to run when the given component is updated.
 * @param options Optional: {
 * runOnInit: if true, run this system for all entities in the component when the system is created.
 * Else only run on updates after the system is created. Default true.
 * }
 */
function defineComponentSystem(world, component, system, options = { runOnInit: true }) {
    const initial$ = (options === null || options === void 0 ? void 0 : options.runOnInit) ? from(getComponentEntities(component)).pipe(toUpdateStream(component)) : EMPTY;
    defineRxSystem(world, concat(initial$, component.update$), system);
}
/**
 * Create a system to synchronize updates to one component with another component.
 *
 * @param world {@link World} object this system should be registered in.
 * @param query Result of `component` is added to all entites matching this query.
 * @param component Function returning the component to be added to all entities matching the given query.
 * @param value Function returning the component value to be added to all entities matching the given query.
 */
function defineSyncSystem(world, query, component, value, options = { update: false, runOnInit: true }) {
    defineSystem(world, query, ({ entity, type }) => {
        if (type === UpdateType.Enter)
            setComponent(component(entity), entity, value(entity));
        if (type === UpdateType.Exit)
            removeComponent(component(entity), entity);
        if ((options === null || options === void 0 ? void 0 : options.update) && type === UpdateType.Update)
            setComponent(component(entity), entity, value(entity));
    }, options);
}

/**
 * Create a new World.
 *
 * @remarks
 * A World is the central object of an ECS application, where all {@link defineComponent Components},
 * {@link registerEntity Entities} and {@link defineSystem Systems} are registerd.
 *
 * @returns A new World
 */
function createWorld() {
    const entityToIndex = new Map();
    const entities = [];
    const components = [];
    let disposers = [];
    function getEntityIndexStrict(entity) {
        const index = entityToIndex.get(entity);
        if (index == null)
            throw new Error("entity does not exist");
        return index;
    }
    function registerEntity({ id, idSuffix } = {}) {
        const entity = (id || entities.length + (idSuffix ? "-" + idSuffix : ""));
        // Skip if entity already exists
        let index = entityToIndex.get(entity);
        if (index != null)
            return index;
        // Register entity
        index = (entities.push(entity) - 1);
        entityToIndex.set(entity, index);
        return index;
    }
    function registerComponent(component) {
        components.push(component);
    }
    function dispose(namespace) {
        for (const [, disposer] of disposers.filter((d) => !namespace || d[0] === namespace)) {
            disposer();
        }
        disposers = disposers.filter((d) => namespace && d[0] !== namespace);
    }
    function registerDisposer(disposer, namespace = "") {
        disposers.push([namespace, disposer]);
    }
    function hasEntity(entity) {
        return entityToIndex.get(entity) != null;
    }
    return {
        entities,
        entityToIndex,
        registerEntity,
        components,
        registerComponent,
        dispose,
        registerDisposer,
        getEntityIndexStrict,
        hasEntity,
    };
}
/**
 * Create a new namespace from an existing World.
 * The `dispose` method of a namespaced World only calls disposers registered on this namespace.
 *
 * @param world World to create a new namespace for.
 * @param namespace String descriptor of the new namespace.
 * @returns World with a new namespace.
 */
function namespaceWorld(world, namespace) {
    return {
        ...world,
        registerDisposer: (disposer) => world.registerDisposer(disposer, namespace),
        dispose: () => world.dispose(namespace),
    };
}
/**
 * Get all components that have a value for the given entity.
 *
 * @dev Design decision: don't store a list of components for each entity but compute it dynamically when needed
 * because there are less components than entities and maintaining a list of components per entity is a large overhead.
 *
 * @param world World object the given entity is registered on.
 * @param entity {@link EntityIndex} of the entity to get the list of components for.
 * @returns Array of components that have a value for the given entity.
 */
function getEntityComponents(world, entity) {
    return world.components.filter((component) => hasComponent(component, entity));
}

export { Has, HasValue, Not, NotValue, OptionalTypes, ProxyExpand, ProxyRead, QueryFragmentType, Type, UpdateType, clearLocalCache, componentValueEquals, createEntity, createIndexer, createLocalCache, createWorld, defineComponent, defineComponentSystem, defineEnterQuery, defineEnterSystem, defineExitQuery, defineExitSystem, defineQuery, defineRxSystem, defineSyncSystem, defineSystem, defineUpdateQuery, defineUpdateSystem, getChildEntities, getComponentEntities, getComponentValue, getComponentValueStrict, getEntitiesWithValue, getEntityComponents, hasComponent, isArrayType, isComponentUpdate, isEntityType, isFullComponentValue, isIndexer, isNumberType, isOptionalType, namespaceWorld, overridableComponent, removeComponent, runQuery, setComponent, toUpdate, toUpdateStream, updateComponent, withValue };
//# sourceMappingURL=index.js.map
