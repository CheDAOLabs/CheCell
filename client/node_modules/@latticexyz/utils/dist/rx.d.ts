import { Observable, OperatorFunction } from "rxjs";
import { IComputedValue, IObservableValue } from "mobx";
export declare function filterNullish<T>(): OperatorFunction<T, NonNullable<T>>;
export declare function awaitPromise<T extends Promise<unknown>>(): OperatorFunction<T, Awaited<T>>;
/**
 * RxJS operator to stretch out an event stream by a given delay per event
 * @param spacingDelayMs Delay between each event in ms
 * @returns stream of events with at least spacingDelayMs spaceing between event
 */
export declare function stretch<T>(spacingDelayMs: number): import("rxjs").UnaryFunction<Observable<T>, Observable<T>>;
export declare function observableToComputed<T>(obs: IObservableValue<T>): IComputedValue<T>;
export declare function computedToStream<T>(comp: IComputedValue<T> | IObservableValue<T>): Observable<T>;
export declare function observableToStream<T>(obs: T): Observable<T>;
export declare function streamToComputed<T>(stream$: Observable<T>): IComputedValue<T | undefined>;
export declare function streamToDefinedComputed<T>(stream$: Observable<T>): Promise<IComputedValue<T>>;
/**
 *
 * @param stream$ RxJS observable to check for the given value
 * @param predicate Predicate to check
 * @returns A promise that resolves with the requested value once the predicate is true
 */
export declare function awaitStreamValue<T>(stream$: Observable<T>, predicate?: (value: T) => boolean): Promise<T>;
/**
 * Turns a stream into an updating object for easy access outside of rxjs
 * @param stream$ Stream to turn into a wrapped value
 * @returns Object with `current` key corresponding to last stream value
 */
export declare function streamToWrappedValue<T>(stream$: Observable<T>): Promise<{
    current: T;
}>;
