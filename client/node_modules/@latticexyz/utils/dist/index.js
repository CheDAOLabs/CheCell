import { reaction, computed, toJS, observable, runInAction } from 'mobx';
import DeepProxy from 'proxy-deep';
import { pipe, filter, concatMap, timestamp, scan, mergeMap, of, delay, ReplaySubject, first, fromEvent, map } from 'rxjs';
import { BigNumber } from 'ethers';
import { keccak256 as keccak256$1, toUtf8Bytes, defaultAbiCoder } from 'ethers/lib/utils';

/**
 * TypeScript type guard to assert the type of a non-empty array
 * @param array Any array to check for non-emptiness
 * @returns True if the empty is non-empty, else false. TypeScript accepts the array as non-empty after the assertion.
 */
function isNotEmpty(array) {
    if (array.length === 0)
        return false;
    return true;
}
/**
 * Filters undefined values from an array and lets TypeScript know the resulting array
 * does not have undefined values
 * @param array Array potentially including undefined values
 * @returns Array without undefined values
 */
function filterNullishValues(array) {
    return array.filter((value) => value != null);
}

/**
 * A convenient way to create a promise with resolve and reject functions.
 * @returns Tuple with resolve function, reject function and promise.
 */
function deferred() {
    let resolve = null;
    let reject = null;
    const promise = new Promise((r, rj) => {
        resolve = (t) => r(t);
        reject = (e) => rj(e);
    });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return [resolve, reject, promise];
}

/**
 * @param comp Computed/Observable value that is either defined or undefined
 * @returns promise that resolves with the first truthy computed value
 */
async function awaitValue(comp) {
    const [resolve, , promise] = deferred();
    const dispose = reaction(() => comp.get(), (value) => {
        if (value) {
            resolve(value);
        }
    }, { fireImmediately: true });
    const value = await promise;
    // Dispose the reaction once the promise is resolved
    dispose();
    return value;
}

function isObject(c) {
    return typeof c === "object" && !Array.isArray(c) && c !== null;
}
function isFunction(c) {
    return c instanceof Function;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
function deepAccess(target, path) {
    if (path.length === 0)
        return target;
    if (path.length === 1)
        return target[path[0]];
    const [next, ...rest] = path;
    const nextTarget = target[next];
    if (!isObject(nextTarget))
        throw new Error("Path does not exist on the target");
    return deepAccess(nextTarget, rest);
}
/**
 * Caches any function calls to the target until the target is ready.
 * @param target T extends Cachable
 * @returns Cached<T>
 */
function cacheUntilReady(target) {
    // The call queue contains the path and arguments of calls to the
    // proxiedTarget while the target was not available yet.
    // It also contains resolve and reject methods to fulfil the promise
    // returned when calling the proxiedTarget once the target becomes available.
    const callQueue = [];
    // The proxiedTarget proxies all calls to the target.
    // If a function is called on the proxiedTarget while the target is not
    // available, a promise is returned and the call will be stored in the callQueue
    // until the target becomes available and the promise is fulfilled.
    const proxiedTarget = new DeepProxy({}, {
        get(_t, prop) {
            const targetReady = target.get();
            if (targetReady) {
                // If the target is ready, relay all calls directly to the target
                // (Except for the "proxied" key, which indicates whether the object is currently proxied)
                if (prop === "proxied")
                    return false;
                return Reflect.get(targetReady, prop);
            }
            else {
                // Note: if the target is not available, accessing a property returns another proxy,
                // not a Promise. It is possible to check whether a value is currently proxied using the proxied key.
                if (prop === "proxied")
                    return true;
                if (prop === "name")
                    return "ProxiedTarget";
                if (prop === "toJSON")
                    return () => ({ proxied: true });
                return this.nest(() => void 0);
            }
        },
        apply(_, thisArg, args) {
            const targetReady = target.get();
            if (targetReady) {
                // If the target is ready, relay all calls directly to the target
                const targetFunc = deepAccess(targetReady, this.path);
                if (!isFunction(targetFunc))
                    throw new Error("Target is not callable");
                return Reflect.apply(targetFunc, thisArg, args);
            }
            else {
                // Otherwise store the call and relay it to the target later once it's ready.
                // The return value of this call is a promise, that gets resolved once the target is ready.
                const [resolve, reject, promise] = deferred();
                callQueue.push({ path: this.path, args, resolve, reject });
                return promise;
            }
        },
    });
    reaction(() => target.get(), (targetReady) => {
        if (!targetReady)
            return;
        // Move all entries from callQueue to queuedCalls
        const queuedCalls = callQueue.splice(0);
        for (const { path, args, resolve, reject } of queuedCalls) {
            const target = deepAccess(targetReady, path);
            if (args && isFunction(target)) {
                (async () => {
                    try {
                        resolve(await target(...args));
                    }
                    catch (e) {
                        reject(e);
                    }
                })();
            }
            else {
                resolve(target);
            }
        }
    });
    return proxiedTarget;
}

/**
 * @param enm Numeric enum
 * @returns Number array containing the enum values
 */
function numValues(enm) {
    const nums = [];
    for (const val of Object.values(enm)) {
        if (!isNaN(Number(val))) {
            nums.push(Number(val));
        }
    }
    return nums;
}

/**
 * Utility function to map a source object to an object with the same keys but mapped values
 * @param source Source object to be mapped
 * @param valueMap Mapping values of the source object to values of the target object
 * @returns An object with the same keys as the source object but mapped values
 */
function mapObject(source, valueMap) {
    const target = {};
    for (const key in source) {
        target[key] = valueMap(source[key], key);
    }
    return target;
}

/**
 *
 * @param to Upper bound (included)
 * @param from Lower bound (included). Default 0.
 * @returns A random integer between from and to.
 */
function random(to, from = 0) {
    return Math.floor(Math.random() * (to - from + 1)) + from;
}
/**
 * @param array Array to pick a random element from.
 * @returns Random element from the given array.
 */
function pickRandom(array) {
    return array[random(array.length - 1)];
}

function filterNullish() {
    return pipe(filter((x) => x != null));
}
function awaitPromise() {
    return pipe(concatMap((x) => x));
}
/**
 * RxJS operator to stretch out an event stream by a given delay per event
 * @param spacingDelayMs Delay between each event in ms
 * @returns stream of events with at least spacingDelayMs spaceing between event
 */
function stretch(spacingDelayMs) {
    return pipe(timestamp(), scan((acc, curr) => {
        // calculate delay needed to offset next emission
        let delay = 0;
        if (acc !== null) {
            const timeDelta = curr.timestamp - acc.timestamp;
            delay = timeDelta > spacingDelayMs ? 0 : spacingDelayMs - timeDelta;
        }
        return {
            timestamp: curr.timestamp,
            delay: delay,
            value: curr.value,
        };
    }, null), filterNullish(), mergeMap((i) => of(i.value).pipe(delay(i.delay)), 1));
}
function observableToComputed(obs) {
    return computed(() => obs.get());
}
function computedToStream(comp) {
    const stream = new ReplaySubject(1);
    reaction(() => comp.get(), (value) => {
        if (value != null)
            stream.next(value);
    }, { fireImmediately: true });
    return stream;
}
function observableToStream(obs) {
    const stream = new ReplaySubject(1);
    reaction(() => toJS(obs), (value) => {
        if (value != null)
            stream.next(value);
    }, { fireImmediately: true });
    return stream;
}
function streamToComputed(stream$) {
    const value = observable.box();
    stream$.subscribe((val) => runInAction(() => value.set(val)));
    return computed(() => value.get());
}
async function streamToDefinedComputed(stream$) {
    const value = observable.box();
    stream$.subscribe((val) => runInAction(() => value.set(val)));
    const computedValue = computed(() => value.get());
    await awaitValue(computedValue);
    return computedValue;
}
/**
 *
 * @param stream$ RxJS observable to check for the given value
 * @param predicate Predicate to check
 * @returns A promise that resolves with the requested value once the predicate is true
 */
async function awaitStreamValue(stream$, predicate = (value) => value != null) {
    const [resolve, , promise] = deferred();
    stream$.pipe(first(predicate)).subscribe(resolve);
    return promise;
}
/**
 * Turns a stream into an updating object for easy access outside of rxjs
 * @param stream$ Stream to turn into a wrapped value
 * @returns Object with `current` key corresponding to last stream value
 */
async function streamToWrappedValue(stream$) {
    const value = {};
    stream$.subscribe((v) => (value.current = v));
    value.current = await awaitStreamValue(stream$);
    return value;
}

/**
 * UUID.core.js - UUID.js for Minimalists
 *
 * @file
 * @author  LiosK
 * @version v4.2.0
 * @license Apache License 2.0: Copyright (c) 2010-2018 LiosK
 * @url https://github.com/LiosK/UUID.js/blob/master/src/uuid.core.js
 */
/**
 * @class
 * @classdesc {@link UUID} object.
 * @hideconstructor
 */
// Core Component {{{
/**
 * Generates a version 4 UUID as a hexadecimal string.
 * @returns {string} Hexadecimal UUID string.
 */
const uuid = function () {
    const rand = _getRandomInt, hex = _hexAligner;
    return (hex(rand(32), 8) + // time_low
        "-" +
        hex(rand(16), 4) + // time_mid
        "-" +
        hex(0x4000 | rand(12), 4) + // time_hi_and_version
        "-" +
        hex(0x8000 | rand(14), 4) + // clock_seq_hi_and_reserved clock_seq_low
        "-" +
        hex(rand(48), 12)); // node
};
/**
 * Returns an unsigned x-bit random integer.
 * @private
 * @param {number} x Unsigned integer ranging from 0 to 53, inclusive.
 * @returns {number} Unsigned x-bit random integer (0 <= f(x) < 2^x).
 */
const _getRandomInt = function (x) {
    if (x < 0 || x > 53) {
        return NaN;
    }
    const n = 0 | (Math.random() * 0x40000000); // 1 << 30
    return x > 30 ? n + (0 | (Math.random() * (1 << (x - 30)))) * 0x40000000 : n >>> (30 - x);
};
/**
 * Converts an integer to a zero-filled hexadecimal string.
 * @private
 * @param {number} num
 * @param {number} length
 * @returns {string}
 */
const _hexAligner = function (num, length) {
    let str = num.toString(16), i = length - str.length, z = "0";
    for (; i > 0; i >>>= 1, z += z) {
        if (i & 1) {
            str = z + str;
        }
    }
    return str;
};

function sleep(timeout, returns) {
    return new Promise((resolve) => setTimeout(() => resolve(returns), timeout));
}

/* eslint-disable @typescript-eslint/no-explicit-any */
const range = function* (total = 0, step = 1, from = 0) {
    // eslint-disable-next-line no-empty
    for (let i = 0; i < total; yield from + i++ * step) { }
};
async function rejectAfter(ms, msg) {
    await sleep(ms);
    throw new Error(msg);
}
const timeoutAfter = async (promise, ms, timeoutMsg) => {
    return Promise.race([promise, rejectAfter(ms, timeoutMsg)]);
};
const callWithRetry = (fn, args = [], maxRetries = 10, retryInterval = 1000) => {
    const [resolve, reject, promise] = deferred();
    const process = async () => {
        let res;
        for (let i = 0; i < maxRetries; i++) {
            try {
                res = await fn(...args);
                resolve(res);
                break;
            }
            catch (e) {
                if (i < maxRetries - 1) {
                    console.info("[CallWithRetry Failed] attempt number=" + i, fn);
                    console.error(e);
                    await sleep(Math.min(retryInterval * 2 ** i + Math.random() * 100, 15000));
                }
                else {
                    reject(e);
                }
            }
        }
    };
    process();
    return promise;
};

function makeIterable(iterator) {
    const iterable = {
        ...iterator,
        [Symbol.iterator]() {
            return this;
        },
    };
    return iterable;
}
function concatIterators(first, second) {
    if (!second)
        return makeIterable(first);
    return makeIterable({
        next() {
            const next = first.next();
            if (!next.done)
                return next;
            return second.next();
        },
    });
}
function mergeIterators(iteratorA, iteratorB) {
    const iterator = {
        next() {
            const nextA = iteratorA.next();
            const nextB = iteratorB.next();
            if (nextA.done && nextB.done)
                return { done: true, value: null };
            return { value: [nextA.value, nextB.value] };
        },
    };
    return makeIterable(iterator);
}
function transformIterator(iterator, transform) {
    return makeIterable({
        next() {
            const { done, value } = iterator.next();
            return { done, value: done ? value : transform(value) };
        },
    });
}
/**
 * Turns an array into an iterator. NOTE: an iterator can only be iterated once.
 * @param array Array to be turned into an iterator
 * @returns Iterator to iterate through the array
 */
function arrayToIterator(array) {
    let i = 0;
    const iterator = {
        next() {
            const done = i >= array.length;
            if (done)
                return { done, value: null };
            return { value: array[i++] };
        },
    };
    return makeIterable(iterator);
}

function areaContains(area, coord) {
    return coord.x >= area.x && coord.y >= area.y && coord.x < area.x + area.width && coord.y < area.y + area.height;
}
function coordsOf(area) {
    const coords = [];
    for (let dx = 0; dx < area.width; dx++) {
        for (let dy = 0; dy < area.height; dy++) {
            coords.push({ x: area.x + dx, y: area.y + dy });
        }
    }
    return coords;
}

/**
 * Compute keccak256 hash from given string and remove padding from the resulting hex string
 * @param data String to be hashed
 * @returns Hash of the given string as hex string without padding
 */
function keccak256(data) {
    return BigNumber.from(keccak256$1(toUtf8Bytes(data))).toHexString();
}
function keccak256Coord(coord) {
    // TODO: make faster by implementing in wasm
    const bytes = defaultAbiCoder.encode(["int32", "int32"], [coord.x, coord.y]);
    return keccak256$1(bytes);
}

function fromWorker(worker, input$) {
    input$.subscribe((event) => worker.postMessage(event));
    return fromEvent(worker, "message").pipe(map((e) => e.data));
}
function runWorker(worker) {
    const input$ = fromEvent(self, "message");
    const output$ = worker.work(input$.pipe(map((event) => event.data)));
    output$.subscribe((event) => self.postMessage(event));
}

function rightMask(input, keep) {
    return input & (2 ** keep - 1);
}
/**
 * Packs two unsigned integers in one 32 bit unsigned integer
 * @param numbers Unsigned integers to be packed in 32 bit integer
 * @param bitsPerNumber Bits for each number
 * @returns Packed 32 bit unsigned integer
 */
function pack(numbers, bitsPerNumber) {
    // Total number of bits must be 32
    if (bitsPerNumber.reduce((acc, curr) => acc + curr, 0) > 32) {
        throw new Error("JS pretends integers are 32 bit when bitshifts are involved");
    }
    // Array lengths must match
    if (numbers.length !== bitsPerNumber.length)
        throw new Error("Arrays' lengths must match");
    // Numbers must fit in number of bits and must be unsigned
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] < 0) {
            throw new Error("Underflow: can only pack unsigned integer");
        }
        if (numbers[i] > 2 ** bitsPerNumber[i] - 1) {
            const error = `Overflow: ${numbers[i]} does not fit in ${bitsPerNumber[i]} bits`;
            throw new Error(error);
        }
    }
    // Pack number
    let packed = 0;
    for (let i = 0; i < numbers.length; i++) {
        packed = (packed << bitsPerNumber[i]) | numbers[i];
    }
    return packed;
}
/**
 * Unpacks a packed 32 bit unsigned integer into the original unsigned integers
 * @param packed Packed 32 bit unsigned integer
 * @param bitsPerNumber Bits for each unsigned integer
 * @returns Array of unpacked unsignd integers
 */
function unpack(packed, bitsPerNumber) {
    const numbers = [];
    let shiftedPacked = packed;
    for (let i = bitsPerNumber.length - 1; i >= 0; i--) {
        numbers.unshift(rightMask(shiftedPacked, bitsPerNumber[i]));
        shiftedPacked = shiftedPacked >>> bitsPerNumber[i];
    }
    return numbers;
}
function packTuple(numbers) {
    return pack(numbers, [8, 24]);
}
function unpackTuple(packed) {
    return unpack(packed, [8, 24]);
}

const LOWER_HALF_MASK = 2 ** 16 - 1;
const MAX_SUPPORTED = 2 ** 15 - 1;
function subtract(from, subtract) {
    const result = new CoordMap();
    for (const coord of from.coords()) {
        if (subtract.get(coord))
            continue;
        result.set(coord, true);
    }
    return result;
}
function coordToKey$1(coord) {
    const key = (coord.x << 16) | (coord.y & LOWER_HALF_MASK);
    return key;
    // Old version using strings:
    // return `${coord.x}/${coord.y}`;
}
function keyToCoord$1(key) {
    const x = key >> 16;
    const y = (key << 16) >> 16;
    return { x, y };
    // Old version using strings:
    // const fragments = key.split("/");
    // return { x: Number(fragments[0]), y: Number(fragments[1]) };
}
class CoordMap {
    constructor(props) {
        this.map = new Map();
        this.defaultValue = props === null || props === void 0 ? void 0 : props.defaultValue;
    }
    static from(coordMapLike) {
        const coordMap = new CoordMap();
        coordMap.map = coordMapLike.map;
        coordMap.defaultValue = coordMapLike.defaultValue;
        return coordMap;
    }
    set(coord, value) {
        if (coord.x > MAX_SUPPORTED ||
            coord.x < -1 * MAX_SUPPORTED ||
            coord.y > MAX_SUPPORTED ||
            coord.y < -1 * MAX_SUPPORTED) {
            throw new Error(`CoordMap only supports coords up to ${MAX_SUPPORTED}`);
        }
        return this.map.set(coordToKey$1(coord), value);
    }
    get(coord) {
        var _a;
        return (_a = this.map.get(coordToKey$1(coord))) !== null && _a !== void 0 ? _a : this.defaultValue;
    }
    keys() {
        return this.map.keys();
    }
    coords() {
        return transformIterator(this.map.keys(), (key) => keyToCoord$1(key));
    }
    entries() {
        return this.map.entries();
    }
    toArray() {
        const entries = Array.from(this.map.entries());
        return entries.map(([key, value]) => [keyToCoord$1(key), value]);
    }
    values() {
        return this.map.values();
    }
    delete(coord) {
        return this.map.delete(coordToKey$1(coord));
    }
    has(coord) {
        return this.map.has(coordToKey$1(coord));
    }
    clear() {
        for (const key of this.map.keys()) {
            this.map.delete(key);
        }
    }
    get size() {
        return this.map.size;
    }
}

function coordToKey(coord) {
    // TODO: find a more memory efficient way to store these keys
    return `${coord.x}/${coord.y}/${coord.z}`;
}
function keyToCoord(key) {
    const fragments = key.split("/");
    return { x: Number(fragments[0]), y: Number(fragments[1]), z: Number(fragments[2]) };
}
class VoxelCoordMap {
    constructor(props) {
        this.map = new Map();
        this.defaultValue = props === null || props === void 0 ? void 0 : props.defaultValue;
    }
    static from(coordMapLike) {
        const coordMap = new VoxelCoordMap();
        coordMap.map = coordMapLike.map;
        coordMap.defaultValue = coordMapLike.defaultValue;
        return coordMap;
    }
    set(coord, value) {
        return this.map.set(coordToKey(coord), value);
    }
    get(coord) {
        var _a;
        return (_a = this.map.get(coordToKey(coord))) !== null && _a !== void 0 ? _a : this.defaultValue;
    }
    keys() {
        return this.map.keys();
    }
    coords() {
        return transformIterator(this.map.keys(), (key) => keyToCoord(key));
    }
    entries() {
        return this.map.entries();
    }
    toArray() {
        const entries = Array.from(this.map.entries());
        return entries.map(([key, value]) => [keyToCoord(key), value]);
    }
    values() {
        return this.map.values();
    }
    delete(coord) {
        return this.map.delete(coordToKey(coord));
    }
    has(coord) {
        return this.map.has(coordToKey(coord));
    }
    clear() {
        for (const key of this.map.keys()) {
            this.map.delete(key);
        }
    }
    get size() {
        return this.map.size;
    }
}

/**
 * Pads start of a hex string with 0 to create a bit string of the given length
 * @param input Hex string
 * @param bits Number of bits in the output hex string
 * @returns Hex string of specified length
 */
function padToBitLength(input, bits) {
    // Cut off 0x prefix
    if (input.substring(0, 2) == "0x")
        input = input.substring(2);
    // Pad start with 0 to get desired bit length
    const length = bits / 4;
    input = input.padStart(length, "0");
    input = input.substring(input.length - length);
    // Prefix with 0x
    return `0x${input}`;
}
/**
 * Pads start of a hex string with 0 to create a 160 bit hex string
 * which can be used as an Ethereum address
 * @param input Hex string
 * @returns 160 bit hex string
 */
function toEthAddress(input) {
    return padToBitLength(input, 160);
}
/**
 * Pads start of a hex string with 0 to create a 256bit hex string
 * which can be used as an Ethereum address
 * @param input Hex string
 * @returns 256 bit hex string
 */
function to256BitString(input) {
    return padToBitLength(input, 256);
}
function extractEncodedArguments(input) {
    // Cutting off the first 4 bytes, which represent the function selector
    if (input[0] !== "0" && input[1] !== "x")
        throw new Error("Invalid hex string");
    return "0x" + input.substring(10);
}

const RND_A = 134775813;
const RND_B = 1103515245;
const ACCURACY = 1000;
function randomize(seed, x, y) {
    return (((((x ^ y) * RND_A) ^ (seed + x)) * (((RND_B * x) << 16) ^ (RND_B * y - RND_A))) >>> 0) / 4294967295;
}
function tile(coordinate, period) {
    if (coordinate < 0)
        while (coordinate < 0)
            coordinate += period;
    return coordinate % period;
}
function interpolate(a, b, c, d, x, s, scale) {
    const p = d - c - (a - b);
    return (b * Math.pow(s, 3) + x * (c * Math.pow(s, 2) + a * s * (-s + x) + x * (-(b + p) * s + p * x))) * scale;
    // return (x) * ((x ) * ((x ) * p + (a - b - p)) + (c - a)) + b;
}
/**
 * Config a cubic noise.
 * @param {Number} seed A seed in the range [0, 1].
 * @param {Number} [periodX] The number of units after which the x coordinate repeats.
 * @param {Number} [periodY] The number of units after which the y coordinate repeats.
 * @returns {Object} A configuration object used by noise functions.
 */
function cubicNoiseConfig(seed, octave, scale, periodX = Number.MAX_SAFE_INTEGER, periodY = Number.MAX_SAFE_INTEGER) {
    return {
        seed: Math.floor(seed * Number.MAX_SAFE_INTEGER),
        periodX: periodX,
        periodY: periodY,
        octave,
        scale,
    };
}
/**
 * Sample 1D cubic noise.
 * @param {Object} config A valid noise configuration.
 * @param {Number} x The X position to sample at.
 * @returns {Number} A noise value in the range [0, 1].
 */
function cubicNoiseSample1(config, x) {
    const xi = Math.floor(x);
    const lerp = x - xi;
    return (interpolate(randomize(config.seed, tile(xi - 1, config.periodX), 0), randomize(config.seed, tile(xi, config.periodX), 0), randomize(config.seed, tile(xi + 1, config.periodX), 0), randomize(config.seed, tile(xi + 2, config.periodX), 0), lerp, 1, 1) *
        0.666666 +
        0.166666);
}
/**
 * Sample 2D cubic noise.
 * @param {Object} config A valid noise configuration.
 * @param {Number} x The X position to sample at.
 * @param {Number} y The Y position to sample at.
 * @returns {Number} A noise value in the range [0, 1].
 */
function cubicNoiseSample2({ octave, periodX, periodY, seed, scale }, x, y) {
    const xi = Math.floor(x / octave);
    const lerpX = Math.floor((x * ACCURACY) / octave) - xi * ACCURACY;
    const yi = Math.floor(y / octave);
    const lerpY = Math.floor((y * ACCURACY) / octave) - yi * ACCURACY;
    const x0 = tile(xi - 1, periodX);
    const x1 = tile(xi, periodX);
    const x2 = tile(xi + 1, periodX);
    const x3 = tile(xi + 2, periodX);
    const xSamples = new Array(4);
    for (let i = 0; i < 4; ++i) {
        const y = tile(yi - 1 + i, periodY);
        xSamples[i] = interpolate(randomize(seed, x0, y), randomize(seed, x1, y), randomize(seed, x2, y), randomize(seed, x3, y), lerpX, ACCURACY, 1);
    }
    return Math.floor(interpolate(xSamples[0], xSamples[1], xSamples[2], xSamples[3], lerpY, ACCURACY, scale) / Math.pow(ACCURACY, 6));
}

const TOPICS_KEY = "mud-logger-topics";
function enableLogger() {
    const windowConsole = window.console;
    let filtersActive = Boolean(localStorage.getItem(TOPICS_KEY));
    const topicsString = localStorage.getItem(TOPICS_KEY);
    let topics = topicsString ? JSON.parse(topicsString) : [];
    function log(...logs) {
        if (filtersActive)
            return;
        windowConsole.log(...logs);
    }
    function logWithTopic(topic, ...logs) {
        if (!filtersActive || topics.includes(topic)) {
            windowConsole.log(`--- BETTER CONSOLE / TOPIC ${topic} ---`);
            windowConsole.log(...logs);
        }
    }
    function enableFilters() {
        localStorage.setItem(TOPICS_KEY, JSON.stringify([]));
        filtersActive = true;
    }
    function disableFilters() {
        localStorage.removeItem(TOPICS_KEY);
        filtersActive = false;
    }
    function addTopic(topic) {
        topics.push(topic);
        localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));
    }
    function removeTopic(topic) {
        topics = topics.filter((t) => t !== topic);
        localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));
    }
    function resetTopics() {
        topics = [];
        localStorage.setItem(TOPICS_KEY, JSON.stringify(topics));
    }
    const logger = {
        ...windowConsole,
        log,
        logWithTopic,
        enableFilters,
        disableFilters,
        addTopic,
        removeTopic,
        resetTopics,
    };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    window.logger = logger;
    window.console = logger;
    return logger;
}

/**
 * Compute the Euclidean distance between two points
 * https://en.wikipedia.org/wiki/Euclidean_distance
 * @param a
 * @param b
 * @returns Euclidian distance between a and b
 */
function euclidean(a, b) {
    if (a.length !== b.length)
        throw new Error("points must have same dimension");
    return Math.sqrt(a.reduce((acc, _, i) => acc + Math.pow(a[i] - b[i], 2), 0));
}

/**
 * For positive inputs: returns the greatest integer less than or equal to its numeric argument.
 * For negative inputs: returns the smallest integer greater than or equal to its numeric argument.
 *
 * @param x A numeric expression.
 * @returns Input rounded towards zero.
 */
function roundTowardsZero(x) {
    const sign = x < 0 ? -1 : 1;
    return sign * Math.floor(Math.abs(x));
}

function formatHex(hex) {
    if (hex.substring(0, 2) == "0x")
        hex = hex.substring(2);
    const prefix = hex.length % 2 !== 0 ? "0x0" : "0x";
    return prefix + hex;
}
function hexStringToUint8Array(hexString) {
    let matches = hexString.match(/.{1,2}/g);
    if (!matches || hexString.length % 2 !== 0)
        throw new Error("invalid hex string: " + hexString);
    if (matches[0] == "0x")
        matches = matches.slice(1);
    return Uint8Array.from(matches.map((byte) => parseInt(byte, 16)));
}
function Uint8ArrayToHexString(data) {
    if (data.length === 0)
        return "0x00";
    return formatHex(data.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), ""));
}
function concatUint8Arrays(...arrays) {
    return Uint8Array.from(arrays.reduce((acc, curr) => {
        return [...acc, ...curr];
    }, []));
}
function splitUint8Arrays(data, byteLengths) {
    const arrays = [];
    let i = 0;
    for (const length of byteLengths) {
        const array = new Uint8Array(length);
        arrays.push(array);
        for (let j = 0; j < length; j++) {
            array[j] = data[i];
            i++;
        }
    }
    return arrays;
}
function Int32ArrayToUint8Array(input) {
    const buffer = new ArrayBuffer(input.length * 4);
    const int32arr = new Int32Array(buffer);
    for (let i = 0; i < input.length; i++) {
        int32arr[i] = input[i];
    }
    return new Uint8Array(buffer);
}
function Uint8ArrayToInt32Array(input) {
    return [...new Int32Array(input.buffer)];
}
function ethAddressToUint8Array(address) {
    return hexStringToUint8Array(toEthAddress(address));
}
// https://stackoverflow.com/a/55330424
function createToInt(size) {
    if (size < 2) {
        throw new Error("Minimum size is 2");
    }
    else if (size > 64) {
        throw new Error("Maximum size is 64");
    }
    // Determine value range
    const maxValue = 2 ** (size - 1) - 1;
    const minValue = -maxValue - 1;
    return (value) => {
        value = value << 0;
        if (value > maxValue || value < minValue) {
            console.log("value", value, maxValue, minValue, value > maxValue, value < minValue);
            throw new Error(`Int${size} overflow`);
        }
        if (value < 0) {
            return 2 ** size + value;
        }
        else {
            return value;
        }
    };
}
const toInt32 = createToInt(32);

export { CoordMap, Int32ArrayToUint8Array, Uint8ArrayToHexString, Uint8ArrayToInt32Array, VoxelCoordMap, areaContains, arrayToIterator, awaitPromise, awaitStreamValue, awaitValue, cacheUntilReady, callWithRetry, computedToStream, concatIterators, concatUint8Arrays, coordToKey$1 as coordToKey, coordsOf, createToInt, cubicNoiseConfig, cubicNoiseSample1, cubicNoiseSample2, deferred, enableLogger, ethAddressToUint8Array, euclidean, extractEncodedArguments, filterNullish, filterNullishValues, formatHex, fromWorker, hexStringToUint8Array, interpolate, isFunction, isNotEmpty, isObject, keccak256, keccak256Coord, keyToCoord$1 as keyToCoord, makeIterable, mapObject, mergeIterators, numValues, observableToComputed, observableToStream, pack, packTuple, padToBitLength, pickRandom, random, randomize, range, rejectAfter, roundTowardsZero, runWorker, sleep, splitUint8Arrays, streamToComputed, streamToDefinedComputed, streamToWrappedValue, stretch, subtract, tile, timeoutAfter, to256BitString, toEthAddress, toInt32, transformIterator, unpack, unpackTuple, uuid };
//# sourceMappingURL=index.js.map
