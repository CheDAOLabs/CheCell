var je = Object.defineProperty;
var Ae = (s, e, t) => e in s ? je(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var w = (s, e, t) => (Ae(s, typeof e != "symbol" ? e + "" : e, t), t);
import { Account as Pe } from "starknet";
class we {
  async getPubKey() {
    throw new Error("Method not implemented");
  }
  async signMessage() {
    throw new Error("Method not implemented");
  }
  async signTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeclareTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeployAccountTransaction() {
    throw new Error("Method not implemented");
  }
}
class Le extends Pe {
  constructor(t, r, n) {
    super(t, r, new we());
    w(this, "signer", new we());
    w(this, "execute", (t, r, n) => this.remoteHandle.call("execute", t, r, n));
    this.address = r, this.remoteHandle = n;
  }
  signMessage(t) {
    return this.remoteHandle.call("signMessage", t);
  }
}
const ne = [];
function Ve(s, e, t, r) {
  if (s.isConnected)
    return s;
  const n = {
    isConnected: !0,
    chainId: e.chainId,
    selectedAddress: r,
    account: new Le(e, r, t),
    provider: e
  };
  return Object.assign(s, n);
}
const Dt = (s, e, t) => {
  const r = {
    ...s,
    isConnected: !1,
    provider: e,
    getLoginStatus: () => t.call("getLoginStatus"),
    async request(n) {
      switch (n.type) {
        case "wallet_addStarknetChain": {
          const a = n.params;
          return t.call("addStarknetChain", a);
        }
        case "wallet_switchStarknetChain": {
          const a = n.params;
          return t.call("switchStarknetChain", a);
        }
        case "wallet_watchAsset": {
          const a = n.params;
          return t.call("watchAsset", a);
        }
        default:
          throw new Error("not implemented");
      }
    },
    async enable(n) {
      if ((n == null ? void 0 : n.starknetVersion) !== "v4")
        throw Error("not implemented");
      const [a] = await t.call("enable");
      return Ve(
        r,
        e,
        t,
        a
      ), [a];
    },
    async isPreauthorized() {
      const n = await t.call("getLoginStatus");
      return n.isLoggedIn && n.isPreauthorized;
    },
    on: (n, a) => {
      if (n === "accountsChanged")
        ne.push({
          type: n,
          handler: a
        });
      else if (n === "networkChanged")
        ne.push({
          type: n,
          handler: a
        });
      else
        throw new Error(`Unknwown event: ${n}`);
    },
    off: (n, a) => {
      if (n !== "accountsChanged" && n !== "networkChanged")
        throw new Error(`Unknwown event: ${n}`);
      const i = ne.findIndex(
        (o) => o.type === n && o.handler === a
      );
      i >= 0 && ne.splice(i, 1);
    }
  };
  return r;
};
class zt {
  constructor(e, {
    post: t = "*",
    listen: r = "*"
  } = {}) {
    w(this, "listeners");
    w(this, "origins");
    w(this, "addListener", (e) => {
      this.listeners.add(e), this.listeners.size === 1 && this.window.addEventListener("message", this.handleMessage);
    });
    w(this, "removeListener", (e) => {
      this.listeners.delete(e), this.listeners.size === 0 && this.window.removeEventListener("message", this.handleMessage);
    });
    w(this, "postMessage", (e) => {
      let t = { ...e };
      "error" in e && (t = JSON.parse(
        JSON.stringify(e, function(n, a) {
          return a instanceof Error ? {
            ...a,
            name: a.name,
            message: a.message,
            stack: a.stack
          } : a;
        })
      )), this.window.postMessage(t, this.origins.post);
    });
    w(this, "handleMessage", (e) => {
      this.listeners.forEach((t) => {
        (e.origin === this.origins.listen || this.origins.listen === "*") && t(e.data, e.origin);
      });
    });
    this.window = e, this.listeners = /* @__PURE__ */ new Set(), this.origins = {
      post: t,
      listen: r
    };
  }
}
class Ut {
  constructor(e, t = e) {
    w(this, "id", Math.random().toString(36).slice(2));
    w(this, "pendingRequests", /* @__PURE__ */ new Map());
    w(this, "call", (e, ...t) => new Promise((r, n) => {
      const a = Math.random().toString(36).slice(2), i = setTimeout(() => {
        console.warn(
          new Error(
            `Request #${a} takes long (>10s): ${e.toString()}(${t})`
          )
        );
      }, 1e4);
      this.pendingRequests.set(a, (o) => {
        clearTimeout(i), "result" in o ? r(o.result) : "error" in o ? n(new Error(o.error.message)) : n(new Error("Invalid response"));
      }), this.postMessenger.postMessage({
        id: a,
        type: "REQUEST",
        method: e.toString(),
        args: t,
        meta: {
          sender: this.id
        }
      });
    }));
    w(this, "handleMessage", (e, t) => {
      const { type: r, id: n } = e;
      if (r === "RESPONSE") {
        const a = this.pendingRequests.get(n);
        a && (a(e), this.pendingRequests.delete(n));
      }
    });
    this.postMessenger = e, this.listenMessenger = t, this.listenMessenger.addListener(this.handleMessage);
  }
}
class Bt {
  constructor(e, t, r = e) {
    w(this, "id", Math.random().toString(36).slice(2));
    w(this, "destroy", () => {
      this.listenMessenger.removeListener(this.handleMessage);
    });
    w(this, "handleMessage", (e, t) => {
      var r;
      if (((r = e.meta) == null ? void 0 : r.sender) !== this.id && e.type === "REQUEST") {
        const n = this.localMethods[e.method];
        n ? n(t)(...e.args).then(
          (a) => this.postMessenger.postMessage({
            id: e.id,
            type: "RESPONSE",
            result: a != null ? a : null,
            meta: {
              sender: this.id
            }
          }),
          (a) => this.postMessenger.postMessage({
            id: e.id,
            type: "RESPONSE",
            error: a,
            meta: {
              sender: this.id
            }
          })
        ) : this.postMessenger.postMessage({
          id: e.id,
          type: "RESPONSE",
          error: new Error(`Method ${e.method} not found`),
          meta: {
            sender: this.id
          }
        });
      }
    });
    this.listenMessenger = e, this.localMethods = t, this.postMessenger = r, this.listenMessenger.addListener(this.handleMessage);
  }
}
class qt {
  constructor(e, t) {
    w(this, "id", Math.random().toString(36).slice(2));
    w(this, "destroy", () => {
      this.messenger1.removeListener(this.forwardMessageTo2), this.messenger2.removeListener(this.forwardMessageTo1);
    });
    w(this, "forwardMessageTo1", (e) => this.forwardMessage(this.messenger1, e));
    w(this, "forwardMessageTo2", (e) => this.forwardMessage(this.messenger2, e));
    w(this, "forwardMessage", (e, t) => {
      const r = t.meta && Array.isArray(t.meta.forwardedBy) ? t.meta.forwardedBy : [];
      if (!r.includes(this.id))
        return e.postMessage({
          ...t,
          meta: {
            ...t.meta,
            forwardedBy: [...r, this.id]
          }
        });
    });
    this.messenger1 = e, this.messenger2 = t, this.messenger1.addListener(this.forwardMessageTo2), this.messenger2.addListener(this.forwardMessageTo1);
  }
}
var x;
(function(s) {
  s.assertEqual = (n) => n;
  function e(n) {
  }
  s.assertIs = e;
  function t(n) {
    throw new Error();
  }
  s.assertNever = t, s.arrayToEnum = (n) => {
    const a = {};
    for (const i of n)
      a[i] = i;
    return a;
  }, s.getValidEnumValues = (n) => {
    const a = s.objectKeys(n).filter((o) => typeof n[n[o]] != "number"), i = {};
    for (const o of a)
      i[o] = n[o];
    return s.objectValues(i);
  }, s.objectValues = (n) => s.objectKeys(n).map(function(a) {
    return n[a];
  }), s.objectKeys = typeof Object.keys == "function" ? (n) => Object.keys(n) : (n) => {
    const a = [];
    for (const i in n)
      Object.prototype.hasOwnProperty.call(n, i) && a.push(i);
    return a;
  }, s.find = (n, a) => {
    for (const i of n)
      if (a(i))
        return i;
  }, s.isInteger = typeof Number.isInteger == "function" ? (n) => Number.isInteger(n) : (n) => typeof n == "number" && isFinite(n) && Math.floor(n) === n;
  function r(n, a = " | ") {
    return n.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  s.joinValues = r, s.jsonStringifyReplacer = (n, a) => typeof a == "bigint" ? a.toString() : a;
})(x || (x = {}));
var ve;
(function(s) {
  s.mergeShapes = (e, t) => ({
    ...e,
    ...t
  });
})(ve || (ve = {}));
const c = x.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), R = (s) => {
  switch (typeof s) {
    case "undefined":
      return c.undefined;
    case "string":
      return c.string;
    case "number":
      return isNaN(s) ? c.nan : c.number;
    case "boolean":
      return c.boolean;
    case "function":
      return c.function;
    case "bigint":
      return c.bigint;
    case "symbol":
      return c.symbol;
    case "object":
      return Array.isArray(s) ? c.array : s === null ? c.null : s.then && typeof s.then == "function" && s.catch && typeof s.catch == "function" ? c.promise : typeof Map < "u" && s instanceof Map ? c.map : typeof Set < "u" && s instanceof Set ? c.set : typeof Date < "u" && s instanceof Date ? c.date : c.object;
    default:
      return c.unknown;
  }
}, d = x.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), $e = (s) => JSON.stringify(s, null, 2).replace(/"([^"]+)":/g, "$1:");
class E extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const t = e || function(a) {
      return a.message;
    }, r = { _errors: [] }, n = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(n);
        else if (i.code === "invalid_return_type")
          n(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          n(i.argumentsError);
        else if (i.path.length === 0)
          r._errors.push(t(i));
        else {
          let o = r, h = 0;
          for (; h < i.path.length; ) {
            const l = i.path[h];
            h === i.path.length - 1 ? (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(t(i))) : o[l] = o[l] || { _errors: [] }, o = o[l], h++;
          }
        }
    };
    return n(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, x.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = {}, r = [];
    for (const n of this.issues)
      n.path.length > 0 ? (t[n.path[0]] = t[n.path[0]] || [], t[n.path[0]].push(e(n))) : r.push(e(n));
    return { formErrors: r, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
}
E.create = (s) => new E(s);
const J = (s, e) => {
  let t;
  switch (s.code) {
    case d.invalid_type:
      s.received === c.undefined ? t = "Required" : t = `Expected ${s.expected}, received ${s.received}`;
      break;
    case d.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(s.expected, x.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${x.joinValues(s.keys, ", ")}`;
      break;
    case d.invalid_union:
      t = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${x.joinValues(s.options)}`;
      break;
    case d.invalid_enum_value:
      t = `Invalid enum value. Expected ${x.joinValues(s.options)}, received '${s.received}'`;
      break;
    case d.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      t = "Invalid function return type";
      break;
    case d.invalid_date:
      t = "Invalid date";
      break;
    case d.invalid_string:
      typeof s.validation == "object" ? "includes" in s.validation ? (t = `Invalid input: must include "${s.validation.includes}"`, typeof s.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${s.validation.position}`)) : "startsWith" in s.validation ? t = `Invalid input: must start with "${s.validation.startsWith}"` : "endsWith" in s.validation ? t = `Invalid input: must end with "${s.validation.endsWith}"` : x.assertNever(s.validation) : s.validation !== "regex" ? t = `Invalid ${s.validation}` : t = "Invalid";
      break;
    case d.too_small:
      s.type === "array" ? t = `Array must contain ${s.exact ? "exactly" : s.inclusive ? "at least" : "more than"} ${s.minimum} element(s)` : s.type === "string" ? t = `String must contain ${s.exact ? "exactly" : s.inclusive ? "at least" : "over"} ${s.minimum} character(s)` : s.type === "number" ? t = `Number must be ${s.exact ? "exactly equal to " : s.inclusive ? "greater than or equal to " : "greater than "}${s.minimum}` : s.type === "date" ? t = `Date must be ${s.exact ? "exactly equal to " : s.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(s.minimum))}` : t = "Invalid input";
      break;
    case d.too_big:
      s.type === "array" ? t = `Array must contain ${s.exact ? "exactly" : s.inclusive ? "at most" : "less than"} ${s.maximum} element(s)` : s.type === "string" ? t = `String must contain ${s.exact ? "exactly" : s.inclusive ? "at most" : "under"} ${s.maximum} character(s)` : s.type === "number" ? t = `Number must be ${s.exact ? "exactly" : s.inclusive ? "less than or equal to" : "less than"} ${s.maximum}` : s.type === "bigint" ? t = `BigInt must be ${s.exact ? "exactly" : s.inclusive ? "less than or equal to" : "less than"} ${s.maximum}` : s.type === "date" ? t = `Date must be ${s.exact ? "exactly" : s.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(s.maximum))}` : t = "Invalid input";
      break;
    case d.custom:
      t = "Invalid input";
      break;
    case d.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      t = `Number must be a multiple of ${s.multipleOf}`;
      break;
    case d.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, x.assertNever(s);
  }
  return { message: t };
};
let Ee = J;
function De(s) {
  Ee = s;
}
function oe() {
  return Ee;
}
const de = (s) => {
  const { data: e, path: t, errorMaps: r, issueData: n } = s, a = [...t, ...n.path || []], i = {
    ...n,
    path: a
  };
  let o = "";
  const h = r.filter((l) => !!l).slice().reverse();
  for (const l of h)
    o = l(i, { data: e, defaultError: o }).message;
  return {
    ...n,
    path: a,
    message: n.message || o
  };
}, ze = [];
function u(s, e) {
  const t = de({
    issueData: e,
    data: s.data,
    path: s.path,
    errorMaps: [
      s.common.contextualErrorMap,
      s.schemaErrorMap,
      oe(),
      J
    ].filter((r) => !!r)
  });
  s.common.issues.push(t);
}
class b {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const r = [];
    for (const n of t) {
      if (n.status === "aborted")
        return y;
      n.status === "dirty" && e.dirty(), r.push(n.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, t) {
    const r = [];
    for (const n of t)
      r.push({
        key: await n.key,
        value: await n.value
      });
    return b.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, t) {
    const r = {};
    for (const n of t) {
      const { key: a, value: i } = n;
      if (a.status === "aborted" || i.status === "aborted")
        return y;
      a.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), (typeof i.value < "u" || n.alwaysSet) && (r[a.value] = i.value);
    }
    return { status: e.value, value: r };
  }
}
const y = Object.freeze({
  status: "aborted"
}), Ze = (s) => ({ status: "dirty", value: s }), T = (s) => ({ status: "valid", value: s }), _e = (s) => s.status === "aborted", xe = (s) => s.status === "dirty", ce = (s) => s.status === "valid", ue = (s) => typeof Promise < "u" && s instanceof Promise;
var p;
(function(s) {
  s.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, s.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(p || (p = {}));
class N {
  constructor(e, t, r, n) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = r, this._key = n;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const be = (s, e) => {
  if (ce(e))
    return { success: !0, data: e.value };
  if (!s.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const t = new E(s.common.issues);
      return this._error = t, this._error;
    }
  };
};
function g(s) {
  if (!s)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: r, description: n } = s;
  if (e && (t || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: n } : { errorMap: (i, o) => i.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: r != null ? r : o.defaultError } : { message: t != null ? t : o.defaultError }, description: n };
}
class v {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return R(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: R(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new b(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: R(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (ue(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const r = this.safeParse(e, t);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, t) {
    var r;
    const n = {
      common: {
        issues: [],
        async: (r = t == null ? void 0 : t.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: R(e)
    }, a = this._parseSync({ data: e, path: n.path, parent: n });
    return be(n, a);
  }
  async parseAsync(e, t) {
    const r = await this.safeParseAsync(e, t);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, t) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: !0
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: R(e)
    }, n = this._parse({ data: e, path: r.path, parent: r }), a = await (ue(n) ? n : Promise.resolve(n));
    return be(r, a);
  }
  refine(e, t) {
    const r = (n) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(n) : t;
    return this._refinement((n, a) => {
      const i = e(n), o = () => a.addIssue({
        code: d.custom,
        ...r(n)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((h) => h ? !0 : (o(), !1)) : i ? !0 : (o(), !1);
    });
  }
  refinement(e, t) {
    return this._refinement((r, n) => e(r) ? !0 : (n.addIssue(typeof t == "function" ? t(r, n) : t), !1));
  }
  _refinement(e) {
    return new C({
      schema: this,
      typeName: m.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return M.create(this, this._def);
  }
  nullable() {
    return D.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Z.create(this, this._def);
  }
  promise() {
    return W.create(this, this._def);
  }
  or(e) {
    return H.create([this, e], this._def);
  }
  and(e) {
    return K.create(this, e, this._def);
  }
  transform(e) {
    return new C({
      ...g(this._def),
      schema: this,
      typeName: m.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new se({
      ...g(this._def),
      innerType: this,
      defaultValue: t,
      typeName: m.ZodDefault
    });
  }
  brand() {
    return new Ne({
      typeName: m.ZodBranded,
      type: this,
      ...g(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new pe({
      ...g(this._def),
      innerType: this,
      catchValue: t,
      typeName: m.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return re.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Ue = /^c[^\s-]{8,}$/i, Be = /^[a-z][a-z0-9]*$/, qe = /[0-9A-HJKMNP-TV-Z]{26}/, We = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Je = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, Ye = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, Ge = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Qe = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, He = (s) => s.precision ? s.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${s.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${s.precision}}Z$`) : s.precision === 0 ? s.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : s.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Ke(s, e) {
  return !!((e === "v4" || !e) && Ge.test(s) || (e === "v6" || !e) && Qe.test(s));
}
class S extends v {
  constructor() {
    super(...arguments), this._regex = (e, t, r) => this.refinement((n) => e.test(n), {
      validation: t,
      code: d.invalid_string,
      ...p.errToObj(r)
    }), this.nonempty = (e) => this.min(1, p.errToObj(e)), this.trim = () => new S({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new S({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new S({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== c.string) {
      const a = this._getOrReturnCtx(e);
      return u(
        a,
        {
          code: d.invalid_type,
          expected: c.string,
          received: a.parsedType
        }
      ), y;
    }
    const r = new b();
    let n;
    for (const a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value && (n = this._getOrReturnCtx(e, n), u(n, {
          code: d.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        e.data.length > a.value && (n = this._getOrReturnCtx(e, n), u(n, {
          code: d.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const i = e.data.length > a.value, o = e.data.length < a.value;
        (i || o) && (n = this._getOrReturnCtx(e, n), i ? u(n, {
          code: d.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : o && u(n, {
          code: d.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        Je.test(e.data) || (n = this._getOrReturnCtx(e, n), u(n, {
          validation: "email",
          code: d.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        Ye.test(e.data) || (n = this._getOrReturnCtx(e, n), u(n, {
          validation: "emoji",
          code: d.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        We.test(e.data) || (n = this._getOrReturnCtx(e, n), u(n, {
          validation: "uuid",
          code: d.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        Ue.test(e.data) || (n = this._getOrReturnCtx(e, n), u(n, {
          validation: "cuid",
          code: d.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        Be.test(e.data) || (n = this._getOrReturnCtx(e, n), u(n, {
          validation: "cuid2",
          code: d.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        qe.test(e.data) || (n = this._getOrReturnCtx(e, n), u(n, {
          validation: "ulid",
          code: d.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          n = this._getOrReturnCtx(e, n), u(n, {
            validation: "url",
            code: d.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else
        a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (n = this._getOrReturnCtx(e, n), u(n, {
          validation: "regex",
          code: d.invalid_string,
          message: a.message
        }), r.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (n = this._getOrReturnCtx(e, n), u(n, {
          code: d.invalid_string,
          validation: { includes: a.value, position: a.position },
          message: a.message
        }), r.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (n = this._getOrReturnCtx(e, n), u(n, {
          code: d.invalid_string,
          validation: { startsWith: a.value },
          message: a.message
        }), r.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (n = this._getOrReturnCtx(e, n), u(n, {
          code: d.invalid_string,
          validation: { endsWith: a.value },
          message: a.message
        }), r.dirty()) : a.kind === "datetime" ? He(a).test(e.data) || (n = this._getOrReturnCtx(e, n), u(n, {
          code: d.invalid_string,
          validation: "datetime",
          message: a.message
        }), r.dirty()) : a.kind === "ip" ? Ke(e.data, a.version) || (n = this._getOrReturnCtx(e, n), u(n, {
          validation: "ip",
          code: d.invalid_string,
          message: a.message
        }), r.dirty()) : x.assertNever(a);
    return { status: r.value, value: e.data };
  }
  _addCheck(e) {
    return new S({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...p.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...p.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...p.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...p.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...p.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...p.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...p.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...p.errToObj(e) });
  }
  datetime(e) {
    var t;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1,
      ...p.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...p.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...p.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...p.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...p.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...p.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...p.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...p.errToObj(t)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
S.create = (s) => {
  var e;
  return new S({
    checks: [],
    typeName: m.ZodString,
    coerce: (e = s == null ? void 0 : s.coerce) !== null && e !== void 0 ? e : !1,
    ...g(s)
  });
};
function Xe(s, e) {
  const t = (s.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, n = t > r ? t : r, a = parseInt(s.toFixed(n).replace(".", "")), i = parseInt(e.toFixed(n).replace(".", ""));
  return a % i / Math.pow(10, n);
}
class j extends v {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== c.number) {
      const a = this._getOrReturnCtx(e);
      return u(a, {
        code: d.invalid_type,
        expected: c.number,
        received: a.parsedType
      }), y;
    }
    let r;
    const n = new b();
    for (const a of this._def.checks)
      a.kind === "int" ? x.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), u(r, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), n.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (r = this._getOrReturnCtx(e, r), u(r, {
        code: d.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), n.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (r = this._getOrReturnCtx(e, r), u(r, {
        code: d.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), n.dirty()) : a.kind === "multipleOf" ? Xe(e.data, a.value) !== 0 && (r = this._getOrReturnCtx(e, r), u(r, {
        code: d.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), n.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), u(r, {
        code: d.not_finite,
        message: a.message
      }), n.dirty()) : x.assertNever(a);
    return { status: n.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, p.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, p.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, p.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, p.toString(t));
  }
  setLimit(e, t, r, n) {
    return new j({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: r,
          message: p.toString(n)
        }
      ]
    });
  }
  _addCheck(e) {
    return new j({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: p.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: p.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: p.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: p.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: p.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: p.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: p.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: p.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: p.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && x.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (t === null || r.value > t) && (t = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
}
j.create = (s) => new j({
  checks: [],
  typeName: m.ZodNumber,
  coerce: (s == null ? void 0 : s.coerce) || !1,
  ...g(s)
});
class A extends v {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== c.bigint) {
      const a = this._getOrReturnCtx(e);
      return u(a, {
        code: d.invalid_type,
        expected: c.bigint,
        received: a.parsedType
      }), y;
    }
    let r;
    const n = new b();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (r = this._getOrReturnCtx(e, r), u(r, {
        code: d.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), n.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (r = this._getOrReturnCtx(e, r), u(r, {
        code: d.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), n.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), u(r, {
        code: d.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), n.dirty()) : x.assertNever(a);
    return { status: n.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, !0, p.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, !1, p.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, !0, p.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, !1, p.toString(t));
  }
  setLimit(e, t, r, n) {
    return new A({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: r,
          message: p.toString(n)
        }
      ]
    });
  }
  _addCheck(e) {
    return new A({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: p.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: p.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: p.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: p.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: p.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
}
A.create = (s) => {
  var e;
  return new A({
    checks: [],
    typeName: m.ZodBigInt,
    coerce: (e = s == null ? void 0 : s.coerce) !== null && e !== void 0 ? e : !1,
    ...g(s)
  });
};
class Y extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = Boolean(e.data)), this._getType(e) !== c.boolean) {
      const r = this._getOrReturnCtx(e);
      return u(r, {
        code: d.invalid_type,
        expected: c.boolean,
        received: r.parsedType
      }), y;
    }
    return T(e.data);
  }
}
Y.create = (s) => new Y({
  typeName: m.ZodBoolean,
  coerce: (s == null ? void 0 : s.coerce) || !1,
  ...g(s)
});
class V extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== c.date) {
      const a = this._getOrReturnCtx(e);
      return u(a, {
        code: d.invalid_type,
        expected: c.date,
        received: a.parsedType
      }), y;
    }
    if (isNaN(e.data.getTime())) {
      const a = this._getOrReturnCtx(e);
      return u(a, {
        code: d.invalid_date
      }), y;
    }
    const r = new b();
    let n;
    for (const a of this._def.checks)
      a.kind === "min" ? e.data.getTime() < a.value && (n = this._getOrReturnCtx(e, n), u(n, {
        code: d.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (n = this._getOrReturnCtx(e, n), u(n, {
        code: d.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : x.assertNever(a);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new V({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: p.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: p.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
}
V.create = (s) => new V({
  checks: [],
  coerce: (s == null ? void 0 : s.coerce) || !1,
  typeName: m.ZodDate,
  ...g(s)
});
class le extends v {
  _parse(e) {
    if (this._getType(e) !== c.symbol) {
      const r = this._getOrReturnCtx(e);
      return u(r, {
        code: d.invalid_type,
        expected: c.symbol,
        received: r.parsedType
      }), y;
    }
    return T(e.data);
  }
}
le.create = (s) => new le({
  typeName: m.ZodSymbol,
  ...g(s)
});
class G extends v {
  _parse(e) {
    if (this._getType(e) !== c.undefined) {
      const r = this._getOrReturnCtx(e);
      return u(r, {
        code: d.invalid_type,
        expected: c.undefined,
        received: r.parsedType
      }), y;
    }
    return T(e.data);
  }
}
G.create = (s) => new G({
  typeName: m.ZodUndefined,
  ...g(s)
});
class Q extends v {
  _parse(e) {
    if (this._getType(e) !== c.null) {
      const r = this._getOrReturnCtx(e);
      return u(r, {
        code: d.invalid_type,
        expected: c.null,
        received: r.parsedType
      }), y;
    }
    return T(e.data);
  }
}
Q.create = (s) => new Q({
  typeName: m.ZodNull,
  ...g(s)
});
class q extends v {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return T(e.data);
  }
}
q.create = (s) => new q({
  typeName: m.ZodAny,
  ...g(s)
});
class L extends v {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return T(e.data);
  }
}
L.create = (s) => new L({
  typeName: m.ZodUnknown,
  ...g(s)
});
class I extends v {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return u(t, {
      code: d.invalid_type,
      expected: c.never,
      received: t.parsedType
    }), y;
  }
}
I.create = (s) => new I({
  typeName: m.ZodNever,
  ...g(s)
});
class he extends v {
  _parse(e) {
    if (this._getType(e) !== c.undefined) {
      const r = this._getOrReturnCtx(e);
      return u(r, {
        code: d.invalid_type,
        expected: c.void,
        received: r.parsedType
      }), y;
    }
    return T(e.data);
  }
}
he.create = (s) => new he({
  typeName: m.ZodVoid,
  ...g(s)
});
class Z extends v {
  _parse(e) {
    const { ctx: t, status: r } = this._processInputParams(e), n = this._def;
    if (t.parsedType !== c.array)
      return u(t, {
        code: d.invalid_type,
        expected: c.array,
        received: t.parsedType
      }), y;
    if (n.exactLength !== null) {
      const i = t.data.length > n.exactLength.value, o = t.data.length < n.exactLength.value;
      (i || o) && (u(t, {
        code: i ? d.too_big : d.too_small,
        minimum: o ? n.exactLength.value : void 0,
        maximum: i ? n.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: n.exactLength.message
      }), r.dirty());
    }
    if (n.minLength !== null && t.data.length < n.minLength.value && (u(t, {
      code: d.too_small,
      minimum: n.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.minLength.message
    }), r.dirty()), n.maxLength !== null && t.data.length > n.maxLength.value && (u(t, {
      code: d.too_big,
      maximum: n.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.maxLength.message
    }), r.dirty()), t.common.async)
      return Promise.all([...t.data].map((i, o) => n.type._parseAsync(new N(t, i, t.path, o)))).then((i) => b.mergeArray(r, i));
    const a = [...t.data].map((i, o) => n.type._parseSync(new N(t, i, t.path, o)));
    return b.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new Z({
      ...this._def,
      minLength: { value: e, message: p.toString(t) }
    });
  }
  max(e, t) {
    return new Z({
      ...this._def,
      maxLength: { value: e, message: p.toString(t) }
    });
  }
  length(e, t) {
    return new Z({
      ...this._def,
      exactLength: { value: e, message: p.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Z.create = (s, e) => new Z({
  type: s,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: m.ZodArray,
  ...g(e)
});
function U(s) {
  if (s instanceof k) {
    const e = {};
    for (const t in s.shape) {
      const r = s.shape[t];
      e[t] = M.create(U(r));
    }
    return new k({
      ...s._def,
      shape: () => e
    });
  } else
    return s instanceof Z ? new Z({
      ...s._def,
      type: U(s.element)
    }) : s instanceof M ? M.create(U(s.unwrap())) : s instanceof D ? D.create(U(s.unwrap())) : s instanceof O ? O.create(s.items.map((e) => U(e))) : s;
}
class k extends v {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = x.objectKeys(e);
    return this._cached = { shape: e, keys: t };
  }
  _parse(e) {
    if (this._getType(e) !== c.object) {
      const l = this._getOrReturnCtx(e);
      return u(l, {
        code: d.invalid_type,
        expected: c.object,
        received: l.parsedType
      }), y;
    }
    const { status: r, ctx: n } = this._processInputParams(e), { shape: a, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof I && this._def.unknownKeys === "strip"))
      for (const l in n.data)
        i.includes(l) || o.push(l);
    const h = [];
    for (const l of i) {
      const _ = a[l], z = n.data[l];
      h.push({
        key: { status: "valid", value: l },
        value: _._parse(new N(n, z, n.path, l)),
        alwaysSet: l in n.data
      });
    }
    if (this._def.catchall instanceof I) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const _ of o)
          h.push({
            key: { status: "valid", value: _ },
            value: { status: "valid", value: n.data[_] }
          });
      else if (l === "strict")
        o.length > 0 && (u(n, {
          code: d.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const _ of o) {
        const z = n.data[_];
        h.push({
          key: { status: "valid", value: _ },
          value: l._parse(
            new N(n, z, n.path, _)
          ),
          alwaysSet: _ in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const _ of h) {
        const z = await _.key;
        l.push({
          key: z,
          value: await _.value,
          alwaysSet: _.alwaysSet
        });
      }
      return l;
    }).then((l) => b.mergeObjectSync(r, l)) : b.mergeObjectSync(r, h);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return p.errToObj, new k({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, r) => {
          var n, a, i, o;
          const h = (i = (a = (n = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(n, t, r).message) !== null && i !== void 0 ? i : r.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: (o = p.errToObj(e).message) !== null && o !== void 0 ? o : h
          } : {
            message: h
          };
        }
      } : {}
    });
  }
  strip() {
    return new k({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new k({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(e) {
    return new k({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  merge(e) {
    return new k({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: m.ZodObject
    });
  }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  catchall(e) {
    return new k({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    return x.objectKeys(e).forEach((r) => {
      e[r] && this.shape[r] && (t[r] = this.shape[r]);
    }), new k({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    return x.objectKeys(this.shape).forEach((r) => {
      e[r] || (t[r] = this.shape[r]);
    }), new k({
      ...this._def,
      shape: () => t
    });
  }
  deepPartial() {
    return U(this);
  }
  partial(e) {
    const t = {};
    return x.objectKeys(this.shape).forEach((r) => {
      const n = this.shape[r];
      e && !e[r] ? t[r] = n : t[r] = n.optional();
    }), new k({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    return x.objectKeys(this.shape).forEach((r) => {
      if (e && !e[r])
        t[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof M; )
          a = a._def.innerType;
        t[r] = a;
      }
    }), new k({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return Ce(x.objectKeys(this.shape));
  }
}
k.create = (s, e) => new k({
  shape: () => s,
  unknownKeys: "strip",
  catchall: I.create(),
  typeName: m.ZodObject,
  ...g(e)
});
k.strictCreate = (s, e) => new k({
  shape: () => s,
  unknownKeys: "strict",
  catchall: I.create(),
  typeName: m.ZodObject,
  ...g(e)
});
k.lazycreate = (s, e) => new k({
  shape: s,
  unknownKeys: "strip",
  catchall: I.create(),
  typeName: m.ZodObject,
  ...g(e)
});
class H extends v {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), r = this._def.options;
    function n(a) {
      for (const o of a)
        if (o.result.status === "valid")
          return o.result;
      for (const o of a)
        if (o.result.status === "dirty")
          return t.common.issues.push(...o.ctx.common.issues), o.result;
      const i = a.map((o) => new E(o.ctx.common.issues));
      return u(t, {
        code: d.invalid_union,
        unionErrors: i
      }), y;
    }
    if (t.common.async)
      return Promise.all(r.map(async (a) => {
        const i = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: t.data,
            path: t.path,
            parent: i
          }),
          ctx: i
        };
      })).then(n);
    {
      let a;
      const i = [];
      for (const h of r) {
        const l = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, _ = h._parseSync({
          data: t.data,
          path: t.path,
          parent: l
        });
        if (_.status === "valid")
          return _;
        _.status === "dirty" && !a && (a = { result: _, ctx: l }), l.common.issues.length && i.push(l.common.issues);
      }
      if (a)
        return t.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((h) => new E(h));
      return u(t, {
        code: d.invalid_union,
        unionErrors: o
      }), y;
    }
  }
  get options() {
    return this._def.options;
  }
}
H.create = (s, e) => new H({
  options: s,
  typeName: m.ZodUnion,
  ...g(e)
});
const ae = (s) => s instanceof F ? ae(s.schema) : s instanceof C ? ae(s.innerType()) : s instanceof ee ? [s.value] : s instanceof P ? s.options : s instanceof te ? Object.keys(s.enum) : s instanceof se ? ae(s._def.innerType) : s instanceof G ? [void 0] : s instanceof Q ? [null] : null;
class ye extends v {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== c.object)
      return u(t, {
        code: d.invalid_type,
        expected: c.object,
        received: t.parsedType
      }), y;
    const r = this.discriminator, n = t.data[r], a = this.optionsMap.get(n);
    return a ? t.common.async ? a._parseAsync({
      data: t.data,
      path: t.path,
      parent: t
    }) : a._parseSync({
      data: t.data,
      path: t.path,
      parent: t
    }) : (u(t, {
      code: d.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), y);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e, t, r) {
    const n = /* @__PURE__ */ new Map();
    for (const a of t) {
      const i = ae(a.shape[e]);
      if (!i)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of i) {
        if (n.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        n.set(o, a);
      }
    }
    return new ye({
      typeName: m.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: n,
      ...g(r)
    });
  }
}
function ke(s, e) {
  const t = R(s), r = R(e);
  if (s === e)
    return { valid: !0, data: s };
  if (t === c.object && r === c.object) {
    const n = x.objectKeys(e), a = x.objectKeys(s).filter((o) => n.indexOf(o) !== -1), i = { ...s, ...e };
    for (const o of a) {
      const h = ke(s[o], e[o]);
      if (!h.valid)
        return { valid: !1 };
      i[o] = h.data;
    }
    return { valid: !0, data: i };
  } else if (t === c.array && r === c.array) {
    if (s.length !== e.length)
      return { valid: !1 };
    const n = [];
    for (let a = 0; a < s.length; a++) {
      const i = s[a], o = e[a], h = ke(i, o);
      if (!h.valid)
        return { valid: !1 };
      n.push(h.data);
    }
    return { valid: !0, data: n };
  } else
    return t === c.date && r === c.date && +s == +e ? { valid: !0, data: s } : { valid: !1 };
}
class K extends v {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e), n = (a, i) => {
      if (_e(a) || _e(i))
        return y;
      const o = ke(a.value, i.value);
      return o.valid ? ((xe(a) || xe(i)) && t.dirty(), { status: t.value, value: o.data }) : (u(r, {
        code: d.invalid_intersection_types
      }), y);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, i]) => n(a, i)) : n(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
K.create = (s, e, t) => new K({
  left: s,
  right: e,
  typeName: m.ZodIntersection,
  ...g(t)
});
class O extends v {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== c.array)
      return u(r, {
        code: d.invalid_type,
        expected: c.array,
        received: r.parsedType
      }), y;
    if (r.data.length < this._def.items.length)
      return u(r, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), y;
    !this._def.rest && r.data.length > this._def.items.length && (u(r, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), t.dirty());
    const a = [...r.data].map((i, o) => {
      const h = this._def.items[o] || this._def.rest;
      return h ? h._parse(new N(r, i, r.path, o)) : null;
    }).filter((i) => !!i);
    return r.common.async ? Promise.all(a).then((i) => b.mergeArray(t, i)) : b.mergeArray(t, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new O({
      ...this._def,
      rest: e
    });
  }
}
O.create = (s, e) => {
  if (!Array.isArray(s))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new O({
    items: s,
    typeName: m.ZodTuple,
    rest: null,
    ...g(e)
  });
};
class X extends v {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== c.object)
      return u(r, {
        code: d.invalid_type,
        expected: c.object,
        received: r.parsedType
      }), y;
    const n = [], a = this._def.keyType, i = this._def.valueType;
    for (const o in r.data)
      n.push({
        key: a._parse(new N(r, o, r.path, o)),
        value: i._parse(new N(r, r.data[o], r.path, o))
      });
    return r.common.async ? b.mergeObjectAsync(t, n) : b.mergeObjectSync(t, n);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, r) {
    return t instanceof v ? new X({
      keyType: e,
      valueType: t,
      typeName: m.ZodRecord,
      ...g(r)
    }) : new X({
      keyType: S.create(),
      valueType: e,
      typeName: m.ZodRecord,
      ...g(t)
    });
  }
}
class fe extends v {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== c.map)
      return u(r, {
        code: d.invalid_type,
        expected: c.map,
        received: r.parsedType
      }), y;
    const n = this._def.keyType, a = this._def.valueType, i = [...r.data.entries()].map(([o, h], l) => ({
      key: n._parse(new N(r, o, r.path, [l, "key"])),
      value: a._parse(new N(r, h, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const h of i) {
          const l = await h.key, _ = await h.value;
          if (l.status === "aborted" || _.status === "aborted")
            return y;
          (l.status === "dirty" || _.status === "dirty") && t.dirty(), o.set(l.value, _.value);
        }
        return { status: t.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const h of i) {
        const l = h.key, _ = h.value;
        if (l.status === "aborted" || _.status === "aborted")
          return y;
        (l.status === "dirty" || _.status === "dirty") && t.dirty(), o.set(l.value, _.value);
      }
      return { status: t.value, value: o };
    }
  }
}
fe.create = (s, e, t) => new fe({
  valueType: e,
  keyType: s,
  typeName: m.ZodMap,
  ...g(t)
});
class $ extends v {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== c.set)
      return u(r, {
        code: d.invalid_type,
        expected: c.set,
        received: r.parsedType
      }), y;
    const n = this._def;
    n.minSize !== null && r.data.size < n.minSize.value && (u(r, {
      code: d.too_small,
      minimum: n.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.minSize.message
    }), t.dirty()), n.maxSize !== null && r.data.size > n.maxSize.value && (u(r, {
      code: d.too_big,
      maximum: n.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.maxSize.message
    }), t.dirty());
    const a = this._def.valueType;
    function i(h) {
      const l = /* @__PURE__ */ new Set();
      for (const _ of h) {
        if (_.status === "aborted")
          return y;
        _.status === "dirty" && t.dirty(), l.add(_.value);
      }
      return { status: t.value, value: l };
    }
    const o = [...r.data.values()].map((h, l) => a._parse(new N(r, h, r.path, l)));
    return r.common.async ? Promise.all(o).then((h) => i(h)) : i(o);
  }
  min(e, t) {
    return new $({
      ...this._def,
      minSize: { value: e, message: p.toString(t) }
    });
  }
  max(e, t) {
    return new $({
      ...this._def,
      maxSize: { value: e, message: p.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
$.create = (s, e) => new $({
  valueType: s,
  minSize: null,
  maxSize: null,
  typeName: m.ZodSet,
  ...g(e)
});
class B extends v {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== c.function)
      return u(t, {
        code: d.invalid_type,
        expected: c.function,
        received: t.parsedType
      }), y;
    function r(o, h) {
      return de({
        data: o,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          oe(),
          J
        ].filter((l) => !!l),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: h
        }
      });
    }
    function n(o, h) {
      return de({
        data: o,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          oe(),
          J
        ].filter((l) => !!l),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: h
        }
      });
    }
    const a = { errorMap: t.common.contextualErrorMap }, i = t.data;
    return this._def.returns instanceof W ? T(async (...o) => {
      const h = new E([]), l = await this._def.args.parseAsync(o, a).catch((ge) => {
        throw h.addIssue(r(o, ge)), h;
      }), _ = await i(...l);
      return await this._def.returns._def.type.parseAsync(_, a).catch((ge) => {
        throw h.addIssue(n(_, ge)), h;
      });
    }) : T((...o) => {
      const h = this._def.args.safeParse(o, a);
      if (!h.success)
        throw new E([r(o, h.error)]);
      const l = i(...h.data), _ = this._def.returns.safeParse(l, a);
      if (!_.success)
        throw new E([n(l, _.error)]);
      return _.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new B({
      ...this._def,
      args: O.create(e).rest(L.create())
    });
  }
  returns(e) {
    return new B({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, r) {
    return new B({
      args: e || O.create([]).rest(L.create()),
      returns: t || L.create(),
      typeName: m.ZodFunction,
      ...g(r)
    });
  }
}
class F extends v {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
}
F.create = (s, e) => new F({
  getter: s,
  typeName: m.ZodLazy,
  ...g(e)
});
class ee extends v {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return u(t, {
        received: t.data,
        code: d.invalid_literal,
        expected: this._def.value
      }), y;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
ee.create = (s, e) => new ee({
  value: s,
  typeName: m.ZodLiteral,
  ...g(e)
});
function Ce(s, e) {
  return new P({
    values: s,
    typeName: m.ZodEnum,
    ...g(e)
  });
}
class P extends v {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), r = this._def.values;
      return u(t, {
        expected: x.joinValues(r),
        received: t.parsedType,
        code: d.invalid_type
      }), y;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const t = this._getOrReturnCtx(e), r = this._def.values;
      return u(t, {
        received: t.data,
        code: d.invalid_enum_value,
        options: r
      }), y;
    }
    return T(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e) {
    return P.create(e);
  }
  exclude(e) {
    return P.create(this.options.filter((t) => !e.includes(t)));
  }
}
P.create = Ce;
class te extends v {
  _parse(e) {
    const t = x.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== c.string && r.parsedType !== c.number) {
      const n = x.objectValues(t);
      return u(r, {
        expected: x.joinValues(n),
        received: r.parsedType,
        code: d.invalid_type
      }), y;
    }
    if (t.indexOf(e.data) === -1) {
      const n = x.objectValues(t);
      return u(r, {
        received: r.data,
        code: d.invalid_enum_value,
        options: n
      }), y;
    }
    return T(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
te.create = (s, e) => new te({
  values: s,
  typeName: m.ZodNativeEnum,
  ...g(e)
});
class W extends v {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== c.promise && t.common.async === !1)
      return u(t, {
        code: d.invalid_type,
        expected: c.promise,
        received: t.parsedType
      }), y;
    const r = t.parsedType === c.promise ? t.data : Promise.resolve(t.data);
    return T(r.then((n) => this._def.type.parseAsync(n, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
}
W.create = (s, e) => new W({
  type: s,
  typeName: m.ZodPromise,
  ...g(e)
});
class C extends v {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === m.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e), n = this._def.effect || null;
    if (n.type === "preprocess") {
      const i = n.transform(r.data);
      return r.common.async ? Promise.resolve(i).then((o) => this._def.schema._parseAsync({
        data: o,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: i,
        path: r.path,
        parent: r
      });
    }
    const a = {
      addIssue: (i) => {
        u(r, i), i.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), n.type === "refinement") {
      const i = (o) => {
        const h = n.refinement(o, a);
        if (r.common.async)
          return Promise.resolve(h);
        if (h instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? y : (o.status === "dirty" && t.dirty(), i(o.value), { status: t.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? y : (o.status === "dirty" && t.dirty(), i(o.value).then(() => ({ status: t.value, value: o.value }))));
    }
    if (n.type === "transform")
      if (r.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!ce(i))
          return i;
        const o = n.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => ce(i) ? Promise.resolve(n.transform(i.value, a)).then((o) => ({ status: t.value, value: o })) : i);
    x.assertNever(n);
  }
}
C.create = (s, e, t) => new C({
  schema: s,
  typeName: m.ZodEffects,
  effect: e,
  ...g(t)
});
C.createWithPreprocess = (s, e, t) => new C({
  schema: e,
  effect: { type: "preprocess", transform: s },
  typeName: m.ZodEffects,
  ...g(t)
});
class M extends v {
  _parse(e) {
    return this._getType(e) === c.undefined ? T(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
M.create = (s, e) => new M({
  innerType: s,
  typeName: m.ZodOptional,
  ...g(e)
});
class D extends v {
  _parse(e) {
    return this._getType(e) === c.null ? T(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
D.create = (s, e) => new D({
  innerType: s,
  typeName: m.ZodNullable,
  ...g(e)
});
class se extends v {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let r = t.data;
    return t.parsedType === c.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
se.create = (s, e) => new se({
  innerType: s,
  typeName: m.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...g(e)
});
class pe extends v {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), r = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, n = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return ue(n) ? n.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new E(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new E(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
pe.create = (s, e) => new pe({
  innerType: s,
  typeName: m.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...g(e)
});
class me extends v {
  _parse(e) {
    if (this._getType(e) !== c.nan) {
      const r = this._getOrReturnCtx(e);
      return u(r, {
        code: d.invalid_type,
        expected: c.nan,
        received: r.parsedType
      }), y;
    }
    return { status: "valid", value: e.data };
  }
}
me.create = (s) => new me({
  typeName: m.ZodNaN,
  ...g(s)
});
const Fe = Symbol("zod_brand");
class Ne extends v {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), r = t.data;
    return this._def.type._parse({
      data: r,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class re extends v {
  _parse(e) {
    const { status: t, ctx: r } = this._processInputParams(e);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? y : a.status === "dirty" ? (t.dirty(), Ze(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const n = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return n.status === "aborted" ? y : n.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: n.value
      }) : this._def.out._parseSync({
        data: n.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(e, t) {
    return new re({
      in: e,
      out: t,
      typeName: m.ZodPipeline
    });
  }
}
const Oe = (s, e = {}, t) => s ? q.create().superRefine((r, n) => {
  var a, i;
  if (!s(r)) {
    const o = typeof e == "function" ? e(r) : typeof e == "string" ? { message: e } : e, h = (i = (a = o.fatal) !== null && a !== void 0 ? a : t) !== null && i !== void 0 ? i : !0, l = typeof o == "string" ? { message: o } : o;
    n.addIssue({ code: "custom", ...l, fatal: h });
  }
}) : q.create(), et = {
  object: k.lazycreate
};
var m;
(function(s) {
  s.ZodString = "ZodString", s.ZodNumber = "ZodNumber", s.ZodNaN = "ZodNaN", s.ZodBigInt = "ZodBigInt", s.ZodBoolean = "ZodBoolean", s.ZodDate = "ZodDate", s.ZodSymbol = "ZodSymbol", s.ZodUndefined = "ZodUndefined", s.ZodNull = "ZodNull", s.ZodAny = "ZodAny", s.ZodUnknown = "ZodUnknown", s.ZodNever = "ZodNever", s.ZodVoid = "ZodVoid", s.ZodArray = "ZodArray", s.ZodObject = "ZodObject", s.ZodUnion = "ZodUnion", s.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", s.ZodIntersection = "ZodIntersection", s.ZodTuple = "ZodTuple", s.ZodRecord = "ZodRecord", s.ZodMap = "ZodMap", s.ZodSet = "ZodSet", s.ZodFunction = "ZodFunction", s.ZodLazy = "ZodLazy", s.ZodLiteral = "ZodLiteral", s.ZodEnum = "ZodEnum", s.ZodEffects = "ZodEffects", s.ZodNativeEnum = "ZodNativeEnum", s.ZodOptional = "ZodOptional", s.ZodNullable = "ZodNullable", s.ZodDefault = "ZodDefault", s.ZodCatch = "ZodCatch", s.ZodPromise = "ZodPromise", s.ZodBranded = "ZodBranded", s.ZodPipeline = "ZodPipeline";
})(m || (m = {}));
const tt = (s, e = {
  message: `Input not instance of ${s.name}`
}) => Oe((t) => t instanceof s, e), Me = S.create, Ie = j.create, st = me.create, rt = A.create, Re = Y.create, nt = V.create, at = le.create, it = G.create, ot = Q.create, dt = q.create, ct = L.create, ut = I.create, lt = he.create, ht = Z.create, ft = k.create, pt = k.strictCreate, mt = H.create, yt = ye.create, gt = K.create, vt = O.create, _t = X.create, xt = fe.create, kt = $.create, wt = B.create, bt = F.create, Tt = ee.create, St = P.create, Et = te.create, Zt = W.create, Te = C.create, Ct = M.create, Nt = D.create, Ot = C.createWithPreprocess, Mt = re.create, It = () => Me().optional(), Rt = () => Ie().optional(), jt = () => Re().optional(), At = {
  string: (s) => S.create({ ...s, coerce: !0 }),
  number: (s) => j.create({ ...s, coerce: !0 }),
  boolean: (s) => Y.create({
    ...s,
    coerce: !0
  }),
  bigint: (s) => A.create({ ...s, coerce: !0 }),
  date: (s) => V.create({ ...s, coerce: !0 })
}, Pt = y;
var f = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: J,
  setErrorMap: De,
  getErrorMap: oe,
  makeIssue: de,
  EMPTY_PATH: ze,
  addIssueToContext: u,
  ParseStatus: b,
  INVALID: y,
  DIRTY: Ze,
  OK: T,
  isAborted: _e,
  isDirty: xe,
  isValid: ce,
  isAsync: ue,
  get util() {
    return x;
  },
  get objectUtil() {
    return ve;
  },
  ZodParsedType: c,
  getParsedType: R,
  ZodType: v,
  ZodString: S,
  ZodNumber: j,
  ZodBigInt: A,
  ZodBoolean: Y,
  ZodDate: V,
  ZodSymbol: le,
  ZodUndefined: G,
  ZodNull: Q,
  ZodAny: q,
  ZodUnknown: L,
  ZodNever: I,
  ZodVoid: he,
  ZodArray: Z,
  ZodObject: k,
  ZodUnion: H,
  ZodDiscriminatedUnion: ye,
  ZodIntersection: K,
  ZodTuple: O,
  ZodRecord: X,
  ZodMap: fe,
  ZodSet: $,
  ZodFunction: B,
  ZodLazy: F,
  ZodLiteral: ee,
  ZodEnum: P,
  ZodNativeEnum: te,
  ZodPromise: W,
  ZodEffects: C,
  ZodTransformer: C,
  ZodOptional: M,
  ZodNullable: D,
  ZodDefault: se,
  ZodCatch: pe,
  ZodNaN: me,
  BRAND: Fe,
  ZodBranded: Ne,
  ZodPipeline: re,
  custom: Oe,
  Schema: v,
  ZodSchema: v,
  late: et,
  get ZodFirstPartyTypeKind() {
    return m;
  },
  coerce: At,
  any: dt,
  array: ht,
  bigint: rt,
  boolean: Re,
  date: nt,
  discriminatedUnion: yt,
  effect: Te,
  enum: St,
  function: wt,
  instanceof: tt,
  intersection: gt,
  lazy: bt,
  literal: Tt,
  map: xt,
  nan: st,
  nativeEnum: Et,
  never: ut,
  null: ot,
  nullable: Nt,
  number: Ie,
  object: ft,
  oboolean: jt,
  onumber: Rt,
  optional: Ct,
  ostring: It,
  pipeline: Mt,
  preprocess: Ot,
  promise: Zt,
  record: _t,
  set: kt,
  strictObject: pt,
  string: Me,
  symbol: at,
  transformer: Te,
  tuple: vt,
  undefined: it,
  union: mt,
  unknown: ct,
  void: lt,
  NEVER: Pt,
  ZodIssueCode: d,
  quotelessJson: $e,
  ZodError: E
});
const ie = f.union([f.string(), f.number(), f.bigint()]), Se = f.object({
  contractAddress: f.string(),
  entrypoint: f.string(),
  calldata: f.array(ie).optional()
}), Lt = f.object({
  types: f.record(
    f.array(
      f.union([
        f.object({
          name: f.string(),
          type: f.string()
        }),
        f.object({
          name: f.string(),
          type: f.literal("merkletree"),
          contains: f.string()
        })
      ])
    )
  ),
  primaryType: f.string(),
  domain: f.record(f.unknown()),
  message: f.record(f.unknown())
}), Wt = {
  enable: f.tuple([
    f.object({
      starknetVersion: f.union([f.literal("v3"), f.literal("v4")]).optional()
    }).optional()
  ]).or(f.tuple([])),
  addStarknetChain: f.tuple([
    f.object({
      id: f.string(),
      chainId: f.string(),
      chainName: f.string(),
      rpcUrls: f.array(f.string()).optional(),
      nativeCurrency: f.object({
        name: f.string(),
        symbol: f.string(),
        decimals: f.number()
      }).optional(),
      blockExplorerUrls: f.array(f.string()).optional()
    })
  ]),
  switchStarknetChain: f.tuple([
    f.object({
      chainId: f.string()
    })
  ]),
  watchAsset: f.tuple([
    f.object({
      type: f.literal("ERC20"),
      options: f.object({
        address: f.string(),
        symbol: f.string().optional(),
        decimals: f.number().optional(),
        image: f.string().optional(),
        name: f.string().optional()
      })
    })
  ]),
  execute: f.tuple([
    f.array(Se).nonempty().or(Se),
    f.array(f.any()).optional(),
    f.object({
      nonce: ie.optional(),
      maxFee: ie.optional(),
      version: ie.optional()
    }).optional()
  ]),
  signMessage: f.tuple([Lt])
};
export {
  Bt as Receiver,
  qt as Relayer,
  Ut as Sender,
  Wt as StarknetMethodArgumentsSchemas,
  zt as WindowMessenger,
  Dt as getArgentStarknetWindowObject
};
